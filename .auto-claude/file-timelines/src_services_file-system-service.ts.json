{
  "file_path": "src/services/file-system-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { existsSync, constants } from 'fs';\nimport ignore from 'ignore';\nimport { CUIError, FileSystemEntry } from '@/types/index.js';\nimport { createLogger } from './logger.js';\nimport { type Logger } from './logger.js';\n\nconst execAsync = promisify(exec);\n\n/**\n * Service for secure file system operations\n */\nexport class FileSystemService {\n  private logger: Logger;\n  private maxFileSize: number = 10 * 1024 * 1024; // 10MB default\n  private allowedBasePaths: string[] = []; // Empty means all paths allowed\n  \n  constructor(maxFileSize?: number, allowedBasePaths?: string[]) {\n    this.logger = createLogger('FileSystemService');\n    if (maxFileSize !== undefined) {\n      this.maxFileSize = maxFileSize;\n    }\n    if (allowedBasePaths) {\n      this.allowedBasePaths = allowedBasePaths.map(p => path.normalize(p));\n    }\n  }\n\n  /**\n   * List directory contents with security checks\n   */\n  async listDirectory(\n    requestedPath: string, \n    recursive: boolean = false,\n    respectGitignore: boolean = false\n  ): Promise<{ path: string; entries: FileSystemEntry[]; total: number }> {\n    this.logger.debug('List directory requested', { requestedPath, recursive, respectGitignore });\n    \n    try {\n      // Validate and normalize path\n      const safePath = await this.validatePath(requestedPath);\n      \n      // Check if path exists and is a directory\n      const stats = await fs.stat(safePath);\n      if (!stats.isDirectory()) {\n        throw new CUIError('NOT_A_DIRECTORY', `Path is not a directory: ${requestedPath}`, 400);\n      }\n      \n      // Initialize gitignore if requested\n      let ig: ReturnType<typeof ignore> | null = null;\n      if (respectGitignore) {\n        ig = await this.loadGitignore(safePath);\n      }\n      \n      // Get entries\n      const entries: FileSystemEntry[] = recursive\n        ? await this.listDirectoryRecursive(safePath, safePath, ig)\n        : await this.listDirectoryFlat(safePath, ig);\n      \n      // Sort entries: directories first, then by name\n      entries.sort((a, b) => {\n        if (a.type !== b.type) {\n          return a.type === 'directory' ? -1 : 1;\n        }\n        return a.name.localeCompare(b.name);\n      });\n      \n      this.logger.debug('Directory listed successfully', { \n        path: safePath, \n        entryCount: entries.length,\n        recursive,\n        respectGitignore\n      });\n      \n      return {\n        path: safePath,\n        entries,\n        total: entries.length\n      };\n    } catch (error) {\n      if (error instanceof CUIError) {\n        throw error;\n      }\n      \n      const errorCode = (error as NodeJS.ErrnoException).code;\n      if (errorCode === 'ENOENT') {\n        throw new CUIError('PATH_NOT_FOUND', `Path not found: ${requestedPath}`, 404);\n      } else if (errorCode === 'EACCES') {\n        throw new CUIError('ACCESS_DENIED', `Access denied to path: ${requestedPath}`, 403);\n      }\n      \n      this.logger.error('Error listing directory', error, { requestedPath });\n      throw new CUIError('LIST_DIRECTORY_FAILED', `Failed to list directory: ${error}`, 500);\n    }\n  }\n\n  /**\n   * Read file contents with security checks\n   */\n  async readFile(requestedPath: string): Promise<{ path: string; content: string; size: number; lastModified: string; encoding: string }> {\n    this.logger.debug('Read file requested', { requestedPath });\n    \n    try {\n      // Validate and normalize path\n      const safePath = await this.validatePath(requestedPath);\n      \n      // Check if path exists and is a file\n      const stats = await fs.stat(safePath);\n      if (!stats.isFile()) {\n        throw new CUIError('NOT_A_FILE', `Path is not a file: ${requestedPath}`, 400);\n      }\n      \n      // Check file size\n      if (stats.size > this.maxFileSize) {\n        throw new CUIError(\n          'FILE_TOO_LARGE', \n          `File size (${stats.size} bytes) exceeds maximum allowed size (${this.maxFileSize} bytes)`, \n          400\n        );\n      }\n      \n      // Read file content\n      const content = await fs.readFile(safePath, 'utf-8');\n      \n      // Check if content is valid UTF-8 text\n      if (!this.isValidUtf8(content)) {\n        throw new CUIError('BINARY_FILE', 'File appears to be binary or not valid UTF-8', 400);\n      }\n      \n      this.logger.debug('File read successfully', { \n        path: safePath, \n        size: stats.size \n      });\n      \n      return {\n        path: safePath,\n        content,\n        size: stats.size,\n        lastModified: stats.mtime.toISOString(),\n        encoding: 'utf-8'\n      };\n    } catch (error) {\n      if (error instanceof CUIError) {\n        throw error;\n      }\n      \n      const errorCode = (error as NodeJS.ErrnoException).code;\n      if (errorCode === 'ENOENT') {\n        throw new CUIError('FILE_NOT_FOUND', `File not found: ${requestedPath}`, 404);\n      } else if (errorCode === 'EACCES') {\n        throw new CUIError('ACCESS_DENIED', `Access denied to file: ${requestedPath}`, 403);\n      }\n      \n      this.logger.error('Error reading file', error, { requestedPath });\n      throw new CUIError('READ_FILE_FAILED', `Failed to read file: ${error}`, 500);\n    }\n  }\n\n  /**\n   * Validate and normalize a path to prevent path traversal attacks\n   */\n  private async validatePath(requestedPath: string): Promise<string> {\n    // Require absolute paths\n    if (!path.isAbsolute(requestedPath)) {\n      throw new CUIError('INVALID_PATH', 'Path must be absolute', 400);\n    }\n    \n    // Check for path traversal attempts before normalization\n    if (requestedPath.includes('..')) {\n      this.logger.warn('Path traversal attempt detected', { \n        requestedPath \n      });\n      throw new CUIError('PATH_TRAVERSAL_DETECTED', 'Invalid path: path traversal detected', 400);\n    }\n    \n    // Normalize the path to resolve . segments and clean up\n    const normalizedPath = path.normalize(requestedPath);\n    \n    // Check against allowed base paths if configured\n    if (this.allowedBasePaths.length > 0) {\n      const isAllowed = this.allowedBasePaths.some(basePath => \n        normalizedPath.startsWith(basePath)\n      );\n      \n      if (!isAllowed) {\n        this.logger.warn('Path outside allowed directories', { \n          requestedPath, \n          normalizedPath,\n          allowedBasePaths: this.allowedBasePaths \n        });\n        throw new CUIError('PATH_NOT_ALLOWED', 'Path is outside allowed directories', 403);\n      }\n    }\n    \n    // Additional security checks\n    const segments = normalizedPath.split(path.sep);\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      if (!segment) continue;\n\n      // Skip drive letter on Windows (e.g., \"C:\")\n      const isDriveLetter = process.platform === 'win32' && i === 0 && /^[A-Za-z]:$/.test(segment);\n      if (isDriveLetter) {\n        continue;\n      }\n\n      // Check for hidden files/directories\n      if (segment.startsWith('.')) {\n        this.logger.warn('Hidden file/directory detected', {\n          requestedPath,\n          segment\n        });\n        throw new CUIError('INVALID_PATH', 'Path contains hidden files/directories', 400);\n      }\n\n      // Check for null bytes\n      if (segment.includes('\\u0000')) {\n        this.logger.warn('Null byte detected in path', {\n          requestedPath,\n          segment\n        });\n        throw new CUIError('INVALID_PATH', 'Path contains null bytes', 400);\n      }\n\n      // Check for invalid characters\n      if (/[<>:|?*]/.test(segment)) {\n        this.logger.warn('Invalid characters detected in path', {\n          requestedPath,\n          segment\n        });\n        throw new CUIError('INVALID_PATH', 'Path contains invalid characters', 400);\n      }\n    }\n    \n    this.logger.debug('Path validated successfully', { \n      requestedPath, \n      normalizedPath \n    });\n    \n    return normalizedPath;\n  }\n\n  /**\n   * Check if content appears to be valid UTF-8 text\n   */\n  private isValidUtf8(content: string): boolean {\n    // Check for null bytes - common binary file indicator\n    if (content.includes('\\u0000')) {\n      return false;\n    }\n    \n    // Check for control characters (excluding tab, newline, and carriage return)\n    for (let i = 0; i < content.length; i++) {\n      const charCode = content.charCodeAt(i);\n      // Allow tab (9), newline (10), and carriage return (13)\n      // Reject other control characters (1-8, 11-12, 14-31)\n      if ((charCode >= 1 && charCode <= 8) || \n          (charCode >= 11 && charCode <= 12) || \n          (charCode >= 14 && charCode <= 31)) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * List directory contents without recursion\n   */\n  private async listDirectoryFlat(\n    dirPath: string,\n    ig: ReturnType<typeof ignore> | null\n  ): Promise<FileSystemEntry[]> {\n    const dirents = await fs.readdir(dirPath, { withFileTypes: true });\n    const entries: FileSystemEntry[] = [];\n    \n    for (const dirent of dirents) {\n      // Check gitignore BEFORE any expensive operations\n      if (ig && ig.ignores(dirent.name)) {\n        continue;\n      }\n      \n      const fullPath = path.join(dirPath, dirent.name);\n      const stats = await fs.stat(fullPath);\n      entries.push({\n        name: dirent.name,\n        type: dirent.isDirectory() ? 'directory' : 'file',\n        size: dirent.isFile() ? stats.size : undefined,\n        lastModified: stats.mtime.toISOString()\n      });\n    }\n    \n    return entries;\n  }\n\n  /**\n   * List directory contents recursively\n   */\n  private async listDirectoryRecursive(\n    dirPath: string,\n    basePath: string,\n    ig: ReturnType<typeof ignore> | null\n  ): Promise<FileSystemEntry[]> {\n    const entries: FileSystemEntry[] = [];\n    \n    async function traverse(currentPath: string): Promise<void> {\n      const dirents = await fs.readdir(currentPath, { withFileTypes: true });\n      \n      for (const dirent of dirents) {\n        const fullPath = path.join(currentPath, dirent.name);\n        const relativePath = path.relative(basePath, fullPath);\n        \n        // Check gitignore BEFORE any expensive operations\n        if (ig && ig.ignores(relativePath)) {\n          // Skip this entry entirely - don't stat, don't recurse into directories\n          continue;\n        }\n        \n        const stats = await fs.stat(fullPath);\n        entries.push({\n          name: relativePath,\n          type: dirent.isDirectory() ? 'directory' : 'file',\n          size: dirent.isFile() ? stats.size : undefined,\n          lastModified: stats.mtime.toISOString()\n        });\n        \n        // Recurse into subdirectories (already checked it's not ignored)\n        if (dirent.isDirectory()) {\n          await traverse(fullPath);\n        }\n      }\n    }\n    \n    await traverse(dirPath);\n    return entries;\n  }\n\n  /**\n   * Load gitignore patterns from a directory and its parents\n   */\n  private async loadGitignore(dirPath: string): Promise<ReturnType<typeof ignore>> {\n    const ig = ignore();\n    \n    // Load .gitignore from the directory\n    try {\n      const gitignorePath = path.join(dirPath, '.gitignore');\n      const content = await fs.readFile(gitignorePath, 'utf-8');\n      ig.add(content);\n      this.logger.debug('Loaded .gitignore', { path: gitignorePath });\n    } catch (error) {\n      // .gitignore doesn't exist or can't be read - that's fine\n      const errorCode = (error as NodeJS.ErrnoException).code;\n      if (errorCode !== 'ENOENT') {\n        this.logger.debug('Error reading .gitignore', { error, path: dirPath });\n      }\n    }\n    \n    // Always ignore .git directory\n    ig.add('.git');\n    \n    return ig;\n  }\n\n  /**\n   * Check if a directory is a git repository\n   */\n  async isGitRepository(dirPath: string): Promise<boolean> {\n    try {\n      await execAsync('git rev-parse --git-dir', { cwd: dirPath });\n      return true;\n    } catch (error) {\n      this.logger.debug('Directory is not a git repository', { dirPath, error });\n      return false;\n    }\n  }\n\n  /**\n   * Get current git HEAD commit hash\n   */\n  async getCurrentGitHead(dirPath: string): Promise<string | null> {\n    try {\n      const { stdout } = await execAsync('git rev-parse HEAD', { cwd: dirPath });\n      return stdout.trim();\n    } catch (error) {\n      this.logger.debug('Failed to get git HEAD', { dirPath, error });\n      return null;\n    }\n  }\n\n  /**\n   * Validate that an executable exists and has executable permissions\n   */\n  async validateExecutable(executablePath: string): Promise<void> {\n    this.logger.debug('Validating executable', { executablePath });\n\n    try {\n      // Check if file exists\n      if (!existsSync(executablePath)) {\n        throw new CUIError(\n          'EXECUTABLE_NOT_FOUND',\n          `Executable not found: ${executablePath}`,\n          404\n        );\n      }\n\n      // Check if file is executable\n      try {\n        await fs.access(executablePath, constants.X_OK);\n      } catch (_error) {\n        throw new CUIError(\n          'NOT_EXECUTABLE',\n          `File exists but is not executable: ${executablePath}`,\n          403\n        );\n      }\n\n      this.logger.debug('Executable validation successful', { executablePath });\n    } catch (error) {\n      if (error instanceof CUIError) {\n        throw error;\n      }\n      \n      this.logger.error('Error validating executable', error, { executablePath });\n      throw new CUIError(\n        'EXECUTABLE_VALIDATION_FAILED',\n        `Failed to validate executable: ${error}`,\n        500\n      );\n    }\n  }\n}",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { existsSync, constants } from 'fs';\nimport ignore from 'ignore';\nimport { CUIError, FileSystemEntry } from '@/types/index.js';\nimport { createLogger } from './logger.js';\nimport { type Logger } from './logger.js';\n\nconst execAsync = promisify(exec);\n\n/**\n * FileSystemService - Secure abstraction over Node.js filesystem operations\n *\n * @description\n * The FileSystemService provides a secure, validated layer over Node.js filesystem operations,\n * implementing comprehensive security checks to prevent path traversal attacks, null byte injection,\n * and other filesystem-related vulnerabilities. It supports directory listing, file reading, git\n * repository detection, and executable validation with configurable size limits and path restrictions.\n *\n * **Key Responsibilities:**\n * - Secure file and directory access with path validation\n * - Path traversal attack prevention (.. detection, normalization)\n * - File size limit enforcement (default: 10MB)\n * - UTF-8 text validation (binary file detection)\n * - Hidden file/directory protection (. prefix detection)\n * - Optional path restrictions (allowedBasePaths whitelist)\n * - Git repository detection and HEAD commit retrieval\n * - Executable validation with permission checks\n * - Gitignore-aware directory listing\n *\n * **Architecture:**\n * - **Security-First Design**: All paths validated and normalized before filesystem access\n * - **Path Validation**: Absolute path requirement, traversal detection, character validation\n * - **Size Limits**: Configurable max file size to prevent memory exhaustion\n * - **Error Handling**: Detailed CUIError instances with appropriate HTTP status codes\n * - **Logging**: Comprehensive debug/warning/error logging for security auditing\n * - **Git Integration**: Repository detection and commit hash retrieval via git CLI\n *\n * **Security Features:**\n * - Path traversal prevention (.. segments rejected before normalization)\n * - Null byte injection detection (\\u0000)\n * - Hidden file/directory blocking (. prefix rejection)\n * - Invalid character detection (<>:|?*)\n * - Optional path whitelist (allowedBasePaths)\n * - File size limits (configurable, default 10MB)\n * - UTF-8 validation for text files (binary file detection)\n * - Windows drive letter support (C:, D:, etc.)\n *\n * **Use Cases:**\n * - Secure file reading for chat attachments and agent context\n * - Directory browsing for project file exploration\n * - Git repository detection for version control integration\n * - Executable validation for MCP server stdio commands\n * - Gitignore-aware file listing for SDK settings discovery\n *\n * @example\n * ```typescript\n * // Basic usage - unrestricted file access with size limits\n * import { FileSystemService } from './file-system-service';\n *\n * const fs = new FileSystemService();\n *\n * // Read a file (validates path, checks size, validates UTF-8)\n * const result = await fs.readFile('/home/user/project/README.md');\n * console.log(result.content); // File contents\n * console.log(result.size); // 1024 bytes\n * console.log(result.lastModified); // \"2024-01-01T00:00:00.000Z\"\n * ```\n *\n * @example\n * ```typescript\n * // Restricted file access - limit to specific directories\n * import { FileSystemService } from './file-system-service';\n *\n * // Allow access only to /home/user/projects and /home/user/documents\n * const fs = new FileSystemService(\n *   5 * 1024 * 1024, // 5MB max file size\n *   ['/home/user/projects', '/home/user/documents'] // Allowed base paths\n * );\n *\n * // This succeeds (within allowed paths)\n * await fs.readFile('/home/user/projects/app/src/index.ts');\n *\n * // This fails with PATH_NOT_ALLOWED error\n * try {\n *   await fs.readFile('/etc/passwd');\n * } catch (error) {\n *   console.error(error.code); // \"PATH_NOT_ALLOWED\"\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Directory listing with gitignore support\n * import { FileSystemService } from './file-system-service';\n *\n * const fs = new FileSystemService();\n *\n * // List directory (flat)\n * const result = await fs.listDirectory('/home/user/project');\n * console.log(result.entries);\n * // [\n * //   { name: 'src', type: 'directory', lastModified: '...' },\n * //   { name: 'README.md', type: 'file', size: 1024, lastModified: '...' }\n * // ]\n *\n * // List directory recursively with gitignore filtering\n * const recursiveResult = await fs.listDirectory(\n *   '/home/user/project',\n *   true, // recursive\n *   true  // respectGitignore\n * );\n * // Automatically excludes node_modules/, .git/, etc. based on .gitignore\n * ```\n *\n * @example\n * ```typescript\n * // Git repository operations\n * import { FileSystemService } from './file-system-service';\n *\n * const fs = new FileSystemService();\n *\n * // Check if directory is a git repository\n * const isGit = await fs.isGitRepository('/home/user/project');\n * if (isGit) {\n *   // Get current commit hash\n *   const commitHash = await fs.getCurrentGitHead('/home/user/project');\n *   console.log(`Current commit: ${commitHash}`); // \"a1b2c3d4...\"\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Executable validation for MCP servers\n * import { FileSystemService } from './file-system-service';\n *\n * const fs = new FileSystemService();\n *\n * // Validate MCP server executable exists and has execute permissions\n * try {\n *   await fs.validateExecutable('/usr/local/bin/mcp-server');\n *   console.log('Executable is valid');\n * } catch (error) {\n *   if (error.code === 'EXECUTABLE_NOT_FOUND') {\n *     console.error('MCP server not found');\n *   } else if (error.code === 'NOT_EXECUTABLE') {\n *     console.error('File exists but not executable (chmod +x required)');\n *   }\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Security: path traversal prevention\n * import { FileSystemService } from './file-system-service';\n *\n * const fs = new FileSystemService();\n *\n * // These all fail with PATH_TRAVERSAL_DETECTED error:\n * try {\n *   await fs.readFile('/home/user/../../../etc/passwd');\n * } catch (error) {\n *   console.error(error.code); // \"PATH_TRAVERSAL_DETECTED\"\n * }\n *\n * // Hidden file access is also blocked\n * try {\n *   await fs.readFile('/home/user/.ssh/id_rsa');\n * } catch (error) {\n *   console.error(error.code); // \"INVALID_PATH\"\n *   console.error(error.message); // \"Path contains hidden files/directories\"\n * }\n * ```\n *\n * @see CUIError for error codes and status codes\n * @see Logger for logging integration\n */\nexport class FileSystemService {\n  /** Logger instance for security auditing and debugging */\n  private logger: Logger;\n\n  /** Maximum file size in bytes (default: 10MB) */\n  private maxFileSize: number = 10 * 1024 * 1024; // 10MB default\n\n  /** Allowed base paths whitelist (empty array = all paths allowed) */\n  private allowedBasePaths: string[] = []; // Empty means all paths allowed\n  \n  constructor(maxFileSize?: number, allowedBasePaths?: string[]) {\n    this.logger = createLogger('FileSystemService');\n    if (maxFileSize !== undefined) {\n      this.maxFileSize = maxFileSize;\n    }\n    if (allowedBasePaths) {\n      this.allowedBasePaths = allowedBasePaths.map(p => path.normalize(p));\n    }\n  }\n\n  /**\n   * List directory contents with comprehensive security validation and gitignore support\n   *\n   * @description\n   * Lists files and subdirectories in a directory with optional recursive traversal and gitignore\n   * filtering. Returns an array of entries with metadata (name, type, size, last modified).\n   * Supports both flat and recursive directory listing with automatic sorting (directories first,\n   * then alphabetically by name).\n   *\n   * **Workflow:**\n   * 1. Validate and normalize path (prevent traversal attacks)\n   * 2. Check path exists and is a directory (not file)\n   * 3. Load .gitignore patterns if respectGitignore is true\n   * 4. List directory entries (flat or recursive based on parameters)\n   * 5. Filter entries based on gitignore patterns (if enabled)\n   * 6. Sort entries (directories first, then alphabetically)\n   * 7. Return path, entries array, and total count\n   *\n   * **Security Checks:**\n   * - Path traversal prevention (.. segments, normalization)\n   * - Hidden file/directory blocking (. prefix)\n   * - Null byte injection detection\n   * - Optional path whitelist (allowedBasePaths)\n   *\n   * **Gitignore Support:**\n   * - Loads .gitignore from target directory\n   * - Respects gitignore patterns for file/directory filtering\n   * - Always ignores .git directory\n   * - Gracefully handles missing .gitignore files\n   *\n   * @param requestedPath - Absolute path to directory (must be absolute, no relative paths)\n   * @param recursive - If true, recursively list all subdirectories (default: false)\n   * @param respectGitignore - If true, filter entries based on .gitignore patterns (default: false)\n   * @returns Promise resolving to object with directory listing\n   * @returns path - Normalized absolute path to the directory\n   * @returns entries - Array of FileSystemEntry objects with file/directory metadata\n   * @returns total - Total number of entries returned (same as entries.length)\n   *\n   * @throws {CUIError} PATH_NOT_FOUND (404) - Directory does not exist\n   * @throws {CUIError} NOT_A_DIRECTORY (400) - Path exists but is a file\n   * @throws {CUIError} ACCESS_DENIED (403) - Insufficient permissions to read directory\n   * @throws {CUIError} PATH_TRAVERSAL_DETECTED (400) - Path contains .. segments\n   * @throws {CUIError} INVALID_PATH (400) - Path is relative, contains hidden files, null bytes, or invalid characters\n   * @throws {CUIError} PATH_NOT_ALLOWED (403) - Path is outside allowedBasePaths\n   * @throws {CUIError} LIST_DIRECTORY_FAILED (500) - Unexpected error listing directory\n   *\n   * @example\n   * ```typescript\n   * // Basic flat directory listing\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const result = await fs.listDirectory('/home/user/project');\n   * console.log(result.path); // \"/home/user/project\"\n   * console.log(result.total); // 5\n   * console.log(result.entries);\n   * // [\n   * //   { name: 'src', type: 'directory', lastModified: '2024-01-01T00:00:00.000Z' },\n   * //   { name: 'tests', type: 'directory', lastModified: '2024-01-01T00:00:00.000Z' },\n   * //   { name: 'package.json', type: 'file', size: 1024, lastModified: '2024-01-01T00:00:00.000Z' },\n   * //   { name: 'README.md', type: 'file', size: 512, lastModified: '2024-01-01T00:00:00.000Z' },\n   * //   { name: 'tsconfig.json', type: 'file', size: 256, lastModified: '2024-01-01T00:00:00.000Z' }\n   * // ]\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Recursive directory listing\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const result = await fs.listDirectory('/home/user/project', true);\n   * console.log(result.entries);\n   * // [\n   * //   { name: 'src', type: 'directory', lastModified: '...' },\n   * //   { name: 'src/index.ts', type: 'file', size: 2048, lastModified: '...' },\n   * //   { name: 'src/utils', type: 'directory', lastModified: '...' },\n   * //   { name: 'src/utils/helpers.ts', type: 'file', size: 1024, lastModified: '...' },\n   * //   { name: 'tests', type: 'directory', lastModified: '...' },\n   * //   { name: 'tests/index.test.ts', type: 'file', size: 512, lastModified: '...' },\n   * //   ...\n   * // ]\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Directory listing with gitignore filtering\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * // .gitignore contains:\n   * // node_modules/\n   * // dist/\n   * // *.log\n   *\n   * const result = await fs.listDirectory('/home/user/project', true, true);\n   * // Automatically excludes node_modules/, dist/, .git/, and *.log files\n   * console.log(result.entries);\n   * // [\n   * //   { name: 'src', type: 'directory', ... },\n   * //   { name: 'src/index.ts', type: 'file', ... },\n   * //   { name: 'tests', type: 'directory', ... },\n   * //   { name: 'package.json', type: 'file', ... }\n   * //   // node_modules/, dist/, .git/ excluded\n   * // ]\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - directory not found\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * try {\n   *   await fs.listDirectory('/nonexistent/directory');\n   * } catch (error) {\n   *   console.error(error.code); // \"PATH_NOT_FOUND\"\n   *   console.error(error.statusCode); // 404\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - not a directory\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * try {\n   *   await fs.listDirectory('/home/user/project/README.md'); // File, not directory\n   * } catch (error) {\n   *   console.error(error.code); // \"NOT_A_DIRECTORY\"\n   *   console.error(error.statusCode); // 400\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // File browser UI integration\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * async function displayDirectory(path: string) {\n   *   const result = await fs.listDirectory(path, false, true);\n   *\n   *   console.log(`\\n${result.path} (${result.total} items)\\n`);\n   *   result.entries.forEach(entry => {\n   *     const icon = entry.type === 'directory' ? '\ud83d\udcc1' : '\ud83d\udcc4';\n   *     const size = entry.size ? ` (${entry.size} bytes)` : '';\n   *     console.log(`${icon} ${entry.name}${size}`);\n   *   });\n   * }\n   *\n   * await displayDirectory('/home/user/project');\n   * // /home/user/project (5 items)\n   * // \ud83d\udcc1 src\n   * // \ud83d\udcc1 tests\n   * // \ud83d\udcc4 package.json (1024 bytes)\n   * // \ud83d\udcc4 README.md (512 bytes)\n   * // \ud83d\udcc4 tsconfig.json (256 bytes)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // SDK settings discovery - find all .claude directories\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const result = await fs.listDirectory('/home/user/project', true, true);\n   * const claudeDirs = result.entries.filter(entry =>\n   *   entry.type === 'directory' && entry.name.includes('.claude')\n   * );\n   * console.log('Found .claude directories:', claudeDirs);\n   * // Useful for Claude SDK settingSources discovery\n   * ```\n   */\n  async listDirectory(\n    requestedPath: string,\n    recursive: boolean = false,\n    respectGitignore: boolean = false\n  ): Promise<{ path: string; entries: FileSystemEntry[]; total: number }> {\n    this.logger.debug('List directory requested', { requestedPath, recursive, respectGitignore });\n    \n    try {\n      // Validate and normalize path\n      const safePath = await this.validatePath(requestedPath);\n      \n      // Check if path exists and is a directory\n      const stats = await fs.stat(safePath);\n      if (!stats.isDirectory()) {\n        throw new CUIError('NOT_A_DIRECTORY', `Path is not a directory: ${requestedPath}`, 400);\n      }\n      \n      // Initialize gitignore if requested\n      let ig: ReturnType<typeof ignore> | null = null;\n      if (respectGitignore) {\n        ig = await this.loadGitignore(safePath);\n      }\n      \n      // Get entries\n      const entries: FileSystemEntry[] = recursive\n        ? await this.listDirectoryRecursive(safePath, safePath, ig)\n        : await this.listDirectoryFlat(safePath, ig);\n      \n      // Sort entries: directories first, then by name\n      entries.sort((a, b) => {\n        if (a.type !== b.type) {\n          return a.type === 'directory' ? -1 : 1;\n        }\n        return a.name.localeCompare(b.name);\n      });\n      \n      this.logger.debug('Directory listed successfully', { \n        path: safePath, \n        entryCount: entries.length,\n        recursive,\n        respectGitignore\n      });\n      \n      return {\n        path: safePath,\n        entries,\n        total: entries.length\n      };\n    } catch (error) {\n      if (error instanceof CUIError) {\n        throw error;\n      }\n      \n      const errorCode = (error as NodeJS.ErrnoException).code;\n      if (errorCode === 'ENOENT') {\n        throw new CUIError('PATH_NOT_FOUND', `Path not found: ${requestedPath}`, 404);\n      } else if (errorCode === 'EACCES') {\n        throw new CUIError('ACCESS_DENIED', `Access denied to path: ${requestedPath}`, 403);\n      }\n      \n      this.logger.error('Error listing directory', error, { requestedPath });\n      throw new CUIError('LIST_DIRECTORY_FAILED', `Failed to list directory: ${error}`, 500);\n    }\n  }\n\n  /**\n   * Read file contents with comprehensive security validation\n   *\n   * @description\n   * Reads a text file from disk with complete security validation including path traversal prevention,\n   * size limit enforcement, and UTF-8 validation. Returns file contents along with metadata (size,\n   * last modified timestamp, encoding). Automatically rejects binary files and files exceeding size limits.\n   *\n   * **Workflow:**\n   * 1. Validate and normalize path (prevent traversal attacks)\n   * 2. Check file exists and is a file (not directory)\n   * 3. Check file size against maxFileSize limit\n   * 4. Read file contents as UTF-8\n   * 5. Validate content is valid UTF-8 text (reject binary files)\n   * 6. Return file data with metadata\n   *\n   * **Security Checks:**\n   * - Path traversal prevention (.. segments, normalization)\n   * - Hidden file/directory blocking (. prefix)\n   * - Null byte injection detection\n   * - File size limit enforcement (default: 10MB)\n   * - UTF-8 validation (binary file detection)\n   * - Optional path whitelist (allowedBasePaths)\n   *\n   * @param requestedPath - Absolute path to file (must be absolute, no relative paths)\n   * @returns Promise resolving to object with file data and metadata\n   * @returns path - Normalized absolute path to the file\n   * @returns content - File contents as UTF-8 string\n   * @returns size - File size in bytes\n   * @returns lastModified - ISO 8601 timestamp of last modification\n   * @returns encoding - Always 'utf-8' for text files\n   *\n   * @throws {CUIError} FILE_NOT_FOUND (404) - File does not exist\n   * @throws {CUIError} NOT_A_FILE (400) - Path exists but is a directory\n   * @throws {CUIError} FILE_TOO_LARGE (400) - File exceeds maxFileSize limit\n   * @throws {CUIError} BINARY_FILE (400) - File contains binary data or invalid UTF-8\n   * @throws {CUIError} ACCESS_DENIED (403) - Insufficient permissions to read file\n   * @throws {CUIError} PATH_TRAVERSAL_DETECTED (400) - Path contains .. segments\n   * @throws {CUIError} INVALID_PATH (400) - Path is relative, contains hidden files, null bytes, or invalid characters\n   * @throws {CUIError} PATH_NOT_ALLOWED (403) - Path is outside allowedBasePaths\n   * @throws {CUIError} READ_FILE_FAILED (500) - Unexpected error reading file\n   *\n   * @example\n   * ```typescript\n   * // Basic file reading\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const result = await fs.readFile('/home/user/project/README.md');\n   * console.log(result.content); // \"# My Project\\n\\nWelcome to...\"\n   * console.log(result.size); // 1024\n   * console.log(result.lastModified); // \"2024-01-01T12:00:00.000Z\"\n   * console.log(result.encoding); // \"utf-8\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - file not found\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * try {\n   *   await fs.readFile('/nonexistent/file.txt');\n   * } catch (error) {\n   *   console.error(error.code); // \"FILE_NOT_FOUND\"\n   *   console.error(error.statusCode); // 404\n   *   console.error(error.message); // \"File not found: /nonexistent/file.txt\"\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - file too large\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService(1024 * 1024); // 1MB limit\n   *\n   * try {\n   *   await fs.readFile('/home/user/large-file.log'); // 5MB file\n   * } catch (error) {\n   *   console.error(error.code); // \"FILE_TOO_LARGE\"\n   *   console.error(error.statusCode); // 400\n   *   console.error(error.message); // \"File size (5242880 bytes) exceeds maximum allowed size (1048576 bytes)\"\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - binary file rejected\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * try {\n   *   await fs.readFile('/home/user/image.png'); // Binary file\n   * } catch (error) {\n   *   console.error(error.code); // \"BINARY_FILE\"\n   *   console.error(error.statusCode); // 400\n   *   console.error(error.message); // \"File appears to be binary or not valid UTF-8\"\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Reading with path restrictions\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService(undefined, ['/home/user/projects']);\n   *\n   * // This succeeds\n   * const result = await fs.readFile('/home/user/projects/app/src/index.ts');\n   *\n   * // This fails with PATH_NOT_ALLOWED\n   * try {\n   *   await fs.readFile('/etc/passwd');\n   * } catch (error) {\n   *   console.error(error.code); // \"PATH_NOT_ALLOWED\"\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Security: path traversal prevention\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * // All of these fail with PATH_TRAVERSAL_DETECTED or INVALID_PATH\n   * try {\n   *   await fs.readFile('/home/user/../../../etc/passwd');\n   * } catch (error) {\n   *   console.error(error.code); // \"PATH_TRAVERSAL_DETECTED\"\n   * }\n   *\n   * try {\n   *   await fs.readFile('/home/user/.ssh/id_rsa'); // Hidden file\n   * } catch (error) {\n   *   console.error(error.code); // \"INVALID_PATH\"\n   * }\n   * ```\n   */\n  async readFile(requestedPath: string): Promise<{ path: string; content: string; size: number; lastModified: string; encoding: string }> {\n    this.logger.debug('Read file requested', { requestedPath });\n    \n    try {\n      // Validate and normalize path\n      const safePath = await this.validatePath(requestedPath);\n      \n      // Check if path exists and is a file\n      const stats = await fs.stat(safePath);\n      if (!stats.isFile()) {\n        throw new CUIError('NOT_A_FILE', `Path is not a file: ${requestedPath}`, 400);\n      }\n      \n      // Check file size\n      if (stats.size > this.maxFileSize) {\n        throw new CUIError(\n          'FILE_TOO_LARGE', \n          `File size (${stats.size} bytes) exceeds maximum allowed size (${this.maxFileSize} bytes)`, \n          400\n        );\n      }\n      \n      // Read file content\n      const content = await fs.readFile(safePath, 'utf-8');\n      \n      // Check if content is valid UTF-8 text\n      if (!this.isValidUtf8(content)) {\n        throw new CUIError('BINARY_FILE', 'File appears to be binary or not valid UTF-8', 400);\n      }\n      \n      this.logger.debug('File read successfully', { \n        path: safePath, \n        size: stats.size \n      });\n      \n      return {\n        path: safePath,\n        content,\n        size: stats.size,\n        lastModified: stats.mtime.toISOString(),\n        encoding: 'utf-8'\n      };\n    } catch (error) {\n      if (error instanceof CUIError) {\n        throw error;\n      }\n      \n      const errorCode = (error as NodeJS.ErrnoException).code;\n      if (errorCode === 'ENOENT') {\n        throw new CUIError('FILE_NOT_FOUND', `File not found: ${requestedPath}`, 404);\n      } else if (errorCode === 'EACCES') {\n        throw new CUIError('ACCESS_DENIED', `Access denied to file: ${requestedPath}`, 403);\n      }\n      \n      this.logger.error('Error reading file', error, { requestedPath });\n      throw new CUIError('READ_FILE_FAILED', `Failed to read file: ${error}`, 500);\n    }\n  }\n\n  /**\n   * Validate and normalize a path to prevent path traversal attacks\n   */\n  private async validatePath(requestedPath: string): Promise<string> {\n    // Require absolute paths\n    if (!path.isAbsolute(requestedPath)) {\n      throw new CUIError('INVALID_PATH', 'Path must be absolute', 400);\n    }\n    \n    // Check for path traversal attempts before normalization\n    if (requestedPath.includes('..')) {\n      this.logger.warn('Path traversal attempt detected', { \n        requestedPath \n      });\n      throw new CUIError('PATH_TRAVERSAL_DETECTED', 'Invalid path: path traversal detected', 400);\n    }\n    \n    // Normalize the path to resolve . segments and clean up\n    const normalizedPath = path.normalize(requestedPath);\n    \n    // Check against allowed base paths if configured\n    if (this.allowedBasePaths.length > 0) {\n      const isAllowed = this.allowedBasePaths.some(basePath => \n        normalizedPath.startsWith(basePath)\n      );\n      \n      if (!isAllowed) {\n        this.logger.warn('Path outside allowed directories', { \n          requestedPath, \n          normalizedPath,\n          allowedBasePaths: this.allowedBasePaths \n        });\n        throw new CUIError('PATH_NOT_ALLOWED', 'Path is outside allowed directories', 403);\n      }\n    }\n    \n    // Additional security checks\n    const segments = normalizedPath.split(path.sep);\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      if (!segment) continue;\n\n      // Skip drive letter on Windows (e.g., \"C:\")\n      const isDriveLetter = process.platform === 'win32' && i === 0 && /^[A-Za-z]:$/.test(segment);\n      if (isDriveLetter) {\n        continue;\n      }\n\n      // Check for hidden files/directories\n      if (segment.startsWith('.')) {\n        this.logger.warn('Hidden file/directory detected', {\n          requestedPath,\n          segment\n        });\n        throw new CUIError('INVALID_PATH', 'Path contains hidden files/directories', 400);\n      }\n\n      // Check for null bytes\n      if (segment.includes('\\u0000')) {\n        this.logger.warn('Null byte detected in path', {\n          requestedPath,\n          segment\n        });\n        throw new CUIError('INVALID_PATH', 'Path contains null bytes', 400);\n      }\n\n      // Check for invalid characters\n      if (/[<>:|?*]/.test(segment)) {\n        this.logger.warn('Invalid characters detected in path', {\n          requestedPath,\n          segment\n        });\n        throw new CUIError('INVALID_PATH', 'Path contains invalid characters', 400);\n      }\n    }\n    \n    this.logger.debug('Path validated successfully', { \n      requestedPath, \n      normalizedPath \n    });\n    \n    return normalizedPath;\n  }\n\n  /**\n   * Check if content appears to be valid UTF-8 text\n   */\n  private isValidUtf8(content: string): boolean {\n    // Check for null bytes - common binary file indicator\n    if (content.includes('\\u0000')) {\n      return false;\n    }\n    \n    // Check for control characters (excluding tab, newline, and carriage return)\n    for (let i = 0; i < content.length; i++) {\n      const charCode = content.charCodeAt(i);\n      // Allow tab (9), newline (10), and carriage return (13)\n      // Reject other control characters (1-8, 11-12, 14-31)\n      if ((charCode >= 1 && charCode <= 8) || \n          (charCode >= 11 && charCode <= 12) || \n          (charCode >= 14 && charCode <= 31)) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * List directory contents without recursion\n   */\n  private async listDirectoryFlat(\n    dirPath: string,\n    ig: ReturnType<typeof ignore> | null\n  ): Promise<FileSystemEntry[]> {\n    const dirents = await fs.readdir(dirPath, { withFileTypes: true });\n    const entries: FileSystemEntry[] = [];\n    \n    for (const dirent of dirents) {\n      // Check gitignore BEFORE any expensive operations\n      if (ig && ig.ignores(dirent.name)) {\n        continue;\n      }\n      \n      const fullPath = path.join(dirPath, dirent.name);\n      const stats = await fs.stat(fullPath);\n      entries.push({\n        name: dirent.name,\n        type: dirent.isDirectory() ? 'directory' : 'file',\n        size: dirent.isFile() ? stats.size : undefined,\n        lastModified: stats.mtime.toISOString()\n      });\n    }\n    \n    return entries;\n  }\n\n  /**\n   * List directory contents recursively\n   */\n  private async listDirectoryRecursive(\n    dirPath: string,\n    basePath: string,\n    ig: ReturnType<typeof ignore> | null\n  ): Promise<FileSystemEntry[]> {\n    const entries: FileSystemEntry[] = [];\n    \n    async function traverse(currentPath: string): Promise<void> {\n      const dirents = await fs.readdir(currentPath, { withFileTypes: true });\n      \n      for (const dirent of dirents) {\n        const fullPath = path.join(currentPath, dirent.name);\n        const relativePath = path.relative(basePath, fullPath);\n        \n        // Check gitignore BEFORE any expensive operations\n        if (ig && ig.ignores(relativePath)) {\n          // Skip this entry entirely - don't stat, don't recurse into directories\n          continue;\n        }\n        \n        const stats = await fs.stat(fullPath);\n        entries.push({\n          name: relativePath,\n          type: dirent.isDirectory() ? 'directory' : 'file',\n          size: dirent.isFile() ? stats.size : undefined,\n          lastModified: stats.mtime.toISOString()\n        });\n        \n        // Recurse into subdirectories (already checked it's not ignored)\n        if (dirent.isDirectory()) {\n          await traverse(fullPath);\n        }\n      }\n    }\n    \n    await traverse(dirPath);\n    return entries;\n  }\n\n  /**\n   * Load gitignore patterns from a directory and its parents\n   */\n  private async loadGitignore(dirPath: string): Promise<ReturnType<typeof ignore>> {\n    const ig = ignore();\n    \n    // Load .gitignore from the directory\n    try {\n      const gitignorePath = path.join(dirPath, '.gitignore');\n      const content = await fs.readFile(gitignorePath, 'utf-8');\n      ig.add(content);\n      this.logger.debug('Loaded .gitignore', { path: gitignorePath });\n    } catch (error) {\n      // .gitignore doesn't exist or can't be read - that's fine\n      const errorCode = (error as NodeJS.ErrnoException).code;\n      if (errorCode !== 'ENOENT') {\n        this.logger.debug('Error reading .gitignore', { error, path: dirPath });\n      }\n    }\n    \n    // Always ignore .git directory\n    ig.add('.git');\n    \n    return ig;\n  }\n\n  /**\n   * Check if a directory is a git repository\n   *\n   * @description\n   * Determines if a directory is a git repository by executing `git rev-parse --git-dir` command.\n   * Returns true if the directory contains a .git directory (is a git repository), false otherwise.\n   * Useful for enabling git-specific features like commit hash retrieval and version control integration.\n   *\n   * **Workflow:**\n   * 1. Execute `git rev-parse --git-dir` in the target directory\n   * 2. If command succeeds (exit code 0), directory is a git repository\n   * 3. If command fails (exit code non-zero), directory is not a git repository\n   * 4. Return boolean result\n   *\n   * **Use Cases:**\n   * - Enable git integration features conditionally\n   * - Detect git repositories for version control workflows\n   * - Pre-flight check before calling getCurrentGitHead()\n   * - Determine if git-based features should be enabled in UI\n   *\n   * @param dirPath - Absolute or relative path to directory to check\n   * @returns Promise resolving to true if directory is a git repository, false otherwise\n   *\n   * @example\n   * ```typescript\n   * // Check if project directory is a git repository\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const isGit = await fs.isGitRepository('/home/user/project');\n   * if (isGit) {\n   *   console.log('Git repository detected - enabling version control features');\n   * } else {\n   *   console.log('Not a git repository - version control features disabled');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Pre-flight check before retrieving commit hash\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * if (await fs.isGitRepository('/home/user/project')) {\n   *   const commitHash = await fs.getCurrentGitHead('/home/user/project');\n   *   console.log(`Current commit: ${commitHash}`);\n   * } else {\n   *   console.log('Not a git repository - skipping commit hash retrieval');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Scan multiple directories to find git repositories\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const directories = [\n   *   '/home/user/project-a',\n   *   '/home/user/project-b',\n   *   '/home/user/project-c'\n   * ];\n   *\n   * const gitRepos = [];\n   * for (const dir of directories) {\n   *   if (await fs.isGitRepository(dir)) {\n   *     gitRepos.push(dir);\n   *   }\n   * }\n   *\n   * console.log(`Found ${gitRepos.length} git repositories:`, gitRepos);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Graceful degradation - always returns false on error\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * // Non-existent directory - returns false\n   * const result1 = await fs.isGitRepository('/nonexistent/path');\n   * console.log(result1); // false\n   *\n   * // Directory without git - returns false\n   * const result2 = await fs.isGitRepository('/tmp');\n   * console.log(result2); // false\n   *\n   * // Git repository - returns true\n   * const result3 = await fs.isGitRepository('/home/user/my-repo');\n   * console.log(result3); // true\n   * ```\n   */\n  async isGitRepository(dirPath: string): Promise<boolean> {\n    try {\n      await execAsync('git rev-parse --git-dir', { cwd: dirPath });\n      return true;\n    } catch (error) {\n      this.logger.debug('Directory is not a git repository', { dirPath, error });\n      return false;\n    }\n  }\n\n  /**\n   * Get current git HEAD commit hash\n   *\n   * @description\n   * Retrieves the current git commit hash (SHA-1) from HEAD in a git repository by executing\n   * `git rev-parse HEAD` command. Returns the full 40-character commit hash or null if the\n   * directory is not a git repository or git command fails. Useful for version tracking,\n   * audit trails, and reproducibility workflows.\n   *\n   * **Workflow:**\n   * 1. Execute `git rev-parse HEAD` in the target directory\n   * 2. If command succeeds, parse stdout to extract commit hash\n   * 3. Trim whitespace from commit hash\n   * 4. Return commit hash string\n   * 5. If command fails, return null (not a git repository or no commits)\n   *\n   * **Use Cases:**\n   * - Track git commit hash for session metadata and audit trails\n   * - Display current commit in UI for version transparency\n   * - Include commit hash in log files for reproducibility\n   * - Verify project version matches expected commit\n   * - Enable commit-based workflows (e.g., \"pin to commit\")\n   *\n   * @param dirPath - Absolute or relative path to git repository directory\n   * @returns Promise resolving to commit hash string (40 characters) or null if not a git repository\n   *\n   * @example\n   * ```typescript\n   * // Get current commit hash for session metadata\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const commitHash = await fs.getCurrentGitHead('/home/user/project');\n   * if (commitHash) {\n   *   console.log(`Current commit: ${commitHash}`);\n   *   // \"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\"\n   * } else {\n   *   console.log('Not a git repository or no commits');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Include commit hash in chat session metadata\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const workingDirectory = '/home/user/project';\n   * const commitHash = await fs.getCurrentGitHead(workingDirectory);\n   *\n   * const sessionMetadata = {\n   *   workingDirectory,\n   *   gitCommit: commitHash || 'not-a-git-repo',\n   *   timestamp: new Date().toISOString()\n   * };\n   *\n   * console.log('Session metadata:', sessionMetadata);\n   * // {\n   * //   workingDirectory: '/home/user/project',\n   * //   gitCommit: 'a1b2c3d4...',\n   * //   timestamp: '2024-01-01T00:00:00.000Z'\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Display version info in UI\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * async function displayVersionInfo(projectPath: string) {\n   *   const isGit = await fs.isGitRepository(projectPath);\n   *\n   *   if (isGit) {\n   *     const commitHash = await fs.getCurrentGitHead(projectPath);\n   *     const shortHash = commitHash?.substring(0, 7) || 'unknown';\n   *     console.log(`\ud83d\udce6 Project: ${projectPath}`);\n   *     console.log(`\ud83d\udd16 Version: ${shortHash}`);\n   *   } else {\n   *     console.log(`\ud83d\udce6 Project: ${projectPath}`);\n   *     console.log(`\ud83d\udd16 Version: not versioned`);\n   *   }\n   * }\n   *\n   * await displayVersionInfo('/home/user/my-app');\n   * // \ud83d\udce6 Project: /home/user/my-app\n   * // \ud83d\udd16 Version: a1b2c3d\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Graceful degradation - returns null on error\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * // Not a git repository - returns null\n   * const result1 = await fs.getCurrentGitHead('/tmp');\n   * console.log(result1); // null\n   *\n   * // Non-existent directory - returns null\n   * const result2 = await fs.getCurrentGitHead('/nonexistent/path');\n   * console.log(result2); // null\n   *\n   * // Git repository with commits - returns commit hash\n   * const result3 = await fs.getCurrentGitHead('/home/user/my-repo');\n   * console.log(result3); // \"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Verify project is on expected commit\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const expectedCommit = 'a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0';\n   * const currentCommit = await fs.getCurrentGitHead('/home/user/project');\n   *\n   * if (currentCommit === expectedCommit) {\n   *   console.log('\u2705 Project is on expected commit');\n   * } else {\n   *   console.warn(`\u26a0\ufe0f Project is on different commit: ${currentCommit}`);\n   *   console.warn(`   Expected: ${expectedCommit}`);\n   * }\n   * ```\n   */\n  async getCurrentGitHead(dirPath: string): Promise<string | null> {\n    try {\n      const { stdout } = await execAsync('git rev-parse HEAD', { cwd: dirPath });\n      return stdout.trim();\n    } catch (error) {\n      this.logger.debug('Failed to get git HEAD', { dirPath, error });\n      return null;\n    }\n  }\n\n  /**\n   * Validate that an executable exists and has executable permissions\n   *\n   * @description\n   * Validates that a file exists at the specified path and has executable permissions (chmod +x).\n   * Throws detailed CUIError if validation fails with appropriate error codes and HTTP status codes.\n   * Essential for validating MCP server stdio executables before attempting to spawn child processes.\n   *\n   * **Workflow:**\n   * 1. Check if file exists at the specified path\n   * 2. Check if file has executable permissions (fs.access with X_OK)\n   * 3. If validation succeeds, return void (no error)\n   * 4. If validation fails, throw CUIError with appropriate code and message\n   *\n   * **Validation Checks:**\n   * - File existence check (existsSync)\n   * - Executable permission check (fs.access with constants.X_OK)\n   * - Detailed error messages for troubleshooting\n   *\n   * **Use Cases:**\n   * - Validate MCP server stdio executables before spawning\n   * - Pre-flight checks for script execution\n   * - Verify tool installations (e.g., git, npm, python)\n   * - Detect permission issues early (before EACCES spawn errors)\n   * - Provide user-friendly error messages for missing executables\n   *\n   * @param executablePath - Absolute or relative path to executable file\n   * @returns Promise resolving to void if validation succeeds\n   *\n   * @throws {CUIError} EXECUTABLE_NOT_FOUND (404) - File does not exist at the specified path\n   * @throws {CUIError} NOT_EXECUTABLE (403) - File exists but does not have executable permissions\n   * @throws {CUIError} EXECUTABLE_VALIDATION_FAILED (500) - Unexpected error during validation\n   *\n   * @example\n   * ```typescript\n   * // Validate MCP server executable before spawning\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * try {\n   *   await fs.validateExecutable('/usr/local/bin/mcp-server');\n   *   console.log('\u2705 MCP server executable is valid');\n   *   // Proceed with spawning child process\n   * } catch (error) {\n   *   if (error.code === 'EXECUTABLE_NOT_FOUND') {\n   *     console.error('\u274c MCP server not found - please install it first');\n   *   } else if (error.code === 'NOT_EXECUTABLE') {\n   *     console.error('\u274c MCP server exists but is not executable');\n   *     console.error('   Run: chmod +x /usr/local/bin/mcp-server');\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Validate tool installations\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * async function validateTools() {\n   *   const tools = [\n   *     { name: 'git', path: '/usr/bin/git' },\n   *     { name: 'node', path: '/usr/local/bin/node' },\n   *     { name: 'npm', path: '/usr/local/bin/npm' }\n   *   ];\n   *\n   *   for (const tool of tools) {\n   *     try {\n   *       await fs.validateExecutable(tool.path);\n   *       console.log(`\u2705 ${tool.name} is installed and executable`);\n   *     } catch (error) {\n   *       console.error(`\u274c ${tool.name} validation failed:`, error.message);\n   *     }\n   *   }\n   * }\n   *\n   * await validateTools();\n   * // \u2705 git is installed and executable\n   * // \u2705 node is installed and executable\n   * // \u2705 npm is installed and executable\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // MCP server configuration validation\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * const mcpServers = [\n   *   { name: 'filesystem', command: '/usr/local/bin/mcp-filesystem' },\n   *   { name: 'database', command: '/usr/local/bin/mcp-database' },\n   *   { name: 'search', command: '/usr/local/bin/mcp-search' }\n   * ];\n   *\n   * for (const server of mcpServers) {\n   *   try {\n   *     await fs.validateExecutable(server.command);\n   *     console.log(`\u2705 ${server.name} MCP server is ready`);\n   *   } catch (error) {\n   *     console.error(`\u274c ${server.name} MCP server validation failed:`, error.message);\n   *     if (error.code === 'NOT_EXECUTABLE') {\n   *       console.error(`   Fix: chmod +x ${server.command}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - file not found\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * try {\n   *   await fs.validateExecutable('/nonexistent/executable');\n   * } catch (error) {\n   *   console.error(error.code); // \"EXECUTABLE_NOT_FOUND\"\n   *   console.error(error.statusCode); // 404\n   *   console.error(error.message); // \"Executable not found: /nonexistent/executable\"\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - not executable\n   * import { FileSystemService } from './file-system-service';\n   *\n   * const fs = new FileSystemService();\n   *\n   * try {\n   *   await fs.validateExecutable('/home/user/script.sh'); // File exists but no +x\n   * } catch (error) {\n   *   console.error(error.code); // \"NOT_EXECUTABLE\"\n   *   console.error(error.statusCode); // 403\n   *   console.error(error.message); // \"File exists but is not executable: /home/user/script.sh\"\n   *\n   *   // Provide user-friendly fix suggestion\n   *   console.error('\\nTo fix this issue, run:');\n   *   console.error(`chmod +x ${error.message.split(': ')[1]}`);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Pre-flight check before spawning child process\n   * import { FileSystemService } from './file-system-service';\n   * import { spawn } from 'child_process';\n   *\n   * const fs = new FileSystemService();\n   *\n   * async function runMcpServer(command: string, args: string[]) {\n   *   // Validate executable before spawning\n   *   await fs.validateExecutable(command);\n   *\n   *   // If validation succeeds, spawn child process\n   *   const child = spawn(command, args, { stdio: ['pipe', 'pipe', 'pipe'] });\n   *\n   *   child.on('error', (error) => {\n   *     // This should rarely happen since we validated the executable\n   *     console.error('Spawn error:', error);\n   *   });\n   *\n   *   return child;\n   * }\n   *\n   * try {\n   *   const mcpProcess = await runMcpServer('/usr/local/bin/mcp-server', ['--port', '8080']);\n   *   console.log('MCP server spawned successfully');\n   * } catch (error) {\n   *   console.error('Failed to start MCP server:', error.message);\n   * }\n   * ```\n   */\n  async validateExecutable(executablePath: string): Promise<void> {\n    this.logger.debug('Validating executable', { executablePath });\n\n    try {\n      // Check if file exists\n      if (!existsSync(executablePath)) {\n        throw new CUIError(\n          'EXECUTABLE_NOT_FOUND',\n          `Executable not found: ${executablePath}`,\n          404\n        );\n      }\n\n      // Check if file is executable\n      try {\n        await fs.access(executablePath, constants.X_OK);\n      } catch (_error) {\n        throw new CUIError(\n          'NOT_EXECUTABLE',\n          `File exists but is not executable: ${executablePath}`,\n          403\n        );\n      }\n\n      this.logger.debug('Executable validation successful', { executablePath });\n    } catch (error) {\n      if (error instanceof CUIError) {\n        throw error;\n      }\n      \n      this.logger.error('Error validating executable', error, { executablePath });\n      throw new CUIError(\n        'EXECUTABLE_VALIDATION_FAILED',\n        `Failed to validate executable: ${error}`,\n        500\n      );\n    }\n  }\n}",
        "last_modified": "2026-01-02T15:10:07.669465"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.551463",
  "last_updated": "2026-01-02T14:06:15.563253"
}