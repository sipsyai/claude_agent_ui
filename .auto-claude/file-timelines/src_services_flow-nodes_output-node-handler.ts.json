{
  "file_path": "src/services/flow-nodes/output-node-handler.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "/**\n * Claude Agent UI - Output Node Handler\n *\n * Handles output nodes in flow execution.\n * Responsibilities:\n * - Format output data according to specified format\n * - Save output to file if configured\n * - Send to webhook if configured\n * - Add metadata and timestamps as needed\n * - Transform output using templates\n *\n * @see src/types/flow-types.ts for OutputNode type definition\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { createLogger, type Logger } from '../logger.js';\nimport type { NodeHandler } from '../flow-execution-service.js';\nimport type {\n  FlowNode,\n  FlowExecutionContext,\n  NodeExecutionResult,\n  OutputNode,\n  FlowOutputFormat,\n} from '../../types/flow-types.js';\nimport { isOutputNode } from '../../types/flow-types.js';\n\n/**\n * OutputNodeHandler - Formats and delivers flow output\n *\n * This handler is typically the terminal node in a flow.\n * It takes the accumulated data from previous nodes and\n * formats/delivers it according to the output configuration.\n */\nexport class OutputNodeHandler implements NodeHandler {\n  private logger: Logger;\n\n  constructor() {\n    this.logger = createLogger('OutputNodeHandler');\n  }\n\n  /**\n   * Execute the output node\n   * @param node - The output node to execute\n   * @param context - The flow execution context\n   * @returns Node execution result with formatted output\n   */\n  async execute(node: FlowNode, context: FlowExecutionContext): Promise<NodeExecutionResult> {\n    // Type guard to ensure we have an OutputNode\n    if (!isOutputNode(node)) {\n      return {\n        success: false,\n        error: `Expected output node, got ${node.type}`,\n      };\n    }\n\n    const outputNode = node as OutputNode;\n    const { data, execution, flow } = context;\n\n    this.logger.info('Processing output node', {\n      nodeId: outputNode.nodeId,\n      nodeName: outputNode.name,\n      outputType: outputNode.outputType,\n      format: outputNode.format,\n    });\n\n    try {\n      // 1. Build the output content\n      let outputContent: any = data;\n\n      // Apply transform template if specified\n      if (outputNode.transformTemplate) {\n        outputContent = this.applyTransformTemplate(\n          outputNode.transformTemplate,\n          data,\n          context.variables\n        );\n      }\n\n      // 2. Add metadata if configured\n      if (outputNode.includeMetadata) {\n        outputContent = {\n          data: outputContent,\n          metadata: {\n            flowId: flow.id,\n            flowName: flow.name,\n            executionId: execution.id,\n            status: execution.status,\n            tokensUsed: execution.tokensUsed,\n            cost: execution.cost,\n          },\n        };\n      }\n\n      // 3. Add timestamp if configured\n      if (outputNode.includeTimestamp) {\n        const wrapper = typeof outputContent === 'object' && outputContent !== null\n          ? outputContent\n          : { data: outputContent };\n        wrapper.timestamp = new Date().toISOString();\n        wrapper.executionTime = execution.executionTime;\n        outputContent = wrapper;\n      }\n\n      // 4. Format the output\n      const formattedOutput = this.formatOutput(outputContent, outputNode.format);\n\n      // 5. Deliver the output based on outputType\n      const deliveryResult = await this.deliverOutput(outputNode, formattedOutput, context);\n\n      if (!deliveryResult.success) {\n        return {\n          success: false,\n          error: deliveryResult.error,\n          errorDetails: deliveryResult.errorDetails,\n        };\n      }\n\n      context.log('info', `Output delivered via ${outputNode.outputType}`, node.nodeId, {\n        format: outputNode.format,\n        deliveryPath: deliveryResult.path,\n      });\n\n      return {\n        success: true,\n        output: {\n          formatted: formattedOutput,\n          deliveryType: outputNode.outputType,\n          deliveryPath: deliveryResult.path,\n          format: outputNode.format,\n        },\n        data: {\n          output: formattedOutput,\n          [outputNode.nodeId]: formattedOutput,\n        },\n        continueExecution: false, // Output node is terminal\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Output node execution failed', error as Error, {\n        nodeId: outputNode.nodeId,\n      });\n\n      return {\n        success: false,\n        error: errorMessage,\n        errorDetails: error instanceof Error ? { stack: error.stack } : undefined,\n      };\n    }\n  }\n\n  /**\n   * Apply transform template to output data\n   * Supports Handlebars-like {{variable}} syntax\n   */\n  private applyTransformTemplate(\n    template: string,\n    data: Record<string, any>,\n    variables: Record<string, any>\n  ): any {\n    // If template is JSON-like, try to parse and interpolate\n    if (template.trim().startsWith('{') || template.trim().startsWith('[')) {\n      try {\n        // Interpolate variables in the template string first\n        const interpolated = this.interpolateTemplate(template, { ...data, ...variables });\n        return JSON.parse(interpolated);\n      } catch {\n        // If parsing fails, return as interpolated string\n        return this.interpolateTemplate(template, { ...data, ...variables });\n      }\n    }\n\n    // For non-JSON templates, just interpolate\n    return this.interpolateTemplate(template, { ...data, ...variables });\n  }\n\n  /**\n   * Interpolate template variables\n   */\n  private interpolateTemplate(template: string, context: Record<string, any>): string {\n    return template.replace(/\\{\\{([^}]+)\\}\\}/g, (match, path) => {\n      const trimmedPath = path.trim();\n      const parts = trimmedPath.split('.');\n      let value: any = context;\n\n      for (const part of parts) {\n        if (value && typeof value === 'object' && part in value) {\n          value = value[part];\n        } else {\n          return match;\n        }\n      }\n\n      if (value === null || value === undefined) {\n        return '';\n      }\n      if (typeof value === 'object') {\n        return JSON.stringify(value);\n      }\n      return String(value);\n    });\n  }\n\n  /**\n   * Format output according to specified format\n   */\n  private formatOutput(data: any, format: FlowOutputFormat): string {\n    switch (format) {\n      case 'json':\n        return JSON.stringify(data, null, 2);\n\n      case 'markdown':\n        return this.toMarkdown(data);\n\n      case 'text':\n        return this.toPlainText(data);\n\n      case 'html':\n        return this.toHtml(data);\n\n      case 'csv':\n        return this.toCsv(data);\n\n      case 'zip':\n        // ZIP format would require additional handling\n        // For now, return JSON representation\n        return JSON.stringify(data, null, 2);\n\n      default:\n        return JSON.stringify(data, null, 2);\n    }\n  }\n\n  /**\n   * Convert data to markdown format\n   */\n  private toMarkdown(data: any): string {\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map((item, index) => `${index + 1}. ${this.toMarkdown(item)}`).join('\\n');\n    }\n\n    if (typeof data === 'object' && data !== null) {\n      const lines: string[] = [];\n\n      // Handle metadata section\n      if (data.metadata) {\n        lines.push('## Execution Metadata\\n');\n        lines.push('| Property | Value |');\n        lines.push('|----------|-------|');\n        for (const [key, value] of Object.entries(data.metadata)) {\n          lines.push(`| ${key} | ${value} |`);\n        }\n        lines.push('');\n      }\n\n      // Handle data section\n      const mainData = data.data || data;\n      if (typeof mainData === 'string') {\n        lines.push(mainData);\n      } else if (typeof mainData === 'object') {\n        lines.push('## Output Data\\n');\n        lines.push('```json');\n        lines.push(JSON.stringify(mainData, null, 2));\n        lines.push('```');\n      }\n\n      // Add timestamp if present\n      if (data.timestamp) {\n        lines.push(`\\n---\\n*Generated at: ${data.timestamp}*`);\n      }\n\n      return lines.join('\\n');\n    }\n\n    return String(data);\n  }\n\n  /**\n   * Convert data to plain text format\n   */\n  private toPlainText(data: any): string {\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map((item) => this.toPlainText(item)).join('\\n');\n    }\n\n    if (typeof data === 'object' && data !== null) {\n      const lines: string[] = [];\n\n      const flatten = (obj: any, prefix = ''): void => {\n        for (const [key, value] of Object.entries(obj)) {\n          const newKey = prefix ? `${prefix}.${key}` : key;\n          if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n            flatten(value, newKey);\n          } else {\n            lines.push(`${newKey}: ${JSON.stringify(value)}`);\n          }\n        }\n      };\n\n      flatten(data);\n      return lines.join('\\n');\n    }\n\n    return String(data);\n  }\n\n  /**\n   * Convert data to HTML format\n   */\n  private toHtml(data: any): string {\n    const escapeHtml = (text: string): string => {\n      return text\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#039;');\n    };\n\n    if (typeof data === 'string') {\n      return `<p>${escapeHtml(data)}</p>`;\n    }\n\n    if (Array.isArray(data)) {\n      const items = data.map((item) => `<li>${this.toHtml(item)}</li>`).join('');\n      return `<ul>${items}</ul>`;\n    }\n\n    if (typeof data === 'object' && data !== null) {\n      const rows: string[] = [];\n\n      for (const [key, value] of Object.entries(data)) {\n        const valueHtml = typeof value === 'object'\n          ? `<pre>${escapeHtml(JSON.stringify(value, null, 2))}</pre>`\n          : escapeHtml(String(value));\n        rows.push(`<tr><th>${escapeHtml(key)}</th><td>${valueHtml}</td></tr>`);\n      }\n\n      return `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Flow Output</title>\n  <style>\n    body { font-family: system-ui, sans-serif; padding: 20px; }\n    table { border-collapse: collapse; width: 100%; }\n    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n    th { background-color: #f4f4f4; }\n    pre { background: #f8f8f8; padding: 10px; overflow-x: auto; }\n  </style>\n</head>\n<body>\n  <h1>Flow Output</h1>\n  <table>${rows.join('')}</table>\n</body>\n</html>`.trim();\n    }\n\n    return `<p>${escapeHtml(String(data))}</p>`;\n  }\n\n  /**\n   * Convert data to CSV format\n   */\n  private toCsv(data: any): string {\n    const escapeCSV = (value: any): string => {\n      const str = typeof value === 'object' ? JSON.stringify(value) : String(value);\n      if (str.includes(',') || str.includes('\"') || str.includes('\\n')) {\n        return `\"${str.replace(/\"/g, '\"\"')}\"`;\n      }\n      return str;\n    };\n\n    if (Array.isArray(data)) {\n      if (data.length === 0) {\n        return '';\n      }\n\n      // If array of objects, create CSV with headers\n      if (typeof data[0] === 'object' && data[0] !== null) {\n        const headers = Object.keys(data[0]);\n        const headerRow = headers.map(escapeCSV).join(',');\n        const dataRows = data.map((row) =>\n          headers.map((h) => escapeCSV(row[h])).join(',')\n        );\n        return [headerRow, ...dataRows].join('\\n');\n      }\n\n      // Simple array\n      return data.map(escapeCSV).join('\\n');\n    }\n\n    if (typeof data === 'object' && data !== null) {\n      const rows = Object.entries(data).map(\n        ([key, value]) => `${escapeCSV(key)},${escapeCSV(value)}`\n      );\n      return rows.join('\\n');\n    }\n\n    return escapeCSV(data);\n  }\n\n  /**\n   * Deliver the output based on outputType\n   */\n  private async deliverOutput(\n    node: OutputNode,\n    formattedOutput: string,\n    context: FlowExecutionContext\n  ): Promise<{ success: boolean; path?: string; error?: string; errorDetails?: any }> {\n    switch (node.outputType) {\n      case 'response':\n        // Response type just returns the formatted output\n        return { success: true, path: 'response' };\n\n      case 'file':\n        return await this.saveToFile(node, formattedOutput, context);\n\n      case 'webhook':\n        return await this.sendToWebhook(node, formattedOutput, context);\n\n      case 'database':\n        // Database delivery would store in a database\n        // For now, this is handled by the execution service via Strapi\n        return { success: true, path: 'database' };\n\n      case 'email':\n        // Email delivery would require email service integration\n        // Not implemented in this personal-use version\n        context.log('warn', 'Email output type not implemented', node.nodeId);\n        return { success: true, path: 'email (not sent)' };\n\n      default:\n        return { success: true, path: 'unknown' };\n    }\n  }\n\n  /**\n   * Save output to file\n   */\n  private async saveToFile(\n    node: OutputNode,\n    content: string,\n    context: FlowExecutionContext\n  ): Promise<{ success: boolean; path?: string; error?: string }> {\n    if (!node.saveToFile) {\n      return { success: true };\n    }\n\n    try {\n      // Determine file extension based on format\n      const extensions: Record<FlowOutputFormat, string> = {\n        json: '.json',\n        markdown: '.md',\n        text: '.txt',\n        html: '.html',\n        csv: '.csv',\n        zip: '.zip',\n      };\n\n      const extension = extensions[node.format] || '.txt';\n\n      // Build file path\n      let filePath = node.filePath || './output';\n      let fileName = node.fileName || `flow-output-${context.execution.id}${extension}`;\n\n      // Interpolate variables in path and name\n      const variables = { ...context.variables, ...context.data };\n      filePath = this.interpolateTemplate(filePath, variables);\n      fileName = this.interpolateTemplate(fileName, variables);\n\n      const fullPath = path.join(filePath, fileName);\n\n      // Ensure directory exists\n      await fs.mkdir(path.dirname(fullPath), { recursive: true });\n\n      // Write file\n      await fs.writeFile(fullPath, content, 'utf-8');\n\n      this.logger.info('Output saved to file', { path: fullPath });\n\n      return { success: true, path: fullPath };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save output to file', error as Error);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  /**\n   * Send output to webhook\n   */\n  private async sendToWebhook(\n    node: OutputNode,\n    content: string,\n    context: FlowExecutionContext\n  ): Promise<{ success: boolean; path?: string; error?: string }> {\n    if (!node.webhookUrl) {\n      return { success: false, error: 'Webhook URL not configured' };\n    }\n\n    try {\n      // Interpolate webhook URL with variables\n      const variables = { ...context.variables, ...context.data };\n      const webhookUrl = this.interpolateTemplate(node.webhookUrl, variables);\n\n      // Build headers\n      const headers: Record<string, string> = {\n        'Content-Type': node.format === 'json' ? 'application/json' : 'text/plain',\n        ...node.webhookHeaders,\n      };\n\n      // Send webhook request\n      const response = await fetch(webhookUrl, {\n        method: 'POST',\n        headers,\n        body: content,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Webhook failed with status ${response.status}: ${response.statusText}`);\n      }\n\n      this.logger.info('Output sent to webhook', { url: webhookUrl, status: response.status });\n\n      return { success: true, path: webhookUrl };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to send output to webhook', error as Error);\n      return { success: false, error: errorMessage };\n    }\n  }\n}\n\n/**\n * Singleton instance for registration\n */\nexport const outputNodeHandler = new OutputNodeHandler();\n",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:47.308387",
  "last_updated": "2026-01-02T15:21:47.319145"
}