{
  "file_path": "backend/src/api/flow-execution/controllers/flow-execution.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "/**\n * Flow Execution controller\n *\n * Enhanced controller for FlowExecution CRUD operations with custom routes\n * for managing flow execution history, tracking, and lifecycle operations.\n */\n\nimport { factories } from '@strapi/strapi';\n\nexport default factories.createCoreController('api::flow-execution.flow-execution', ({ strapi }) => ({\n  /**\n   * Get executions for a specific flow\n   * GET /api/flow-executions/flow/:flowId\n   */\n  async findByFlowId(ctx) {\n    const { flowId } = ctx.params;\n    const limit = parseInt(ctx.query.limit as string) || 10;\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const executions = await executionService.findByFlowId(parseInt(flowId), limit);\n\n      ctx.send({\n        data: executions,\n      });\n    } catch (error: any) {\n      strapi.log.error('Find by flow ID failed:', error);\n      return ctx.badRequest('Find by flow ID failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Get all running executions\n   * GET /api/flow-executions/running\n   */\n  async findRunning(ctx) {\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const executions = await executionService.findRunning();\n\n      ctx.send({\n        data: executions,\n      });\n    } catch (error: any) {\n      strapi.log.error('Find running executions failed:', error);\n      return ctx.badRequest('Find running executions failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Get recent executions across all flows\n   * GET /api/flow-executions/recent\n   */\n  async findRecent(ctx) {\n    const limit = parseInt(ctx.query.limit as string) || 20;\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const executions = await executionService.findRecent(limit);\n\n      ctx.send({\n        data: executions,\n      });\n    } catch (error: any) {\n      strapi.log.error('Find recent executions failed:', error);\n      return ctx.badRequest('Find recent executions failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Get executions by status\n   * GET /api/flow-executions/status/:status\n   */\n  async findByStatus(ctx) {\n    const { status } = ctx.params;\n    const limit = parseInt(ctx.query.limit as string) || 20;\n\n    const validStatuses = ['pending', 'running', 'completed', 'failed', 'cancelled'];\n    if (!validStatuses.includes(status)) {\n      return ctx.badRequest(`Invalid status. Must be one of: ${validStatuses.join(', ')}`);\n    }\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const executions = await executionService.findByStatus(status, limit);\n\n      ctx.send({\n        data: executions,\n      });\n    } catch (error: any) {\n      strapi.log.error('Find by status failed:', error);\n      return ctx.badRequest('Find by status failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Get execution with full details\n   * GET /api/flow-executions/:id/details\n   */\n  async findDetails(ctx) {\n    const { id } = ctx.params;\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const execution = await executionService.findWithFlow(parseInt(id));\n\n      if (!execution) {\n        return ctx.notFound('Execution not found');\n      }\n\n      ctx.send({\n        data: execution,\n      });\n    } catch (error: any) {\n      strapi.log.error('Find execution details failed:', error);\n      return ctx.badRequest('Find execution details failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Get execution statistics for a flow\n   * GET /api/flow-executions/stats/:flowId\n   */\n  async getStats(ctx) {\n    const { flowId } = ctx.params;\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const stats = await executionService.getFlowStats(parseInt(flowId));\n\n      ctx.send({\n        data: stats,\n      });\n    } catch (error: any) {\n      strapi.log.error('Get flow stats failed:', error);\n      return ctx.badRequest('Get flow stats failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Get global execution statistics\n   * GET /api/flow-executions/stats\n   */\n  async getGlobalStats(ctx) {\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const stats = await executionService.getGlobalStats();\n\n      ctx.send({\n        data: stats,\n      });\n    } catch (error: any) {\n      strapi.log.error('Get global stats failed:', error);\n      return ctx.badRequest('Get global stats failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Start a new flow execution\n   * POST /api/flow-executions/start\n   * Body: { flowId, input, triggeredBy?, triggerData? }\n   */\n  async start(ctx) {\n    const { flowId, input, triggeredBy, triggerData } = ctx.request.body;\n\n    if (!flowId) {\n      return ctx.badRequest('Missing \"flowId\" in request body');\n    }\n\n    try {\n      // Verify flow exists\n      const flow = await strapi.entityService.findOne('api::flow.flow', parseInt(flowId));\n      if (!flow) {\n        return ctx.notFound('Flow not found');\n      }\n\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const execution = await executionService.startExecution(\n        parseInt(flowId),\n        input || {},\n        triggeredBy || 'manual',\n        triggerData\n      );\n\n      ctx.send({\n        data: execution,\n        message: 'Flow execution started',\n      });\n    } catch (error: any) {\n      strapi.log.error('Start execution failed:', error);\n      return ctx.badRequest('Start execution failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Add a log entry to an execution\n   * POST /api/flow-executions/:id/log\n   * Body: { level, message, nodeId? }\n   */\n  async addLog(ctx) {\n    const { id } = ctx.params;\n    const { level, message, nodeId } = ctx.request.body;\n\n    if (!level || !message) {\n      return ctx.badRequest('Missing \"level\" or \"message\" in request body');\n    }\n\n    const validLevels = ['debug', 'info', 'warn', 'error'];\n    if (!validLevels.includes(level)) {\n      return ctx.badRequest(`Invalid level. Must be one of: ${validLevels.join(', ')}`);\n    }\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const execution = await executionService.addLog(parseInt(id), level, message, nodeId);\n\n      ctx.send({\n        data: execution,\n        message: 'Log entry added',\n      });\n    } catch (error: any) {\n      strapi.log.error('Add log failed:', error);\n      return ctx.badRequest('Add log failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Update node execution state\n   * PUT /api/flow-executions/:id/node/:nodeId\n   * Body: { status, input?, output?, error?, startedAt?, completedAt? }\n   */\n  async updateNode(ctx) {\n    const { id, nodeId } = ctx.params;\n    const nodeState = ctx.request.body;\n\n    if (!nodeState || Object.keys(nodeState).length === 0) {\n      return ctx.badRequest('Node state is required in request body');\n    }\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const execution = await executionService.updateNodeExecution(\n        parseInt(id),\n        nodeId,\n        nodeState\n      );\n\n      ctx.send({\n        data: execution,\n        message: 'Node execution updated',\n      });\n    } catch (error: any) {\n      strapi.log.error('Update node execution failed:', error);\n      return ctx.badRequest('Update node execution failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Complete an execution\n   * POST /api/flow-executions/:id/complete\n   * Body: { output, tokensUsed?, cost? }\n   */\n  async complete(ctx) {\n    const { id } = ctx.params;\n    const { output, tokensUsed, cost } = ctx.request.body;\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const execution = await executionService.completeExecution(\n        parseInt(id),\n        output || {},\n        tokensUsed || 0,\n        cost || 0\n      );\n\n      ctx.send({\n        data: execution,\n        message: 'Execution completed successfully',\n      });\n    } catch (error: any) {\n      strapi.log.error('Complete execution failed:', error);\n      return ctx.badRequest('Complete execution failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Fail an execution\n   * POST /api/flow-executions/:id/fail\n   * Body: { error, errorDetails? }\n   */\n  async fail(ctx) {\n    const { id } = ctx.params;\n    const { error, errorDetails } = ctx.request.body;\n\n    if (!error) {\n      return ctx.badRequest('Missing \"error\" in request body');\n    }\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const execution = await executionService.failExecution(parseInt(id), error, errorDetails);\n\n      ctx.send({\n        data: execution,\n        message: 'Execution marked as failed',\n      });\n    } catch (error: any) {\n      strapi.log.error('Fail execution failed:', error);\n      return ctx.badRequest('Fail execution failed', { error: (error as Error).message });\n    }\n  },\n\n  /**\n   * Cancel a running execution\n   * POST /api/flow-executions/:id/cancel\n   */\n  async cancel(ctx) {\n    const { id } = ctx.params;\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const execution = await executionService.cancelExecution(parseInt(id));\n\n      ctx.send({\n        data: execution,\n        message: 'Execution cancelled',\n      });\n    } catch (error: any) {\n      strapi.log.error('Cancel execution failed:', error);\n      return ctx.badRequest('Cancel execution failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Retry a failed execution\n   * POST /api/flow-executions/:id/retry\n   */\n  async retry(ctx) {\n    const { id } = ctx.params;\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const newExecution = await executionService.retryExecution(parseInt(id));\n\n      ctx.send({\n        data: newExecution,\n        message: 'Execution retry started',\n      });\n    } catch (error: any) {\n      strapi.log.error('Retry execution failed:', error);\n      return ctx.badRequest('Retry execution failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Get execution logs\n   * GET /api/flow-executions/:id/logs\n   */\n  async getLogs(ctx) {\n    const { id } = ctx.params;\n\n    try {\n      const execution: any = await strapi.entityService.findOne(\n        'api::flow-execution.flow-execution',\n        parseInt(id)\n      );\n\n      if (!execution) {\n        return ctx.notFound('Execution not found');\n      }\n\n      ctx.send({\n        data: execution.logs || [],\n      });\n    } catch (error: any) {\n      strapi.log.error('Get logs failed:', error);\n      return ctx.badRequest('Get logs failed', { error: error.message });\n    }\n  },\n\n  /**\n   * Clean up old executions\n   * DELETE /api/flow-executions/cleanup\n   * Query: { olderThanDays?: number, status?: string }\n   */\n  async cleanup(ctx) {\n    const olderThanDays = parseInt(ctx.query.olderThanDays as string) || 30;\n    const status = ctx.query.status as string;\n\n    try {\n      const executionService = strapi.service('api::flow-execution.flow-execution');\n      const deletedCount = await executionService.cleanupOld(olderThanDays, status);\n\n      ctx.send({\n        data: { deletedCount },\n        message: `Cleaned up ${deletedCount} old executions`,\n      });\n    } catch (error: any) {\n      strapi.log.error('Cleanup failed:', error);\n      return ctx.badRequest('Cleanup failed', { error: error.message });\n    }\n  },\n}));\n",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:47.218629",
  "last_updated": "2026-01-02T15:21:47.230069"
}