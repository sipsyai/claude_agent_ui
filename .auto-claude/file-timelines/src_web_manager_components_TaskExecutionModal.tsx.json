{
  "file_path": "src/web/manager/components/TaskExecutionModal.tsx",
  "main_branch_history": [],
  "task_views": {
    "004-document-frontend-react-components-and-hooks": {
      "task_id": "004-document-frontend-react-components-and-hooks",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import React, { useState, useEffect, useRef } from 'react';\nimport * as api from '../services/api';\nimport { Button } from './ui/Button';\nimport { XCircleIcon } from './ui/Icons';\n\ninterface TaskExecutionModalProps {\n  task: api.Task;\n  onClose: () => void;\n  onComplete: () => void;\n}\n\ninterface Message {\n  id: string;\n  type: 'status' | 'assistant' | 'user' | 'result' | 'error' | 'debug' | 'tool_use';\n  content: string;\n  timestamp: Date;\n  toolName?: string;\n  toolInput?: any;\n  toolResult?: any; // Added to tool_use messages when result arrives\n  toolUseId?: string;\n}\n\nconst TaskExecutionModal: React.FC<TaskExecutionModalProps> = ({ task, onClose, onComplete }) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isExecuting, setIsExecuting] = useState(true);\n  const [executionStatus, setExecutionStatus] = useState<string>('Starting...');\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const executionStartedRef = useRef(false);\n\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  useEffect(() => {\n    // Prevent double execution in React StrictMode\n    if (executionStartedRef.current) return;\n    executionStartedRef.current = true;\n\n    // Start execution\n    executeTask();\n  }, []);\n\n  const executeTask = async () => {\n    setIsExecuting(true);\n    setMessages([]);\n\n    try {\n      await api.executeTask(task.id, (event) => {\n        // Handle assistant messages (contains tool_use blocks)\n        if (event.type === 'message' && event.content) {\n          const eventContent = event.content;\n\n          // Handle assistant messages\n          if (eventContent.type === 'assistant' && eventContent.message) {\n            const message = eventContent.message;\n            if (message.content && Array.isArray(message.content)) {\n              const blocks = message.content;\n\n              // Process text blocks for assistant message\n              const textContent = blocks\n                .filter((block: any) => block.type === 'text')\n                .map((block: any) => block.text)\n                .join('\\n');\n\n              if (textContent) {\n                setMessages((prev) => [...prev, {\n                  id: `${Date.now()}-${Math.random()}`,\n                  type: 'assistant',\n                  content: textContent,\n                  timestamp: new Date(),\n                }]);\n              }\n\n              // Process tool_use blocks separately\n              const toolUseBlocks = blocks.filter((block: any) => block.type === 'tool_use');\n              toolUseBlocks.forEach((toolBlock: any) => {\n                setMessages((prev) => [...prev, {\n                  id: `tool-use-${toolBlock.id}`,\n                  type: 'tool_use',\n                  content: '',\n                  timestamp: new Date(),\n                  toolName: toolBlock.name,\n                  toolInput: toolBlock.input,\n                  toolUseId: toolBlock.id,\n                }]);\n              });\n            }\n            return;\n          }\n\n          // Handle user messages (contains tool_result blocks)\n          if (eventContent.type === 'user' && eventContent.message) {\n            const message = eventContent.message;\n            if (message.content && Array.isArray(message.content)) {\n              const blocks = message.content;\n\n              // Process tool_result blocks\n              const toolResultBlocks = blocks.filter((block: any) => block.type === 'tool_result');\n              toolResultBlocks.forEach((resultBlock: any) => {\n                const toolUseId = resultBlock.tool_use_id;\n                const toolResult = resultBlock.content;\n\n                // Find and update the corresponding tool_use message\n                setMessages((prev) => prev.map(msg =>\n                  msg.toolUseId === toolUseId\n                    ? { ...msg, toolResult }\n                    : msg\n                ));\n              });\n            }\n            return;\n          }\n\n          // Handle result\n          if (eventContent.type === 'result') {\n            const resultText = eventContent.is_error\n              ? `\u274c Task failed: ${eventContent.result}`\n              : `\u2705 Task completed successfully`;\n\n            setMessages((prev) => [...prev, {\n              id: `${Date.now()}-${Math.random()}`,\n              type: 'status',\n              content: resultText,\n              timestamp: new Date(),\n            }]);\n\n            if (!eventContent.is_error && eventContent.result) {\n              setMessages((prev) => [...prev, {\n                id: `${Date.now()}-${Math.random()}`,\n                type: 'assistant',\n                content: typeof eventContent.result === 'string' ? eventContent.result : JSON.stringify(eventContent.result, null, 2),\n                timestamp: new Date(),\n              }]);\n            }\n\n            setIsExecuting(false);\n            setExecutionStatus(eventContent.is_error ? 'Failed' : 'Completed');\n            onComplete();\n            return;\n          }\n        }\n\n        // Handle other event types\n        if (event.type === 'status') {\n          setExecutionStatus(event.message || event.status);\n          setMessages((prev) => [...prev, {\n            id: `${Date.now()}-${Math.random()}`,\n            type: 'status',\n            content: event.message || event.status,\n            timestamp: new Date(),\n          }]);\n        } else if (event.type === 'debug') {\n          // Only show important debug messages\n          if (event.message && event.message.includes('STDIN')) {\n            setMessages((prev) => [...prev, {\n              id: `${Date.now()}-${Math.random()}`,\n              type: 'debug',\n              content: event.message,\n              timestamp: new Date(),\n            }]);\n          }\n        } else if (event.type === 'error') {\n          setMessages((prev) => [...prev, {\n            id: `${Date.now()}-${Math.random()}`,\n            type: 'error',\n            content: `\u274c Error: ${event.error}`,\n            timestamp: new Date(),\n          }]);\n          setIsExecuting(false);\n          setExecutionStatus('Failed');\n          onComplete();\n        }\n      });\n    } catch (error: any) {\n      setMessages((prev) => [...prev, {\n        id: `${Date.now()}-${Math.random()}`,\n        type: 'error',\n        content: `\u274c Error: ${error.message}`,\n        timestamp: new Date(),\n      }]);\n      setIsExecuting(false);\n      setExecutionStatus('Failed');\n    }\n  };\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50\">\n      <div className=\"bg-background border border-border rounded-lg shadow-lg w-full max-w-4xl max-h-[90vh] flex flex-col\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between p-4 border-b border-border\">\n          <div>\n            <h2 className=\"text-xl font-bold\">Execute Task: {task.name}</h2>\n            <div className=\"flex items-center gap-2 mt-1\">\n              <span className=\"text-sm text-muted-foreground\">{task.agentName}</span>\n              <span className=\"text-xs px-2 py-0.5 rounded bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300\">\n                {executionStatus}\n              </span>\n            </div>\n          </div>\n          <button\n            onClick={onClose}\n            className=\"text-muted-foreground hover:text-foreground\"\n            disabled={isExecuting}\n          >\n            <XCircleIcon className=\"h-6 w-6\" />\n          </button>\n        </div>\n\n        {/* Messages */}\n        <div className=\"flex-1 overflow-y-auto p-4 space-y-3\">\n          {messages.length === 0 && !isExecuting && (\n            <div className=\"text-center text-muted-foreground py-12\">\n              Task execution starting...\n            </div>\n          )}\n\n          {messages.map((message) => (\n            <div\n              key={message.id}\n              className={`p-3 rounded-lg ${\n                message.type === 'error'\n                  ? 'bg-red-500/10 border border-red-500/20'\n                  : message.type === 'debug'\n                  ? 'bg-yellow-500/10 border border-yellow-500/20'\n                  : message.type === 'status'\n                  ? 'bg-blue-500/10 border border-blue-500/20'\n                  : message.type === 'tool_use'\n                  ? 'bg-purple-500/10 border border-purple-500/20'\n                  : message.type === 'assistant'\n                  ? 'bg-primary/10 border border-primary/20'\n                  : 'bg-secondary'\n              }`}\n            >\n              <div className=\"flex items-start justify-between mb-1\">\n                <span className=\"text-xs font-semibold uppercase tracking-wide\">\n                  {message.type === 'tool_use'\n                    ? `\ud83d\udd27 ${message.toolName}`\n                    : message.type}\n                </span>\n                <span className=\"text-xs text-muted-foreground\">\n                  {message.timestamp.toLocaleTimeString()}\n                </span>\n              </div>\n\n              {message.type === 'tool_use' ? (\n                <div className=\"text-sm space-y-2\">\n                  <div className=\"font-medium text-purple-400\">Tool: {message.toolName}</div>\n\n                  {/* Input Parameters */}\n                  {message.toolInput && (\n                    <details className=\"cursor-pointer\">\n                      <summary className=\"text-xs text-muted-foreground hover:text-foreground\">\n                        \ud83d\udce5 Input Parameters\n                      </summary>\n                      <pre className=\"mt-2 text-xs bg-black/20 p-2 rounded overflow-x-auto\">\n                        {JSON.stringify(message.toolInput, null, 2)}\n                      </pre>\n                    </details>\n                  )}\n\n                  {/* Output Result - only show if available */}\n                  {message.toolResult && (\n                    <details\n                      className=\"cursor-pointer\"\n                      open={typeof message.toolResult === 'string' && message.toolResult.length < 200}\n                    >\n                      <summary className=\"text-xs text-muted-foreground hover:text-foreground\">\n                        \ud83d\udce4 Output Result\n                      </summary>\n                      <div className=\"mt-2 text-xs bg-black/20 p-2 rounded overflow-x-auto\">\n                        {typeof message.toolResult === 'string' ? (\n                          <pre className=\"whitespace-pre-wrap\">{message.toolResult}</pre>\n                        ) : (\n                          <pre>{JSON.stringify(message.toolResult, null, 2)}</pre>\n                        )}\n                      </div>\n                    </details>\n                  )}\n\n                  {/* Show loading state if no result yet */}\n                  {!message.toolResult && (\n                    <div className=\"text-xs text-muted-foreground italic\">\n                      Waiting for result...\n                    </div>\n                  )}\n                </div>\n              ) : (\n                <div className=\"text-sm whitespace-pre-wrap break-words\">\n                  {message.content}\n                </div>\n              )}\n            </div>\n          ))}\n\n          {isExecuting && messages.length === 0 && (\n            <div className=\"text-center text-muted-foreground py-6\">\n              <div className=\"animate-pulse\">Starting task execution...</div>\n            </div>\n          )}\n\n          <div ref={messagesEndRef} />\n        </div>\n\n        {/* Footer */}\n        <div className=\"p-4 border-t border-border flex justify-end gap-2\">\n          <Button variant=\"secondary\" onClick={onClose} disabled={isExecuting}>\n            {isExecuting ? 'Running...' : 'Close'}\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TaskExecutionModal;\n",
        "timestamp": "2026-01-02T14:22:14.293924"
      },
      "worktree_state": {
        "content": "/**\n * @file TaskExecutionModal.tsx\n * @description Modal component for executing tasks with real-time SSE streaming and comprehensive\n * message handling including tool use visualization and progress tracking.\n *\n * ## Features\n * - Automatic task execution on mount\n * - Real-time SSE event streaming with message updates\n * - Tool use tracking with input parameters and results\n * - Execution progress tracking with status updates\n * - Auto-scrolling message list\n * - Loading and execution states\n * - Error handling with user-friendly messages\n * - Completion callback for parent component updates\n *\n * ## Task Execution Flow\n * The component follows this execution lifecycle:\n * 1. Modal opens with task details\n * 2. `executeTask` automatically triggered on mount via useEffect\n * 3. SSE stream initiated via `api.executeTask` with event callback\n * 4. Events processed in real-time and messages updated incrementally\n * 5. Tool use blocks tracked separately with unique IDs\n * 6. Tool results matched back to tool use messages via `toolUseId`\n * 7. Execution completes with success or error status\n * 8. `onComplete` callback invoked to notify parent component\n * 9. User can close modal via Close button (disabled during execution)\n *\n * ## Progress Tracking\n * The component maintains execution progress through:\n * - **isExecuting**: Boolean state indicating whether task is currently running\n * - **executionStatus**: String state showing current status (e.g., \"Starting...\", \"Completed\", \"Failed\")\n * - Status updates appear in header badge with color-coded background\n * - Status messages added to message list for detailed progress visibility\n *\n * ## Message Handling\n * The component processes multiple message types from SSE events:\n *\n * ### Assistant Messages\n * - Content blocks parsed from `message.content` array\n * - Text blocks displayed as assistant messages with primary styling\n * - Tool use blocks create separate tool_use messages\n * - Each tool use tracked with unique ID for result matching\n *\n * ### User Messages\n * - Tool result blocks parsed from `message.content` array\n * - Results matched back to tool use messages via `toolUseId`\n * - Updates existing tool_use message with `toolResult` property\n *\n * ### Result Messages\n * - Final execution result from task completion\n * - Success: \"\u2705 Task completed successfully\" with green indicator\n * - Failure: \"\u274c Task failed: {error}\" with red indicator\n * - Result data displayed as assistant message (JSON or string)\n * - Sets `isExecuting` to false and updates `executionStatus`\n * - Triggers `onComplete` callback\n *\n * ### Status Messages\n * - General status updates from task execution\n * - Displayed with blue background/border\n * - Updates both message list and header status badge\n *\n * ### Error Messages\n * - Error events displayed with red styling\n * - Catches both streaming errors and execution failures\n * - Sets `isExecuting` to false and `executionStatus` to \"Failed\"\n * - Triggers `onComplete` callback even on error\n *\n * ### Debug Messages\n * - Debug information with yellow styling\n * - Filtered to show only important messages (e.g., STDIN-related)\n * - Useful for troubleshooting task behavior\n *\n * ### Tool Use Messages\n * - Special message type for tool executions\n * - Displays tool name with \ud83d\udd27 emoji icon\n * - Collapsible sections for input parameters (\ud83d\udce5) and output results (\ud83d\udce4)\n * - Auto-expand short results (<200 chars)\n * - Loading state (\"Waiting for result...\") while waiting for tool results\n * - Purple background/border for visual distinction\n *\n * ## Result Display\n * When task execution completes successfully:\n * - Success status message added to message list\n * - Result data displayed as assistant message\n * - Handles both string and object results (JSON stringified with formatting)\n * - Header status badge updates to \"Completed\" with appropriate color\n * - Close button becomes enabled\n *\n * ## UI States\n *\n * ### Empty State (Initial Load)\n * - Shown briefly when execution starting but no messages yet\n * - \"Task execution starting...\" message\n *\n * ### Loading State\n * - Shown when `isExecuting === true` and no messages yet\n * - Animated pulse with \"Starting task execution...\" message\n *\n * ### Executing State\n * - Close button disabled to prevent premature closure\n * - Close button shows \"Running...\" text\n * - Messages appear in real-time as events arrive\n * - Status badge shows current execution status\n *\n * ### Completed State\n * - Close button re-enabled and shows \"Close\" text\n * - Status badge shows \"Completed\" or \"Failed\"\n * - Messages remain visible for review\n * - User can close modal\n *\n * ## Styling Behavior\n * - Modal overlay with dark semi-transparent backdrop (bg-black/50)\n * - Centered modal dialog with max width 4xl and max height 90vh\n * - Three-section layout: header (with task name, agent, status), messages (scrollable), footer\n * - Message styling varies by type:\n *   - Error: red background/border (bg-red-500/10, border-red-500/20)\n *   - Debug: yellow background/border (bg-yellow-500/10, border-yellow-500/20)\n *   - Status: blue background/border (bg-blue-500/10, border-blue-500/20)\n *   - Tool use: purple background/border (bg-purple-500/10, border-purple-500/20)\n *   - Assistant: primary background/border (bg-primary/10, border-primary/20)\n *   - Default: secondary background (bg-secondary)\n * - Auto-scroll to bottom on new messages with smooth behavior\n * - Tool use sections with collapsible details elements\n * - Status badge in header with blue background (bg-blue-100, dark:bg-blue-900)\n *\n * @example\n * ```tsx\n * // Basic usage with task execution\n * const [selectedTask, setSelectedTask] = useState<Task | null>(null);\n * const [isModalOpen, setIsModalOpen] = useState(false);\n *\n * const handleTaskComplete = () => {\n *   // Refresh task list or update UI\n *   fetchTasks();\n * };\n *\n * <TaskExecutionModal\n *   task={selectedTask}\n *   onClose={() => setIsModalOpen(false)}\n *   onComplete={handleTaskComplete}\n * />\n * ```\n *\n * @example\n * ```tsx\n * // Execute task from list with automatic cleanup\n * const handleExecuteTask = (task: Task) => {\n *   setSelectedTask(task);\n *   setModalOpen(true);\n * };\n *\n * <TaskExecutionModal\n *   task={selectedTask}\n *   onClose={() => {\n *     setModalOpen(false);\n *     setSelectedTask(null);\n *   }}\n *   onComplete={() => {\n *     // Optionally close modal on completion\n *     // setModalOpen(false);\n *     // Or keep it open for user to review results\n *     refreshTaskList();\n *   }}\n * />\n * ```\n *\n * @example\n * ```tsx\n * // Understanding tool use message flow\n * // 1. Assistant message arrives with tool_use block:\n * //    { type: 'tool_use', toolName: 'read_file', toolInput: { path: 'config.json' } }\n * //\n * // 2. Message displayed with \"Waiting for result...\" loading state\n * //\n * // 3. User message arrives with tool_result block:\n * //    { tool_use_id: 'toolu_123', content: '{\"key\": \"value\"}' }\n * //\n * // 4. Existing tool_use message updated with toolResult property\n * //    Message now shows both input and output in collapsible sections\n * ```\n *\n * @example\n * ```tsx\n * // Navigate to task details after completion\n * const navigate = useNavigate();\n *\n * <TaskExecutionModal\n *   task={selectedTask}\n *   onClose={() => setModalOpen(false)}\n *   onComplete={() => {\n *     // Navigate to task details page to view full results\n *     navigate(`/tasks/${selectedTask.id}`);\n *   }}\n * />\n * ```\n */\nimport React, { useState, useEffect, useRef } from 'react';\nimport * as api from '../services/api';\nimport { Button } from './ui/Button';\nimport { XCircleIcon } from './ui/Icons';\n\n/**\n * Props for the TaskExecutionModal component.\n *\n * @property {api.Task} task - The task object to execute, containing id, name, and agentName\n * @property {() => void} onClose - Callback invoked when user clicks close button (disabled during execution)\n * @property {() => void} onComplete - Callback invoked when task execution completes (success or failure)\n */\ninterface TaskExecutionModalProps {\n  task: api.Task;\n  onClose: () => void;\n  onComplete: () => void;\n}\n\n/**\n * Message object representing a single message in the execution stream.\n *\n * @property {string} id - Unique identifier for the message\n * @property {'status' | 'assistant' | 'user' | 'result' | 'error' | 'debug' | 'tool_use'} type - Message type determines styling and display\n * @property {string} content - Text content of the message\n * @property {Date} timestamp - Timestamp when message was created\n * @property {string} [toolName] - Name of the tool (only for tool_use messages)\n * @property {any} [toolInput] - Input parameters for the tool (only for tool_use messages)\n * @property {any} [toolResult] - Result from tool execution, added when result arrives (only for tool_use messages)\n * @property {string} [toolUseId] - Unique ID for matching tool use with its result (only for tool_use messages)\n */\ninterface Message {\n  id: string;\n  type: 'status' | 'assistant' | 'user' | 'result' | 'error' | 'debug' | 'tool_use';\n  content: string;\n  timestamp: Date;\n  toolName?: string;\n  toolInput?: any;\n  toolResult?: any; // Added to tool_use messages when result arrives\n  toolUseId?: string;\n}\n\n/**\n * TaskExecutionModal component for executing tasks with real-time progress tracking.\n *\n * Automatically executes the task on mount and streams execution events via SSE.\n * Messages are processed in real-time and displayed in a scrollable list with\n * color-coded styling based on message type.\n *\n * @param {TaskExecutionModalProps} props - Component props\n * @returns {JSX.Element} Modal with task execution interface\n */\nconst TaskExecutionModal: React.FC<TaskExecutionModalProps> = ({ task, onClose, onComplete }) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isExecuting, setIsExecuting] = useState(true);\n  const [executionStatus, setExecutionStatus] = useState<string>('Starting...');\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const executionStartedRef = useRef(false);\n\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  useEffect(() => {\n    // Prevent double execution in React StrictMode\n    if (executionStartedRef.current) return;\n    executionStartedRef.current = true;\n\n    // Start execution\n    executeTask();\n  }, []);\n\n  /**\n   * Executes the task via SSE streaming API and processes events in real-time.\n   *\n   * This function handles the complete task execution workflow:\n   * 1. Clears existing messages and resets state\n   * 2. Calls `api.executeTask` with task ID and event callback\n   * 3. Processes SSE events as they arrive:\n   *    - **message events**: Parse content blocks from assistant/user messages\n   *      - Assistant messages: Extract text blocks and tool_use blocks\n   *      - User messages: Extract tool_result blocks and match to tool uses\n   *      - Result messages: Display final result and update status\n   *    - **status events**: Update execution status and add status messages\n   *    - **debug events**: Add filtered debug messages (STDIN-related only)\n   *    - **error events**: Display error messages and mark execution as failed\n   * 4. Updates message state incrementally for real-time display\n   * 5. Matches tool results back to tool use messages via `toolUseId`\n   * 6. Sets final execution status and invokes `onComplete` callback\n   * 7. Catches and displays any errors during execution\n   *\n   * @internal\n   * @async\n   * @returns {Promise<void>}\n   */\n  const executeTask = async () => {\n    setIsExecuting(true);\n    setMessages([]);\n\n    try {\n      await api.executeTask(task.id, (event) => {\n        // Handle assistant messages (contains tool_use blocks)\n        if (event.type === 'message' && event.content) {\n          const eventContent = event.content;\n\n          // Handle assistant messages\n          if (eventContent.type === 'assistant' && eventContent.message) {\n            const message = eventContent.message;\n            if (message.content && Array.isArray(message.content)) {\n              const blocks = message.content;\n\n              // Process text blocks for assistant message\n              const textContent = blocks\n                .filter((block: any) => block.type === 'text')\n                .map((block: any) => block.text)\n                .join('\\n');\n\n              if (textContent) {\n                setMessages((prev) => [...prev, {\n                  id: `${Date.now()}-${Math.random()}`,\n                  type: 'assistant',\n                  content: textContent,\n                  timestamp: new Date(),\n                }]);\n              }\n\n              // Process tool_use blocks separately\n              const toolUseBlocks = blocks.filter((block: any) => block.type === 'tool_use');\n              toolUseBlocks.forEach((toolBlock: any) => {\n                setMessages((prev) => [...prev, {\n                  id: `tool-use-${toolBlock.id}`,\n                  type: 'tool_use',\n                  content: '',\n                  timestamp: new Date(),\n                  toolName: toolBlock.name,\n                  toolInput: toolBlock.input,\n                  toolUseId: toolBlock.id,\n                }]);\n              });\n            }\n            return;\n          }\n\n          // Handle user messages (contains tool_result blocks)\n          if (eventContent.type === 'user' && eventContent.message) {\n            const message = eventContent.message;\n            if (message.content && Array.isArray(message.content)) {\n              const blocks = message.content;\n\n              // Process tool_result blocks\n              const toolResultBlocks = blocks.filter((block: any) => block.type === 'tool_result');\n              toolResultBlocks.forEach((resultBlock: any) => {\n                const toolUseId = resultBlock.tool_use_id;\n                const toolResult = resultBlock.content;\n\n                // Find and update the corresponding tool_use message\n                setMessages((prev) => prev.map(msg =>\n                  msg.toolUseId === toolUseId\n                    ? { ...msg, toolResult }\n                    : msg\n                ));\n              });\n            }\n            return;\n          }\n\n          // Handle result\n          if (eventContent.type === 'result') {\n            const resultText = eventContent.is_error\n              ? `\u274c Task failed: ${eventContent.result}`\n              : `\u2705 Task completed successfully`;\n\n            setMessages((prev) => [...prev, {\n              id: `${Date.now()}-${Math.random()}`,\n              type: 'status',\n              content: resultText,\n              timestamp: new Date(),\n            }]);\n\n            if (!eventContent.is_error && eventContent.result) {\n              setMessages((prev) => [...prev, {\n                id: `${Date.now()}-${Math.random()}`,\n                type: 'assistant',\n                content: typeof eventContent.result === 'string' ? eventContent.result : JSON.stringify(eventContent.result, null, 2),\n                timestamp: new Date(),\n              }]);\n            }\n\n            setIsExecuting(false);\n            setExecutionStatus(eventContent.is_error ? 'Failed' : 'Completed');\n            onComplete();\n            return;\n          }\n        }\n\n        // Handle other event types\n        if (event.type === 'status') {\n          setExecutionStatus(event.message || event.status);\n          setMessages((prev) => [...prev, {\n            id: `${Date.now()}-${Math.random()}`,\n            type: 'status',\n            content: event.message || event.status,\n            timestamp: new Date(),\n          }]);\n        } else if (event.type === 'debug') {\n          // Only show important debug messages\n          if (event.message && event.message.includes('STDIN')) {\n            setMessages((prev) => [...prev, {\n              id: `${Date.now()}-${Math.random()}`,\n              type: 'debug',\n              content: event.message,\n              timestamp: new Date(),\n            }]);\n          }\n        } else if (event.type === 'error') {\n          setMessages((prev) => [...prev, {\n            id: `${Date.now()}-${Math.random()}`,\n            type: 'error',\n            content: `\u274c Error: ${event.error}`,\n            timestamp: new Date(),\n          }]);\n          setIsExecuting(false);\n          setExecutionStatus('Failed');\n          onComplete();\n        }\n      });\n    } catch (error: any) {\n      setMessages((prev) => [...prev, {\n        id: `${Date.now()}-${Math.random()}`,\n        type: 'error',\n        content: `\u274c Error: ${error.message}`,\n        timestamp: new Date(),\n      }]);\n      setIsExecuting(false);\n      setExecutionStatus('Failed');\n    }\n  };\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50\">\n      <div className=\"bg-background border border-border rounded-lg shadow-lg w-full max-w-4xl max-h-[90vh] flex flex-col\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between p-4 border-b border-border\">\n          <div>\n            <h2 className=\"text-xl font-bold\">Execute Task: {task.name}</h2>\n            <div className=\"flex items-center gap-2 mt-1\">\n              <span className=\"text-sm text-muted-foreground\">{task.agentName}</span>\n              <span className=\"text-xs px-2 py-0.5 rounded bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300\">\n                {executionStatus}\n              </span>\n            </div>\n          </div>\n          <button\n            onClick={onClose}\n            className=\"text-muted-foreground hover:text-foreground\"\n            disabled={isExecuting}\n          >\n            <XCircleIcon className=\"h-6 w-6\" />\n          </button>\n        </div>\n\n        {/* Messages */}\n        <div className=\"flex-1 overflow-y-auto p-4 space-y-3\">\n          {messages.length === 0 && !isExecuting && (\n            <div className=\"text-center text-muted-foreground py-12\">\n              Task execution starting...\n            </div>\n          )}\n\n          {messages.map((message) => (\n            <div\n              key={message.id}\n              className={`p-3 rounded-lg ${\n                message.type === 'error'\n                  ? 'bg-red-500/10 border border-red-500/20'\n                  : message.type === 'debug'\n                  ? 'bg-yellow-500/10 border border-yellow-500/20'\n                  : message.type === 'status'\n                  ? 'bg-blue-500/10 border border-blue-500/20'\n                  : message.type === 'tool_use'\n                  ? 'bg-purple-500/10 border border-purple-500/20'\n                  : message.type === 'assistant'\n                  ? 'bg-primary/10 border border-primary/20'\n                  : 'bg-secondary'\n              }`}\n            >\n              <div className=\"flex items-start justify-between mb-1\">\n                <span className=\"text-xs font-semibold uppercase tracking-wide\">\n                  {message.type === 'tool_use'\n                    ? `\ud83d\udd27 ${message.toolName}`\n                    : message.type}\n                </span>\n                <span className=\"text-xs text-muted-foreground\">\n                  {message.timestamp.toLocaleTimeString()}\n                </span>\n              </div>\n\n              {message.type === 'tool_use' ? (\n                <div className=\"text-sm space-y-2\">\n                  <div className=\"font-medium text-purple-400\">Tool: {message.toolName}</div>\n\n                  {/* Input Parameters */}\n                  {message.toolInput && (\n                    <details className=\"cursor-pointer\">\n                      <summary className=\"text-xs text-muted-foreground hover:text-foreground\">\n                        \ud83d\udce5 Input Parameters\n                      </summary>\n                      <pre className=\"mt-2 text-xs bg-black/20 p-2 rounded overflow-x-auto\">\n                        {JSON.stringify(message.toolInput, null, 2)}\n                      </pre>\n                    </details>\n                  )}\n\n                  {/* Output Result - only show if available */}\n                  {message.toolResult && (\n                    <details\n                      className=\"cursor-pointer\"\n                      open={typeof message.toolResult === 'string' && message.toolResult.length < 200}\n                    >\n                      <summary className=\"text-xs text-muted-foreground hover:text-foreground\">\n                        \ud83d\udce4 Output Result\n                      </summary>\n                      <div className=\"mt-2 text-xs bg-black/20 p-2 rounded overflow-x-auto\">\n                        {typeof message.toolResult === 'string' ? (\n                          <pre className=\"whitespace-pre-wrap\">{message.toolResult}</pre>\n                        ) : (\n                          <pre>{JSON.stringify(message.toolResult, null, 2)}</pre>\n                        )}\n                      </div>\n                    </details>\n                  )}\n\n                  {/* Show loading state if no result yet */}\n                  {!message.toolResult && (\n                    <div className=\"text-xs text-muted-foreground italic\">\n                      Waiting for result...\n                    </div>\n                  )}\n                </div>\n              ) : (\n                <div className=\"text-sm whitespace-pre-wrap break-words\">\n                  {message.content}\n                </div>\n              )}\n            </div>\n          ))}\n\n          {isExecuting && messages.length === 0 && (\n            <div className=\"text-center text-muted-foreground py-6\">\n              <div className=\"animate-pulse\">Starting task execution...</div>\n            </div>\n          )}\n\n          <div ref={messagesEndRef} />\n        </div>\n\n        {/* Footer */}\n        <div className=\"p-4 border-t border-border flex justify-end gap-2\">\n          <Button variant=\"secondary\" onClick={onClose} disabled={isExecuting}>\n            {isExecuting ? 'Running...' : 'Close'}\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nTaskExecutionModal.displayName = 'TaskExecutionModal';\n\nexport default TaskExecutionModal;\n",
        "last_modified": "2026-01-02T15:11:36.288826"
      },
      "task_intent": {
        "title": "Document Frontend React Components and Hooks",
        "description": "Add comprehensive JSDoc documentation to all React components and custom hooks in the frontend, including prop types, usage examples, component purposes, state management, and side effects.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:01:11.553013",
  "last_updated": "2026-01-02T14:22:15.095075"
}