{
  "file_path": "src/services/session-info-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport Database from 'better-sqlite3';\nimport type { SessionInfo } from '@/types/index.js';\nimport { createLogger } from './logger.js';\nimport { type Logger } from './logger.js';\n\ntype SessionRow = {\n  custom_name: string;\n  created_at: string;\n  updated_at: string;\n  version: number;\n  pinned: number | boolean;\n  archived: number | boolean;\n  continuation_session_id: string;\n  initial_commit_head: string;\n  permission_mode: string;\n};\n\n/**\n * SessionInfoService manages session information using SQLite backend\n * Stores session metadata including custom names in ~/.cui/session-info.db\n * Provides fast lookups and updates for session-specific data\n */\nexport class SessionInfoService {\n  private static instance: SessionInfoService;\n  private logger: Logger;\n  private dbPath!: string;\n  private configDir!: string;\n  private isInitialized = false;\n  private db!: Database.Database;\n\n  private getSessionStmt!: Database.Statement;\n  private insertSessionStmt!: Database.Statement;\n  private updateSessionStmt!: Database.Statement;\n  private deleteSessionStmt!: Database.Statement;\n  private getAllStmt!: Database.Statement;\n  private countStmt!: Database.Statement;\n  private archiveAllStmt!: Database.Statement;\n  private setMetadataStmt!: Database.Statement;\n  private getMetadataStmt!: Database.Statement;\n\n  constructor(customConfigDir?: string) {\n    this.logger = createLogger('SessionInfoService');\n    this.initializePaths(customConfigDir);\n  }\n\n  static getInstance(): SessionInfoService {\n    if (!SessionInfoService.instance) {\n      SessionInfoService.instance = new SessionInfoService();\n    }\n    return SessionInfoService.instance;\n  }\n\n  static resetInstance(): void {\n    if (SessionInfoService.instance) {\n      SessionInfoService.instance.isInitialized = false;\n    }\n    SessionInfoService.instance = null as unknown as SessionInfoService;\n  }\n\n  private initializePaths(customConfigDir?: string): void {\n    if (customConfigDir) {\n      if (customConfigDir === ':memory:') {\n        this.configDir = ':memory:';\n        this.dbPath = ':memory:';\n        return;\n      }\n      this.configDir = path.join(customConfigDir, '.cui');\n    } else {\n      this.configDir = path.join(os.homedir(), '.cui');\n    }\n    this.dbPath = path.join(this.configDir, 'session-info.db');\n\n    this.logger.debug('Initializing paths', {\n      homedir: os.homedir(),\n      configDir: this.configDir,\n      dbPath: this.dbPath\n    });\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      if (this.dbPath !== ':memory:' && !fs.existsSync(this.configDir)) {\n        fs.mkdirSync(this.configDir, { recursive: true });\n        this.logger.debug('Created config directory', { dir: this.configDir });\n      }\n\n      this.db = new Database(this.dbPath);\n      this.db.pragma('journal_mode = WAL');\n\n      this.db.exec(`\n        CREATE TABLE IF NOT EXISTS sessions (\n          session_id TEXT PRIMARY KEY,\n          custom_name TEXT NOT NULL DEFAULT '',\n          created_at TEXT NOT NULL,\n          updated_at TEXT NOT NULL,\n          version INTEGER NOT NULL,\n          pinned INTEGER NOT NULL DEFAULT 0,\n          archived INTEGER NOT NULL DEFAULT 0,\n          continuation_session_id TEXT NOT NULL DEFAULT '',\n          initial_commit_head TEXT NOT NULL DEFAULT '',\n          permission_mode TEXT NOT NULL DEFAULT 'default'\n        );\n        CREATE TABLE IF NOT EXISTS metadata (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n      `);\n\n      this.prepareStatements();\n      this.ensureMetadata();\n      this.isInitialized = true;\n    } catch (error) {\n      this.logger.error('Failed to initialize session info database', error);\n      throw new Error(`Session info database initialization failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  private prepareStatements(): void {\n    this.getSessionStmt = this.db.prepare('SELECT * FROM sessions WHERE session_id = ?');\n    this.insertSessionStmt = this.db.prepare(`\n      INSERT INTO sessions (\n        session_id,\n        custom_name,\n        created_at,\n        updated_at,\n        version,\n        pinned,\n        archived,\n        continuation_session_id,\n        initial_commit_head,\n        permission_mode\n      ) VALUES (\n        @session_id,\n        @custom_name,\n        @created_at,\n        @updated_at,\n        @version,\n        @pinned,\n        @archived,\n        @continuation_session_id,\n        @initial_commit_head,\n        @permission_mode\n      )\n    `);\n    this.updateSessionStmt = this.db.prepare(`\n      UPDATE sessions SET\n        custom_name=@custom_name,\n        updated_at=@updated_at,\n        pinned=@pinned,\n        archived=@archived,\n        continuation_session_id=@continuation_session_id,\n        initial_commit_head=@initial_commit_head,\n        permission_mode=@permission_mode,\n        version=@version\n      WHERE session_id=@session_id\n    `);\n    this.deleteSessionStmt = this.db.prepare('DELETE FROM sessions WHERE session_id = ?');\n    this.getAllStmt = this.db.prepare('SELECT * FROM sessions');\n    this.countStmt = this.db.prepare('SELECT COUNT(*) as count FROM sessions');\n    this.archiveAllStmt = this.db.prepare('UPDATE sessions SET archived=1, updated_at=@updated_at WHERE archived=0');\n    this.setMetadataStmt = this.db.prepare('INSERT INTO metadata (key, value) VALUES (@key, @value) ON CONFLICT(key) DO UPDATE SET value=excluded.value');\n    this.getMetadataStmt = this.db.prepare('SELECT value FROM metadata WHERE key = ?');\n  }\n\n  private ensureMetadata(): void {\n    const now = new Date().toISOString();\n    const schema = this.getMetadataStmt.get('schema_version') as { value?: string } | undefined;\n    if (!schema) {\n      this.setMetadataStmt.run({ key: 'schema_version', value: '3' });\n      this.setMetadataStmt.run({ key: 'created_at', value: now });\n      this.setMetadataStmt.run({ key: 'last_updated', value: now });\n    }\n  }\n\n  private mapRow(row: SessionRow): SessionInfo {\n    return {\n      custom_name: row.custom_name,\n      created_at: row.created_at,\n      updated_at: row.updated_at,\n      version: row.version,\n      pinned: !!row.pinned,\n      archived: !!row.archived,\n      continuation_session_id: row.continuation_session_id,\n      initial_commit_head: row.initial_commit_head,\n      permission_mode: row.permission_mode\n    };\n  }\n\n  async getSessionInfo(sessionId: string): Promise<SessionInfo> {\n    try {\n      const row = this.getSessionStmt.get(sessionId) as SessionRow | undefined;\n      if (row) {\n        return this.mapRow(row);\n      }\n\n      const now = new Date().toISOString();\n      const defaultSession: SessionInfo = {\n        custom_name: '',\n        created_at: now,\n        updated_at: now,\n        version: 3,\n        pinned: false,\n        archived: false,\n        continuation_session_id: '',\n        initial_commit_head: '',\n        permission_mode: 'default'\n      };\n      this.insertSessionStmt.run({\n        session_id: sessionId,\n        custom_name: '',\n        created_at: now,\n        updated_at: now,\n        version: 3,\n        pinned: 0,\n        archived: 0,\n        continuation_session_id: '',\n        initial_commit_head: '',\n        permission_mode: 'default'\n      });\n      this.setMetadataStmt.run({ key: 'last_updated', value: now });\n      return defaultSession;\n    } catch (error) {\n      this.logger.error('Failed to get session info', { sessionId, error });\n      const now = new Date().toISOString();\n      return {\n        custom_name: '',\n        created_at: now,\n        updated_at: now,\n        version: 3,\n        pinned: false,\n        archived: false,\n        continuation_session_id: '',\n        initial_commit_head: '',\n        permission_mode: 'default'\n      };\n    }\n  }\n\n  async updateSessionInfo(sessionId: string, updates: Partial<SessionInfo>): Promise<SessionInfo> {\n    try {\n      const existingRow = this.getSessionStmt.get(sessionId) as SessionRow | undefined;\n      const now = new Date().toISOString();\n      if (existingRow) {\n        const updatedSession: SessionInfo = {\n          ...this.mapRow(existingRow),\n          ...updates,\n          updated_at: now\n        };\n        this.updateSessionStmt.run({\n          session_id: sessionId,\n          custom_name: updatedSession.custom_name,\n          updated_at: updatedSession.updated_at,\n          pinned: updatedSession.pinned ? 1 : 0,\n          archived: updatedSession.archived ? 1 : 0,\n          continuation_session_id: updatedSession.continuation_session_id,\n          initial_commit_head: updatedSession.initial_commit_head,\n          permission_mode: updatedSession.permission_mode,\n          version: updatedSession.version\n        });\n        this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        return updatedSession;\n      } else {\n        const newSession: SessionInfo = {\n          custom_name: '',\n          created_at: now,\n          updated_at: now,\n          version: 3,\n          pinned: false,\n          archived: false,\n          continuation_session_id: '',\n          initial_commit_head: '',\n          permission_mode: 'default',\n          ...updates\n        };\n        this.insertSessionStmt.run({\n          session_id: sessionId,\n          custom_name: newSession.custom_name,\n          created_at: newSession.created_at,\n          updated_at: newSession.updated_at,\n          version: newSession.version,\n          pinned: newSession.pinned ? 1 : 0,\n          archived: newSession.archived ? 1 : 0,\n          continuation_session_id: newSession.continuation_session_id,\n          initial_commit_head: newSession.initial_commit_head,\n          permission_mode: newSession.permission_mode\n        });\n        this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        return newSession;\n      }\n    } catch (error) {\n      this.logger.error('Failed to update session info', { sessionId, updates, error });\n      throw new Error(`Failed to update session info: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  async updateCustomName(sessionId: string, customName: string): Promise<void> {\n    await this.updateSessionInfo(sessionId, { custom_name: customName });\n  }\n\n  async deleteSession(sessionId: string): Promise<void> {\n    this.logger.info('Deleting session info', { sessionId });\n    try {\n      const result = this.deleteSessionStmt.run(sessionId);\n      if (result.changes > 0) {\n        const now = new Date().toISOString();\n        this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        this.logger.info('Session info deleted successfully', { sessionId });\n      } else {\n        this.logger.debug('Session info not found for deletion', { sessionId });\n      }\n    } catch (error) {\n      this.logger.error('Failed to delete session info', { sessionId, error });\n      throw new Error(`Failed to delete session info: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  async getAllSessionInfo(): Promise<Record<string, SessionInfo>> {\n    this.logger.debug('Getting all session info');\n    try {\n      const rows = this.getAllStmt.all() as Array<SessionRow & { session_id: string }>;\n      const result: Record<string, SessionInfo> = {};\n      for (const row of rows) {\n        result[row.session_id] = this.mapRow(row);\n      }\n      return result;\n    } catch (error) {\n      this.logger.error('Failed to get all session info', error);\n      return {};\n    }\n  }\n\n  async getStats(): Promise<{ sessionCount: number; dbSize: number; lastUpdated: string }> {\n    try {\n      const countRow = this.countStmt.get() as { count: number };\n      let dbSize = 0;\n      if (this.dbPath !== ':memory:') {\n        try {\n          const stats = fs.statSync(this.dbPath);\n          dbSize = stats.size;\n        } catch {\n          dbSize = 0;\n        }\n      }\n      const lastUpdatedRow = this.getMetadataStmt.get('last_updated') as { value?: string } | undefined;\n      return {\n        sessionCount: countRow.count,\n        dbSize,\n        lastUpdated: lastUpdatedRow?.value || new Date().toISOString()\n      };\n    } catch (error) {\n      this.logger.error('Failed to get database stats', error);\n      return {\n        sessionCount: 0,\n        dbSize: 0,\n        lastUpdated: new Date().toISOString()\n      };\n    }\n  }\n\n  reinitializePaths(customConfigDir?: string): void {\n    this.initializePaths(customConfigDir);\n  }\n\n  getDbPath(): string {\n    return this.dbPath;\n  }\n\n  getConfigDir(): string {\n    return this.configDir;\n  }\n\n  async archiveAllSessions(): Promise<number> {\n    this.logger.info('Archiving all sessions');\n    try {\n      const now = new Date().toISOString();\n      const transaction = this.db.transaction(() => {\n        const info = this.archiveAllStmt.run({ updated_at: now });\n        if (info.changes > 0) {\n          this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        }\n        return info.changes;\n      });\n      const archivedCount = transaction();\n      this.logger.info('Sessions archived successfully', { archivedCount });\n      return archivedCount;\n    } catch (error) {\n      this.logger.error('Failed to archive all sessions', error);\n      throw new Error(`Failed to archive all sessions: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  async syncMissingSessions(sessionIds: string[]): Promise<number> {\n    try {\n      const now = new Date().toISOString();\n      const insert = this.db.prepare(`\n        INSERT OR IGNORE INTO sessions (\n          session_id,\n          custom_name,\n          created_at,\n          updated_at,\n          version,\n          pinned,\n          archived,\n          continuation_session_id,\n          initial_commit_head,\n          permission_mode\n        ) VALUES (\n          @session_id,\n          '',\n          @now,\n          @now,\n          3,\n          0,\n          0,\n          '',\n          '',\n          'default'\n        )\n      `);\n      const transaction = this.db.transaction((ids: string[]) => {\n        let inserted = 0;\n        for (const id of ids) {\n          const info = insert.run({ session_id: id, now });\n          if (info.changes > 0) inserted++;\n        }\n        if (inserted > 0) {\n          this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        }\n        return inserted;\n      });\n      return transaction(sessionIds);\n    } catch (error) {\n      this.logger.error('Failed to sync missing sessions', error);\n      throw new Error(`Failed to sync missing sessions: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n}\n\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport Database from 'better-sqlite3';\nimport type { SessionInfo } from '@/types/index.js';\nimport { createLogger } from './logger.js';\nimport { type Logger } from './logger.js';\n\n/**\n * Internal database row representation for sessions table\n *\n * @description\n * SQLite stores booleans as integers (0 or 1), so this type represents the raw database row\n * format before transformation to the SessionInfo domain model. The service uses mapRow() to\n * convert between SessionRow (database format) and SessionInfo (application format).\n *\n * @property {string} custom_name - User-defined custom name for the session\n * @property {string} created_at - ISO 8601 timestamp when session was first created\n * @property {string} updated_at - ISO 8601 timestamp of last update\n * @property {number} version - Schema version number (currently 3)\n * @property {number | boolean} pinned - Whether session is pinned (1/true or 0/false)\n * @property {number | boolean} archived - Whether session is archived (1/true or 0/false)\n * @property {string} continuation_session_id - Session ID this session continues from (for conversation resumption)\n * @property {string} initial_commit_head - Git commit hash when session was created\n * @property {string} permission_mode - Permission mode for the session ('default', 'bypass', 'auto', 'plan')\n *\n * @example\n * ```typescript\n * // Raw database row (SQLite format)\n * const row: SessionRow = {\n *   custom_name: 'Code Review Session',\n *   created_at: '2024-01-15T10:30:00.000Z',\n *   updated_at: '2024-01-15T11:45:00.000Z',\n *   version: 3,\n *   pinned: 1,        // SQLite integer\n *   archived: 0,      // SQLite integer\n *   continuation_session_id: '',\n *   initial_commit_head: 'abc123def',\n *   permission_mode: 'default'\n * };\n * ```\n *\n * @example\n * ```typescript\n * // mapRow() converts to SessionInfo (application format)\n * const sessionInfo: SessionInfo = {\n *   custom_name: 'Code Review Session',\n *   created_at: '2024-01-15T10:30:00.000Z',\n *   updated_at: '2024-01-15T11:45:00.000Z',\n *   version: 3,\n *   pinned: true,     // Boolean\n *   archived: false,  // Boolean\n *   continuation_session_id: '',\n *   initial_commit_head: 'abc123def',\n *   permission_mode: 'default'\n * };\n * ```\n */\ntype SessionRow = {\n  custom_name: string;\n  created_at: string;\n  updated_at: string;\n  version: number;\n  pinned: number | boolean;\n  archived: number | boolean;\n  continuation_session_id: string;\n  initial_commit_head: string;\n  permission_mode: string;\n};\n\n/**\n * SessionInfoService - Persistent SQLite-backed storage for session metadata\n *\n * @description\n * The SessionInfoService manages session metadata using a SQLite database stored in the user's\n * home directory at `~/.cui/session-info.db`. It provides fast lookups and updates for session-specific\n * data including custom names, pinned status, archived status, permission modes, and conversation\n * continuation tracking. The service implements a singleton pattern with prepared statements for\n * optimal performance.\n *\n * **Key Responsibilities:**\n * - Persist session metadata (custom names, pinned status, archived status, permission modes)\n * - Track conversation continuation chains via continuation_session_id\n * - Store Git commit hashes for session versioning and reproducibility\n * - Provide fast session lookups and bulk operations\n * - Manage database schema migrations and metadata\n * - Support both production (~/.cui/) and test (:memory:) database modes\n *\n * **Architecture:**\n * - **SQLite Backend**: Embedded database with WAL mode for concurrent reads/sequential writes\n * - **Singleton Pattern**: Single shared instance accessed via getInstance()\n * - **Prepared Statements**: Pre-compiled SQL statements for optimal performance\n * - **Auto-Creation**: Automatically creates default session records on first access\n * - **Schema Versioning**: Metadata table tracks schema version for future migrations\n * - **Graceful Degradation**: Returns default values on errors (logged but don't throw)\n *\n * **Database Schema:**\n * ```sql\n * -- sessions table (primary data)\n * CREATE TABLE sessions (\n *   session_id TEXT PRIMARY KEY,\n *   custom_name TEXT NOT NULL DEFAULT '',\n *   created_at TEXT NOT NULL,\n *   updated_at TEXT NOT NULL,\n *   version INTEGER NOT NULL,\n *   pinned INTEGER NOT NULL DEFAULT 0,\n *   archived INTEGER NOT NULL DEFAULT 0,\n *   continuation_session_id TEXT NOT NULL DEFAULT '',\n *   initial_commit_head TEXT NOT NULL DEFAULT '',\n *   permission_mode TEXT NOT NULL DEFAULT 'default'\n * );\n *\n * -- metadata table (schema version, timestamps)\n * CREATE TABLE metadata (\n *   key TEXT PRIMARY KEY,\n *   value TEXT NOT NULL\n * );\n * ```\n *\n * **Session Lifecycle:**\n * 1. **First Access**: getSessionInfo() auto-creates default session if not exists\n * 2. **Updates**: updateSessionInfo() merges partial updates with existing data\n * 3. **Archival**: Session status changed to archived=1 (soft delete, data preserved)\n * 4. **Deletion**: deleteSession() permanently removes session record from database\n * 5. **Sync**: syncMissingSessions() bulk-creates default records for discovered sessions\n *\n * **Use Cases:**\n * - Storing user-defined session names for UI display\n * - Pinning important conversations to top of session list\n * - Archiving completed or inactive sessions (soft delete)\n * - Tracking conversation continuation chains (resume workflows)\n * - Recording Git state for session reproducibility\n * - Managing permission modes (default, bypass, auto, plan)\n *\n * @example\n * ```typescript\n * // Initialize service and database (singleton pattern)\n * import { SessionInfoService } from './session-info-service';\n *\n * const service = SessionInfoService.getInstance();\n * await service.initialize();\n *\n * // Service is now ready with:\n * // - Database created at ~/.cui/session-info.db\n * // - WAL mode enabled for concurrent access\n * // - Prepared statements compiled\n * // - Schema version metadata initialized\n * ```\n *\n * @example\n * ```typescript\n * // Get session info (auto-creates if not exists)\n * import { SessionInfoService } from './session-info-service';\n *\n * const service = SessionInfoService.getInstance();\n * await service.initialize();\n *\n * const sessionInfo = await service.getSessionInfo('session-abc-123');\n * // First access returns default values:\n * // {\n * //   custom_name: '',\n * //   created_at: '2024-01-15T10:30:00.000Z',\n * //   updated_at: '2024-01-15T10:30:00.000Z',\n * //   version: 3,\n * //   pinned: false,\n * //   archived: false,\n * //   continuation_session_id: '',\n * //   initial_commit_head: '',\n * //   permission_mode: 'default'\n * // }\n * ```\n *\n * @example\n * ```typescript\n * // Update session metadata (partial updates)\n * import { SessionInfoService } from './session-info-service';\n *\n * const service = SessionInfoService.getInstance();\n * await service.initialize();\n *\n * // Set custom name and pin session\n * const updated = await service.updateSessionInfo('session-abc-123', {\n *   custom_name: 'Code Review Session',\n *   pinned: true\n * });\n * // Returns: { custom_name: 'Code Review Session', pinned: true, ... }\n *\n * // Archive session (soft delete)\n * await service.updateSessionInfo('session-abc-123', { archived: true });\n * ```\n *\n * @example\n * ```typescript\n * // Track conversation continuation chains\n * import { SessionInfoService } from './session-info-service';\n *\n * const service = SessionInfoService.getInstance();\n * await service.initialize();\n *\n * // Create new session that continues from previous session\n * const newSession = await service.updateSessionInfo('session-new-456', {\n *   continuation_session_id: 'session-abc-123',\n *   initial_commit_head: 'def456abc'\n * });\n *\n * // Retrieve continuation chain\n * const originalSession = await service.getSessionInfo('session-abc-123');\n * const continuedSession = await service.getSessionInfo(\n *   originalSession.continuation_session_id || 'session-new-456'\n * );\n * ```\n *\n * @example\n * ```typescript\n * // Bulk operations and statistics\n * import { SessionInfoService } from './session-info-service';\n *\n * const service = SessionInfoService.getInstance();\n * await service.initialize();\n *\n * // Get all sessions\n * const allSessions = await service.getAllSessionInfo();\n * // Returns: Record<string, SessionInfo> with session IDs as keys\n *\n * // Archive all sessions at once\n * const archivedCount = await service.archiveAllSessions();\n * console.log(`Archived ${archivedCount} sessions`);\n *\n * // Get database statistics\n * const stats = await service.getStats();\n * // Returns: { sessionCount: 42, dbSize: 16384, lastUpdated: '...' }\n * ```\n *\n * @example\n * ```typescript\n * // Test mode with in-memory database\n * import { SessionInfoService } from './session-info-service';\n *\n * // Create test instance with in-memory database\n * const testService = new SessionInfoService(':memory:');\n * await testService.initialize();\n *\n * // Use for testing (no filesystem I/O)\n * await testService.updateSessionInfo('test-session', {\n *   custom_name: 'Test Session'\n * });\n *\n * // Reset for clean state\n * SessionInfoService.resetInstance();\n * ```\n *\n * @see {@link https://github.com/WiseLibs/better-sqlite3 | better-sqlite3 Documentation}\n * @see {@link SessionInfo} - Domain model interface for session metadata\n */\nexport class SessionInfoService {\n  /** Singleton instance shared across the application */\n  private static instance: SessionInfoService;\n\n  /** Logger instance for service operations */\n  private logger: Logger;\n\n  /** Absolute path to SQLite database file (~/.cui/session-info.db or :memory:) */\n  private dbPath!: string;\n\n  /** Absolute path to configuration directory (~/.cui/) */\n  private configDir!: string;\n\n  /** Flag indicating whether database and statements are initialized */\n  private isInitialized = false;\n\n  /** better-sqlite3 database instance */\n  private db!: Database.Database;\n\n  /** Prepared statement for SELECT by session_id (fast lookups) */\n  private getSessionStmt!: Database.Statement;\n\n  /** Prepared statement for INSERT new session records */\n  private insertSessionStmt!: Database.Statement;\n\n  /** Prepared statement for UPDATE session records */\n  private updateSessionStmt!: Database.Statement;\n\n  /** Prepared statement for DELETE session by session_id */\n  private deleteSessionStmt!: Database.Statement;\n\n  /** Prepared statement for SELECT all sessions */\n  private getAllStmt!: Database.Statement;\n\n  /** Prepared statement for COUNT(*) sessions */\n  private countStmt!: Database.Statement;\n\n  /** Prepared statement for bulk archive all sessions */\n  private archiveAllStmt!: Database.Statement;\n\n  /** Prepared statement for upsert metadata key-value pairs */\n  private setMetadataStmt!: Database.Statement;\n\n  /** Prepared statement for SELECT metadata value by key */\n  private getMetadataStmt!: Database.Statement;\n\n  constructor(customConfigDir?: string) {\n    this.logger = createLogger('SessionInfoService');\n    this.initializePaths(customConfigDir);\n  }\n\n  static getInstance(): SessionInfoService {\n    if (!SessionInfoService.instance) {\n      SessionInfoService.instance = new SessionInfoService();\n    }\n    return SessionInfoService.instance;\n  }\n\n  static resetInstance(): void {\n    if (SessionInfoService.instance) {\n      SessionInfoService.instance.isInitialized = false;\n    }\n    SessionInfoService.instance = null as unknown as SessionInfoService;\n  }\n\n  private initializePaths(customConfigDir?: string): void {\n    if (customConfigDir) {\n      if (customConfigDir === ':memory:') {\n        this.configDir = ':memory:';\n        this.dbPath = ':memory:';\n        return;\n      }\n      this.configDir = path.join(customConfigDir, '.cui');\n    } else {\n      this.configDir = path.join(os.homedir(), '.cui');\n    }\n    this.dbPath = path.join(this.configDir, 'session-info.db');\n\n    this.logger.debug('Initializing paths', {\n      homedir: os.homedir(),\n      configDir: this.configDir,\n      dbPath: this.dbPath\n    });\n  }\n\n  /**\n   * Initialize the SQLite database and prepare statements\n   *\n   * @description\n   * Initializes the SQLite database at ~/.cui/session-info.db (or :memory: for tests), creates\n   * database tables if they don't exist, enables WAL mode for concurrent access, prepares SQL\n   * statements for optimal performance, and initializes metadata. This method is idempotent -\n   * calling it multiple times has no effect after the first successful initialization.\n   *\n   * **Initialization Workflow:**\n   * 1. Check if already initialized (skip if true)\n   * 2. Create ~/.cui/ directory if doesn't exist (production mode)\n   * 3. Open SQLite database connection\n   * 4. Enable WAL mode (Write-Ahead Logging) for concurrent reads\n   * 5. Create sessions and metadata tables (if not exist)\n   * 6. Prepare all SQL statements for performance\n   * 7. Initialize metadata (schema_version, created_at, last_updated)\n   * 8. Mark service as initialized\n   *\n   * **Database Configuration:**\n   * - **WAL Mode**: Enables concurrent reads while writes are happening\n   * - **Prepared Statements**: All SQL is pre-compiled for fast execution\n   * - **Schema Version**: Tracked in metadata for future migrations\n   * - **Idempotent**: Safe to call multiple times (no-op after first call)\n   *\n   * @returns {Promise<void>} Resolves when initialization is complete\n   * @throws {Error} Throws if database initialization fails\n   *\n   * @example\n   * ```typescript\n   * // Initialize on app startup (singleton pattern)\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * // Service is now ready - database created and configured:\n   * // - Database file: ~/.cui/session-info.db\n   * // - WAL mode enabled\n   * // - Tables created (sessions, metadata)\n   * // - Prepared statements compiled\n   * // - Schema version: 3\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Initialize with error handling\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * try {\n   *   await service.initialize();\n   *   console.log('Database initialized successfully');\n   * } catch (error) {\n   *   console.error('Failed to initialize database:', error.message);\n   *   // Handle initialization failure (e.g., permissions issue, disk full)\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Idempotent behavior (safe to call multiple times)\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize(); // Initializes database\n   * await service.initialize(); // No-op (already initialized)\n   * await service.initialize(); // No-op (already initialized)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Test mode with in-memory database\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const testService = new SessionInfoService(':memory:');\n   * await testService.initialize();\n   *\n   * // In-memory database (no filesystem I/O)\n   * // - Fast for testing\n   * // - Isolated from production database\n   * // - Destroyed when process exits\n   * ```\n   *\n   * @see {@link getInstance} - Get singleton instance\n   * @see {@link resetInstance} - Reset for testing\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      if (this.dbPath !== ':memory:' && !fs.existsSync(this.configDir)) {\n        fs.mkdirSync(this.configDir, { recursive: true });\n        this.logger.debug('Created config directory', { dir: this.configDir });\n      }\n\n      this.db = new Database(this.dbPath);\n      this.db.pragma('journal_mode = WAL');\n\n      this.db.exec(`\n        CREATE TABLE IF NOT EXISTS sessions (\n          session_id TEXT PRIMARY KEY,\n          custom_name TEXT NOT NULL DEFAULT '',\n          created_at TEXT NOT NULL,\n          updated_at TEXT NOT NULL,\n          version INTEGER NOT NULL,\n          pinned INTEGER NOT NULL DEFAULT 0,\n          archived INTEGER NOT NULL DEFAULT 0,\n          continuation_session_id TEXT NOT NULL DEFAULT '',\n          initial_commit_head TEXT NOT NULL DEFAULT '',\n          permission_mode TEXT NOT NULL DEFAULT 'default'\n        );\n        CREATE TABLE IF NOT EXISTS metadata (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        );\n      `);\n\n      this.prepareStatements();\n      this.ensureMetadata();\n      this.isInitialized = true;\n    } catch (error) {\n      this.logger.error('Failed to initialize session info database', error);\n      throw new Error(`Session info database initialization failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  private prepareStatements(): void {\n    this.getSessionStmt = this.db.prepare('SELECT * FROM sessions WHERE session_id = ?');\n    this.insertSessionStmt = this.db.prepare(`\n      INSERT INTO sessions (\n        session_id,\n        custom_name,\n        created_at,\n        updated_at,\n        version,\n        pinned,\n        archived,\n        continuation_session_id,\n        initial_commit_head,\n        permission_mode\n      ) VALUES (\n        @session_id,\n        @custom_name,\n        @created_at,\n        @updated_at,\n        @version,\n        @pinned,\n        @archived,\n        @continuation_session_id,\n        @initial_commit_head,\n        @permission_mode\n      )\n    `);\n    this.updateSessionStmt = this.db.prepare(`\n      UPDATE sessions SET\n        custom_name=@custom_name,\n        updated_at=@updated_at,\n        pinned=@pinned,\n        archived=@archived,\n        continuation_session_id=@continuation_session_id,\n        initial_commit_head=@initial_commit_head,\n        permission_mode=@permission_mode,\n        version=@version\n      WHERE session_id=@session_id\n    `);\n    this.deleteSessionStmt = this.db.prepare('DELETE FROM sessions WHERE session_id = ?');\n    this.getAllStmt = this.db.prepare('SELECT * FROM sessions');\n    this.countStmt = this.db.prepare('SELECT COUNT(*) as count FROM sessions');\n    this.archiveAllStmt = this.db.prepare('UPDATE sessions SET archived=1, updated_at=@updated_at WHERE archived=0');\n    this.setMetadataStmt = this.db.prepare('INSERT INTO metadata (key, value) VALUES (@key, @value) ON CONFLICT(key) DO UPDATE SET value=excluded.value');\n    this.getMetadataStmt = this.db.prepare('SELECT value FROM metadata WHERE key = ?');\n  }\n\n  private ensureMetadata(): void {\n    const now = new Date().toISOString();\n    const schema = this.getMetadataStmt.get('schema_version') as { value?: string } | undefined;\n    if (!schema) {\n      this.setMetadataStmt.run({ key: 'schema_version', value: '3' });\n      this.setMetadataStmt.run({ key: 'created_at', value: now });\n      this.setMetadataStmt.run({ key: 'last_updated', value: now });\n    }\n  }\n\n  private mapRow(row: SessionRow): SessionInfo {\n    return {\n      custom_name: row.custom_name,\n      created_at: row.created_at,\n      updated_at: row.updated_at,\n      version: row.version,\n      pinned: !!row.pinned,\n      archived: !!row.archived,\n      continuation_session_id: row.continuation_session_id,\n      initial_commit_head: row.initial_commit_head,\n      permission_mode: row.permission_mode\n    };\n  }\n\n  /**\n   * Retrieve session metadata by session ID (auto-creates default if not exists)\n   *\n   * @description\n   * Retrieves session metadata from the SQLite database. If the session doesn't exist, it automatically\n   * creates a new database record with default values and returns it. This auto-creation pattern ensures\n   * every session has metadata without requiring explicit initialization.\n   *\n   * **Auto-Creation Behavior:**\n   * - First access to a session ID automatically creates a database record\n   * - Default values: empty custom_name, current timestamp, unpinned, not archived\n   * - Metadata table updated with last_updated timestamp\n   * - Idempotent: subsequent calls return the same record\n   *\n   * **Graceful Degradation:**\n   * - On database errors, returns default values without throwing\n   * - Error is logged but doesn't break application flow\n   * - Ensures UI always receives valid SessionInfo data\n   *\n   * @param {string} sessionId - Unique session identifier (Claude SDK session ID)\n   * @returns {Promise<SessionInfo>} Session metadata (auto-created if not exists)\n   *\n   * @example\n   * ```typescript\n   * // First access auto-creates session with defaults\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * const sessionInfo = await service.getSessionInfo('session-abc-123');\n   * console.log(sessionInfo);\n   * // {\n   * //   custom_name: '',\n   * //   created_at: '2024-01-15T10:30:00.000Z',\n   * //   updated_at: '2024-01-15T10:30:00.000Z',\n   * //   version: 3,\n   * //   pinned: false,\n   * //   archived: false,\n   * //   continuation_session_id: '',\n   * //   initial_commit_head: '',\n   * //   permission_mode: 'default'\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Subsequent access returns existing record\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * // Update session\n   * await service.updateSessionInfo('session-abc-123', {\n   *   custom_name: 'Code Review Session'\n   * });\n   *\n   * // Retrieve updated record\n   * const sessionInfo = await service.getSessionInfo('session-abc-123');\n   * console.log(sessionInfo.custom_name); // 'Code Review Session'\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Use in session list display\n   * import { SessionInfoService } from './session-info-service';\n   * import { ClaudeHistoryReader } from './claude-history-reader';\n   *\n   * const service = SessionInfoService.getInstance();\n   * const historyReader = new ClaudeHistoryReader();\n   *\n   * await service.initialize();\n   * const conversations = await historyReader.getConversationList();\n   *\n   * // Enrich conversations with metadata\n   * const enriched = await Promise.all(\n   *   conversations.map(async (conv) => {\n   *     const metadata = await service.getSessionInfo(conv.sessionId);\n   *     return {\n   *       ...conv,\n   *       customName: metadata.custom_name || conv.title,\n   *       pinned: metadata.pinned,\n   *       archived: metadata.archived\n   *     };\n   *   })\n   * );\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Filter archived sessions\n   * import { SessionInfoService } from './session-info-service';\n   * import { ClaudeHistoryReader } from './claude-history-reader';\n   *\n   * const service = SessionInfoService.getInstance();\n   * const historyReader = new ClaudeHistoryReader();\n   *\n   * await service.initialize();\n   * const conversations = await historyReader.getConversationList();\n   *\n   * // Filter out archived sessions\n   * const activeConversations = [];\n   * for (const conv of conversations) {\n   *   const metadata = await service.getSessionInfo(conv.sessionId);\n   *   if (!metadata.archived) {\n   *     activeConversations.push(conv);\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Graceful error handling (always returns valid data)\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * // Note: initialize() not called (database not ready)\n   *\n   * // Still returns default values (doesn't throw)\n   * const sessionInfo = await service.getSessionInfo('session-abc-123');\n   * console.log(sessionInfo.custom_name); // ''\n   * // Error logged but application continues\n   * ```\n   *\n   * @see {@link updateSessionInfo} - Update session metadata\n   * @see {@link getAllSessionInfo} - Retrieve all sessions\n   */\n  async getSessionInfo(sessionId: string): Promise<SessionInfo> {\n    try {\n      const row = this.getSessionStmt.get(sessionId) as SessionRow | undefined;\n      if (row) {\n        return this.mapRow(row);\n      }\n\n      const now = new Date().toISOString();\n      const defaultSession: SessionInfo = {\n        custom_name: '',\n        created_at: now,\n        updated_at: now,\n        version: 3,\n        pinned: false,\n        archived: false,\n        continuation_session_id: '',\n        initial_commit_head: '',\n        permission_mode: 'default'\n      };\n      this.insertSessionStmt.run({\n        session_id: sessionId,\n        custom_name: '',\n        created_at: now,\n        updated_at: now,\n        version: 3,\n        pinned: 0,\n        archived: 0,\n        continuation_session_id: '',\n        initial_commit_head: '',\n        permission_mode: 'default'\n      });\n      this.setMetadataStmt.run({ key: 'last_updated', value: now });\n      return defaultSession;\n    } catch (error) {\n      this.logger.error('Failed to get session info', { sessionId, error });\n      const now = new Date().toISOString();\n      return {\n        custom_name: '',\n        created_at: now,\n        updated_at: now,\n        version: 3,\n        pinned: false,\n        archived: false,\n        continuation_session_id: '',\n        initial_commit_head: '',\n        permission_mode: 'default'\n      };\n    }\n  }\n\n  /**\n   * Update session metadata with partial updates (creates session if not exists)\n   *\n   * @description\n   * Updates session metadata in the SQLite database using partial update semantics. If the session\n   * doesn't exist, it creates a new record with defaults merged with the provided updates. This method\n   * supports both update and create operations in a single interface (upsert pattern).\n   *\n   * **Update Semantics:**\n   * - **Partial Updates**: Only provided fields are updated, existing fields are preserved\n   * - **Auto-Creation**: Creates new session if doesn't exist (insert with defaults + updates)\n   * - **Timestamp Management**: updated_at automatically set to current timestamp\n   * - **Boolean Conversion**: Converts boolean values to SQLite integers (1/0) automatically\n   * - **Metadata Update**: Updates database last_updated timestamp after successful operation\n   *\n   * **Common Use Cases:**\n   * - Set custom session names for UI display\n   * - Pin/unpin sessions for priority sorting\n   * - Archive sessions (soft delete)\n   * - Track conversation continuation chains\n   * - Record Git commit hashes for reproducibility\n   * - Update permission modes\n   *\n   * @param {string} sessionId - Unique session identifier (Claude SDK session ID)\n   * @param {Partial<SessionInfo>} updates - Partial session metadata to update/create\n   * @returns {Promise<SessionInfo>} Updated session metadata (full SessionInfo object)\n   * @throws {Error} Throws if database update fails\n   *\n   * @example\n   * ```typescript\n   * // Update custom name (partial update)\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * const updated = await service.updateSessionInfo('session-abc-123', {\n   *   custom_name: 'Code Review Session'\n   * });\n   * console.log(updated.custom_name); // 'Code Review Session'\n   * console.log(updated.pinned);      // false (unchanged)\n   * console.log(updated.archived);    // false (unchanged)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Pin session to top of list\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * await service.updateSessionInfo('session-abc-123', { pinned: true });\n   *\n   * // Later, unpin session\n   * await service.updateSessionInfo('session-abc-123', { pinned: false });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Archive session (soft delete)\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * await service.updateSessionInfo('session-abc-123', { archived: true });\n   *\n   * // Later, restore from archive\n   * await service.updateSessionInfo('session-abc-123', { archived: false });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Create session with continuation tracking\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * // Create new session that continues from previous session\n   * const newSession = await service.updateSessionInfo('session-new-456', {\n   *   custom_name: 'Continued: Code Review',\n   *   continuation_session_id: 'session-abc-123',\n   *   initial_commit_head: 'def456abc',\n   *   permission_mode: 'auto'\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Multiple field update\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * const updated = await service.updateSessionInfo('session-abc-123', {\n   *   custom_name: 'Important Session',\n   *   pinned: true,\n   *   permission_mode: 'bypass'\n   * });\n   * // All three fields updated atomically\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Auto-creation on first update (session doesn't exist)\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * // Session doesn't exist yet - creates with defaults + updates\n   * const created = await service.updateSessionInfo('session-new-789', {\n   *   custom_name: 'New Session',\n   *   pinned: true\n   * });\n   * console.log(created);\n   * // {\n   * //   custom_name: 'New Session',\n   * //   created_at: '2024-01-15T10:30:00.000Z',\n   * //   updated_at: '2024-01-15T10:30:00.000Z',\n   * //   version: 3,\n   * //   pinned: true,          // From updates\n   * //   archived: false,       // Default\n   * //   continuation_session_id: '', // Default\n   * //   initial_commit_head: '',     // Default\n   * //   permission_mode: 'default'   // Default\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // UI integration: rename session dialog\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * async function handleRenameSession(sessionId: string, newName: string) {\n   *   try {\n   *     const updated = await service.updateSessionInfo(sessionId, {\n   *       custom_name: newName\n   *     });\n   *     console.log(`Session renamed to: ${updated.custom_name}`);\n   *     return updated;\n   *   } catch (error) {\n   *     console.error('Failed to rename session:', error);\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling (throws on database errors)\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * // Note: initialize() not called (database not ready)\n   *\n   * try {\n   *   await service.updateSessionInfo('session-abc-123', {\n   *     custom_name: 'Test'\n   *   });\n   * } catch (error) {\n   *   console.error('Update failed:', error.message);\n   *   // Error: Failed to update session info: ...\n   * }\n   * ```\n   *\n   * @see {@link getSessionInfo} - Retrieve session metadata\n   * @see {@link updateCustomName} - Convenience method for updating custom name only\n   */\n  async updateSessionInfo(sessionId: string, updates: Partial<SessionInfo>): Promise<SessionInfo> {\n    try {\n      const existingRow = this.getSessionStmt.get(sessionId) as SessionRow | undefined;\n      const now = new Date().toISOString();\n      if (existingRow) {\n        const updatedSession: SessionInfo = {\n          ...this.mapRow(existingRow),\n          ...updates,\n          updated_at: now\n        };\n        this.updateSessionStmt.run({\n          session_id: sessionId,\n          custom_name: updatedSession.custom_name,\n          updated_at: updatedSession.updated_at,\n          pinned: updatedSession.pinned ? 1 : 0,\n          archived: updatedSession.archived ? 1 : 0,\n          continuation_session_id: updatedSession.continuation_session_id,\n          initial_commit_head: updatedSession.initial_commit_head,\n          permission_mode: updatedSession.permission_mode,\n          version: updatedSession.version\n        });\n        this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        return updatedSession;\n      } else {\n        const newSession: SessionInfo = {\n          custom_name: '',\n          created_at: now,\n          updated_at: now,\n          version: 3,\n          pinned: false,\n          archived: false,\n          continuation_session_id: '',\n          initial_commit_head: '',\n          permission_mode: 'default',\n          ...updates\n        };\n        this.insertSessionStmt.run({\n          session_id: sessionId,\n          custom_name: newSession.custom_name,\n          created_at: newSession.created_at,\n          updated_at: newSession.updated_at,\n          version: newSession.version,\n          pinned: newSession.pinned ? 1 : 0,\n          archived: newSession.archived ? 1 : 0,\n          continuation_session_id: newSession.continuation_session_id,\n          initial_commit_head: newSession.initial_commit_head,\n          permission_mode: newSession.permission_mode\n        });\n        this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        return newSession;\n      }\n    } catch (error) {\n      this.logger.error('Failed to update session info', { sessionId, updates, error });\n      throw new Error(`Failed to update session info: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  async updateCustomName(sessionId: string, customName: string): Promise<void> {\n    await this.updateSessionInfo(sessionId, { custom_name: customName });\n  }\n\n  async deleteSession(sessionId: string): Promise<void> {\n    this.logger.info('Deleting session info', { sessionId });\n    try {\n      const result = this.deleteSessionStmt.run(sessionId);\n      if (result.changes > 0) {\n        const now = new Date().toISOString();\n        this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        this.logger.info('Session info deleted successfully', { sessionId });\n      } else {\n        this.logger.debug('Session info not found for deletion', { sessionId });\n      }\n    } catch (error) {\n      this.logger.error('Failed to delete session info', { sessionId, error });\n      throw new Error(`Failed to delete session info: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Retrieve all session metadata as a dictionary keyed by session ID\n   *\n   * @description\n   * Retrieves all session records from the SQLite database and returns them as a dictionary\n   * with session IDs as keys and SessionInfo objects as values. This method is useful for\n   * bulk operations, analytics, and enriching conversation lists with metadata.\n   *\n   * **Graceful Degradation:**\n   * - On database errors, returns empty object {} without throwing\n   * - Error is logged but doesn't break application flow\n   * - Ensures UI always receives valid data structure\n   *\n   * **Use Cases:**\n   * - Enrich conversation list with custom names, pinned status, archived status\n   * - Filter conversations by metadata (archived, pinned, permission mode)\n   * - Export session metadata for analytics or backup\n   * - Display session statistics (total sessions, archived count, pinned count)\n   * - Bulk operations (archive all, sync metadata)\n   *\n   * @returns {Promise<Record<string, SessionInfo>>} Dictionary of session metadata keyed by session ID\n   *\n   * @example\n   * ```typescript\n   * // Basic usage - get all sessions\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * const allSessions = await service.getAllSessionInfo();\n   * console.log(Object.keys(allSessions).length); // Total session count\n   *\n   * // Example output:\n   * // {\n   * //   'session-abc-123': { custom_name: 'Code Review', pinned: true, ... },\n   * //   'session-def-456': { custom_name: '', pinned: false, archived: true, ... },\n   * //   ...\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Filter archived vs active sessions\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * const allSessions = await service.getAllSessionInfo();\n   * const activeSessions = Object.entries(allSessions)\n   *   .filter(([_, info]) => !info.archived)\n   *   .reduce((acc, [id, info]) => ({ ...acc, [id]: info }), {});\n   *\n   * const archivedSessions = Object.entries(allSessions)\n   *   .filter(([_, info]) => info.archived)\n   *   .reduce((acc, [id, info]) => ({ ...acc, [id]: info }), {});\n   *\n   * console.log(`Active: ${Object.keys(activeSessions).length}`);\n   * console.log(`Archived: ${Object.keys(archivedSessions).length}`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Get all pinned sessions\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * const allSessions = await service.getAllSessionInfo();\n   * const pinnedSessionIds = Object.entries(allSessions)\n   *   .filter(([_, info]) => info.pinned)\n   *   .map(([id, _]) => id);\n   *\n   * console.log('Pinned sessions:', pinnedSessionIds);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Enrich conversation list with metadata\n   * import { SessionInfoService } from './session-info-service';\n   * import { ClaudeHistoryReader } from './claude-history-reader';\n   *\n   * const service = SessionInfoService.getInstance();\n   * const historyReader = new ClaudeHistoryReader();\n   *\n   * await service.initialize();\n   * const conversations = await historyReader.getConversationList();\n   * const allSessions = await service.getAllSessionInfo();\n   *\n   * const enriched = conversations.map(conv => ({\n   *   ...conv,\n   *   customName: allSessions[conv.sessionId]?.custom_name || conv.title,\n   *   pinned: allSessions[conv.sessionId]?.pinned || false,\n   *   archived: allSessions[conv.sessionId]?.archived || false\n   * }));\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Session statistics dashboard\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * const allSessions = await service.getAllSessionInfo();\n   * const stats = {\n   *   total: Object.keys(allSessions).length,\n   *   active: Object.values(allSessions).filter(s => !s.archived).length,\n   *   archived: Object.values(allSessions).filter(s => s.archived).length,\n   *   pinned: Object.values(allSessions).filter(s => s.pinned).length,\n   *   withCustomNames: Object.values(allSessions).filter(s => s.custom_name).length\n   * };\n   * console.log('Session Statistics:', stats);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Export session metadata to JSON\n   * import { SessionInfoService } from './session-info-service';\n   * import fs from 'fs/promises';\n   *\n   * const service = SessionInfoService.getInstance();\n   * await service.initialize();\n   *\n   * const allSessions = await service.getAllSessionInfo();\n   * await fs.writeFile(\n   *   'session-metadata-backup.json',\n   *   JSON.stringify(allSessions, null, 2)\n   * );\n   * console.log('Exported metadata for', Object.keys(allSessions).length, 'sessions');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Graceful error handling (returns empty object)\n   * import { SessionInfoService } from './session-info-service';\n   *\n   * const service = SessionInfoService.getInstance();\n   * // Note: initialize() not called (database not ready)\n   *\n   * const allSessions = await service.getAllSessionInfo();\n   * console.log(allSessions); // {} (empty object, not undefined)\n   * // Error logged but application continues\n   * ```\n   *\n   * @see {@link getSessionInfo} - Retrieve single session metadata\n   * @see {@link getStats} - Get database statistics\n   */\n  async getAllSessionInfo(): Promise<Record<string, SessionInfo>> {\n    this.logger.debug('Getting all session info');\n    try {\n      const rows = this.getAllStmt.all() as Array<SessionRow & { session_id: string }>;\n      const result: Record<string, SessionInfo> = {};\n      for (const row of rows) {\n        result[row.session_id] = this.mapRow(row);\n      }\n      return result;\n    } catch (error) {\n      this.logger.error('Failed to get all session info', error);\n      return {};\n    }\n  }\n\n  async getStats(): Promise<{ sessionCount: number; dbSize: number; lastUpdated: string }> {\n    try {\n      const countRow = this.countStmt.get() as { count: number };\n      let dbSize = 0;\n      if (this.dbPath !== ':memory:') {\n        try {\n          const stats = fs.statSync(this.dbPath);\n          dbSize = stats.size;\n        } catch {\n          dbSize = 0;\n        }\n      }\n      const lastUpdatedRow = this.getMetadataStmt.get('last_updated') as { value?: string } | undefined;\n      return {\n        sessionCount: countRow.count,\n        dbSize,\n        lastUpdated: lastUpdatedRow?.value || new Date().toISOString()\n      };\n    } catch (error) {\n      this.logger.error('Failed to get database stats', error);\n      return {\n        sessionCount: 0,\n        dbSize: 0,\n        lastUpdated: new Date().toISOString()\n      };\n    }\n  }\n\n  reinitializePaths(customConfigDir?: string): void {\n    this.initializePaths(customConfigDir);\n  }\n\n  getDbPath(): string {\n    return this.dbPath;\n  }\n\n  getConfigDir(): string {\n    return this.configDir;\n  }\n\n  async archiveAllSessions(): Promise<number> {\n    this.logger.info('Archiving all sessions');\n    try {\n      const now = new Date().toISOString();\n      const transaction = this.db.transaction(() => {\n        const info = this.archiveAllStmt.run({ updated_at: now });\n        if (info.changes > 0) {\n          this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        }\n        return info.changes;\n      });\n      const archivedCount = transaction();\n      this.logger.info('Sessions archived successfully', { archivedCount });\n      return archivedCount;\n    } catch (error) {\n      this.logger.error('Failed to archive all sessions', error);\n      throw new Error(`Failed to archive all sessions: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  async syncMissingSessions(sessionIds: string[]): Promise<number> {\n    try {\n      const now = new Date().toISOString();\n      const insert = this.db.prepare(`\n        INSERT OR IGNORE INTO sessions (\n          session_id,\n          custom_name,\n          created_at,\n          updated_at,\n          version,\n          pinned,\n          archived,\n          continuation_session_id,\n          initial_commit_head,\n          permission_mode\n        ) VALUES (\n          @session_id,\n          '',\n          @now,\n          @now,\n          3,\n          0,\n          0,\n          '',\n          '',\n          'default'\n        )\n      `);\n      const transaction = this.db.transaction((ids: string[]) => {\n        let inserted = 0;\n        for (const id of ids) {\n          const info = insert.run({ session_id: id, now });\n          if (info.changes > 0) inserted++;\n        }\n        if (inserted > 0) {\n          this.setMetadataStmt.run({ key: 'last_updated', value: now });\n        }\n        return inserted;\n      });\n      return transaction(sessionIds);\n    } catch (error) {\n      this.logger.error('Failed to sync missing sessions', error);\n      throw new Error(`Failed to sync missing sessions: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n}\n\n",
        "last_modified": "2026-01-02T14:06:15.770716"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.637880",
  "last_updated": "2026-01-02T14:06:15.650476"
}