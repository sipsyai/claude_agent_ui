{
  "file_path": "docs/architecture/05-sequences.md",
  "main_branch_history": [],
  "task_views": {
    "003-create-architecture-documentation-with-system-diag": {
      "task_id": "003-create-architecture-documentation-with-system-diag",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "",
        "timestamp": "2026-01-02T10:53:08.483278"
      },
      "worktree_state": {
        "content": "# Sequence Diagrams\n\n## Introduction\n\nThis document provides detailed sequence diagrams showing the step-by-step interactions between components for critical system operations. These diagrams illustrate the temporal flow of messages, method calls, and data transformations across the entire stack.\n\n## Overview\n\nThe system has four critical operational flows documented here:\n\n1. **Agent Creation and Execution** - Complete flow from agent configuration to task execution\n2. **MCP Server Connection and Tool Discovery** - How MCP servers are initialized and tools discovered\n3. **Skill Management Flow** - Skill synchronization from database to filesystem\n4. **Real-time SSE Communication** - Server-Sent Events streaming architecture\n\n---\n\n## 1. Agent Creation and Execution Flow\n\nThis sequence diagram shows the complete lifecycle of creating an agent and executing it with a task, including MCP tool integration and SSE streaming.\n\n```mermaid\nsequenceDiagram\n    participant User as Web Browser\n    participant React as React Frontend\n    participant Express as Express Server\n    participant Strapi as Strapi CMS\n    participant DB as PostgreSQL\n    participant SDK as Claude SDK Service\n    participant MCP as MCP Service\n    participant Claude as Anthropic API\n\n    Note over User,Claude: Phase 1: Agent Creation\n\n    User->>React: Click \"Create Agent\"\n    React->>React: Open AgentConfigModal\n    User->>React: Fill in form:<br/>name, systemPrompt, model, etc.\n    User->>React: Select skills & MCP servers\n    React->>Express: POST /api/strapi/agents<br/>{name, systemPrompt, toolConfig, modelConfig}\n\n    Express->>Express: Validate agent data\n    Express->>Strapi: createAgent(data)\n    Strapi->>DB: INSERT INTO agents<br/>with relations\n    DB-->>Strapi: New agent record\n    Strapi-->>Express: Agent object\n    Express-->>React: 201 Created<br/>{agent: {...}}\n    React->>User: Show success message\n\n    Note over User,Claude: Phase 2: Agent Execution\n\n    User->>React: Click \"Execute Agent\"\n    React->>React: Open TaskExecutionModal\n    User->>React: Enter task message\n    React->>React: Open EventSource<br/>/api/execute/agent/:id\n    React->>Express: POST /api/execute/agent/:id<br/>{message, conversationId?}\n\n    Express->>Express: Set SSE headers<br/>(text/event-stream)\n    Express->>Express: Start keep-alive (30s)\n    Express->>React: SSE: connection established\n\n    Express->>Strapi: GET /api/agents/:id<br/>populate=skills,mcpServers\n    Strapi->>DB: SELECT agent with relations\n    DB-->>Strapi: Agent + skills + MCP servers\n    Strapi-->>Express: Full agent config\n\n    Express->>Express: skillSyncService.syncAllSkills()<br/>Write skills to .claude/skills/\n    Express->>React: SSE: {type:\"status\",\"status\":\"Loading agent...\"}\n\n    Express->>SDK: startConversation({<br/>  initialPrompt,<br/>  systemPrompt,<br/>  model,<br/>  skills,<br/>  mcpServers<br/>})\n\n    Note over SDK,MCP: MCP Server Initialization (see diagram 2)\n\n    SDK->>SDK: buildSdkOptions()<br/>Merge MCP configs<br/>(skill > agent > project)\n    SDK->>MCP: Initialize MCP servers\n    MCP->>MCP: Spawn server processes\n    MCP->>MCP: Discover tools\n    MCP-->>SDK: Available tools\n\n    SDK->>SDK: Create query() instance\n    SDK->>Claude: POST /v1/messages<br/>Stream: true<br/>Tools: [...discovered tools]\n\n    Express->>React: SSE: {type:\"status\",\"status\":\"Agent running...\"}\n\n    loop For each Claude response\n        Claude-->>SDK: Stream chunk\n        SDK->>SDK: Parse SDK message type\n\n        alt Assistant Text Message\n            SDK->>Express: Emit 'claude-message'<br/>{type: 'assistant'}\n            Express->>React: SSE: {type:\"message\",content:{...}}\n            React->>User: Display assistant response\n        else Tool Use Request\n            SDK->>Express: Emit 'claude-message'<br/>{type: 'tool_use'}\n            Express->>React: SSE: {type:\"message\",tool_use:{...}}\n            React->>User: Show \"Executing tool...\"\n\n            SDK->>MCP: Execute tool<br/>JSON-RPC: tools/call\n            MCP->>MCP: Execute tool logic\n            MCP-->>SDK: Tool result\n\n            SDK->>Express: Emit 'claude-message'<br/>{type: 'tool_result'}\n            Express->>React: SSE: {type:\"message\",tool_result:{...}}\n            React->>User: Show tool result\n\n            SDK->>Claude: Continue with tool result\n        else Thinking/Reasoning\n            SDK->>Express: Emit 'claude-message'<br/>{type: 'thinking'}\n            Express->>React: SSE: {type:\"message\",thinking:{...}}\n            React->>User: Show thinking process\n        end\n    end\n\n    Claude-->>SDK: Final response\n    SDK->>SDK: Calculate usage metrics\n    SDK->>Express: Emit 'process-closed'<br/>{tokens, usage}\n\n    Express->>Express: Calculate cost:<br/>input*$0.003 + output*$0.015\n    Express->>React: SSE: {type:\"completion\",<br/>tokens,cost,duration}\n    Express->>React: SSE: done\n    Express->>Express: Close SSE stream\n\n    React->>User: Show \"Completed\"<br/>with metrics\n\n    Note over Express,DB: Optional: Save execution to Task table\n    Express->>Strapi: createTask({<br/>  agent, message, result,<br/>  tokens, cost, duration<br/>})\n    Strapi->>DB: INSERT INTO tasks\n```\n\n### Key Points\n\n- **Three-phase flow**: Create agent \u2192 Configure execution \u2192 Stream results\n- **SSE Stream Lifecycle**: Connection established \u2192 Status updates \u2192 Messages \u2192 Completion \u2192 Close\n- **MCP Integration**: Tools discovered during SDK initialization, executed synchronously during conversation\n- **Error Handling**: Errors sent as SSE events if stream started, otherwise JSON response\n- **Cost Calculation**: Based on Claude 3.5 Sonnet pricing (input: $3/MTok, output: $15/MTok)\n\n### SSE Event Types\n\n| Event Type | Description | Data |\n|-----------|-------------|------|\n| `status` | Agent status update | `{status: string, timestamp: string}` |\n| `message` | Claude SDK message | `{type: 'assistant'|'tool_use'|'tool_result', content: {...}}` |\n| `completion` | Execution complete | `{tokens: {...}, cost: number, duration: number}` |\n| `error` | Error occurred | `{error: string, details?: any}` |\n| `done` | Stream finished | `{}` (just the string \"done\") |\n\n---\n\n## 2. MCP Server Connection and Tool Discovery\n\nThis sequence diagram details the Model Context Protocol (MCP) server initialization, connection, and tool discovery process using JSON-RPC.\n\n```mermaid\nsequenceDiagram\n    participant SDK as Claude SDK Service\n    participant MCP as MCP Service\n    participant FileSystem as File System\n    participant StrapiDB as Strapi Database\n    participant Process as MCP Server Process\n    participant Tool as Tool Implementation\n\n    Note over SDK,Tool: Phase 1: Three-Tier MCP Configuration Discovery\n\n    SDK->>SDK: buildSdkOptions()\n    SDK->>FileSystem: Read .mcp.json<br/>(project root)\n    FileSystem-->>SDK: Project-level config<br/>(Priority: Low)\n\n    SDK->>StrapiDB: Load agent's MCP servers<br/>WHERE agent.id = :agentId\n    StrapiDB-->>SDK: Agent-level MCP servers<br/>(Priority: Medium)\n\n    SDK->>StrapiDB: Load skills' MCP servers<br/>WHERE skill.id IN :skillIds\n    StrapiDB-->>SDK: Skill-level MCP servers<br/>(Priority: High)\n\n    SDK->>SDK: Merge configs with precedence:<br/>Skill > Agent > Project\n    SDK->>SDK: Filter out disabled servers\n    SDK->>SDK: Apply env var substitution:<br/>${HOME}, ${API_KEY}, etc.\n\n    Note over SDK,Tool: Phase 2: MCP Server Initialization\n\n    SDK->>MCP: Initialize servers<br/>(converted to SDK format)\n\n    loop For each MCP server config\n        MCP->>MCP: Validate config<br/>(command, args, env)\n\n        alt stdio transport (most common)\n            MCP->>Process: spawn(command, args, {<br/>  stdio: ['pipe','pipe','inherit'],<br/>  env: {...process.env, ...config.env}<br/>})\n            Process-->>MCP: Child process started<br/>PID: xxxxx\n            MCP->>MCP: Set up stdin/stdout pipes\n        else sse transport (remote)\n            MCP->>Process: Connect to SSE endpoint<br/>URL: config.url\n            Process-->>MCP: SSE connection established\n        else http transport (polling)\n            MCP->>Process: Set up HTTP polling<br/>URL: config.url\n            Process-->>MCP: HTTP endpoint ready\n        end\n\n        Note over MCP,Process: JSON-RPC Initialization Handshake\n\n        MCP->>Process: JSON-RPC Request:<br/>{<br/>  method: \"initialize\",<br/>  params: {<br/>    protocolVersion: \"2024-11-05\",<br/>    capabilities: {},<br/>    clientInfo: {name, version}<br/>  }<br/>}\n\n        Process->>Process: Start MCP server<br/>Initialize resources\n\n        Process-->>MCP: JSON-RPC Response:<br/>{<br/>  result: {<br/>    protocolVersion: \"2024-11-05\",<br/>    capabilities: {<br/>      tools: {},<br/>      resources: {}<br/>    },<br/>    serverInfo: {name, version}<br/>  }<br/>}\n\n        MCP->>MCP: Validate protocol version\n        MCP->>MCP: Store server capabilities\n    end\n\n    Note over MCP,Tool: Phase 3: Tool Discovery\n\n    loop For each initialized server\n        MCP->>Process: JSON-RPC Request:<br/>{<br/>  method: \"tools/list\",<br/>  params: {}<br/>}\n\n        Process->>Tool: Query available tools\n        Tool-->>Process: Tool definitions array\n\n        Process-->>MCP: JSON-RPC Response:<br/>{<br/>  result: {<br/>    tools: [<br/>      {<br/>        name: \"read_file\",<br/>        description: \"...\",<br/>        inputSchema: {<br/>          type: \"object\",<br/>          properties: {...},<br/>          required: [...]<br/>        }<br/>      },<br/>      ...<br/>    ]<br/>  }<br/>}\n\n        MCP->>MCP: Parse tool schemas\n        MCP->>MCP: Validate JSON schemas\n        MCP->>MCP: Store tool metadata:<br/>server name \u2192 tool mappings\n    end\n\n    MCP->>SDK: Return all discovered tools<br/>(formatted for Anthropic API)\n    SDK->>SDK: Include tools in<br/>Claude API request\n\n    Note over SDK,Tool: Phase 4: Tool Execution (during conversation)\n\n    SDK->>SDK: Receive tool_use from Claude:<br/>{name, id, input}\n    SDK->>MCP: executeTool(serverName, toolName, args)\n\n    MCP->>MCP: Find server for tool\n    MCP->>Process: JSON-RPC Request:<br/>{<br/>  method: \"tools/call\",<br/>  params: {<br/>    name: \"read_file\",<br/>    arguments: {<br/>      path: \"/path/to/file\"<br/>    }<br/>  }<br/>}\n\n    Process->>Tool: Execute tool logic<br/>with arguments\n    Tool->>Tool: Perform operation<br/>(e.g., read file, search, API call)\n\n    alt Success\n        Tool-->>Process: Tool result data\n        Process-->>MCP: JSON-RPC Response:<br/>{<br/>  result: {<br/>    content: [<br/>      {<br/>        type: \"text\",<br/>        text: \"File contents...\"<br/>      }<br/>    ]<br/>  }<br/>}\n        MCP-->>SDK: Tool result\n        SDK->>SDK: Format as tool_result message\n    else Error\n        Tool-->>Process: Error\n        Process-->>MCP: JSON-RPC Error:<br/>{<br/>  error: {<br/>    code: -32603,<br/>    message: \"Internal error\",<br/>    data: {...}<br/>  }<br/>}\n        MCP-->>SDK: Tool error\n        SDK->>SDK: Format as error message\n    end\n\n    SDK->>SDK: Send tool_result to Claude\n```\n\n### MCP Configuration Priority\n\n1. **Skill-level** (Highest priority) - Skills can specify required MCP servers\n2. **Agent-level** (Medium priority) - Agent configuration can add MCP servers\n3. **Project-level** (Lowest priority) - `.mcp.json` provides default servers\n\nWhen the same server name appears in multiple configs, higher priority takes precedence.\n\n### MCP Transport Types\n\n| Transport | Connection Method | Use Case | Example |\n|-----------|------------------|----------|---------|\n| **stdio** | Process stdin/stdout | Local CLI tools | `npx @modelcontextprotocol/server-filesystem` |\n| **sse** | Server-Sent Events | Remote APIs | `https://api.example.com/sse` |\n| **http** | HTTP polling | Remote APIs | `https://api.example.com/mcp` |\n| **sdk** | In-process TypeScript | Custom tools | Direct module import |\n\n### JSON-RPC Protocol Version\n\nCurrent protocol version: `2024-11-05` (as of Claude Agent SDK)\n\n---\n\n## 3. Skill Management Flow\n\nThis sequence diagram shows how skills are created in Strapi, synchronized to the filesystem, and made available to the Claude Agent SDK.\n\n```mermaid\nsequenceDiagram\n    participant User as Web Browser\n    participant React as React Frontend\n    participant Express as Express Server\n    participant Strapi as Strapi CMS\n    participant DB as PostgreSQL\n    participant SkillSync as Skill Sync Service\n    participant FileSystem as File System (.claude/skills/)\n    participant SDK as Claude SDK\n\n    Note over User,SDK: Phase 1: Skill Creation\n\n    User->>React: Click \"Create Skill\"\n    React->>React: Open SkillCreationModal\n    User->>React: Fill skill form:<br/>name, description,<br/>category, SKILL.md content\n    User->>React: Optional: Select training agent\n    User->>React: Optional: Add MCP servers\n\n    React->>Express: POST /api/strapi/skills<br/>{<br/>  name,<br/>  displayName,<br/>  description,<br/>  skillmd,<br/>  category,<br/>  version,<br/>  trainingAgent?,<br/>  mcpConfig?<br/>}\n\n    Express->>Express: Validate skill data\n    Express->>Strapi: createSkill(data)\n    Strapi->>DB: INSERT INTO skills<br/>with components\n    DB-->>Strapi: New skill record\n    Strapi-->>Express: Skill object\n    Express-->>React: 201 Created<br/>{skill: {...}}\n    React->>User: Show \"Skill created\"\n\n    Note over User,SDK: Phase 2: Skill Training (Optional)\n\n    User->>React: Click \"Train Skill\"\n    React->>React: Open SkillCreatorChatPanel\n    User->>React: Provide training examples\n    React->>Express: POST /api/chat/sessions<br/>{skillIds: [skillId]}\n    Express->>Express: Create training session<br/>with selected agent\n\n    loop Training iterations\n        User->>React: Send training message\n        React->>Express: POST /api/chat/sessions/:id/messages\n        Express->>SDK: Execute with skill\n        SDK-->>Express: Skill performance data\n        Express->>React: Stream training results\n        React->>User: Show skill execution\n\n        User->>React: Provide feedback\n        React->>Express: POST /api/strapi/skills/:id<br/>{trainingHistory: [...]}\n        Express->>Strapi: Update training history\n        Strapi->>DB: UPDATE skills<br/>SET training_history=...\n    end\n\n    Express->>Strapi: Update experienceScore<br/>based on training quality\n    Strapi->>DB: UPDATE skills<br/>SET experience_score=X\n\n    Note over User,SDK: Phase 3: Skill Synchronization to Filesystem\n\n    User->>React: Execute agent with skills\n    React->>Express: POST /api/execute/agent/:id<br/>or POST /api/chat/sessions\n\n    Express->>Strapi: GET /api/agents/:id<br/>populate=skills\n    Strapi->>DB: SELECT agent<br/>JOIN skills\n    DB-->>Strapi: Agent with skills array\n    Strapi-->>Express: [{skill1}, {skill2}, ...]\n\n    Express->>SkillSync: syncAllSkills(skills, parameters?)\n\n    loop For each skill\n        SkillSync->>SkillSync: Validate skill data\n        SkillSync->>SkillSync: Sanitize skill name<br/>(prevent path traversal)\n        SkillSync->>SkillSync: Inject parameters<br/>{{param}} \u2192 actual value\n\n        SkillSync->>SkillSync: Build YAML frontmatter:<br/>---<br/>name: skill-name<br/>description: ...<br/>version: 1.0.0<br/>category: custom<br/>---\n\n        SkillSync->>SkillSync: Combine frontmatter + skillmd\n\n        SkillSync->>FileSystem: mkdir .claude/skills/{skill-name}\n        FileSystem-->>SkillSync: Directory created\n\n        SkillSync->>FileSystem: writeFile<br/>.claude/skills/{skill-name}/SKILL.md\n        FileSystem-->>SkillSync: File written\n\n        SkillSync->>SkillSync: Log: \u2705 Synced skill: {name}\n    end\n\n    SkillSync-->>Express: All skills synced\n\n    Note over Express,SDK: Phase 4: SDK Skill Discovery\n\n    Express->>SDK: startConversation({<br/>  skills: [...],<br/>  settingSources: ['project']<br/>})\n\n    SDK->>SDK: Build SDK options:<br/>{<br/>  settingSources: ['project'],<br/>  tools: {...},<br/>  model: {...}<br/>}\n\n    SDK->>FileSystem: Scan .claude/skills/**/SKILL.md\n    FileSystem-->>SDK: Found skill files\n\n    loop For each SKILL.md\n        SDK->>FileSystem: Read SKILL.md content\n        FileSystem-->>SDK: File content\n        SDK->>SDK: Parse YAML frontmatter\n        SDK->>SDK: Parse skill markdown\n        SDK->>SDK: Register skill in SDK context\n    end\n\n    SDK->>SDK: Skills available for agent:<br/>- Skill name (from frontmatter)<br/>- Description<br/>- Version<br/>- Category\n\n    Note over SDK: Skills can be invoked by Claude<br/>using /skill command or auto-invoked\n\n    Note over User,SDK: Phase 5: Skill Usage in Conversation\n\n    SDK->>SDK: Claude receives prompt\n\n    alt Skill auto-invoked by agent\n        SDK->>SDK: Agent determines skill needed\n        SDK->>SDK: Load skill context from SKILL.md\n        SDK->>SDK: Execute with skill instructions\n        SDK->>SDK: Return skill result to Claude\n    else User explicitly invokes skill\n        SDK->>SDK: Parse /skill command\n        SDK->>SDK: Load skill by name\n        SDK->>SDK: Execute skill with provided input\n        SDK->>SDK: Return result\n    end\n\n    Note over User,SDK: Phase 6: Skill Update Propagation\n\n    User->>React: Edit skill in UI\n    React->>Express: PUT /api/strapi/skills/:id<br/>{skillmd: \"updated content\"}\n    Express->>Strapi: updateSkill(id, data)\n    Strapi->>DB: UPDATE skills\n    DB-->>Strapi: Updated record\n    Strapi-->>Express: Updated skill\n    Express-->>React: 200 OK\n\n    Note over Express: Next execution will re-sync\n\n    User->>React: Execute agent again\n    Express->>SkillSync: syncAllSkills(skills)\n    SkillSync->>FileSystem: Overwrite .claude/skills/{name}/SKILL.md\n    FileSystem-->>SkillSync: Updated\n    SkillSync-->>Express: Synced\n\n    Express->>SDK: startConversation(...)\n    SDK->>FileSystem: Re-read SKILL.md files\n    FileSystem-->>SDK: Updated skill content\n    SDK->>SDK: Use updated skill\n```\n\n### Skill Directory Structure\n\n```\n.claude/\n\u2514\u2500\u2500 skills/\n    \u251c\u2500\u2500 code-analysis/\n    \u2502   \u2514\u2500\u2500 SKILL.md          # Code analysis skill\n    \u251c\u2500\u2500 bug-finder/\n    \u2502   \u2514\u2500\u2500 SKILL.md          # Bug detection skill\n    \u2514\u2500\u2500 documentation-writer/\n        \u2514\u2500\u2500 SKILL.md          # Documentation generation skill\n```\n\n### SKILL.md Format\n\n```markdown\n---\nname: code-analysis\ndescription: Analyze code for patterns, quality, and potential improvements\nversion: 1.0.0\ncategory: code-analysis\n---\n\n# Code Analysis Skill\n\nThis skill analyzes source code to identify:\n- Code patterns and anti-patterns\n- Potential bugs and issues\n- Performance optimization opportunities\n- Code quality metrics\n\n## Usage\n\nProvide the code to analyze and specify:\n- Language (e.g., TypeScript, Python, Go)\n- Focus areas (e.g., performance, security, readability)\n\n## Example\n\n[Tool use examples...]\n```\n\n### Parameter Injection\n\nSkills support parameter templating:\n\n```markdown\n# Database Query Skill\n\nDatabase: {{database_name}}\nTable: {{table_name}}\n```\n\nParameters provided at execution time:\n```typescript\nsyncSkillToFilesystem(skill, {\n  database_name: 'production',\n  table_name: 'users'\n});\n```\n\nResult:\n```markdown\n# Database Query Skill\n\nDatabase: production\nTable: users\n```\n\n---\n\n## 4. Real-time SSE Communication\n\nThis sequence diagram illustrates the Server-Sent Events (SSE) streaming architecture used for real-time communication between Express backend and React frontend.\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant React as React Frontend\n    participant EventSource as EventSource API\n    participant Nginx as Nginx Proxy\n    participant Express as Express Server\n    participant SDK as Claude SDK\n    participant Claude as Anthropic API\n\n    Note over Browser,Claude: Phase 1: SSE Connection Establishment\n\n    Browser->>React: User triggers action<br/>(Execute agent, Send chat message)\n    React->>React: Create EventSource instance\n\n    React->>EventSource: new EventSource(<br/>  '/api/execute/agent/:id',<br/>  {withCredentials: true}<br/>)\n\n    EventSource->>Nginx: GET /api/execute/agent/:id<br/>Accept: text/event-stream\n    Nginx->>Express: Forward request to :3001\n\n    Express->>Express: Route handler:<br/>execution.routes.ts\n    Express->>Express: Create SSEStream instance\n    Express->>Express: Set headers:<br/>Content-Type: text/event-stream<br/>Cache-Control: no-cache<br/>Connection: keep-alive<br/>X-Accel-Buffering: no\n\n    Express->>EventSource: : SSE stream initialized\\n\\n<br/>(initial comment)\n    Express->>Express: Start keep-alive timer<br/>(30 second interval)\n\n    EventSource-->>React: onopen event fired\n    React->>Browser: Show \"Connecting...\" \u2192 \"Connected\"\n\n    Note over Express,Claude: Phase 2: Request Processing & SDK Initialization\n\n    Express->>Express: Load agent configuration\n    Express->>SDK: startConversation({...})\n    SDK->>SDK: Initialize MCP servers\n    SDK->>SDK: Discover tools\n\n    Express->>EventSource: event: status\\n<br/>data: {\"type\":\"status\",\"status\":\"Loading agent...\"}\\n\\n\n    EventSource-->>React: onmessage event<br/>{type: 'status', ...}\n    React->>Browser: Update status UI\n\n    SDK->>Claude: POST /v1/messages<br/>Stream: true\n\n    Express->>EventSource: event: status\\n<br/>data: {\"type\":\"status\",\"status\":\"Agent running...\"}\\n\\n\n    EventSource-->>React: onmessage event\n    React->>Browser: Update status\n\n    Note over Express,Claude: Phase 3: Streaming Claude Responses\n\n    loop For each Claude stream chunk\n        Claude-->>SDK: Stream chunk<br/>(content delta)\n        SDK->>SDK: Parse and emit event\n        SDK->>Express: EventEmitter: 'claude-message'<br/>{type: 'assistant', content: ...}\n\n        Express->>Express: Transform to SSE format\n        Express->>EventSource: event: message\\n<br/>data: {\"type\":\"message\",\"content\":{...}}\\n\\n\n\n        EventSource-->>React: onmessage event<br/>{type: 'message', ...}\n        React->>React: Parse message type\n\n        alt Assistant text message\n            React->>Browser: Append text to chat bubble<br/>(incremental rendering)\n        else Tool use message\n            React->>Browser: Show \"Executing: tool_name\"<br/>with input parameters\n        else Tool result message\n            React->>Browser: Show tool output<br/>(formatted/syntax highlighted)\n        else Thinking message\n            React->>Browser: Show thinking indicator<br/>with reasoning text\n        end\n    end\n\n    Note over Express,EventSource: Phase 4: Keep-Alive Mechanism\n\n    loop Every 30 seconds (while stream active)\n        Express->>Express: keep-alive timer fires\n        Express->>EventSource: : keep-alive\\n\\n<br/>(comment, not data)\n        EventSource->>EventSource: Reset connection timeout\n\n        Note over Express,EventSource: Prevents proxy/browser<br/>from closing idle connection\n    end\n\n    Note over Express,Claude: Phase 5: Stream Completion\n\n    Claude-->>SDK: Final response<br/>(stream complete)\n    SDK->>SDK: Calculate usage metrics:<br/>- Input tokens<br/>- Output tokens<br/>- Cache read/write\n\n    SDK->>Express: EventEmitter: 'process-closed'<br/>{tokens: {...}, cost: ...}\n\n    Express->>Express: Calculate metrics:<br/>- Total cost<br/>- Duration<br/>- Tokens used\n\n    Express->>EventSource: event: completion\\n<br/>data: {<br/>  \"type\":\"completion\",<br/>  \"tokens\":{\"input\":100,\"output\":50},<br/>  \"cost\":0.0025,<br/>  \"duration\":5.2<br/>}\\n\\n\n\n    EventSource-->>React: onmessage event<br/>{type: 'completion', ...}\n    React->>Browser: Show completion metrics\n\n    Express->>EventSource: data: done\\n\\n<br/>(done signal)\n    EventSource-->>React: onmessage: \"done\"\n\n    Express->>Express: Clear keep-alive timer\n    Express->>EventSource: res.end()<br/>(close stream)\n\n    EventSource-->>React: onclose event\n    React->>React: eventSource.close()\n    React->>Browser: Update UI: \"Completed\"\n\n    Note over Browser,Express: Phase 6: Error Handling\n\n    alt Error before stream starts\n        Express->>Express: Catch error\n        Express->>EventSource: HTTP 500<br/>Content-Type: application/json<br/>{\"error\": \"message\"}\n        EventSource-->>React: onerror event\n        React->>Browser: Show error dialog\n    else Error after stream starts\n        Express->>Express: Catch error\n        Express->>EventSource: event: error\\n<br/>data: {\"type\":\"error\",\"error\":\"message\"}\\n\\n\n        EventSource-->>React: onmessage: {type: 'error'}\n        React->>Browser: Show inline error\n        Express->>EventSource: res.end()\n        EventSource-->>React: onclose event\n    end\n\n    Note over Browser,React: Phase 7: User-Initiated Cancellation\n\n    Browser->>React: User clicks \"Cancel\"\n    React->>Express: POST /api/chat/sessions/:id/cancel<br/>(separate HTTP request)\n    Express->>SDK: abortController.abort()\n    SDK->>SDK: Stop processing\n    SDK->>Claude: Cancel stream\n\n    Express->>EventSource: event: cancelled\\n<br/>data: {\"type\":\"cancelled\"}\\n\\n\n    EventSource-->>React: onmessage: cancelled\n    React->>React: eventSource.close()\n    React->>Browser: Show \"Cancelled by user\"\n\n    Note over Browser,Express: Phase 8: Connection Cleanup\n\n    alt Normal completion\n        Express->>Express: Stream ended gracefully\n        Express->>Express: Clean up resources:<br/>- Clear timers<br/>- Remove from active streams<br/>- Close SDK query\n    else Network error\n        EventSource-->>React: onerror event\n        React->>React: Auto-retry (3 attempts)<br/>with exponential backoff\n        alt Retry succeeds\n            React->>EventSource: Reconnect\n        else Retry fails\n            React->>Browser: Show \"Connection lost\"\n        end\n    else Client closes tab\n        Browser->>EventSource: Close connection\n        EventSource->>Express: Connection closed\n        Express->>Express: Detect client disconnect\n        Express->>SDK: Abort ongoing operations\n        Express->>Express: Clean up resources\n    end\n```\n\n### SSE Message Format\n\n```\nevent: status\ndata: {\"type\":\"status\",\"status\":\"Loading agent...\",\"timestamp\":\"2024-01-02T10:30:00Z\"}\n\nevent: message\ndata: {\"type\":\"message\",\"content\":{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"text\",\"text\":\"Hello!\"}]}}}\n\nevent: message\ndata: {\"type\":\"message\",\"content\":{\"type\":\"tool_use\",\"id\":\"toolu_123\",\"name\":\"read_file\",\"input\":{\"path\":\"file.txt\"}}}\n\nevent: message\ndata: {\"type\":\"message\",\"content\":{\"type\":\"tool_result\",\"tool_use_id\":\"toolu_123\",\"content\":\"file contents...\"}}\n\nevent: completion\ndata: {\"type\":\"completion\",\"tokens\":{\"input\":100,\"output\":50},\"cost\":0.0025,\"duration\":5.2}\n\ndata: done\n\n```\n\n### SSE Headers\n\n**Request Headers (Client \u2192 Server):**\n```\nGET /api/execute/agent/123 HTTP/1.1\nAccept: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n\n**Response Headers (Server \u2192 Client):**\n```\nHTTP/1.1 200 OK\nContent-Type: text/event-stream\nCache-Control: no-cache, no-transform\nConnection: keep-alive\nX-Accel-Buffering: no\nTransfer-Encoding: chunked\n```\n\n### EventSource Lifecycle\n\n```typescript\n// React frontend SSE handling\nconst eventSource = new EventSource('/api/execute/agent/123', {\n  withCredentials: true\n});\n\n// Connection opened\neventSource.onopen = () => {\n  console.log('SSE connection established');\n  setStatus('connected');\n};\n\n// Message received\neventSource.onmessage = (event) => {\n  const data = JSON.parse(event.data);\n\n  switch (data.type) {\n    case 'status':\n      setStatus(data.status);\n      break;\n    case 'message':\n      appendMessage(data.content);\n      break;\n    case 'completion':\n      showMetrics(data.tokens, data.cost);\n      break;\n  }\n\n  if (event.data === 'done') {\n    eventSource.close();\n  }\n};\n\n// Error occurred\neventSource.onerror = (error) => {\n  console.error('SSE error:', error);\n  setStatus('error');\n  // EventSource automatically reconnects (up to browser limit)\n};\n\n// Manual cleanup\nconst cleanup = () => {\n  eventSource.close();\n};\n```\n\n### Keep-Alive Mechanism\n\n```typescript\n// Express backend keep-alive\nclass SSEStream {\n  private keepAliveInterval: NodeJS.Timeout | null = null;\n\n  startKeepAlive(): void {\n    this.keepAliveInterval = setInterval(() => {\n      this.sendComment('keep-alive');\n    }, 30000); // 30 seconds\n  }\n\n  sendComment(comment: string): void {\n    this.res.write(`: ${comment}\\n\\n`);\n  }\n\n  close(): void {\n    if (this.keepAliveInterval) {\n      clearInterval(this.keepAliveInterval);\n    }\n    this.res.end();\n  }\n}\n```\n\n### Error Handling Patterns\n\n**Before Stream Starts (No SSE headers sent):**\n```typescript\ntry {\n  // ... validation\n} catch (error) {\n  res.status(500).json({ error: error.message });\n  return;\n}\n\nres.setHeader('Content-Type', 'text/event-stream');\n// Stream started - now use SSE for errors\n```\n\n**After Stream Starts (SSE active):**\n```typescript\ntry {\n  // ... processing\n} catch (error) {\n  sseStream.send('error', {\n    type: 'error',\n    error: error.message,\n    details: error.stack\n  });\n  sseStream.close();\n}\n```\n\n### Connection Timeout & Retry\n\n- **Browser EventSource**: Automatically reconnects on connection loss (typically 3-5 seconds)\n- **Keep-Alive**: Prevents 60-second idle timeout (common in proxies/browsers)\n- **Custom Retry Logic**: React can implement exponential backoff for failed connections\n- **Maximum Duration**: No hard limit, but consider 5-10 minute timeout for long operations\n\n---\n\n## Summary\n\nThese sequence diagrams illustrate the four critical flows in the Claude Agent UI system:\n\n1. **Agent Creation and Execution** - End-to-end flow from configuration to streaming results with SSE\n2. **MCP Server Connection and Tool Discovery** - Three-tier config merging, JSON-RPC initialization, and tool execution\n3. **Skill Management** - Database \u2192 Filesystem synchronization and SDK discovery\n4. **Real-time SSE Communication** - Connection lifecycle, streaming, keep-alive, and error handling\n\n### Common Patterns Across Flows\n\n- **Event-Driven Architecture**: Services communicate via EventEmitter\n- **Streaming**: SSE for real-time updates, async generators for backpressure\n- **Three-Tier Config**: Skill > Agent > Project precedence\n- **Error Handling**: Graceful degradation, retry logic, detailed error events\n- **Cleanup**: Proper resource disposal (timers, connections, processes)\n\n### Technology Stack\n\n| Component | Technology | Purpose |\n|-----------|-----------|---------|\n| **Real-time Streaming** | Server-Sent Events (SSE) | Unidirectional server\u2192client updates |\n| **MCP Protocol** | JSON-RPC 2.0 | Tool discovery and execution |\n| **Filesystem Sync** | Node.js fs/promises | Skill persistence |\n| **Database** | PostgreSQL + Strapi ORM | Persistent data storage |\n| **AI Integration** | Anthropic Claude SDK | Agent conversations |\n\n---\n\n## Related Documentation\n\n- [System Overview](./01-system-overview.md) - High-level architecture\n- [Data Flow](./02-data-flow.md) - Data flow patterns with additional sequence diagrams\n- [Deployment](./03-deployment.md) - Docker infrastructure\n- [Components](./04-components.md) - Service and component details\n\n---\n\n*Last Updated: 2026-01-02*\n",
        "last_modified": "2026-01-02T15:11:22.009141"
      },
      "task_intent": {
        "title": "003-create-architecture-documentation-with-system-diag",
        "description": "Create comprehensive visual documentation showing how the hybrid architecture components (React + Express + Strapi + PostgreSQL + Claude SDK + MCP) interact, including data flow, service communication, and deployment topology.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T10:53:08.936854",
  "last_updated": "2026-01-02T10:53:08.950331"
}