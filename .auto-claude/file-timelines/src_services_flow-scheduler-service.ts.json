{
  "file_path": "src/services/flow-scheduler-service.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": {
        "content": "/**\n * Claude Agent UI - Flow Scheduler Service\n *\n * A simple scheduler service for automated flow execution using setInterval.\n * Designed for personal use - not production-grade.\n *\n * Features:\n * - Checks for scheduled flows every minute\n * - Supports schedule types: 'once', 'cron', 'interval'\n * - Basic cron expression parsing (minutes, hours, day of month, month, day of week)\n * - Interval-based scheduling (minutes, hours, days, weeks)\n * - One-time execution scheduling\n * - Automatic schedule updates after execution\n *\n * @see src/types/flow-types.ts for FlowSchedule type\n * @see src/services/flow-execution-service.ts for flow execution\n */\n\nimport { EventEmitter } from 'events';\nimport { createLogger, type Logger } from './logger.js';\nimport { strapiClient } from './strapi-client.js';\nimport { flowExecutionService } from './flow-execution-service.js';\nimport type {\n  Flow,\n  FlowSchedule,\n  FlowIntervalUnit,\n} from '../types/flow-types.js';\n\n// ============= CONFIGURATION =============\n\n/** Check interval in milliseconds (1 minute) */\nconst CHECK_INTERVAL_MS = 60 * 1000;\n\n/** Time tolerance for schedule matching (30 seconds before/after) */\nconst SCHEDULE_TOLERANCE_MS = 30 * 1000;\n\n// ============= FLOW SCHEDULER SERVICE =============\n\n/**\n * FlowSchedulerService - Singleton service for scheduled flow execution\n *\n * Uses setInterval to periodically check for flows that need to be executed\n * based on their schedule configuration.\n */\nexport class FlowSchedulerService extends EventEmitter {\n  private logger: Logger;\n  private checkInterval: NodeJS.Timeout | null = null;\n  private isRunning: boolean = false;\n  private lastCheckTime: Date | null = null;\n  private scheduledFlowIds: Set<string> = new Set();\n  private executingFlowIds: Set<string> = new Set();\n\n  constructor() {\n    super();\n    this.logger = createLogger('FlowSchedulerService');\n  }\n\n  /**\n   * Start the scheduler service\n   * Begins periodic checking for scheduled flows\n   */\n  start(): void {\n    if (this.isRunning) {\n      this.logger.warn('Scheduler is already running');\n      return;\n    }\n\n    this.logger.info('Starting flow scheduler service', {\n      checkIntervalMs: CHECK_INTERVAL_MS,\n    });\n\n    this.isRunning = true;\n\n    // Run initial check\n    this.checkScheduledFlows().catch((error) => {\n      this.logger.error('Initial schedule check failed', error);\n    });\n\n    // Set up periodic checking\n    this.checkInterval = setInterval(() => {\n      this.checkScheduledFlows().catch((error) => {\n        this.logger.error('Scheduled check failed', error);\n      });\n    }, CHECK_INTERVAL_MS);\n\n    this.emit('started');\n    this.logger.info('Flow scheduler service started successfully');\n  }\n\n  /**\n   * Stop the scheduler service\n   * Clears the check interval and stops scheduling\n   */\n  stop(): void {\n    if (!this.isRunning) {\n      this.logger.warn('Scheduler is not running');\n      return;\n    }\n\n    this.logger.info('Stopping flow scheduler service');\n\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n\n    this.isRunning = false;\n    this.emit('stopped');\n    this.logger.info('Flow scheduler service stopped');\n  }\n\n  /**\n   * Check if the scheduler is currently running\n   */\n  isSchedulerRunning(): boolean {\n    return this.isRunning;\n  }\n\n  /**\n   * Get the last time a schedule check was performed\n   */\n  getLastCheckTime(): Date | null {\n    return this.lastCheckTime;\n  }\n\n  /**\n   * Get IDs of flows currently being tracked for scheduling\n   */\n  getScheduledFlowIds(): string[] {\n    return Array.from(this.scheduledFlowIds);\n  }\n\n  /**\n   * Get IDs of flows currently being executed by the scheduler\n   */\n  getExecutingFlowIds(): string[] {\n    return Array.from(this.executingFlowIds);\n  }\n\n  /**\n   * Force a schedule check immediately\n   * Useful for testing or manual triggering\n   */\n  async forceCheck(): Promise<void> {\n    this.logger.info('Forcing immediate schedule check');\n    await this.checkScheduledFlows();\n  }\n\n  // ============= PRIVATE: SCHEDULE CHECKING =============\n\n  /**\n   * Check all flows for scheduled executions\n   * This is the main loop that runs periodically\n   */\n  private async checkScheduledFlows(): Promise<void> {\n    const checkTime = new Date();\n    this.lastCheckTime = checkTime;\n\n    this.logger.debug('Checking for scheduled flows', {\n      checkTime: checkTime.toISOString(),\n    });\n\n    try {\n      // Get all active flows with schedules\n      const flows = await this.getScheduledFlows();\n      this.scheduledFlowIds = new Set(flows.map((f) => f.id));\n\n      this.logger.debug('Found flows with active schedules', {\n        count: flows.length,\n        flowIds: flows.map((f) => f.id),\n      });\n\n      // Check each flow's schedule\n      for (const flow of flows) {\n        try {\n          await this.processFlowSchedule(flow, checkTime);\n        } catch (error) {\n          this.logger.error('Failed to process flow schedule', error as Error, {\n            flowId: flow.id,\n            flowName: flow.name,\n          });\n        }\n      }\n    } catch (error) {\n      this.logger.error('Failed to check scheduled flows', error as Error);\n    }\n  }\n\n  /**\n   * Get all flows that have active, enabled schedules\n   */\n  private async getScheduledFlows(): Promise<Flow[]> {\n    try {\n      // Get all active flows\n      const flows = await strapiClient.getActiveFlows();\n\n      // Filter to only flows with enabled schedules\n      return flows.filter((flow) => {\n        if (!flow.schedule) return false;\n        if (!flow.schedule.isEnabled) return false;\n        if (!flow.isActive) return false;\n\n        // Check if within date range\n        const now = new Date();\n        if (flow.schedule.startDate && new Date(flow.schedule.startDate) > now) {\n          return false;\n        }\n        if (flow.schedule.endDate && new Date(flow.schedule.endDate) < now) {\n          return false;\n        }\n\n        // Check if max runs reached\n        if (\n          flow.schedule.maxRuns &&\n          flow.schedule.runCount >= flow.schedule.maxRuns\n        ) {\n          return false;\n        }\n\n        return true;\n      });\n    } catch (error) {\n      this.logger.error('Failed to get scheduled flows', error as Error);\n      return [];\n    }\n  }\n\n  /**\n   * Process a single flow's schedule\n   * Determines if the flow should be executed now\n   */\n  private async processFlowSchedule(flow: Flow, checkTime: Date): Promise<void> {\n    const schedule = flow.schedule!;\n\n    // Skip if flow is already being executed\n    if (this.executingFlowIds.has(flow.id)) {\n      this.logger.debug('Flow is already being executed, skipping', {\n        flowId: flow.id,\n      });\n      return;\n    }\n\n    // Calculate if we should run now\n    const shouldRun = this.shouldRunNow(schedule, checkTime);\n\n    if (shouldRun) {\n      this.logger.info('Executing scheduled flow', {\n        flowId: flow.id,\n        flowName: flow.name,\n        scheduleType: schedule.scheduleType,\n      });\n\n      await this.executeScheduledFlow(flow);\n    }\n  }\n\n  /**\n   * Determine if a flow should run based on its schedule\n   */\n  private shouldRunNow(schedule: FlowSchedule, checkTime: Date): boolean {\n    // If nextRunAt is set, check if we're past it\n    if (schedule.nextRunAt) {\n      const nextRun = new Date(schedule.nextRunAt);\n      const timeDiff = checkTime.getTime() - nextRun.getTime();\n\n      // Run if we're within tolerance window after next run time\n      if (timeDiff >= -SCHEDULE_TOLERANCE_MS && timeDiff <= CHECK_INTERVAL_MS) {\n        return true;\n      }\n      return false;\n    }\n\n    // Otherwise, calculate based on schedule type\n    switch (schedule.scheduleType) {\n      case 'once':\n        // For 'once', we should have a nextRunAt - if not set, don't run\n        return false;\n\n      case 'interval':\n        return this.shouldRunInterval(schedule, checkTime);\n\n      case 'cron':\n        return this.shouldRunCron(schedule, checkTime);\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Check if an interval-based schedule should run\n   */\n  private shouldRunInterval(schedule: FlowSchedule, checkTime: Date): boolean {\n    // If never run before, run now\n    if (!schedule.lastRunAt) {\n      return true;\n    }\n\n    const lastRun = new Date(schedule.lastRunAt);\n    const intervalMs = this.getIntervalMs(\n      schedule.intervalValue,\n      schedule.intervalUnit\n    );\n\n    // Check if enough time has passed since last run\n    const timeSinceLastRun = checkTime.getTime() - lastRun.getTime();\n    return timeSinceLastRun >= intervalMs - SCHEDULE_TOLERANCE_MS;\n  }\n\n  /**\n   * Check if a cron-based schedule should run\n   */\n  private shouldRunCron(schedule: FlowSchedule, checkTime: Date): boolean {\n    if (!schedule.cronExpression) {\n      return false;\n    }\n\n    try {\n      return this.matchesCronExpression(schedule.cronExpression, checkTime);\n    } catch (error) {\n      this.logger.warn('Invalid cron expression', {\n        cronExpression: schedule.cronExpression,\n        error: (error as Error).message,\n      });\n      return false;\n    }\n  }\n\n  // ============= PRIVATE: FLOW EXECUTION =============\n\n  /**\n   * Execute a flow as a scheduled run\n   */\n  private async executeScheduledFlow(flow: Flow): Promise<void> {\n    const schedule = flow.schedule!;\n\n    // Mark as executing to prevent duplicate runs\n    this.executingFlowIds.add(flow.id);\n\n    try {\n      // Get default input from schedule\n      const input = schedule.defaultInput || {};\n\n      this.emit('flow-executing', {\n        flowId: flow.id,\n        flowName: flow.name,\n        scheduleType: schedule.scheduleType,\n      });\n\n      // Execute the flow\n      const result = await flowExecutionService.startExecution({\n        flowId: flow.id,\n        input,\n        triggeredBy: 'schedule',\n        triggerData: {\n          scheduleType: schedule.scheduleType,\n          scheduledAt: new Date().toISOString(),\n        },\n      });\n\n      this.logger.info('Scheduled flow execution completed', {\n        flowId: flow.id,\n        executionId: result.executionId,\n        success: result.success,\n        status: result.status,\n      });\n\n      // Update schedule after execution\n      await this.updateScheduleAfterExecution(flow, result.success);\n\n      this.emit('flow-executed', {\n        flowId: flow.id,\n        executionId: result.executionId,\n        success: result.success,\n      });\n    } catch (error) {\n      this.logger.error('Scheduled flow execution failed', error as Error, {\n        flowId: flow.id,\n      });\n\n      // Update schedule even on failure\n      await this.updateScheduleAfterExecution(flow, false);\n\n      this.emit('flow-failed', {\n        flowId: flow.id,\n        error: (error as Error).message,\n      });\n    } finally {\n      // Remove from executing set\n      this.executingFlowIds.delete(flow.id);\n    }\n  }\n\n  /**\n   * Update schedule fields after an execution\n   */\n  private async updateScheduleAfterExecution(\n    flow: Flow,\n    success: boolean\n  ): Promise<void> {\n    const schedule = flow.schedule!;\n    const now = new Date();\n\n    try {\n      // Calculate next run time\n      const nextRunAt = this.calculateNextRunTime(schedule, now);\n\n      // Build updated schedule\n      const updatedSchedule: Partial<FlowSchedule> = {\n        ...schedule,\n        lastRunAt: now,\n        runCount: (schedule.runCount || 0) + 1,\n        nextRunAt: nextRunAt || undefined,\n      };\n\n      // For 'once' schedules, disable after running\n      if (schedule.scheduleType === 'once') {\n        updatedSchedule.isEnabled = false;\n      }\n\n      // Check if max runs reached\n      if (schedule.maxRuns && updatedSchedule.runCount! >= schedule.maxRuns) {\n        updatedSchedule.isEnabled = false;\n        this.logger.info('Max runs reached, disabling schedule', {\n          flowId: flow.id,\n          runCount: updatedSchedule.runCount,\n          maxRuns: schedule.maxRuns,\n        });\n      }\n\n      // Update the flow in Strapi\n      await strapiClient.updateFlow(flow.id, {\n        schedule: updatedSchedule as FlowSchedule,\n      });\n\n      this.logger.debug('Schedule updated after execution', {\n        flowId: flow.id,\n        lastRunAt: now.toISOString(),\n        nextRunAt: nextRunAt?.toISOString(),\n        runCount: updatedSchedule.runCount,\n      });\n    } catch (error) {\n      this.logger.error('Failed to update schedule after execution', error as Error, {\n        flowId: flow.id,\n      });\n    }\n  }\n\n  // ============= PRIVATE: SCHEDULE CALCULATIONS =============\n\n  /**\n   * Calculate the next run time based on schedule configuration\n   */\n  private calculateNextRunTime(\n    schedule: FlowSchedule,\n    fromTime: Date\n  ): Date | null {\n    switch (schedule.scheduleType) {\n      case 'once':\n        // One-time schedules don't have a next run\n        return null;\n\n      case 'interval':\n        return this.calculateNextIntervalRun(schedule, fromTime);\n\n      case 'cron':\n        return this.calculateNextCronRun(schedule, fromTime);\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Calculate next run time for interval-based schedule\n   */\n  private calculateNextIntervalRun(\n    schedule: FlowSchedule,\n    fromTime: Date\n  ): Date {\n    const intervalMs = this.getIntervalMs(\n      schedule.intervalValue,\n      schedule.intervalUnit\n    );\n\n    return new Date(fromTime.getTime() + intervalMs);\n  }\n\n  /**\n   * Calculate next run time for cron-based schedule\n   * Simplified implementation for common patterns\n   */\n  private calculateNextCronRun(schedule: FlowSchedule, fromTime: Date): Date {\n    if (!schedule.cronExpression) {\n      // Default to 1 hour if no cron expression\n      return new Date(fromTime.getTime() + 60 * 60 * 1000);\n    }\n\n    // Parse the cron expression to find next matching time\n    // For simplicity, we'll calculate the next minute that matches\n    const next = new Date(fromTime);\n    next.setSeconds(0);\n    next.setMilliseconds(0);\n\n    // Try up to 24*60 times (1 day worth of minutes)\n    for (let i = 0; i < 24 * 60; i++) {\n      next.setMinutes(next.getMinutes() + 1);\n      if (this.matchesCronExpression(schedule.cronExpression, next)) {\n        return next;\n      }\n    }\n\n    // Fallback to 1 day if no match found\n    return new Date(fromTime.getTime() + 24 * 60 * 60 * 1000);\n  }\n\n  /**\n   * Convert interval value and unit to milliseconds\n   */\n  private getIntervalMs(value: number, unit: FlowIntervalUnit): number {\n    const multipliers: Record<FlowIntervalUnit, number> = {\n      minutes: 60 * 1000,\n      hours: 60 * 60 * 1000,\n      days: 24 * 60 * 60 * 1000,\n      weeks: 7 * 24 * 60 * 60 * 1000,\n    };\n\n    return value * (multipliers[unit] || multipliers.hours);\n  }\n\n  /**\n   * Check if a given time matches a cron expression\n   *\n   * Cron format: minute hour day-of-month month day-of-week\n   * Examples:\n   * - \"0 9 * * 1-5\" - 9am on weekdays\n   * - \"0,15,30,45 * * * *\" - Every 15 minutes (using list instead of step)\n   * - \"0 0 1 * *\" - First of every month at midnight\n   */\n  private matchesCronExpression(cronExpr: string, time: Date): boolean {\n    const parts = cronExpr.trim().split(/\\s+/);\n\n    if (parts.length !== 5) {\n      throw new Error(`Invalid cron expression: ${cronExpr}`);\n    }\n\n    const [minuteExpr, hourExpr, dayExpr, monthExpr, weekdayExpr] = parts;\n\n    const minute = time.getMinutes();\n    const hour = time.getHours();\n    const day = time.getDate();\n    const month = time.getMonth() + 1; // JavaScript months are 0-indexed\n    const weekday = time.getDay(); // 0 = Sunday\n\n    return (\n      this.matchesCronField(minuteExpr, minute, 0, 59) &&\n      this.matchesCronField(hourExpr, hour, 0, 23) &&\n      this.matchesCronField(dayExpr, day, 1, 31) &&\n      this.matchesCronField(monthExpr, month, 1, 12) &&\n      this.matchesCronField(weekdayExpr, weekday, 0, 6)\n    );\n  }\n\n  /**\n   * Match a single cron field against a value\n   * Supports: wildcard (*), specific values, ranges (1-5), steps, lists (1,3,5)\n   */\n  private matchesCronField(\n    expr: string,\n    value: number,\n    min: number,\n    max: number\n  ): boolean {\n    // Handle wildcard\n    if (expr === '*') {\n      return true;\n    }\n\n    // Handle step values (*/n)\n    if (expr.startsWith('*/')) {\n      const step = parseInt(expr.slice(2), 10);\n      if (isNaN(step) || step <= 0) {\n        throw new Error(`Invalid step in cron field: ${expr}`);\n      }\n      return value % step === 0;\n    }\n\n    // Handle range with step (1-30/5)\n    if (expr.includes('/')) {\n      const [rangeOrStar, stepStr] = expr.split('/');\n      const step = parseInt(stepStr, 10);\n\n      if (rangeOrStar === '*') {\n        return value % step === 0;\n      }\n\n      if (rangeOrStar.includes('-')) {\n        const [startStr, endStr] = rangeOrStar.split('-');\n        const start = parseInt(startStr, 10);\n        const end = parseInt(endStr, 10);\n        return value >= start && value <= end && (value - start) % step === 0;\n      }\n    }\n\n    // Handle list (1,3,5)\n    if (expr.includes(',')) {\n      const values = expr.split(',').map((v) => {\n        // Handle ranges within lists\n        if (v.includes('-')) {\n          const [start, end] = v.split('-').map((n) => parseInt(n, 10));\n          const rangeValues: number[] = [];\n          for (let i = start; i <= end; i++) {\n            rangeValues.push(i);\n          }\n          return rangeValues;\n        }\n        return [parseInt(v, 10)];\n      }).flat();\n\n      return values.includes(value);\n    }\n\n    // Handle range (1-5)\n    if (expr.includes('-')) {\n      const [start, end] = expr.split('-').map((v) => parseInt(v, 10));\n      return value >= start && value <= end;\n    }\n\n    // Handle specific value\n    const specificValue = parseInt(expr, 10);\n    if (isNaN(specificValue)) {\n      throw new Error(`Invalid cron field value: ${expr}`);\n    }\n    return value === specificValue;\n  }\n}\n\n// ============= SINGLETON EXPORT =============\n\n/**\n * Singleton instance of FlowSchedulerService\n * Use this throughout the application for flow scheduling\n */\nexport const flowSchedulerService = new FlowSchedulerService();\n",
        "last_modified": "2026-01-02T17:55:06.519041"
      },
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:47.005163",
  "last_updated": "2026-01-02T15:21:47.017486"
}