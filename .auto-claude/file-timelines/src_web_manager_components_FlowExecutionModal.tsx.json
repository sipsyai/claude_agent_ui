{
  "file_path": "src/web/manager/components/FlowExecutionModal.tsx",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": {
        "content": "import React, { useState, useEffect, useRef } from 'react';\nimport type {\n  Flow,\n  FlowInputField,\n  FlowExecution,\n  FlowExecutionStatus,\n  InputNode,\n  isInputNode,\n} from '../types';\nimport * as flowApi from '../services/flow-api';\nimport type { FlowExecutionEvent } from '../services/flow-api';\nimport { Button } from './ui/Button';\nimport { Input } from './ui/Input';\nimport { Select } from './ui/Select';\nimport { Textarea } from './ui/Textarea';\nimport {\n  XCircleIcon,\n  PlayCircleIcon,\n  CheckCircleIcon,\n  SpinnerIcon,\n  ClockIcon,\n} from './ui/Icons';\n\ninterface FlowExecutionModalProps {\n  flow: Flow;\n  isOpen: boolean;\n  onClose: () => void;\n  onExecutionComplete?: (execution: FlowExecution) => void;\n}\n\ninterface ExecutionMessage {\n  id: string;\n  type: 'status' | 'info' | 'node_started' | 'node_completed' | 'node_failed' | 'result' | 'error' | 'log';\n  content: string;\n  timestamp: Date;\n  nodeId?: string;\n  nodeType?: string;\n  data?: Record<string, any>;\n}\n\n/**\n * Get input fields from flow's input node\n */\nfunction getInputFields(flow: Flow): FlowInputField[] {\n  const inputNode = flow.nodes?.find((node) => node.type === 'input') as InputNode | undefined;\n  return inputNode?.inputFields || [];\n}\n\n/**\n * Modal for executing a flow with dynamic input form and real-time execution status\n */\nconst FlowExecutionModal: React.FC<FlowExecutionModalProps> = ({\n  flow,\n  isOpen,\n  onClose,\n  onExecutionComplete,\n}) => {\n  const [inputValues, setInputValues] = useState<Record<string, any>>({});\n  const [messages, setMessages] = useState<ExecutionMessage[]>([]);\n  const [isExecuting, setIsExecuting] = useState(false);\n  const [executionStatus, setExecutionStatus] = useState<FlowExecutionStatus | 'idle'>('idle');\n  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});\n  const [executionResult, setExecutionResult] = useState<Record<string, any> | null>(null);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  const inputFields = getInputFields(flow);\n\n  // Initialize default values\n  useEffect(() => {\n    const defaults: Record<string, any> = {};\n    inputFields.forEach((field) => {\n      if (field.defaultValue !== undefined) {\n        defaults[field.name] = field.defaultValue;\n      } else if (field.type === 'checkbox') {\n        defaults[field.name] = false;\n      } else if (field.type === 'multiselect') {\n        defaults[field.name] = [];\n      }\n    });\n    setInputValues(defaults);\n  }, [flow.id]);\n\n  // Scroll to bottom when new messages arrive\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  // Reset state when modal opens\n  useEffect(() => {\n    if (isOpen) {\n      setMessages([]);\n      setExecutionStatus('idle');\n      setExecutionResult(null);\n      setValidationErrors({});\n    }\n  }, [isOpen]);\n\n  // Validate inputs\n  const validateInputs = (): boolean => {\n    const errors: Record<string, string> = {};\n\n    inputFields.forEach((field) => {\n      const value = inputValues[field.name];\n\n      // Check required\n      if (field.required) {\n        if (value === undefined || value === null || value === '') {\n          errors[field.name] = `${field.label} is required`;\n          return;\n        }\n      }\n\n      // Skip further validation if empty and not required\n      if (value === undefined || value === null || value === '') {\n        return;\n      }\n\n      // Type-specific validation\n      switch (field.type) {\n        case 'email':\n          if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n            errors[field.name] = 'Invalid email format';\n          }\n          break;\n        case 'url':\n          try {\n            new URL(value);\n          } catch {\n            errors[field.name] = 'Invalid URL format';\n          }\n          break;\n        case 'number':\n          const num = parseFloat(value);\n          if (isNaN(num)) {\n            errors[field.name] = 'Must be a valid number';\n          } else {\n            if (field.min !== undefined && num < field.min) {\n              errors[field.name] = `Must be at least ${field.min}`;\n            }\n            if (field.max !== undefined && num > field.max) {\n              errors[field.name] = `Must be at most ${field.max}`;\n            }\n          }\n          break;\n        case 'text':\n        case 'textarea':\n          if (field.min !== undefined && value.length < field.min) {\n            errors[field.name] = `Must be at least ${field.min} characters`;\n          }\n          if (field.max !== undefined && value.length > field.max) {\n            errors[field.name] = `Must be at most ${field.max} characters`;\n          }\n          break;\n      }\n\n      // Pattern validation\n      if (field.pattern && typeof value === 'string') {\n        try {\n          const regex = new RegExp(field.pattern);\n          if (!regex.test(value)) {\n            errors[field.name] = `Invalid format`;\n          }\n        } catch {\n          // Invalid regex pattern, skip validation\n        }\n      }\n    });\n\n    setValidationErrors(errors);\n    return Object.keys(errors).length === 0;\n  };\n\n  // Handle input change\n  const handleInputChange = (name: string, value: any) => {\n    setInputValues((prev) => ({ ...prev, [name]: value }));\n    // Clear validation error when user types\n    if (validationErrors[name]) {\n      setValidationErrors((prev) => {\n        const next = { ...prev };\n        delete next[name];\n        return next;\n      });\n    }\n  };\n\n  // Handle execution\n  const handleExecute = async () => {\n    if (!validateInputs()) {\n      return;\n    }\n\n    setIsExecuting(true);\n    setMessages([]);\n    setExecutionStatus('pending');\n    setExecutionResult(null);\n\n    // Add initial status message\n    addMessage('status', `Starting flow: ${flow.name}`);\n\n    try {\n      await flowApi.executeFlow(\n        flow.id,\n        { input: inputValues },\n        (event: FlowExecutionEvent) => {\n          handleExecutionEvent(event);\n        }\n      );\n    } catch (error) {\n      addMessage('error', error instanceof Error ? error.message : 'Execution failed');\n      setExecutionStatus('failed');\n    } finally {\n      setIsExecuting(false);\n    }\n  };\n\n  // Add message helper\n  const addMessage = (\n    type: ExecutionMessage['type'],\n    content: string,\n    extra?: Partial<ExecutionMessage>\n  ) => {\n    setMessages((prev) => [\n      ...prev,\n      {\n        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        type,\n        content,\n        timestamp: new Date(),\n        ...extra,\n      },\n    ]);\n  };\n\n  // Handle SSE execution events\n  const handleExecutionEvent = (event: FlowExecutionEvent) => {\n    const timestamp = event.timestamp ? new Date(event.timestamp) : new Date();\n\n    switch (event.type) {\n      case 'status':\n        setExecutionStatus(event.status as FlowExecutionStatus || 'running');\n        addMessage('status', event.message || `Status: ${event.status}`, {\n          timestamp,\n          data: event.data,\n        });\n        break;\n\n      case 'node_started':\n        addMessage('node_started', `Started: ${event.nodeId || 'node'}`, {\n          timestamp,\n          nodeId: event.nodeId,\n          nodeType: event.nodeType,\n        });\n        break;\n\n      case 'node_completed':\n        addMessage('node_completed', `Completed: ${event.nodeId || 'node'}`, {\n          timestamp,\n          nodeId: event.nodeId,\n          nodeType: event.nodeType,\n          data: event.data,\n        });\n        break;\n\n      case 'node_failed':\n        addMessage('node_failed', `Failed: ${event.nodeId || 'node'} - ${event.error || 'Unknown error'}`, {\n          timestamp,\n          nodeId: event.nodeId,\n          nodeType: event.nodeType,\n          data: event.data,\n        });\n        break;\n\n      case 'log':\n        addMessage('log', event.message || 'Log', {\n          timestamp,\n          data: event.data,\n        });\n        break;\n\n      case 'result':\n        setExecutionStatus(event.result?.status || 'completed');\n        setExecutionResult(event.result?.output || null);\n\n        if (event.result?.success) {\n          addMessage('result', 'Flow execution completed successfully', {\n            timestamp,\n            data: {\n              executionTime: event.result.executionTime,\n              tokensUsed: event.result.tokensUsed,\n              cost: event.result.cost,\n            },\n          });\n        } else {\n          addMessage('error', event.result?.error || 'Execution failed', {\n            timestamp,\n          });\n        }\n\n        if (onExecutionComplete && event.result) {\n          onExecutionComplete({\n            id: event.result.executionId,\n            flowId: flow.id,\n            status: event.result.status,\n            output: event.result.output,\n            executionTime: event.result.executionTime,\n            tokensUsed: event.result.tokensUsed || 0,\n            cost: event.result.cost || 0,\n            triggeredBy: 'manual',\n            logs: [],\n            nodeExecutions: (event.result.nodeExecutions || []) as import('../types').NodeExecution[],\n            retryCount: 0,\n          });\n        }\n        break;\n\n      case 'error':\n        setExecutionStatus('failed');\n        addMessage('error', event.error || event.message || 'Unknown error', {\n          timestamp,\n        });\n        break;\n\n      default:\n        // Handle unknown event types\n        if (event.message) {\n          addMessage('info', event.message, { timestamp, data: event.data });\n        }\n    }\n  };\n\n  // Render input field based on type\n  const renderInputField = (field: FlowInputField) => {\n    const value = inputValues[field.name] ?? '';\n    const error = validationErrors[field.name];\n\n    const commonProps = {\n      id: field.name,\n      disabled: isExecuting,\n      className: error ? 'border-red-500' : '',\n    };\n\n    switch (field.type) {\n      case 'textarea':\n        return (\n          <Textarea\n            {...commonProps}\n            value={value}\n            onChange={(e) => handleInputChange(field.name, e.target.value)}\n            placeholder={field.placeholder}\n            className={`min-h-[100px] ${error ? 'border-red-500' : ''}`}\n          />\n        );\n\n      case 'select':\n        return (\n          <Select\n            {...commonProps}\n            value={value}\n            onChange={(e) => handleInputChange(field.name, e.target.value)}\n          >\n            <option value=\"\">Select {field.label}...</option>\n            {(field.options || []).map((opt) => (\n              <option key={opt} value={opt}>\n                {opt}\n              </option>\n            ))}\n          </Select>\n        );\n\n      case 'multiselect':\n        return (\n          <div className=\"space-y-1\">\n            {(field.options || []).map((opt) => (\n              <label key={opt} className=\"flex items-center gap-2 cursor-pointer\">\n                <input\n                  type=\"checkbox\"\n                  checked={(value || []).includes(opt)}\n                  onChange={(e) => {\n                    const current = value || [];\n                    const next = e.target.checked\n                      ? [...current, opt]\n                      : current.filter((v: string) => v !== opt);\n                    handleInputChange(field.name, next);\n                  }}\n                  disabled={isExecuting}\n                  className=\"w-4 h-4 rounded\"\n                />\n                <span className=\"text-sm\">{opt}</span>\n              </label>\n            ))}\n          </div>\n        );\n\n      case 'checkbox':\n        return (\n          <label className=\"flex items-center gap-2 cursor-pointer\">\n            <input\n              type=\"checkbox\"\n              checked={!!value}\n              onChange={(e) => handleInputChange(field.name, e.target.checked)}\n              disabled={isExecuting}\n              className=\"w-4 h-4 rounded\"\n            />\n            <span className=\"text-sm\">{field.description || field.label}</span>\n          </label>\n        );\n\n      case 'number':\n        return (\n          <Input\n            {...commonProps}\n            type=\"number\"\n            value={value}\n            onChange={(e) => handleInputChange(field.name, e.target.value)}\n            placeholder={field.placeholder}\n            min={field.min}\n            max={field.max}\n          />\n        );\n\n      case 'date':\n        return (\n          <Input\n            {...commonProps}\n            type=\"date\"\n            value={value}\n            onChange={(e) => handleInputChange(field.name, e.target.value)}\n          />\n        );\n\n      case 'datetime':\n        return (\n          <Input\n            {...commonProps}\n            type=\"datetime-local\"\n            value={value}\n            onChange={(e) => handleInputChange(field.name, e.target.value)}\n          />\n        );\n\n      case 'email':\n        return (\n          <Input\n            {...commonProps}\n            type=\"email\"\n            value={value}\n            onChange={(e) => handleInputChange(field.name, e.target.value)}\n            placeholder={field.placeholder || 'email@example.com'}\n          />\n        );\n\n      case 'url':\n        return (\n          <Input\n            {...commonProps}\n            type=\"url\"\n            value={value}\n            onChange={(e) => handleInputChange(field.name, e.target.value)}\n            placeholder={field.placeholder || 'https://example.com'}\n          />\n        );\n\n      case 'file':\n        return (\n          <Input\n            {...commonProps}\n            type=\"file\"\n            onChange={(e) => {\n              const file = e.target.files?.[0];\n              if (file) {\n                // For now, just store the file name\n                // In a real implementation, you'd upload the file\n                handleInputChange(field.name, file.name);\n              }\n            }}\n          />\n        );\n\n      case 'text':\n      default:\n        return (\n          <Input\n            {...commonProps}\n            type=\"text\"\n            value={value}\n            onChange={(e) => handleInputChange(field.name, e.target.value)}\n            placeholder={field.placeholder}\n          />\n        );\n    }\n  };\n\n  // Get status icon\n  const getStatusIcon = () => {\n    switch (executionStatus) {\n      case 'running':\n      case 'pending':\n        return <SpinnerIcon className=\"h-5 w-5 text-blue-500\" />;\n      case 'completed':\n        return <CheckCircleIcon className=\"h-5 w-5 text-green-500\" />;\n      case 'failed':\n        return <XCircleIcon className=\"h-5 w-5 text-red-500\" />;\n      case 'cancelled':\n        return <XCircleIcon className=\"h-5 w-5 text-gray-500\" />;\n      default:\n        return <ClockIcon className=\"h-5 w-5 text-gray-400\" />;\n    }\n  };\n\n  // Get message styles\n  const getMessageStyles = (type: ExecutionMessage['type']): string => {\n    switch (type) {\n      case 'error':\n        return 'bg-red-500/10 border-red-500/20 text-red-700 dark:text-red-300';\n      case 'node_failed':\n        return 'bg-red-500/10 border-red-500/20 text-red-600 dark:text-red-400';\n      case 'result':\n        return 'bg-green-500/10 border-green-500/20 text-green-700 dark:text-green-300';\n      case 'node_completed':\n        return 'bg-green-500/10 border-green-500/20 text-green-600 dark:text-green-400';\n      case 'node_started':\n        return 'bg-blue-500/10 border-blue-500/20 text-blue-600 dark:text-blue-400';\n      case 'status':\n        return 'bg-blue-500/10 border-blue-500/20 text-blue-700 dark:text-blue-300';\n      case 'log':\n        return 'bg-gray-500/10 border-gray-500/20';\n      default:\n        return 'bg-secondary border-border';\n    }\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50\">\n      <div className=\"bg-background border border-border rounded-lg shadow-lg w-full max-w-4xl max-h-[90vh] flex flex-col\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between p-4 border-b border-border\">\n          <div className=\"flex items-center gap-3\">\n            <div>\n              <h2 className=\"text-xl font-bold flex items-center gap-2\">\n                <span className=\"text-primary\">\u26a1</span>\n                Run Flow: {flow.name}\n              </h2>\n              <p className=\"text-sm text-muted-foreground\">\n                {flow.description || 'Execute this workflow with custom inputs'}\n              </p>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-3\">\n            {executionStatus !== 'idle' && (\n              <div className=\"flex items-center gap-2\">\n                {getStatusIcon()}\n                <span className=\"text-sm font-medium capitalize\">{executionStatus}</span>\n              </div>\n            )}\n            <button\n              onClick={onClose}\n              className=\"text-muted-foreground hover:text-foreground\"\n              disabled={isExecuting}\n            >\n              <XCircleIcon className=\"h-6 w-6\" />\n            </button>\n          </div>\n        </div>\n\n        {/* Content - Split into input form and execution log */}\n        <div className=\"flex-1 overflow-hidden flex\">\n          {/* Input Form Panel */}\n          <div className=\"w-1/2 border-r border-border p-4 overflow-y-auto\">\n            <h3 className=\"font-semibold mb-4 text-sm uppercase tracking-wide text-muted-foreground\">\n              Input Parameters\n            </h3>\n\n            {inputFields.length === 0 ? (\n              <div className=\"text-center py-8 bg-secondary/30 rounded-lg text-muted-foreground\">\n                <p>This flow has no input parameters.</p>\n                <p className=\"text-sm mt-2\">Click \"Run Flow\" to execute directly.</p>\n              </div>\n            ) : (\n              <div className=\"space-y-4\">\n                {inputFields.map((field) => (\n                  <div key={field.name}>\n                    <label\n                      htmlFor={field.name}\n                      className=\"block text-sm font-medium mb-1\"\n                    >\n                      {field.label}\n                      {field.required && <span className=\"text-red-500 ml-1\">*</span>}\n                    </label>\n                    {field.description && (\n                      <p className=\"text-xs text-muted-foreground mb-1\">\n                        {field.description}\n                      </p>\n                    )}\n                    {renderInputField(field)}\n                    {validationErrors[field.name] && (\n                      <p className=\"text-xs text-red-500 mt-1\">\n                        {validationErrors[field.name]}\n                      </p>\n                    )}\n                  </div>\n                ))}\n              </div>\n            )}\n\n            {/* Execute Button */}\n            <div className=\"mt-6 pt-4 border-t border-border\">\n              <Button\n                onClick={handleExecute}\n                disabled={isExecuting || !flow.isActive}\n                className=\"w-full flex items-center justify-center gap-2\"\n              >\n                {isExecuting ? (\n                  <>\n                    <SpinnerIcon className=\"h-5 w-5\" />\n                    Running...\n                  </>\n                ) : (\n                  <>\n                    <PlayCircleIcon className=\"h-5 w-5\" />\n                    Run Flow\n                  </>\n                )}\n              </Button>\n              {!flow.isActive && (\n                <p className=\"text-xs text-yellow-600 mt-2 text-center\">\n                  This flow is not active. Activate it first to execute.\n                </p>\n              )}\n            </div>\n          </div>\n\n          {/* Execution Log Panel */}\n          <div className=\"w-1/2 p-4 overflow-y-auto bg-secondary/20\">\n            <h3 className=\"font-semibold mb-4 text-sm uppercase tracking-wide text-muted-foreground\">\n              Execution Log\n            </h3>\n\n            {messages.length === 0 ? (\n              <div className=\"text-center py-12 text-muted-foreground\">\n                <ClockIcon className=\"h-12 w-12 mx-auto mb-4 opacity-50\" />\n                <p>Execution log will appear here</p>\n                <p className=\"text-sm mt-1\">Fill in the inputs and click \"Run Flow\"</p>\n              </div>\n            ) : (\n              <div className=\"space-y-2\">\n                {messages.map((message) => (\n                  <div\n                    key={message.id}\n                    className={`p-3 rounded-lg border ${getMessageStyles(message.type)}`}\n                  >\n                    <div className=\"flex items-start justify-between mb-1\">\n                      <span className=\"text-xs font-semibold uppercase tracking-wide\">\n                        {message.type.replace('_', ' ')}\n                        {message.nodeId && (\n                          <span className=\"ml-2 text-muted-foreground font-normal\">\n                            ({message.nodeId})\n                          </span>\n                        )}\n                      </span>\n                      <span className=\"text-xs text-muted-foreground\">\n                        {message.timestamp.toLocaleTimeString()}\n                      </span>\n                    </div>\n                    <div className=\"text-sm\">{message.content}</div>\n                    {message.data && Object.keys(message.data).length > 0 && (\n                      <details className=\"mt-2\">\n                        <summary className=\"text-xs text-muted-foreground cursor-pointer hover:text-foreground\">\n                          View details\n                        </summary>\n                        <pre className=\"mt-2 text-xs bg-black/10 p-2 rounded overflow-x-auto\">\n                          {JSON.stringify(message.data, null, 2)}\n                        </pre>\n                      </details>\n                    )}\n                  </div>\n                ))}\n                <div ref={messagesEndRef} />\n              </div>\n            )}\n\n            {/* Result Display */}\n            {executionResult && (\n              <div className=\"mt-4 p-4 bg-green-500/10 border border-green-500/20 rounded-lg\">\n                <h4 className=\"font-semibold text-green-700 dark:text-green-300 mb-2\">\n                  Execution Result\n                </h4>\n                <pre className=\"text-sm bg-black/10 p-3 rounded overflow-x-auto\">\n                  {typeof executionResult === 'string'\n                    ? executionResult\n                    : JSON.stringify(executionResult, null, 2)}\n                </pre>\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"p-4 border-t border-border flex justify-end gap-2\">\n          <Button variant=\"secondary\" onClick={onClose} disabled={isExecuting}>\n            {isExecuting ? 'Running...' : 'Close'}\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default FlowExecutionModal;\n",
        "last_modified": "2026-01-02T17:55:06.527578"
      },
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:47.102477",
  "last_updated": "2026-01-02T15:21:47.113417"
}