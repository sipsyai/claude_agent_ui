{
  "file_path": "src/services/claude-structure-parser.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport { createLogger, type Logger } from './logger.js';\n\n/**\n * Represents a parsed slash command from .claude/commands/\n */\nexport interface SlashCommand {\n  id: string;\n  name: string;\n  description?: string;\n  path: string;\n  relativePath: string;\n  content: string;\n  metadata?: {\n    allowedTools?: string[];\n    argumentHint?: string;\n    model?: string;\n    disableModelInvocation?: boolean;\n  };\n  category?: string; // Extracted from subdirectory structure\n}\n\n/**\n * Training record for skill execution analysis\n */\nexport interface TrainingRecord {\n  date: string;\n  scoreBefore: number;\n  scoreAfter: number;\n  issuesFound: string[];\n  correctionsMade: boolean;\n  executionSuccess: boolean;\n}\n\n/**\n * Represents a parsed skill from .claude/skills/\n */\nexport interface Skill {\n  id: string;\n  name: string;\n  description: string;\n  path: string;\n  skillMdPath: string;\n  content: string;\n  metadata?: {\n    allowedTools?: string[];\n    mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n    inputFields?: InputField[]; // Input parameters for skill execution\n  };\n  supportingFiles?: {\n    reference?: string;\n    examples?: string;\n    scripts?: string[];\n    templates?: string[];\n  };\n  usedInAgents?: string[]; // List of agent IDs that use this skill\n  usageCount?: number; // Number of agents using this skill\n  experienceScore?: number; // 0-100 skill proficiency score\n  trainingHistory?: TrainingRecord[]; // History of training sessions\n}\n\n/**\n * Input field definition for agent and skill execution\n */\nexport interface InputField {\n  name: string;\n  type: 'text' | 'textarea' | 'dropdown' | 'multiselect' | 'checkbox' | 'number' | 'filepath';\n  label: string;\n  description?: string;\n  placeholder?: string;\n  required?: boolean;\n  options?: string[]; // For dropdown and multiselect\n  default?: any;\n}\n\n/**\n * Represents a parsed agent from .claude/agents/\n */\nexport interface Agent {\n  id: string;\n  name: string;\n  description: string;\n  path: string;\n  content: string;\n  metadata?: {\n    tools?: string[];\n    allowedTools?: string[];\n    model?: string;\n    inputFields?: InputField[];\n    outputSchema?: string | object;\n    mcpTools?: Record<string, string[]>;\n    skills?: string[]; // List of skill IDs that this agent can use\n  };\n}\n\n/**\n * Service for parsing Claude Code's .claude folder structure\n * Extracts slash commands and skills from the project\n */\nexport class ClaudeStructureParser {\n  private logger: Logger;\n\n  constructor() {\n    this.logger = createLogger('ClaudeStructureParser');\n  }\n\n  /**\n   * Parse all slash commands from .claude/commands/\n   */\n  async parseSlashCommands(projectPath: string): Promise<SlashCommand[]> {\n    const commandsDir = path.join(projectPath, '.claude', 'commands');\n\n    try {\n      await fs.access(commandsDir);\n    } catch {\n      this.logger.debug('No .claude/commands directory found', { projectPath });\n      return [];\n    }\n\n    const commands: SlashCommand[] = [];\n    await this.scanCommandsRecursive(commandsDir, commandsDir, commands);\n\n    this.logger.info('Parsed slash commands', {\n      projectPath,\n      count: commands.length,\n      commands: commands.map(c => c.name)\n    });\n\n    return commands;\n  }\n\n  /**\n   * Recursively scan commands directory\n   */\n  private async scanCommandsRecursive(\n    currentDir: string,\n    rootDir: string,\n    commands: SlashCommand[]\n  ): Promise<void> {\n    const entries = await fs.readdir(currentDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(currentDir, entry.name);\n\n      if (entry.isDirectory()) {\n        // Recurse into subdirectories\n        await this.scanCommandsRecursive(fullPath, rootDir, commands);\n      } else if (entry.isFile() && entry.name.endsWith('.md')) {\n        const command = await this.parseCommandFile(fullPath, rootDir);\n        if (command) {\n          commands.push(command);\n        }\n      }\n    }\n  }\n\n  /**\n   * Parse a single slash command file\n   */\n  private async parseCommandFile(\n    filePath: string,\n    rootDir: string\n  ): Promise<SlashCommand | null> {\n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      const relativePath = path.relative(rootDir, filePath);\n      const commandName = path.basename(filePath, '.md');\n\n      // Extract category from subdirectory (if any)\n      const dirPath = path.dirname(relativePath);\n      const category = dirPath === '.' ? undefined : dirPath;\n\n      // Parse frontmatter\n      const { metadata, bodyContent } = this.parseFrontmatter(content);\n\n      // Parse allowed-tools (handle both array and comma-separated string formats)\n      const parseToolsField = (toolsValue: unknown): string[] | undefined => {\n        if (!toolsValue) return undefined;\n        if (Array.isArray(toolsValue)) return toolsValue;\n        if (typeof toolsValue === 'string') {\n          return toolsValue.split(',').map(t => t.trim()).filter(t => t.length > 0);\n        }\n        return undefined;\n      };\n\n      return {\n        id: relativePath.replace(/\\\\/g, '/').replace('.md', ''),\n        name: commandName,\n        description: metadata.description as string | undefined,\n        path: filePath,\n        relativePath: relativePath.replace(/\\\\/g, '/'),\n        content: bodyContent,\n        metadata: {\n          allowedTools: parseToolsField(metadata['allowed-tools']),\n          argumentHint: metadata['argument-hint'] as string | undefined,\n          model: metadata.model as string | undefined,\n          disableModelInvocation: metadata['disable-model-invocation'] as boolean | undefined,\n        },\n        category,\n      };\n    } catch (error) {\n      this.logger.error('Failed to parse command file', error, { filePath });\n      return null;\n    }\n  }\n\n  /**\n   * Parse all skills from .claude/skills/\n   */\n  async parseSkills(projectPath: string): Promise<Skill[]> {\n    const skillsDir = path.join(projectPath, '.claude', 'skills');\n\n    try {\n      await fs.access(skillsDir);\n    } catch {\n      this.logger.debug('No .claude/skills directory found', { projectPath });\n      return [];\n    }\n\n    const skills: Skill[] = [];\n    const entries = await fs.readdir(skillsDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        const skillPath = path.join(skillsDir, entry.name);\n        const skill = await this.parseSkill(skillPath, entry.name);\n        if (skill) {\n          skills.push(skill);\n        }\n      }\n    }\n\n    this.logger.info('Parsed skills', {\n      projectPath,\n      count: skills.length,\n      skills: skills.map(s => s.name)\n    });\n\n    return skills;\n  }\n\n  /**\n   * Parse a specific skill directory by name (for forced execution)\n   * Use this when you want to load ONLY one skill, not all skills.\n   *\n   * @param projectPath - Project root directory\n   * @param skillName - Name of the skill to parse\n   * @returns Parsed skill or null if not found\n   */\n  async parseSpecificSkill(projectPath: string, skillName: string): Promise<Skill | null> {\n    const skillPath = path.join(projectPath, '.claude', 'skills', skillName);\n\n    try {\n      await fs.access(skillPath);\n    } catch {\n      this.logger.warn('Skill directory not found', { skillPath, skillName });\n      return null;\n    }\n\n    const skill = await this.parseSkill(skillPath, skillName);\n\n    if (skill) {\n      this.logger.info('Parsed specific skill', {\n        projectPath,\n        skillName,\n        skillId: skill.id\n      });\n    }\n\n    return skill;\n  }\n\n  /**\n   * Parse a single skill directory\n   */\n  private async parseSkill(skillPath: string, skillName: string): Promise<Skill | null> {\n    const skillMdPath = path.join(skillPath, 'SKILL.md');\n\n    try {\n      await fs.access(skillMdPath);\n    } catch {\n      this.logger.warn('Skill directory missing SKILL.md', { skillPath });\n      return null;\n    }\n\n    try {\n      const content = await fs.readFile(skillMdPath, 'utf-8');\n      const { metadata, bodyContent } = this.parseFrontmatter(content);\n\n      // Parse allowed-tools (handle both array and comma-separated string formats)\n      const parseToolsField = (toolsValue: unknown): string[] | undefined => {\n        if (!toolsValue) return undefined;\n        if (Array.isArray(toolsValue)) return toolsValue;\n        if (typeof toolsValue === 'string') {\n          return toolsValue.split(',').map(t => t.trim()).filter(t => t.length > 0);\n        }\n        return undefined;\n      };\n\n      // Parse skill.config.json for input fields\n      let inputFields: InputField[] | undefined;\n      const configPath = path.join(skillPath, 'skill.config.json');\n      try {\n        await fs.access(configPath);\n        const configContent = await fs.readFile(configPath, 'utf-8');\n        const configData = JSON.parse(configContent);\n\n        if (configData.inputs && Array.isArray(configData.inputs)) {\n          inputFields = configData.inputs.map((field: any) => ({\n            name: field.name,\n            type: field.type || 'text',\n            label: field.label || field.name,\n            description: field.description,\n            placeholder: field.placeholder,\n            required: field.required === true,\n            options: field.options,\n            default: field.default,\n          }));\n          if (inputFields && inputFields.length > 0) {\n            this.logger.debug(`Parsed ${inputFields.length} input fields for skill ${skillName}`);\n          }\n        }\n      } catch (error) {\n        // skill.config.json is optional, so no error if it doesn't exist\n        this.logger.debug('No skill.config.json found or failed to parse', { skillPath });\n      }\n\n      // Scan for supporting files\n      const supportingFiles = await this.scanSupportingFiles(skillPath);\n\n      // Parse experience score and training history\n      const experienceScore = typeof metadata.experience_score === 'number'\n        ? metadata.experience_score\n        : 0;\n\n      const trainingHistory = Array.isArray(metadata.training_history)\n        ? (metadata.training_history as TrainingRecord[])\n        : undefined;\n\n      return {\n        id: skillName,\n        name: metadata.name as string || skillName,\n        description: metadata.description as string || 'No description',\n        path: skillPath,\n        skillMdPath,\n        content: bodyContent,\n        metadata: {\n          allowedTools: parseToolsField(metadata['allowed-tools']),\n          mcpTools: metadata['mcp_tools'] as Record<string, string[]> | undefined,\n          inputFields,\n        },\n        supportingFiles,\n        experienceScore,\n        trainingHistory,\n      };\n    } catch (error) {\n      this.logger.error('Failed to parse skill', error, { skillPath });\n      return null;\n    }\n  }\n\n  /**\n   * Scan for supporting files in skill directory\n   */\n  private async scanSupportingFiles(skillPath: string): Promise<Skill['supportingFiles']> {\n    const supportingFiles: Skill['supportingFiles'] = {};\n\n    // Check for reference.md\n    const referencePath = path.join(skillPath, 'reference.md');\n    try {\n      await fs.access(referencePath);\n      supportingFiles.reference = await fs.readFile(referencePath, 'utf-8');\n    } catch {}\n\n    // Check for examples.md\n    const examplesPath = path.join(skillPath, 'examples.md');\n    try {\n      await fs.access(examplesPath);\n      supportingFiles.examples = await fs.readFile(examplesPath, 'utf-8');\n    } catch {}\n\n    // Check for scripts directory\n    const scriptsDir = path.join(skillPath, 'scripts');\n    try {\n      const scriptFiles = await fs.readdir(scriptsDir);\n      supportingFiles.scripts = scriptFiles;\n    } catch {}\n\n    // Check for templates directory\n    const templatesDir = path.join(skillPath, 'templates');\n    try {\n      const templateFiles = await fs.readdir(templatesDir);\n      supportingFiles.templates = templateFiles;\n    } catch {}\n\n    return supportingFiles;\n  }\n\n  /**\n   * Parse YAML frontmatter from markdown content\n   * Returns metadata object and body content separately\n   */\n  private parseFrontmatter(content: string): {\n    metadata: Record<string, unknown>;\n    bodyContent: string;\n  } {\n    const frontmatterRegex = /^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n([\\s\\S]*)$/;\n    const match = content.match(frontmatterRegex);\n\n    if (!match) {\n      return { metadata: {}, bodyContent: content };\n    }\n\n    const [, frontmatterText, bodyContent] = match;\n\n    try {\n      // Use js-yaml for proper YAML parsing (handles nested objects, arrays, etc.)\n      const metadata = yaml.load(frontmatterText) as Record<string, unknown> || {};\n      return { metadata, bodyContent: bodyContent.trim() };\n    } catch (error) {\n      this.logger.error('Failed to parse YAML frontmatter', error);\n      return { metadata: {}, bodyContent: bodyContent.trim() };\n    }\n  }\n\n  /**\n   * Parse all agents from .claude/agents/\n   */\n  async parseAgents(projectPath: string): Promise<Agent[]> {\n    const agentsDir = path.join(projectPath, '.claude', 'agents');\n\n    try {\n      await fs.access(agentsDir);\n    } catch {\n      this.logger.debug('No .claude/agents directory found', { projectPath });\n      return [];\n    }\n\n    const agents: Agent[] = [];\n    const entries = await fs.readdir(agentsDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (entry.isFile() && entry.name.endsWith('.md') && entry.name !== 'README.md') {\n        const agentPath = path.join(agentsDir, entry.name);\n        const agent = await this.parseAgent(agentPath, entry.name);\n        if (agent) {\n          agents.push(agent);\n        }\n      }\n    }\n\n    this.logger.info('Parsed agents', {\n      projectPath,\n      count: agents.length,\n      agents: agents.map(a => a.name)\n    });\n\n    return agents;\n  }\n\n  /**\n   * Parse a single agent file\n   */\n  private async parseAgent(agentPath: string, fileName: string): Promise<Agent | null> {\n    try {\n      const content = await fs.readFile(agentPath, 'utf-8');\n      const { metadata, bodyContent } = this.parseFrontmatter(content);\n\n      const agentId = fileName.replace('.md', '');\n\n      // Parse input fields\n      let inputFields: InputField[] | undefined;\n      const inputFieldsData = metadata.input_fields || metadata['input-fields'];\n\n      if (inputFieldsData && Array.isArray(inputFieldsData)) {\n        inputFields = inputFieldsData.map((field: any) => ({\n          name: field.name,\n          type: field.type || 'text',\n          label: field.label || field.name,\n          placeholder: field.placeholder,\n          required: field.required === true,\n          options: field.options,\n          default: field.default,\n        }));\n        console.log(`Parsed ${inputFields.length} input fields for agent ${fileName}:`, JSON.stringify(inputFields, null, 2));\n      }\n\n      // Parse tools (handle both array and comma-separated string formats)\n      const parseToolsField = (toolsValue: unknown): string[] | undefined => {\n        if (!toolsValue) return undefined;\n        if (Array.isArray(toolsValue)) return toolsValue;\n        if (typeof toolsValue === 'string') {\n          // Handle comma-separated format: \"Tool1,Tool2,Tool3\"\n          return toolsValue.split(',').map(t => t.trim()).filter(t => t.length > 0);\n        }\n        return undefined;\n      };\n\n      const tools = parseToolsField(metadata.tools);\n      const allowedTools = parseToolsField(metadata['allowed-tools']);\n\n      // Parse MCP tools (nested object with server IDs as keys)\n      let mcpTools: Record<string, string[]> | undefined;\n      const mcpToolsData = metadata.mcp_tools || metadata['mcp-tools'];\n      if (mcpToolsData && typeof mcpToolsData === 'object' && !Array.isArray(mcpToolsData)) {\n        mcpTools = {};\n        Object.entries(mcpToolsData).forEach(([serverId, toolsValue]) => {\n          if (Array.isArray(toolsValue) && toolsValue.length > 0) {\n            mcpTools![serverId] = toolsValue;\n          }\n        });\n        // Only keep mcpTools if it has entries\n        if (Object.keys(mcpTools).length === 0) {\n          mcpTools = undefined;\n        }\n      }\n\n      // Parse output schema\n      let outputSchema: string | object | undefined = (metadata.output_schema || metadata['output-schema']) as string | object | undefined;\n\n      if (typeof outputSchema === 'string') {\n        try {\n          outputSchema = JSON.parse(outputSchema);\n        } catch {\n          // Keep as string if not valid JSON\n        }\n      }\n\n      // Parse skills (handle both array and comma-separated string formats)\n      const skills = parseToolsField(metadata.skills);\n\n      return {\n        id: agentId,\n        name: metadata.name as string || agentId,\n        description: metadata.description as string || 'No description',\n        path: agentPath,\n        content: bodyContent,\n        metadata: {\n          tools,\n          allowedTools,\n          model: metadata.model as string | undefined,\n          inputFields,\n          outputSchema,\n          mcpTools,\n          skills,\n        },\n      };\n    } catch (error) {\n      this.logger.error('Failed to parse agent', error, { agentPath });\n      return null;\n    }\n  }\n\n  /**\n   * Get full structure analysis for a project\n   */\n  async analyzeProject(projectPath: string): Promise<{\n    commands: SlashCommand[];\n    skills: Skill[];\n    agents: Agent[];\n    hasClaudeFolder: boolean;\n  }> {\n    const claudePath = path.join(projectPath, '.claude');\n\n    let hasClaudeFolder = false;\n    try {\n      await fs.access(claudePath);\n      hasClaudeFolder = true;\n    } catch {}\n\n    const commands = await this.parseSlashCommands(projectPath);\n    const skills = await this.parseSkills(projectPath);\n    const agents = await this.parseAgents(projectPath);\n\n    return {\n      commands,\n      skills,\n      agents,\n      hasClaudeFolder,\n    };\n  }\n}\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport { createLogger, type Logger } from './logger.js';\n\n/**\n * Represents a parsed slash command from .claude/commands/\n */\nexport interface SlashCommand {\n  id: string;\n  name: string;\n  description?: string;\n  path: string;\n  relativePath: string;\n  content: string;\n  metadata?: {\n    allowedTools?: string[];\n    argumentHint?: string;\n    model?: string;\n    disableModelInvocation?: boolean;\n  };\n  category?: string; // Extracted from subdirectory structure\n}\n\n/**\n * Training record for skill execution analysis\n *\n * @description\n * Represents a single training session record in a skill's training history.\n * Each record captures the performance metrics before and after a training execution,\n * along with issues identified and whether corrections were successfully applied.\n *\n * **Used in:**\n * - Skill interface's `trainingHistory` array field\n * - SKILL.md YAML frontmatter `training_history` field\n * - Skill performance tracking and improvement workflows\n *\n * @example\n * // Example training record from SKILL.md frontmatter\n * const trainingRecord: TrainingRecord = {\n *   date: '2024-01-15T10:30:00Z',\n *   scoreBefore: 75,\n *   scoreAfter: 85,\n *   issuesFound: [\n *     'Missing error handling in validation step',\n *     'Inconsistent file path handling'\n *   ],\n *   correctionsMade: true,\n *   executionSuccess: true\n * };\n *\n * @example\n * // Failed training session\n * const failedTraining: TrainingRecord = {\n *   date: '2024-01-16T14:20:00Z',\n *   scoreBefore: 85,\n *   scoreAfter: 85, // No improvement due to failure\n *   issuesFound: [\n *     'Timeout during skill execution',\n *     'MCP server connection failed'\n *   ],\n *   correctionsMade: false,\n *   executionSuccess: false\n * };\n */\nexport interface TrainingRecord {\n  /** ISO 8601 timestamp of training session (e.g., '2024-01-15T10:30:00Z') */\n  date: string;\n  /** Skill experience score before training (0-100) */\n  scoreBefore: number;\n  /** Skill experience score after training (0-100) */\n  scoreAfter: number;\n  /** List of issues identified during training execution */\n  issuesFound: string[];\n  /** Whether corrections were successfully applied to the skill */\n  correctionsMade: boolean;\n  /** Whether the training execution completed successfully */\n  executionSuccess: boolean;\n}\n\n/**\n * Represents a parsed skill from .claude/skills/\n *\n * @description\n * Represents a skill parsed from the `.claude/skills/` directory structure.\n * Each skill is a specialized capability that can be invoked by Claude agents during task execution.\n * Skills are discovered by the Claude Agent SDK via the `settingSources: ['project']` configuration.\n *\n * **Directory Structure:**\n * ```\n * .claude/skills/\n * \u2514\u2500\u2500 {skill-name}/\n *     \u251c\u2500\u2500 SKILL.md              # Required: Skill definition with YAML frontmatter\n *     \u251c\u2500\u2500 skill.config.json     # Optional: Input field definitions\n *     \u251c\u2500\u2500 reference.md          # Optional: Reference documentation\n *     \u251c\u2500\u2500 examples.md           # Optional: Usage examples\n *     \u251c\u2500\u2500 scripts/              # Optional: Helper scripts\n *     \u2514\u2500\u2500 templates/            # Optional: Template files\n * ```\n *\n * **SKILL.md YAML Frontmatter Format:**\n * ```yaml\n * ---\n * name: skill-name\n * description: \"Use when you need to...\"\n * allowed-tools:\n *   - Tool1\n *   - Tool2\n * mcp_tools:\n *   server-id:\n *     - tool1\n *     - tool2\n * experience_score: 85\n * training_history:\n *   - date: '2024-01-15T10:30:00Z'\n *     scoreBefore: 75\n *     scoreAfter: 85\n *     issuesFound: ['Missing error handling']\n *     correctionsMade: true\n *     executionSuccess: true\n * ---\n *\n * # Skill Content (Markdown)\n * Detailed skill instructions and usage guidelines...\n * ```\n *\n * @example\n * // Parse all skills from project\n * const parser = new ClaudeStructureParser();\n * const skills = await parser.parseSkills('/path/to/project');\n *\n * console.log(`Found ${skills.length} skills`);\n * skills.forEach(skill => {\n *   console.log(`- ${skill.name}: ${skill.description}`);\n *   console.log(`  Allowed Tools: ${skill.metadata?.allowedTools?.join(', ') || 'none'}`);\n *   console.log(`  Experience: ${skill.experienceScore || 0}/100`);\n * });\n *\n * @example\n * // Access skill metadata and supporting files\n * const skill = skills.find(s => s.id === 'data-analysis');\n * if (skill) {\n *   // Check tool configuration\n *   console.log('Allowed Tools:', skill.metadata?.allowedTools);\n *   console.log('MCP Tools:', skill.metadata?.mcpTools);\n *\n *   // Access supporting files\n *   if (skill.supportingFiles?.reference) {\n *     console.log('Reference Documentation:', skill.supportingFiles.reference);\n *   }\n *\n *   // Check input field requirements\n *   if (skill.metadata?.inputFields) {\n *     console.log('Input Fields:', skill.metadata.inputFields.map(f => f.name));\n *   }\n * }\n *\n * @example\n * // Check skill usage and training history\n * const popularSkills = skills\n *   .filter(s => (s.usageCount || 0) > 0)\n *   .sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0));\n *\n * popularSkills.forEach(skill => {\n *   console.log(`${skill.name} (used by ${skill.usageCount} agents)`);\n *   console.log(`  Experience: ${skill.experienceScore}/100`);\n *   console.log(`  Training Sessions: ${skill.trainingHistory?.length || 0}`);\n * });\n *\n * @see ClaudeStructureParser.parseSkills - Parses all skills from .claude/skills/\n * @see ClaudeStructureParser.parseSkill - Parses a single skill directory\n * @see InputField - Input field definitions from skill.config.json\n * @see TrainingRecord - Training history records from YAML frontmatter\n */\nexport interface Skill {\n  /** Unique identifier (skill directory name, e.g., 'data-analysis') */\n  id: string;\n  /** Human-readable skill name from YAML frontmatter */\n  name: string;\n  /** Skill description explaining when to use this skill (must include \"Use when\") */\n  description: string;\n  /** Absolute path to skill directory (e.g., '/project/.claude/skills/data-analysis') */\n  path: string;\n  /** Absolute path to SKILL.md file */\n  skillMdPath: string;\n  /** Markdown content from SKILL.md body (excluding YAML frontmatter) */\n  content: string;\n  /** Skill configuration from YAML frontmatter */\n  metadata?: {\n    /** List of allowed tool names (e.g., ['Read', 'Write', 'Bash']) */\n    allowedTools?: string[];\n    /** MCP server tools organized by server ID (e.g., { 'github': ['create_issue', 'search_repos'] }) */\n    mcpTools?: Record<string, string[]>;\n    /** Input field definitions from skill.config.json inputs array */\n    inputFields?: InputField[];\n  };\n  /** Supporting files found in skill directory */\n  supportingFiles?: {\n    /** Content of reference.md file */\n    reference?: string;\n    /** Content of examples.md file */\n    examples?: string;\n    /** List of script filenames in scripts/ directory */\n    scripts?: string[];\n    /** List of template filenames in templates/ directory */\n    templates?: string[];\n  };\n  /** List of agent IDs that reference this skill (populated by external analysis) */\n  usedInAgents?: string[];\n  /** Number of agents using this skill (populated by external analysis) */\n  usageCount?: number;\n  /** Skill proficiency score (0-100) from YAML frontmatter experience_score */\n  experienceScore?: number;\n  /** Training session history from YAML frontmatter training_history */\n  trainingHistory?: TrainingRecord[];\n}\n\n/**\n * Input field definition for agent and skill execution\n *\n * @description\n * Defines a single input parameter that users can configure when executing an agent or skill.\n * Input fields are displayed in the UI as form controls, allowing users to provide custom\n * values that are injected into the agent/skill prompt or configuration before execution.\n *\n * **Supported Field Types:**\n * - `text`: Single-line text input\n * - `textarea`: Multi-line text input\n * - `dropdown`: Single-select dropdown menu (requires `options` array)\n * - `multiselect`: Multi-select checkbox list (requires `options` array)\n * - `checkbox`: Boolean toggle (true/false)\n * - `number`: Numeric input with validation\n * - `filepath`: File path input with file picker integration\n *\n * **Used in:**\n * - Agent interface's `metadata.inputFields` array (from YAML frontmatter `input_fields` or `input-fields`)\n * - Skill interface's `metadata.inputFields` array (from skill.config.json `inputs` array)\n * - UI form rendering for parameterized agent/skill execution\n * - Template parameter injection (e.g., {{param_name}} syntax)\n *\n * @example\n * // Basic text input field\n * const textField: InputField = {\n *   name: 'project_name',\n *   type: 'text',\n *   label: 'Project Name',\n *   description: 'The name of your project',\n *   placeholder: 'my-awesome-project',\n *   required: true\n * };\n *\n * @example\n * // Dropdown field with options\n * const dropdownField: InputField = {\n *   name: 'environment',\n *   type: 'dropdown',\n *   label: 'Environment',\n *   description: 'Target deployment environment',\n *   required: true,\n *   options: ['development', 'staging', 'production'],\n *   default: 'development'\n * };\n *\n * @example\n * // Multiselect field for features\n * const multiselectField: InputField = {\n *   name: 'features',\n *   type: 'multiselect',\n *   label: 'Features',\n *   description: 'Select features to enable',\n *   options: ['authentication', 'database', 'api', 'logging'],\n *   default: ['authentication', 'logging']\n * };\n *\n * @example\n * // Checkbox for boolean toggle\n * const checkboxField: InputField = {\n *   name: 'include_tests',\n *   type: 'checkbox',\n *   label: 'Include Tests',\n *   description: 'Generate test files for the project',\n *   default: true\n * };\n *\n * @example\n * // Number field with validation\n * const numberField: InputField = {\n *   name: 'max_retries',\n *   type: 'number',\n *   label: 'Max Retries',\n *   description: 'Maximum number of retry attempts',\n *   placeholder: '3',\n *   required: false,\n *   default: 3\n * };\n *\n * @example\n * // Filepath field for file selection\n * const filepathField: InputField = {\n *   name: 'config_file',\n *   type: 'filepath',\n *   label: 'Config File',\n *   description: 'Path to configuration file',\n *   placeholder: '/path/to/config.json',\n *   required: true\n * };\n *\n * @see Skill - Uses inputFields for skill.config.json inputs\n * @see Agent - Uses inputFields for agent YAML frontmatter input_fields\n */\nexport interface InputField {\n  /** Unique identifier for the field (used in template injection as {{name}}) */\n  name: string;\n  /** Input field type determining UI rendering and validation */\n  type: 'text' | 'textarea' | 'dropdown' | 'multiselect' | 'checkbox' | 'number' | 'filepath';\n  /** Human-readable label displayed in UI form */\n  label: string;\n  /** Optional help text explaining the field's purpose */\n  description?: string;\n  /** Placeholder text shown in empty input fields */\n  placeholder?: string;\n  /** Whether the field must be filled before execution */\n  required?: boolean;\n  /** Available options for dropdown and multiselect types */\n  options?: string[];\n  /** Default value used if user doesn't provide input */\n  default?: any;\n}\n\n/**\n * Represents a parsed agent from .claude/agents/\n *\n * @description\n * Represents an agent parsed from the `.claude/agents/` directory.\n * Each agent is a specialized AI assistant with a custom system prompt, tool access,\n * and skill capabilities. Agents are discovered by the Claude Agent SDK and can be\n * selected by users for conversation sessions.\n *\n * **File Structure:**\n * ```\n * .claude/agents/\n * \u2514\u2500\u2500 {agent-name}.md\n * ```\n *\n * **Agent YAML Frontmatter Format:**\n * ```yaml\n * ---\n * name: Code Assistant\n * description: Helps with coding tasks\n * model: sonnet\n * tools:\n *   - Read\n *   - Write\n *   - Bash\n * allowed-tools:\n *   - Read\n *   - Write\n * mcp-tools:\n *   github:\n *     - create_issue\n *     - search_repos\n * skills:\n *   - data-analysis\n *   - code-review\n * input-fields:\n *   - name: project_type\n *     type: dropdown\n *     label: Project Type\n *     options:\n *       - web\n *       - mobile\n *       - backend\n *     required: true\n * output-schema:\n *   type: object\n *   properties:\n *     summary: { type: string }\n *     recommendations: { type: array, items: { type: string } }\n * ---\n *\n * # Agent System Prompt (Markdown)\n * You are a helpful coding assistant...\n * ```\n *\n * @example\n * // Parse all agents from project\n * const parser = new ClaudeStructureParser();\n * const agents = await parser.parseAgents('/path/to/project');\n *\n * console.log(`Found ${agents.length} agents`);\n * agents.forEach(agent => {\n *   console.log(`- ${agent.name}: ${agent.description}`);\n *   console.log(`  Model: ${agent.metadata?.model || 'default'}`);\n *   console.log(`  Skills: ${agent.metadata?.skills?.join(', ') || 'none'}`);\n * });\n *\n * @example\n * // Access agent metadata and configuration\n * const agent = agents.find(a => a.id === 'code-assistant');\n * if (agent) {\n *   // Check tool configuration\n *   console.log('Allowed Tools:', agent.metadata?.allowedTools);\n *   console.log('MCP Tools:', agent.metadata?.mcpTools);\n *\n *   // Check model preference\n *   console.log('Model:', agent.metadata?.model); // 'sonnet', 'opus', 'haiku'\n *\n *   // Check input field requirements\n *   if (agent.metadata?.inputFields) {\n *     console.log('Input Fields:', agent.metadata.inputFields.map(f => f.name));\n *   }\n *\n *   // Check output schema\n *   if (agent.metadata?.outputSchema) {\n *     console.log('Output Schema:', agent.metadata.outputSchema);\n *   }\n *\n *   // Check skill assignments\n *   if (agent.metadata?.skills) {\n *     console.log('Assigned Skills:', agent.metadata.skills);\n *   }\n * }\n *\n * @example\n * // Filter agents by capabilities\n * const agentsWithSkills = agents.filter(a =>\n *   a.metadata?.skills && a.metadata.skills.length > 0\n * );\n *\n * const mcpEnabledAgents = agents.filter(a =>\n *   a.metadata?.mcpTools && Object.keys(a.metadata.mcpTools).length > 0\n * );\n *\n * console.log(`Agents with skills: ${agentsWithSkills.length}`);\n * console.log(`MCP-enabled agents: ${mcpEnabledAgents.length}`);\n *\n * @see ClaudeStructureParser.parseAgents - Parses all agents from .claude/agents/\n * @see ClaudeStructureParser.parseAgent - Parses a single agent file\n * @see InputField - Input field definitions from YAML frontmatter input_fields\n * @see Skill - Skills that agents can reference via metadata.skills\n */\nexport interface Agent {\n  /** Unique identifier (filename without .md extension, e.g., 'code-assistant') */\n  id: string;\n  /** Human-readable agent name from YAML frontmatter */\n  name: string;\n  /** Agent description explaining the agent's purpose and capabilities */\n  description: string;\n  /** Absolute path to agent markdown file (e.g., '/project/.claude/agents/code-assistant.md') */\n  path: string;\n  /** Markdown content (system prompt) from agent file body (excluding YAML frontmatter) */\n  content: string;\n  /** Agent configuration from YAML frontmatter */\n  metadata?: {\n    /** List of tool names the agent can use (e.g., ['Read', 'Write', 'Bash']) */\n    tools?: string[];\n    /** List of allowed tool names (restricts tools further, subset of tools) */\n    allowedTools?: string[];\n    /** Preferred Claude model ('sonnet', 'opus', 'haiku') */\n    model?: string;\n    /** Input field definitions from YAML frontmatter input_fields or input-fields */\n    inputFields?: InputField[];\n    /** Output schema for structured responses (JSON Schema as object or JSON string) */\n    outputSchema?: string | object;\n    /** MCP server tools organized by server ID (e.g., { 'github': ['create_issue'] }) */\n    mcpTools?: Record<string, string[]>;\n    /** List of skill IDs that this agent can invoke (e.g., ['data-analysis', 'code-review']) */\n    skills?: string[];\n  };\n}\n\n/**\n * ClaudeStructureParser - Service for parsing Claude Code's .claude folder structure\n *\n * @description\n * Parses the `.claude` directory structure to extract slash commands, skills, and agents\n * from a Claude Code project. This service enables discovery and analysis of project-level\n * Claude configurations, including agent definitions, skill libraries, and custom commands.\n *\n * **Parsed Directory Structure:**\n * ```\n * .claude/\n * \u251c\u2500\u2500 commands/           # Slash commands (*.md files with YAML frontmatter)\n * \u2502   \u251c\u2500\u2500 command1.md\n * \u2502   \u2514\u2500\u2500 subdir/\n * \u2502       \u2514\u2500\u2500 command2.md\n * \u251c\u2500\u2500 skills/             # Skills (directories with SKILL.md files)\n * \u2502   \u251c\u2500\u2500 skill-name/\n * \u2502   \u2502   \u251c\u2500\u2500 SKILL.md\n * \u2502   \u2502   \u251c\u2500\u2500 skill.config.json\n * \u2502   \u2502   \u251c\u2500\u2500 reference.md\n * \u2502   \u2502   \u2514\u2500\u2500 examples.md\n * \u2502   \u2514\u2500\u2500 another-skill/\n * \u2502       \u2514\u2500\u2500 SKILL.md\n * \u2514\u2500\u2500 agents/             # Agents (*.md files with YAML frontmatter)\n *     \u251c\u2500\u2500 agent1.md\n *     \u2514\u2500\u2500 agent2.md\n * ```\n *\n * **Key Features:**\n * - YAML frontmatter parsing using js-yaml library\n * - Recursive directory scanning for commands and skills\n * - Input field extraction from skill.config.json files\n * - Supporting file discovery (reference.md, examples.md, scripts/, templates/)\n * - Training history and experience score parsing from SKILL.md\n * - MCP tools configuration parsing for agents and skills\n * - Tool configuration parsing (allowed-tools, tools, mcp-tools)\n * - Flexible tool field format support (array or comma-separated string)\n * - Graceful handling of missing or malformed files\n *\n * **YAML Frontmatter Formats Supported:**\n * - Skills: name, description, allowed-tools, mcp_tools, experience_score, training_history\n * - Agents: name, description, model, tools, allowed-tools, mcp-tools, skills, input-fields, output-schema\n * - Commands: description, allowed-tools, argument-hint, model, disable-model-invocation\n *\n * @example\n * // Parse entire .claude directory structure\n * const parser = new ClaudeStructureParser();\n * const analysis = await parser.analyzeProject('/path/to/project');\n *\n * console.log(`Found ${analysis.skills.length} skills`);\n * console.log(`Found ${analysis.agents.length} agents`);\n * console.log(`Found ${analysis.commands.length} commands`);\n * console.log(`Has .claude folder: ${analysis.hasClaudeFolder}`);\n *\n * @example\n * // Parse only skills\n * const parser = new ClaudeStructureParser();\n * const skills = await parser.parseSkills('/path/to/project');\n *\n * skills.forEach(skill => {\n *   console.log(`${skill.name}: ${skill.description}`);\n *   console.log(`  Experience: ${skill.experienceScore || 0}/100`);\n *   console.log(`  Training Sessions: ${skill.trainingHistory?.length || 0}`);\n * });\n *\n * @example\n * // Parse only agents\n * const parser = new ClaudeStructureParser();\n * const agents = await parser.parseAgents('/path/to/project');\n *\n * agents.forEach(agent => {\n *   console.log(`${agent.name}: ${agent.description}`);\n *   console.log(`  Model: ${agent.metadata?.model || 'default'}`);\n *   console.log(`  Skills: ${agent.metadata?.skills?.join(', ') || 'none'}`);\n * });\n *\n * @example\n * // Parse a specific skill by name\n * const parser = new ClaudeStructureParser();\n * const skill = await parser.parseSpecificSkill('/path/to/project', 'data-analysis');\n *\n * if (skill) {\n *   console.log(`Skill: ${skill.name}`);\n *   console.log(`Description: ${skill.description}`);\n *   console.log(`Content:\\n${skill.content}`);\n * } else {\n *   console.log('Skill not found');\n * }\n *\n * @example\n * // Check for input fields in skills\n * const parser = new ClaudeStructureParser();\n * const skills = await parser.parseSkills('/path/to/project');\n *\n * const skillsWithInputs = skills.filter(s =>\n *   s.metadata?.inputFields && s.metadata.inputFields.length > 0\n * );\n *\n * skillsWithInputs.forEach(skill => {\n *   console.log(`${skill.name} requires inputs:`);\n *   skill.metadata!.inputFields!.forEach(field => {\n *     console.log(`  - ${field.name} (${field.type}): ${field.label}`);\n *   });\n * });\n *\n * @see Skill - Skill interface returned by parseSkills\n * @see Agent - Agent interface returned by parseAgents\n * @see InputField - Input field definition for parameterized execution\n * @see TrainingRecord - Training history record for skill performance tracking\n */\nexport class ClaudeStructureParser {\n  /** Logger instance for debugging and error tracking */\n  private logger: Logger;\n\n  constructor() {\n    this.logger = createLogger('ClaudeStructureParser');\n  }\n\n  /**\n   * Parse all slash commands from .claude/commands/\n   */\n  async parseSlashCommands(projectPath: string): Promise<SlashCommand[]> {\n    const commandsDir = path.join(projectPath, '.claude', 'commands');\n\n    try {\n      await fs.access(commandsDir);\n    } catch {\n      this.logger.debug('No .claude/commands directory found', { projectPath });\n      return [];\n    }\n\n    const commands: SlashCommand[] = [];\n    await this.scanCommandsRecursive(commandsDir, commandsDir, commands);\n\n    this.logger.info('Parsed slash commands', {\n      projectPath,\n      count: commands.length,\n      commands: commands.map(c => c.name)\n    });\n\n    return commands;\n  }\n\n  /**\n   * Recursively scan commands directory\n   */\n  private async scanCommandsRecursive(\n    currentDir: string,\n    rootDir: string,\n    commands: SlashCommand[]\n  ): Promise<void> {\n    const entries = await fs.readdir(currentDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(currentDir, entry.name);\n\n      if (entry.isDirectory()) {\n        // Recurse into subdirectories\n        await this.scanCommandsRecursive(fullPath, rootDir, commands);\n      } else if (entry.isFile() && entry.name.endsWith('.md')) {\n        const command = await this.parseCommandFile(fullPath, rootDir);\n        if (command) {\n          commands.push(command);\n        }\n      }\n    }\n  }\n\n  /**\n   * Parse a single slash command file\n   */\n  private async parseCommandFile(\n    filePath: string,\n    rootDir: string\n  ): Promise<SlashCommand | null> {\n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      const relativePath = path.relative(rootDir, filePath);\n      const commandName = path.basename(filePath, '.md');\n\n      // Extract category from subdirectory (if any)\n      const dirPath = path.dirname(relativePath);\n      const category = dirPath === '.' ? undefined : dirPath;\n\n      // Parse frontmatter\n      const { metadata, bodyContent } = this.parseFrontmatter(content);\n\n      // Parse allowed-tools (handle both array and comma-separated string formats)\n      const parseToolsField = (toolsValue: unknown): string[] | undefined => {\n        if (!toolsValue) return undefined;\n        if (Array.isArray(toolsValue)) return toolsValue;\n        if (typeof toolsValue === 'string') {\n          return toolsValue.split(',').map(t => t.trim()).filter(t => t.length > 0);\n        }\n        return undefined;\n      };\n\n      return {\n        id: relativePath.replace(/\\\\/g, '/').replace('.md', ''),\n        name: commandName,\n        description: metadata.description as string | undefined,\n        path: filePath,\n        relativePath: relativePath.replace(/\\\\/g, '/'),\n        content: bodyContent,\n        metadata: {\n          allowedTools: parseToolsField(metadata['allowed-tools']),\n          argumentHint: metadata['argument-hint'] as string | undefined,\n          model: metadata.model as string | undefined,\n          disableModelInvocation: metadata['disable-model-invocation'] as boolean | undefined,\n        },\n        category,\n      };\n    } catch (error) {\n      this.logger.error('Failed to parse command file', error, { filePath });\n      return null;\n    }\n  }\n\n  /**\n   * Parse all skills from .claude/skills/\n   *\n   * @description\n   * Scans the `.claude/skills/` directory and parses all skill subdirectories.\n   * Each subdirectory must contain a `SKILL.md` file with YAML frontmatter to be considered a valid skill.\n   * Optionally parses `skill.config.json` for input field definitions and supporting files\n   * (reference.md, examples.md, scripts/, templates/).\n   *\n   * **Parsing Workflow:**\n   * 1. Check if `.claude/skills/` directory exists (returns empty array if not found)\n   * 2. Read all entries in the skills directory\n   * 3. For each subdirectory, call `parseSkill()` to extract skill data\n   * 4. Filter out null results (failed parses or missing SKILL.md)\n   * 5. Log parsed skill names and count\n   * 6. Return array of successfully parsed skills\n   *\n   * **Skill Discovery:**\n   * - Only directory entries are processed (ignores loose files)\n   * - Each skill directory must contain `SKILL.md` with YAML frontmatter\n   * - Missing or malformed skills are logged as warnings and skipped\n   * - Skills are discovered by Claude Agent SDK via `settingSources: ['project']`\n   *\n   * @param projectPath - Absolute path to project root directory\n   * @returns Promise resolving to array of parsed Skill objects (empty array if no skills found)\n   *\n   * @example\n   * // Parse all skills from project\n   * const parser = new ClaudeStructureParser();\n   * const skills = await parser.parseSkills('/path/to/project');\n   *\n   * console.log(`Found ${skills.length} skills`);\n   * skills.forEach(skill => {\n   *   console.log(`- ${skill.name}: ${skill.description}`);\n   *   console.log(`  Tools: ${skill.metadata?.allowedTools?.join(', ') || 'none'}`);\n   *   console.log(`  Experience: ${skill.experienceScore || 0}/100`);\n   * });\n   *\n   * @example\n   * // Filter skills by experience level\n   * const parser = new ClaudeStructureParser();\n   * const skills = await parser.parseSkills('/path/to/project');\n   *\n   * const expertSkills = skills.filter(s => (s.experienceScore || 0) >= 80);\n   * const beginnerSkills = skills.filter(s => (s.experienceScore || 0) < 50);\n   *\n   * console.log(`Expert skills (80+): ${expertSkills.length}`);\n   * console.log(`Beginner skills (<50): ${beginnerSkills.length}`);\n   *\n   * @example\n   * // Check for skills with MCP tools configured\n   * const parser = new ClaudeStructureParser();\n   * const skills = await parser.parseSkills('/path/to/project');\n   *\n   * const mcpSkills = skills.filter(s =>\n   *   s.metadata?.mcpTools && Object.keys(s.metadata.mcpTools).length > 0\n   * );\n   *\n   * mcpSkills.forEach(skill => {\n   *   console.log(`${skill.name} uses MCP servers:`);\n   *   Object.entries(skill.metadata!.mcpTools!).forEach(([serverId, tools]) => {\n   *     console.log(`  - ${serverId}: ${tools.join(', ')}`);\n   *   });\n   * });\n   *\n   * @example\n   * // Check for skills with input fields\n   * const parser = new ClaudeStructureParser();\n   * const skills = await parser.parseSkills('/path/to/project');\n   *\n   * const parameterizedSkills = skills.filter(s =>\n   *   s.metadata?.inputFields && s.metadata.inputFields.length > 0\n   * );\n   *\n   * parameterizedSkills.forEach(skill => {\n   *   console.log(`${skill.name} requires inputs:`);\n   *   skill.metadata!.inputFields!.forEach(field => {\n   *     const req = field.required ? '(required)' : '(optional)';\n   *     console.log(`  - ${field.name}: ${field.label} ${req}`);\n   *   });\n   * });\n   *\n   * @example\n   * // Check for skills with supporting files\n   * const parser = new ClaudeStructureParser();\n   * const skills = await parser.parseSkills('/path/to/project');\n   *\n   * skills.forEach(skill => {\n   *   if (skill.supportingFiles?.reference) {\n   *     console.log(`${skill.name} has reference documentation`);\n   *   }\n   *   if (skill.supportingFiles?.examples) {\n   *     console.log(`${skill.name} has usage examples`);\n   *   }\n   *   if (skill.supportingFiles?.scripts && skill.supportingFiles.scripts.length > 0) {\n   *     console.log(`${skill.name} has ${skill.supportingFiles.scripts.length} helper scripts`);\n   *   }\n   * });\n   *\n   * @example\n   * // Analyze training history\n   * const parser = new ClaudeStructureParser();\n   * const skills = await parser.parseSkills('/path/to/project');\n   *\n   * skills.forEach(skill => {\n   *   if (skill.trainingHistory && skill.trainingHistory.length > 0) {\n   *     const successfulTrainings = skill.trainingHistory.filter(t => t.executionSuccess);\n   *     const avgImprovement = skill.trainingHistory.reduce((sum, t) =>\n   *       sum + (t.scoreAfter - t.scoreBefore), 0\n   *     ) / skill.trainingHistory.length;\n   *\n   *     console.log(`${skill.name}:`);\n   *     console.log(`  Training Sessions: ${skill.trainingHistory.length}`);\n   *     console.log(`  Successful: ${successfulTrainings.length}`);\n   *     console.log(`  Avg Improvement: ${avgImprovement.toFixed(1)} points`);\n   *   }\n   * });\n   *\n   * @see parseSkill - Parses a single skill directory\n   * @see parseSpecificSkill - Parses a specific skill by name\n   * @see Skill - Returned skill interface\n   */\n  async parseSkills(projectPath: string): Promise<Skill[]> {\n    const skillsDir = path.join(projectPath, '.claude', 'skills');\n\n    try {\n      await fs.access(skillsDir);\n    } catch {\n      this.logger.debug('No .claude/skills directory found', { projectPath });\n      return [];\n    }\n\n    const skills: Skill[] = [];\n    const entries = await fs.readdir(skillsDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        const skillPath = path.join(skillsDir, entry.name);\n        const skill = await this.parseSkill(skillPath, entry.name);\n        if (skill) {\n          skills.push(skill);\n        }\n      }\n    }\n\n    this.logger.info('Parsed skills', {\n      projectPath,\n      count: skills.length,\n      skills: skills.map(s => s.name)\n    });\n\n    return skills;\n  }\n\n  /**\n   * Parse a specific skill directory by name (for forced execution)\n   * Use this when you want to load ONLY one skill, not all skills.\n   *\n   * @param projectPath - Project root directory\n   * @param skillName - Name of the skill to parse\n   * @returns Parsed skill or null if not found\n   */\n  async parseSpecificSkill(projectPath: string, skillName: string): Promise<Skill | null> {\n    const skillPath = path.join(projectPath, '.claude', 'skills', skillName);\n\n    try {\n      await fs.access(skillPath);\n    } catch {\n      this.logger.warn('Skill directory not found', { skillPath, skillName });\n      return null;\n    }\n\n    const skill = await this.parseSkill(skillPath, skillName);\n\n    if (skill) {\n      this.logger.info('Parsed specific skill', {\n        projectPath,\n        skillName,\n        skillId: skill.id\n      });\n    }\n\n    return skill;\n  }\n\n  /**\n   * Parse a single skill directory\n   *\n   * @description\n   * Parses a single skill directory containing SKILL.md with YAML frontmatter.\n   * Extracts skill metadata, content, input fields from skill.config.json, and supporting files\n   * (reference.md, examples.md, scripts/, templates/). This is a private helper method called by\n   * `parseSkills()` and `parseSpecificSkill()`.\n   *\n   * **Required Files:**\n   * - SKILL.md with YAML frontmatter (required)\n   *\n   * **Optional Files:**\n   * - skill.config.json with inputs array (for input field definitions)\n   * - reference.md (reference documentation)\n   * - examples.md (usage examples)\n   * - scripts/ directory (helper scripts)\n   * - templates/ directory (template files)\n   *\n   * **Parsing Workflow:**\n   * 1. Check if SKILL.md exists (returns null if not found)\n   * 2. Read and parse SKILL.md YAML frontmatter\n   * 3. Extract metadata (name, description, allowed-tools, mcp_tools, experience_score, training_history)\n   * 4. Parse skill.config.json if present (for input field definitions)\n   * 5. Scan for supporting files (reference.md, examples.md, scripts/, templates/)\n   * 6. Return Skill object with all parsed data\n   *\n   * **Error Handling:**\n   * - Returns null if SKILL.md is missing\n   * - Logs errors and returns null if parsing fails\n   * - Gracefully handles missing optional files (skill.config.json, supporting files)\n   *\n   * @param skillPath - Absolute path to skill directory (e.g., '/project/.claude/skills/data-analysis')\n   * @param skillName - Skill directory name (used as skill ID, e.g., 'data-analysis')\n   * @returns Promise resolving to Skill object or null if parsing fails\n   * @private\n   *\n   * @see parseSkills - Public method that calls this for all skills\n   * @see parseSpecificSkill - Public method that calls this for a single skill\n   * @see Skill - Returned skill interface\n   */\n  private async parseSkill(skillPath: string, skillName: string): Promise<Skill | null> {\n    const skillMdPath = path.join(skillPath, 'SKILL.md');\n\n    try {\n      await fs.access(skillMdPath);\n    } catch {\n      this.logger.warn('Skill directory missing SKILL.md', { skillPath });\n      return null;\n    }\n\n    try {\n      const content = await fs.readFile(skillMdPath, 'utf-8');\n      const { metadata, bodyContent } = this.parseFrontmatter(content);\n\n      // Parse allowed-tools (handle both array and comma-separated string formats)\n      const parseToolsField = (toolsValue: unknown): string[] | undefined => {\n        if (!toolsValue) return undefined;\n        if (Array.isArray(toolsValue)) return toolsValue;\n        if (typeof toolsValue === 'string') {\n          return toolsValue.split(',').map(t => t.trim()).filter(t => t.length > 0);\n        }\n        return undefined;\n      };\n\n      // Parse skill.config.json for input fields\n      let inputFields: InputField[] | undefined;\n      const configPath = path.join(skillPath, 'skill.config.json');\n      try {\n        await fs.access(configPath);\n        const configContent = await fs.readFile(configPath, 'utf-8');\n        const configData = JSON.parse(configContent);\n\n        if (configData.inputs && Array.isArray(configData.inputs)) {\n          inputFields = configData.inputs.map((field: any) => ({\n            name: field.name,\n            type: field.type || 'text',\n            label: field.label || field.name,\n            description: field.description,\n            placeholder: field.placeholder,\n            required: field.required === true,\n            options: field.options,\n            default: field.default,\n          }));\n          if (inputFields && inputFields.length > 0) {\n            this.logger.debug(`Parsed ${inputFields.length} input fields for skill ${skillName}`);\n          }\n        }\n      } catch (error) {\n        // skill.config.json is optional, so no error if it doesn't exist\n        this.logger.debug('No skill.config.json found or failed to parse', { skillPath });\n      }\n\n      // Scan for supporting files\n      const supportingFiles = await this.scanSupportingFiles(skillPath);\n\n      // Parse experience score and training history\n      const experienceScore = typeof metadata.experience_score === 'number'\n        ? metadata.experience_score\n        : 0;\n\n      const trainingHistory = Array.isArray(metadata.training_history)\n        ? (metadata.training_history as TrainingRecord[])\n        : undefined;\n\n      return {\n        id: skillName,\n        name: metadata.name as string || skillName,\n        description: metadata.description as string || 'No description',\n        path: skillPath,\n        skillMdPath,\n        content: bodyContent,\n        metadata: {\n          allowedTools: parseToolsField(metadata['allowed-tools']),\n          mcpTools: metadata['mcp_tools'] as Record<string, string[]> | undefined,\n          inputFields,\n        },\n        supportingFiles,\n        experienceScore,\n        trainingHistory,\n      };\n    } catch (error) {\n      this.logger.error('Failed to parse skill', error, { skillPath });\n      return null;\n    }\n  }\n\n  /**\n   * Scan for supporting files in skill directory\n   */\n  private async scanSupportingFiles(skillPath: string): Promise<Skill['supportingFiles']> {\n    const supportingFiles: Skill['supportingFiles'] = {};\n\n    // Check for reference.md\n    const referencePath = path.join(skillPath, 'reference.md');\n    try {\n      await fs.access(referencePath);\n      supportingFiles.reference = await fs.readFile(referencePath, 'utf-8');\n    } catch {}\n\n    // Check for examples.md\n    const examplesPath = path.join(skillPath, 'examples.md');\n    try {\n      await fs.access(examplesPath);\n      supportingFiles.examples = await fs.readFile(examplesPath, 'utf-8');\n    } catch {}\n\n    // Check for scripts directory\n    const scriptsDir = path.join(skillPath, 'scripts');\n    try {\n      const scriptFiles = await fs.readdir(scriptsDir);\n      supportingFiles.scripts = scriptFiles;\n    } catch {}\n\n    // Check for templates directory\n    const templatesDir = path.join(skillPath, 'templates');\n    try {\n      const templateFiles = await fs.readdir(templatesDir);\n      supportingFiles.templates = templateFiles;\n    } catch {}\n\n    return supportingFiles;\n  }\n\n  /**\n   * Parse YAML frontmatter from markdown content\n   * Returns metadata object and body content separately\n   */\n  private parseFrontmatter(content: string): {\n    metadata: Record<string, unknown>;\n    bodyContent: string;\n  } {\n    const frontmatterRegex = /^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n([\\s\\S]*)$/;\n    const match = content.match(frontmatterRegex);\n\n    if (!match) {\n      return { metadata: {}, bodyContent: content };\n    }\n\n    const [, frontmatterText, bodyContent] = match;\n\n    try {\n      // Use js-yaml for proper YAML parsing (handles nested objects, arrays, etc.)\n      const metadata = yaml.load(frontmatterText) as Record<string, unknown> || {};\n      return { metadata, bodyContent: bodyContent.trim() };\n    } catch (error) {\n      this.logger.error('Failed to parse YAML frontmatter', error);\n      return { metadata: {}, bodyContent: bodyContent.trim() };\n    }\n  }\n\n  /**\n   * Parse all agents from .claude/agents/\n   *\n   * @description\n   * Scans the `.claude/agents/` directory and parses all agent markdown files.\n   * Each `.md` file (except README.md) is parsed as an agent definition with YAML frontmatter\n   * containing agent configuration (name, description, model, tools, skills, etc.).\n   *\n   * **Parsing Workflow:**\n   * 1. Check if `.claude/agents/` directory exists (returns empty array if not found)\n   * 2. Read all entries in the agents directory\n   * 3. For each `.md` file (excluding README.md), call `parseAgent()` to extract agent data\n   * 4. Parse YAML frontmatter for agent metadata (tools, skills, input fields, etc.)\n   * 5. Filter out null results (failed parses or malformed files)\n   * 6. Log parsed agent names and count\n   * 7. Return array of successfully parsed agents\n   *\n   * **Agent Discovery:**\n   * - Only `.md` files are processed (ignores non-markdown files and subdirectories)\n   * - README.md is explicitly excluded to avoid parsing documentation as an agent\n   * - Missing or malformed agents are logged as errors and skipped\n   * - Agents are discovered by Claude Agent SDK and selectable in UI\n   *\n   * @param projectPath - Absolute path to project root directory\n   * @returns Promise resolving to array of parsed Agent objects (empty array if no agents found)\n   *\n   * @example\n   * // Parse all agents from project\n   * const parser = new ClaudeStructureParser();\n   * const agents = await parser.parseAgents('/path/to/project');\n   *\n   * console.log(`Found ${agents.length} agents`);\n   * agents.forEach(agent => {\n   *   console.log(`- ${agent.name}: ${agent.description}`);\n   *   console.log(`  Model: ${agent.metadata?.model || 'default'}`);\n   *   console.log(`  Skills: ${agent.metadata?.skills?.join(', ') || 'none'}`);\n   * });\n   *\n   * @example\n   * // Filter agents by model preference\n   * const parser = new ClaudeStructureParser();\n   * const agents = await parser.parseAgents('/path/to/project');\n   *\n   * const sonnetAgents = agents.filter(a => a.metadata?.model === 'sonnet');\n   * const opusAgents = agents.filter(a => a.metadata?.model === 'opus');\n   *\n   * console.log(`Sonnet agents: ${sonnetAgents.length}`);\n   * console.log(`Opus agents: ${opusAgents.length}`);\n   *\n   * @example\n   * // Find agents with specific skills\n   * const parser = new ClaudeStructureParser();\n   * const agents = await parser.parseAgents('/path/to/project');\n   *\n   * const dataAnalysisAgents = agents.filter(a =>\n   *   a.metadata?.skills?.includes('data-analysis')\n   * );\n   *\n   * console.log('Agents with data-analysis skill:');\n   * dataAnalysisAgents.forEach(agent => {\n   *   console.log(`  - ${agent.name}`);\n   * });\n   *\n   * @example\n   * // Check agents with MCP tools configured\n   * const parser = new ClaudeStructureParser();\n   * const agents = await parser.parseAgents('/path/to/project');\n   *\n   * const mcpAgents = agents.filter(a =>\n   *   a.metadata?.mcpTools && Object.keys(a.metadata.mcpTools).length > 0\n   * );\n   *\n   * mcpAgents.forEach(agent => {\n   *   console.log(`${agent.name} uses MCP servers:`);\n   *   Object.entries(agent.metadata!.mcpTools!).forEach(([serverId, tools]) => {\n   *     console.log(`  - ${serverId}: ${tools.join(', ')}`);\n   *   });\n   * });\n   *\n   * @example\n   * // Find agents with input fields\n   * const parser = new ClaudeStructureParser();\n   * const agents = await parser.parseAgents('/path/to/project');\n   *\n   * const parameterizedAgents = agents.filter(a =>\n   *   a.metadata?.inputFields && a.metadata.inputFields.length > 0\n   * );\n   *\n   * parameterizedAgents.forEach(agent => {\n   *   console.log(`${agent.name} requires inputs:`);\n   *   agent.metadata!.inputFields!.forEach(field => {\n   *     const req = field.required ? '(required)' : '(optional)';\n   *     console.log(`  - ${field.name}: ${field.label} ${req}`);\n   *   });\n   * });\n   *\n   * @example\n   * // Check agents with output schemas\n   * const parser = new ClaudeStructureParser();\n   * const agents = await parser.parseAgents('/path/to/project');\n   *\n   * const structuredAgents = agents.filter(a => a.metadata?.outputSchema);\n   *\n   * structuredAgents.forEach(agent => {\n   *   console.log(`${agent.name} has structured output:`);\n   *   console.log(JSON.stringify(agent.metadata!.outputSchema, null, 2));\n   * });\n   *\n   * @example\n   * // Analyze tool usage across agents\n   * const parser = new ClaudeStructureParser();\n   * const agents = await parser.parseAgents('/path/to/project');\n   *\n   * const toolUsage = new Map<string, number>();\n   * agents.forEach(agent => {\n   *   agent.metadata?.allowedTools?.forEach(tool => {\n   *     toolUsage.set(tool, (toolUsage.get(tool) || 0) + 1);\n   *   });\n   * });\n   *\n   * console.log('Tool usage across agents:');\n   * Array.from(toolUsage.entries())\n   *   .sort((a, b) => b[1] - a[1])\n   *   .forEach(([tool, count]) => {\n   *     console.log(`  ${tool}: ${count} agents`);\n   *   });\n   *\n   * @see parseAgent - Parses a single agent file\n   * @see Agent - Returned agent interface\n   */\n  async parseAgents(projectPath: string): Promise<Agent[]> {\n    const agentsDir = path.join(projectPath, '.claude', 'agents');\n\n    try {\n      await fs.access(agentsDir);\n    } catch {\n      this.logger.debug('No .claude/agents directory found', { projectPath });\n      return [];\n    }\n\n    const agents: Agent[] = [];\n    const entries = await fs.readdir(agentsDir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (entry.isFile() && entry.name.endsWith('.md') && entry.name !== 'README.md') {\n        const agentPath = path.join(agentsDir, entry.name);\n        const agent = await this.parseAgent(agentPath, entry.name);\n        if (agent) {\n          agents.push(agent);\n        }\n      }\n    }\n\n    this.logger.info('Parsed agents', {\n      projectPath,\n      count: agents.length,\n      agents: agents.map(a => a.name)\n    });\n\n    return agents;\n  }\n\n  /**\n   * Parse a single agent file\n   *\n   * @description\n   * Parses a single agent markdown file containing YAML frontmatter with agent configuration.\n   * Extracts agent metadata (name, description, model, tools, skills, input fields, output schema),\n   * and the system prompt content. This is a private helper method called by `parseAgents()`.\n   *\n   * **YAML Frontmatter Fields:**\n   * - name: Agent name (string)\n   * - description: Agent description (string)\n   * - model: Preferred model ('sonnet', 'opus', 'haiku')\n   * - tools: List of tool names (array or comma-separated string)\n   * - allowed-tools: List of allowed tool names (array or comma-separated string)\n   * - mcp-tools or mcp_tools: MCP server tools organized by server ID (object)\n   * - skills: List of skill IDs (array or comma-separated string)\n   * - input-fields or input_fields: Input field definitions (array)\n   * - output-schema or output_schema: Output schema for structured responses (object or JSON string)\n   *\n   * **Parsing Workflow:**\n   * 1. Read agent markdown file content\n   * 2. Parse YAML frontmatter to extract metadata\n   * 3. Extract body content (system prompt)\n   * 4. Parse input fields from input-fields or input_fields\n   * 5. Parse tools, allowed-tools, skills (supports array or comma-separated string formats)\n   * 6. Parse MCP tools (nested object with server IDs as keys)\n   * 7. Parse output schema (supports object or JSON string)\n   * 8. Return Agent object with all parsed data\n   *\n   * **Error Handling:**\n   * - Returns null if file read or parsing fails\n   * - Logs errors with agent path context\n   * - Gracefully handles missing or malformed metadata fields\n   *\n   * @param agentPath - Absolute path to agent markdown file (e.g., '/project/.claude/agents/code-assistant.md')\n   * @param fileName - Agent filename (e.g., 'code-assistant.md')\n   * @returns Promise resolving to Agent object or null if parsing fails\n   * @private\n   *\n   * @see parseAgents - Public method that calls this for all agents\n   * @see Agent - Returned agent interface\n   */\n  private async parseAgent(agentPath: string, fileName: string): Promise<Agent | null> {\n    try {\n      const content = await fs.readFile(agentPath, 'utf-8');\n      const { metadata, bodyContent } = this.parseFrontmatter(content);\n\n      const agentId = fileName.replace('.md', '');\n\n      // Parse input fields\n      let inputFields: InputField[] | undefined;\n      const inputFieldsData = metadata.input_fields || metadata['input-fields'];\n\n      if (inputFieldsData && Array.isArray(inputFieldsData)) {\n        inputFields = inputFieldsData.map((field: any) => ({\n          name: field.name,\n          type: field.type || 'text',\n          label: field.label || field.name,\n          placeholder: field.placeholder,\n          required: field.required === true,\n          options: field.options,\n          default: field.default,\n        }));\n        this.logger.debug(`Parsed ${inputFields.length} input fields for agent ${fileName}`);\n      }\n\n      // Parse tools (handle both array and comma-separated string formats)\n      const parseToolsField = (toolsValue: unknown): string[] | undefined => {\n        if (!toolsValue) return undefined;\n        if (Array.isArray(toolsValue)) return toolsValue;\n        if (typeof toolsValue === 'string') {\n          // Handle comma-separated format: \"Tool1,Tool2,Tool3\"\n          return toolsValue.split(',').map(t => t.trim()).filter(t => t.length > 0);\n        }\n        return undefined;\n      };\n\n      const tools = parseToolsField(metadata.tools);\n      const allowedTools = parseToolsField(metadata['allowed-tools']);\n\n      // Parse MCP tools (nested object with server IDs as keys)\n      let mcpTools: Record<string, string[]> | undefined;\n      const mcpToolsData = metadata.mcp_tools || metadata['mcp-tools'];\n      if (mcpToolsData && typeof mcpToolsData === 'object' && !Array.isArray(mcpToolsData)) {\n        mcpTools = {};\n        Object.entries(mcpToolsData).forEach(([serverId, toolsValue]) => {\n          if (Array.isArray(toolsValue) && toolsValue.length > 0) {\n            mcpTools![serverId] = toolsValue;\n          }\n        });\n        // Only keep mcpTools if it has entries\n        if (Object.keys(mcpTools).length === 0) {\n          mcpTools = undefined;\n        }\n      }\n\n      // Parse output schema\n      let outputSchema: string | object | undefined = (metadata.output_schema || metadata['output-schema']) as string | object | undefined;\n\n      if (typeof outputSchema === 'string') {\n        try {\n          outputSchema = JSON.parse(outputSchema);\n        } catch {\n          // Keep as string if not valid JSON\n        }\n      }\n\n      // Parse skills (handle both array and comma-separated string formats)\n      const skills = parseToolsField(metadata.skills);\n\n      return {\n        id: agentId,\n        name: metadata.name as string || agentId,\n        description: metadata.description as string || 'No description',\n        path: agentPath,\n        content: bodyContent,\n        metadata: {\n          tools,\n          allowedTools,\n          model: metadata.model as string | undefined,\n          inputFields,\n          outputSchema,\n          mcpTools,\n          skills,\n        },\n      };\n    } catch (error) {\n      this.logger.error('Failed to parse agent', error, { agentPath });\n      return null;\n    }\n  }\n\n  /**\n   * Get full structure analysis for a project\n   */\n  async analyzeProject(projectPath: string): Promise<{\n    commands: SlashCommand[];\n    skills: Skill[];\n    agents: Agent[];\n    hasClaudeFolder: boolean;\n  }> {\n    const claudePath = path.join(projectPath, '.claude');\n\n    let hasClaudeFolder = false;\n    try {\n      await fs.access(claudePath);\n      hasClaudeFolder = true;\n    } catch {}\n\n    const commands = await this.parseSlashCommands(projectPath);\n    const skills = await this.parseSkills(projectPath);\n    const agents = await this.parseAgents(projectPath);\n\n    return {\n      commands,\n      skills,\n      agents,\n      hasClaudeFolder,\n    };\n  }\n}\n",
        "last_modified": "2026-01-02T14:06:15.758649"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.501638",
  "last_updated": "2026-01-02T14:06:15.512886"
}