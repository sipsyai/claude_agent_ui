{
  "file_path": "src/services/flow-execution-service.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "/**\n * Claude Agent UI - Flow Execution Service\n *\n * This service orchestrates the execution of flows (workflows).\n * It manages node execution in sequence, tracks state, handles errors,\n * and provides real-time updates via SSE.\n *\n * Key responsibilities:\n * - Start, stop, and cancel flow executions\n * - Execute nodes in sequence following the flow graph\n * - Manage execution context and state\n * - Handle errors with retry support\n * - Emit SSE updates for real-time monitoring\n * - Track token usage and costs\n *\n * @see src/types/flow-types.ts for type definitions\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { createLogger, type Logger } from './logger.js';\nimport { strapiClient } from './strapi-client.js';\nimport type {\n  Flow,\n  FlowNode,\n  FlowExecution,\n  FlowExecutionContext,\n  FlowExecutionResult,\n  FlowExecutionStatus,\n  FlowExecutionUpdate,\n  FlowExecutionUpdateType,\n  FlowTriggerType,\n  NodeExecution,\n  NodeExecutionResult,\n  NodeExecutionStatus,\n  LogLevel,\n  FlowExecutionLog,\n  StartFlowExecutionRequest,\n  AgentNode,\n} from '../types/flow-types.js';\nimport {\n  isInputNode,\n  isAgentNode,\n  isOutputNode,\n} from '../types/flow-types.js';\n\n// ============= CONFIGURATION =============\n\nconst DEFAULT_NODE_TIMEOUT = 300000; // 5 minutes\nconst MAX_RETRY_ATTEMPTS = 3;\nconst RETRY_DELAY_MS = 1000;\n\n// ============= NODE HANDLER INTERFACE =============\n\n/**\n * Interface for node handlers\n * Each node type (input, agent, output) implements this interface\n */\nexport interface NodeHandler {\n  execute(node: FlowNode, context: FlowExecutionContext): Promise<NodeExecutionResult>;\n}\n\n// ============= FLOW EXECUTION SERVICE =============\n\n/**\n * FlowExecutionService - Singleton service for executing flows\n *\n * Manages the lifecycle of flow executions:\n * - Starting new executions\n * - Tracking running executions\n * - Cancelling executions\n * - Emitting real-time updates\n */\nexport class FlowExecutionService extends EventEmitter {\n  private logger: Logger;\n  private activeExecutions: Map<string, FlowExecutionContext> = new Map();\n  private nodeHandlers: Map<string, NodeHandler> = new Map();\n\n  constructor() {\n    super();\n    this.logger = createLogger('FlowExecutionService');\n  }\n\n  /**\n   * Register a node handler for a specific node type\n   */\n  registerNodeHandler(nodeType: string, handler: NodeHandler): void {\n    this.nodeHandlers.set(nodeType, handler);\n    this.logger.info('Node handler registered', { nodeType });\n  }\n\n  /**\n   * Start a new flow execution\n   * @param request - Flow execution request with flowId and input\n   * @returns Flow execution result (or execution ID for async)\n   */\n  async startExecution(request: StartFlowExecutionRequest): Promise<FlowExecutionResult> {\n    const executionId = uuidv4();\n    const startTime = new Date();\n\n    this.logger.info('Starting flow execution', {\n      executionId,\n      flowId: request.flowId,\n      triggeredBy: request.triggeredBy || 'manual',\n    });\n\n    try {\n      // 1. Fetch the flow definition\n      const flow = await this.fetchFlow(request.flowId);\n\n      if (!flow) {\n        throw new Error(`Flow with ID ${request.flowId} not found`);\n      }\n\n      if (!flow.isActive) {\n        throw new Error(`Flow ${flow.name} is not active`);\n      }\n\n      // 2. Create execution record in Strapi\n      const execution = await this.createExecutionRecord({\n        executionId,\n        flowId: request.flowId,\n        input: request.input,\n        triggeredBy: request.triggeredBy || 'manual',\n        triggerData: request.triggerData,\n      });\n\n      // 3. Create execution context\n      const context = this.createExecutionContext(execution, flow, request.input);\n\n      // 4. Store context for active execution tracking\n      this.activeExecutions.set(executionId, context);\n\n      // 5. Emit execution started event\n      this.emitUpdate(context, 'execution_started');\n\n      // 6. Execute the flow\n      try {\n        const result = await this.executeFlow(context);\n\n        // 7. Complete execution\n        await this.completeExecution(context, result);\n\n        return result;\n      } catch (error) {\n        // 8. Handle execution failure\n        await this.failExecution(context, error as Error);\n\n        return {\n          executionId,\n          success: false,\n          status: 'failed',\n          error: error instanceof Error ? error.message : String(error),\n          errorDetails: error instanceof Error ? { stack: error.stack } : undefined,\n          executionTime: Date.now() - startTime.getTime(),\n          tokensUsed: context.execution.tokensUsed,\n          cost: context.execution.cost,\n          nodeExecutions: context.execution.nodeExecutions,\n        };\n      } finally {\n        // 9. Cleanup\n        this.activeExecutions.delete(executionId);\n      }\n    } catch (error) {\n      this.logger.error('Failed to start flow execution', error as Error, {\n        executionId,\n        flowId: request.flowId,\n      });\n\n      return {\n        executionId,\n        success: false,\n        status: 'failed',\n        error: error instanceof Error ? error.message : String(error),\n        executionTime: Date.now() - startTime.getTime(),\n        tokensUsed: 0,\n        cost: 0,\n        nodeExecutions: [],\n      };\n    }\n  }\n\n  /**\n   * Cancel a running flow execution\n   */\n  async cancelExecution(executionId: string): Promise<boolean> {\n    const context = this.activeExecutions.get(executionId);\n\n    if (!context) {\n      this.logger.warn('Execution not found or already completed', { executionId });\n      return false;\n    }\n\n    this.logger.info('Cancelling flow execution', { executionId });\n\n    // Set cancellation flag\n    context.isCancelled = true;\n\n    // Update execution status\n    context.execution.status = 'cancelled';\n    context.execution.completedAt = new Date();\n    context.execution.executionTime = Date.now() - (context.execution.startedAt?.getTime() || Date.now());\n\n    // Update in Strapi\n    await this.updateExecutionInStrapi(context.execution);\n\n    // Emit cancellation event\n    this.emitUpdate(context, 'execution_cancelled');\n\n    // Remove from active executions\n    this.activeExecutions.delete(executionId);\n\n    return true;\n  }\n\n  /**\n   * Get status of a running execution\n   */\n  getExecutionStatus(executionId: string): FlowExecution | null {\n    const context = this.activeExecutions.get(executionId);\n    return context?.execution || null;\n  }\n\n  /**\n   * Get all active execution IDs\n   */\n  getActiveExecutionIds(): string[] {\n    return Array.from(this.activeExecutions.keys());\n  }\n\n  // ============= PRIVATE: FLOW EXECUTION LOGIC =============\n\n  /**\n   * Execute the flow by traversing nodes in sequence\n   */\n  private async executeFlow(context: FlowExecutionContext): Promise<FlowExecutionResult> {\n    const { flow, execution } = context;\n    const startTime = context.startTime;\n\n    // Find the entry node (first input node or first node if no input)\n    let currentNode = this.findEntryNode(flow);\n\n    if (!currentNode) {\n      throw new Error('No entry node found in flow');\n    }\n\n    context.log('info', `Starting flow execution: ${flow.name}`, undefined, {\n      nodeCount: flow.nodes.length,\n    });\n\n    // Execute nodes in sequence\n    while (currentNode && !context.isCancelled) {\n      const nodeResult = await this.executeNode(currentNode, context);\n\n      if (!nodeResult.success) {\n        // Node failed - check if we should retry\n        const shouldRetry = await this.shouldRetryNode(currentNode, context);\n\n        if (shouldRetry) {\n          context.log('warn', `Retrying node: ${currentNode.name}`, currentNode.nodeId);\n          continue;\n        }\n\n        // No retry - fail the execution\n        throw new Error(nodeResult.error || `Node ${currentNode.name} failed`);\n      }\n\n      // Merge node output into context data\n      if (nodeResult.data) {\n        context.data = { ...context.data, ...nodeResult.data };\n      }\n\n      // Update variables for template interpolation\n      if (nodeResult.output) {\n        context.variables[currentNode.nodeId] = nodeResult.output;\n      }\n\n      // Accumulate tokens and cost\n      if (nodeResult.tokensUsed) {\n        execution.tokensUsed += nodeResult.tokensUsed;\n      }\n      if (nodeResult.cost) {\n        execution.cost += nodeResult.cost;\n      }\n\n      // Check if we should continue\n      if (nodeResult.continueExecution === false) {\n        context.log('info', 'Execution stopped by node', currentNode.nodeId);\n        break;\n      }\n\n      // Move to next node\n      currentNode = this.getNextNode(currentNode, flow);\n    }\n\n    // Check if cancelled\n    if (context.isCancelled) {\n      return {\n        executionId: execution.id,\n        success: false,\n        status: 'cancelled',\n        error: 'Execution was cancelled',\n        executionTime: Date.now() - startTime.getTime(),\n        tokensUsed: execution.tokensUsed,\n        cost: execution.cost,\n        nodeExecutions: execution.nodeExecutions,\n      };\n    }\n\n    // Build final result\n    const executionTime = Date.now() - startTime.getTime();\n\n    return {\n      executionId: execution.id,\n      success: true,\n      status: 'completed',\n      output: context.data,\n      executionTime,\n      tokensUsed: execution.tokensUsed,\n      cost: execution.cost,\n      nodeExecutions: execution.nodeExecutions,\n    };\n  }\n\n  /**\n   * Execute a single node\n   */\n  private async executeNode(\n    node: FlowNode,\n    context: FlowExecutionContext\n  ): Promise<NodeExecutionResult> {\n    const { execution } = context;\n    const nodeStartTime = Date.now();\n\n    // Create node execution record\n    const nodeExecution: NodeExecution = {\n      nodeId: node.nodeId,\n      nodeType: node.type,\n      status: 'running',\n      startedAt: new Date(),\n      retryCount: 0,\n    };\n\n    // Add to execution's node list\n    execution.nodeExecutions.push(nodeExecution);\n    execution.currentNodeId = node.nodeId;\n\n    // Emit node started event\n    this.emitUpdate(context, 'node_started', node.nodeId, node.type);\n\n    context.log('info', `Executing node: ${node.name}`, node.nodeId, {\n      nodeType: node.type,\n    });\n\n    try {\n      // Get the appropriate handler for this node type\n      const handler = this.nodeHandlers.get(node.type);\n\n      if (!handler) {\n        throw new Error(`No handler registered for node type: ${node.type}`);\n      }\n\n      // Execute the node with timeout\n      const result = await this.executeWithTimeout(\n        () => handler.execute(node, context),\n        this.getNodeTimeout(node),\n        `Node ${node.name} timed out`\n      );\n\n      // Update node execution record\n      nodeExecution.status = result.success ? 'completed' : 'failed';\n      nodeExecution.completedAt = new Date();\n      nodeExecution.executionTime = Date.now() - nodeStartTime;\n      nodeExecution.output = result.output;\n      nodeExecution.tokensUsed = result.tokensUsed;\n      nodeExecution.cost = result.cost;\n\n      if (!result.success) {\n        nodeExecution.error = result.error;\n        nodeExecution.errorDetails = result.errorDetails;\n\n        context.log('error', `Node failed: ${result.error}`, node.nodeId);\n        this.emitUpdate(context, 'node_failed', node.nodeId, node.type, {\n          error: result.error,\n        });\n      } else {\n        context.log('info', `Node completed successfully`, node.nodeId, {\n          executionTime: nodeExecution.executionTime,\n        });\n        this.emitUpdate(context, 'node_completed', node.nodeId, node.type, {\n          output: result.output,\n          tokensUsed: result.tokensUsed,\n          cost: result.cost,\n          executionTime: nodeExecution.executionTime,\n        });\n      }\n\n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Update node execution record\n      nodeExecution.status = 'failed';\n      nodeExecution.completedAt = new Date();\n      nodeExecution.executionTime = Date.now() - nodeStartTime;\n      nodeExecution.error = errorMessage;\n      nodeExecution.errorDetails = error instanceof Error ? { stack: error.stack } : undefined;\n\n      context.log('error', `Node execution error: ${errorMessage}`, node.nodeId);\n      this.emitUpdate(context, 'node_failed', node.nodeId, node.type, {\n        error: errorMessage,\n      });\n\n      return {\n        success: false,\n        error: errorMessage,\n        errorDetails: error instanceof Error ? { stack: error.stack } : undefined,\n      };\n    }\n  }\n\n  /**\n   * Execute a function with timeout\n   */\n  private async executeWithTimeout<T>(\n    fn: () => Promise<T>,\n    timeoutMs: number,\n    timeoutMessage: string\n  ): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(timeoutMessage));\n      }, timeoutMs);\n\n      fn()\n        .then((result) => {\n          clearTimeout(timeout);\n          resolve(result);\n        })\n        .catch((error) => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n    });\n  }\n\n  /**\n   * Get timeout for a node (in milliseconds)\n   */\n  private getNodeTimeout(node: FlowNode): number {\n    // Agent nodes may have custom timeout\n    if (isAgentNode(node) && node.timeout) {\n      return node.timeout;\n    }\n    return DEFAULT_NODE_TIMEOUT;\n  }\n\n  /**\n   * Check if a node should be retried after failure\n   */\n  private async shouldRetryNode(node: FlowNode, context: FlowExecutionContext): Promise<boolean> {\n    // Only agent nodes support retry\n    if (!isAgentNode(node) || !node.retryOnError) {\n      return false;\n    }\n\n    // Find the node execution record\n    const nodeExecution = context.execution.nodeExecutions.find(\n      (ne) => ne.nodeId === node.nodeId && ne.status === 'failed'\n    );\n\n    if (!nodeExecution) {\n      return false;\n    }\n\n    const retryCount = nodeExecution.retryCount || 0;\n\n    if (retryCount >= (node.maxRetries || MAX_RETRY_ATTEMPTS)) {\n      context.log('warn', `Max retries reached for node: ${node.name}`, node.nodeId);\n      return false;\n    }\n\n    // Increment retry count\n    nodeExecution.retryCount = retryCount + 1;\n    nodeExecution.status = 'pending';\n\n    // Wait before retry\n    await this.delay(RETRY_DELAY_MS * (retryCount + 1));\n\n    context.log('info', `Retrying node (attempt ${retryCount + 1})`, node.nodeId);\n\n    return true;\n  }\n\n  /**\n   * Find the entry node of the flow\n   */\n  private findEntryNode(flow: Flow): FlowNode | null {\n    // First, try to find an input node\n    const inputNode = flow.nodes.find((n) => isInputNode(n));\n    if (inputNode) {\n      return inputNode;\n    }\n\n    // Otherwise, return the first node\n    return flow.nodes[0] || null;\n  }\n\n  /**\n   * Get the next node in the flow sequence\n   */\n  private getNextNode(currentNode: FlowNode, flow: Flow): FlowNode | null {\n    if (!currentNode.nextNodeId) {\n      return null;\n    }\n\n    return flow.nodes.find((n) => n.nodeId === currentNode.nextNodeId) || null;\n  }\n\n  // ============= PRIVATE: STRAPI INTEGRATION =============\n\n  /**\n   * Fetch a flow definition from Strapi\n   */\n  private async fetchFlow(flowId: string): Promise<Flow | null> {\n    try {\n      const response = await strapiClient.getFlow(flowId);\n      return response;\n    } catch (error) {\n      this.logger.error('Failed to fetch flow', error as Error, { flowId });\n      return null;\n    }\n  }\n\n  /**\n   * Create an execution record in Strapi\n   */\n  private async createExecutionRecord(params: {\n    executionId: string;\n    flowId: string;\n    input: Record<string, any>;\n    triggeredBy: FlowTriggerType;\n    triggerData?: Record<string, any>;\n  }): Promise<FlowExecution> {\n    try {\n      const response = await strapiClient.createFlowExecution({\n        flowId: params.flowId,\n        status: 'running',\n        input: params.input,\n        triggeredBy: params.triggeredBy,\n        triggerData: params.triggerData,\n        startedAt: new Date(),\n        logs: [],\n        nodeExecutions: [],\n        tokensUsed: 0,\n        cost: 0,\n        retryCount: 0,\n      });\n\n      return {\n        id: response.id || params.executionId,\n        flowId: params.flowId,\n        status: 'running',\n        input: params.input,\n        logs: [],\n        nodeExecutions: [],\n        tokensUsed: 0,\n        cost: 0,\n        triggeredBy: params.triggeredBy,\n        triggerData: params.triggerData,\n        retryCount: 0,\n        startedAt: new Date(),\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n    } catch (error) {\n      this.logger.error('Failed to create execution record', error as Error);\n      // Return a local execution object if Strapi fails\n      return {\n        id: params.executionId,\n        flowId: params.flowId,\n        status: 'running',\n        input: params.input,\n        logs: [],\n        nodeExecutions: [],\n        tokensUsed: 0,\n        cost: 0,\n        triggeredBy: params.triggeredBy,\n        triggerData: params.triggerData,\n        retryCount: 0,\n        startedAt: new Date(),\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n    }\n  }\n\n  /**\n   * Update execution record in Strapi\n   */\n  private async updateExecutionInStrapi(execution: FlowExecution): Promise<void> {\n    try {\n      await strapiClient.updateFlowExecution(execution.id, {\n        status: execution.status,\n        output: execution.output,\n        logs: execution.logs,\n        error: execution.error,\n        errorDetails: execution.errorDetails,\n        completedAt: execution.completedAt,\n        executionTime: execution.executionTime,\n        nodeExecutions: execution.nodeExecutions,\n        currentNodeId: execution.currentNodeId,\n        tokensUsed: execution.tokensUsed,\n        cost: execution.cost,\n      });\n    } catch (error) {\n      this.logger.error('Failed to update execution in Strapi', error as Error, {\n        executionId: execution.id,\n      });\n    }\n  }\n\n  /**\n   * Complete a flow execution\n   */\n  private async completeExecution(\n    context: FlowExecutionContext,\n    result: FlowExecutionResult\n  ): Promise<void> {\n    const { execution } = context;\n\n    execution.status = 'completed';\n    execution.output = result.output;\n    execution.completedAt = new Date();\n    execution.executionTime = result.executionTime;\n\n    await this.updateExecutionInStrapi(execution);\n\n    context.log('info', 'Flow execution completed successfully', undefined, {\n      executionTime: result.executionTime,\n      tokensUsed: result.tokensUsed,\n      cost: result.cost,\n    });\n\n    this.emitUpdate(context, 'execution_completed', undefined, undefined, {\n      output: result.output,\n      executionTime: result.executionTime,\n      tokensUsed: result.tokensUsed,\n      cost: result.cost,\n    });\n  }\n\n  /**\n   * Fail a flow execution\n   */\n  private async failExecution(context: FlowExecutionContext, error: Error): Promise<void> {\n    const { execution } = context;\n\n    execution.status = 'failed';\n    execution.error = error.message;\n    execution.errorDetails = { stack: error.stack };\n    execution.completedAt = new Date();\n    execution.executionTime = Date.now() - (execution.startedAt?.getTime() || Date.now());\n\n    await this.updateExecutionInStrapi(execution);\n\n    context.log('error', `Flow execution failed: ${error.message}`);\n\n    this.emitUpdate(context, 'execution_failed', undefined, undefined, {\n      error: error.message,\n    });\n  }\n\n  // ============= PRIVATE: CONTEXT & HELPERS =============\n\n  /**\n   * Create execution context\n   */\n  private createExecutionContext(\n    execution: FlowExecution,\n    flow: Flow,\n    input: Record<string, any>\n  ): FlowExecutionContext {\n    const context: FlowExecutionContext = {\n      execution,\n      flow,\n      data: { ...input },\n      input,\n      variables: { input },\n      startTime: new Date(),\n      log: (level: LogLevel, message: string, nodeId?: string, data?: Record<string, any>) => {\n        this.addLog(context, level, message, nodeId, data);\n      },\n      isCancelled: false,\n      onUpdate: (update: FlowExecutionUpdate) => {\n        this.emit('execution-update', update);\n      },\n    };\n\n    return context;\n  }\n\n  /**\n   * Add a log entry to the execution\n   */\n  private addLog(\n    context: FlowExecutionContext,\n    level: LogLevel,\n    message: string,\n    nodeId?: string,\n    data?: Record<string, any>\n  ): void {\n    const logEntry: FlowExecutionLog = {\n      timestamp: new Date(),\n      level,\n      message,\n      nodeId,\n      data,\n    };\n\n    context.execution.logs.push(logEntry);\n\n    // Also emit as update for real-time monitoring\n    if (context.onUpdate) {\n      context.onUpdate({\n        type: 'log',\n        executionId: context.execution.id,\n        timestamp: new Date(),\n        nodeId,\n        data: {\n          log: logEntry,\n        },\n      });\n    }\n\n    // Log to server logger as well\n    this.logger[level](message, {\n      executionId: context.execution.id,\n      nodeId,\n      ...data,\n    });\n  }\n\n  /**\n   * Emit an execution update event\n   */\n  private emitUpdate(\n    context: FlowExecutionContext,\n    type: FlowExecutionUpdateType,\n    nodeId?: string,\n    nodeType?: string,\n    data?: Record<string, any>\n  ): void {\n    const update: FlowExecutionUpdate = {\n      type,\n      executionId: context.execution.id,\n      timestamp: new Date(),\n      nodeId,\n      nodeType: nodeType as any,\n      data: {\n        status: context.execution.status,\n        ...data,\n      },\n    };\n\n    // Call onUpdate callback if set\n    if (context.onUpdate) {\n      context.onUpdate(update);\n    }\n\n    // Also emit on EventEmitter for SSE\n    this.emit('execution-update', update);\n  }\n\n  /**\n   * Delay helper for retries\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// ============= SINGLETON EXPORT =============\n\n/**\n * Singleton instance of FlowExecutionService\n * Use this throughout the application for flow execution\n */\nexport const flowExecutionService = new FlowExecutionService();\n",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:46.897448",
  "last_updated": "2026-01-02T15:21:46.916051"
}