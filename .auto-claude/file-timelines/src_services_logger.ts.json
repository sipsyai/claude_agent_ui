{
  "file_path": "src/services/logger.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import pino, { Logger as PinoLogger } from 'pino';\nimport { PassThrough } from 'stream';\nimport { LogFormatter } from './log-formatter.js';\n\nexport interface LogContext {\n  component?: string;\n  sessionId?: string;\n  streamingId?: string;\n  requestId?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n}\n\n/**\n * Wrapper class for Pino logger that provides an intuitive API\n * Translates logger.method('message', context) to Pino's logger.method(context, 'message')\n */\n// Re-export CUILogger as Logger for backward compatibility\nexport type Logger = CUILogger;\n\nexport class CUILogger {\n  constructor(private pinoLogger: PinoLogger) {}\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  debug(message: string, context?: any): void {\n    if (context !== undefined) {\n      this.pinoLogger.debug(context, message);\n    } else {\n      this.pinoLogger.debug(message);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  info(message: string, context?: any): void {\n    if (context !== undefined) {\n      this.pinoLogger.info(context, message);\n    } else {\n      this.pinoLogger.info(message);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  warn(message: string, error?: Error | unknown, context?: any): void {\n    if (error instanceof Error) {\n      const logData = { err: error, ...context };\n      this.pinoLogger.warn(logData, message);\n    } else if (error !== undefined && context !== undefined) {\n      // error is actually context, context is extra data\n      const logData = { ...error, ...context };\n      this.pinoLogger.warn(logData, message);\n    } else if (error !== undefined) {\n      // error is context\n      this.pinoLogger.warn(error, message);\n    } else {\n      this.pinoLogger.warn(message);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error(message: string, error?: Error | unknown, context?: any): void {\n    if (error instanceof Error) {\n      const logData = { err: error, ...context };\n      this.pinoLogger.error(logData, message);\n    } else if (error !== undefined && context !== undefined) {\n      // error is actually context, context is extra data\n      const logData = { ...error, ...context };\n      this.pinoLogger.error(logData, message);\n    } else if (error !== undefined) {\n      // error is context\n      this.pinoLogger.error(error, message);\n    } else {\n      this.pinoLogger.error(message);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  fatal(message: string, error?: Error | unknown, context?: any): void {\n    if (error instanceof Error) {\n      const logData = { err: error, ...context };\n      this.pinoLogger.fatal(logData, message);\n    } else if (error !== undefined && context !== undefined) {\n      // error is actually context, context is extra data\n      const logData = { ...error, ...context };\n      this.pinoLogger.fatal(logData, message);\n    } else if (error !== undefined) {\n      // error is context\n      this.pinoLogger.fatal(error, message);\n    } else {\n      this.pinoLogger.fatal(message);\n    }\n  }\n\n  // Support for creating child loggers\n  child(context: LogContext): CUILogger {\n    return new CUILogger(this.pinoLogger.child(context));\n  }\n}\n\n/**\n * Centralized logger service using Pino\n * Provides consistent logging across all CUI components\n * Log level is controlled by LOG_LEVEL environment variable\n */\nclass LoggerService {\n  private static instance: LoggerService;\n  private baseLogger: PinoLogger;\n  private logInterceptStream: PassThrough;\n  private childLoggers: Map<string, PinoLogger> = new Map();\n\n  private constructor() {\n    // Get log level from environment variable, default to 'info'\n    const logLevel = process.env.LOG_LEVEL || 'info';\n    \n    // Create a pass-through stream to intercept logs\n    this.logInterceptStream = new PassThrough();\n    \n    // Forward logs to the log buffer (lazy loaded to avoid circular dependency)\n    this.logInterceptStream.on('data', (chunk) => {\n      const logLine = chunk.toString().trim();\n      if (logLine) {\n        // Lazy load to avoid circular dependency\n        import('@/services/log-stream-buffer').then(({ logStreamBuffer }) => {\n          logStreamBuffer.addLog(logLine);\n        }).catch(() => {\n          // Silently ignore if log buffer is not available\n        });\n      }\n    });\n    \n    const formatter = new LogFormatter();\n    formatter.pipe(process.stdout);\n    \n    // Create multi-stream configuration with formatter\n    const streams = [\n      { level: logLevel as pino.Level, stream: formatter },\n      { level: logLevel as pino.Level, stream: this.logInterceptStream }\n    ];\n    \n    this.baseLogger = pino({\n      level: logLevel,\n      formatters: {\n        level: (label) => {\n          return { level: label };\n        }\n      },\n      timestamp: pino.stdTimeFunctions.isoTime,\n      // Enable in test environment if debug level, otherwise suppress\n      enabled: process.env.NODE_ENV !== 'test' || logLevel === 'debug'\n    }, pino.multistream(streams));\n  }\n\n  /**\n   * Get the singleton logger instance\n   */\n  static getInstance(): LoggerService {\n    if (!LoggerService.instance) {\n      LoggerService.instance = new LoggerService();\n    }\n    return LoggerService.instance;\n  }\n\n  /**\n   * Create a child logger with context\n   */\n  child(context: LogContext): CUILogger {\n    const contextKey = JSON.stringify(context);\n    if (!this.childLoggers.has(contextKey)) {\n      this.childLoggers.set(contextKey, this.baseLogger.child(context));\n    }\n    return new CUILogger(this.childLoggers.get(contextKey)!);\n  }\n\n  /**\n   * Get the base logger\n   */\n  getLogger(): CUILogger {\n    return new CUILogger(this.baseLogger);\n  }\n\n  /**\n   * Log debug message\n   */\n  debug(message: string, context?: LogContext): void {\n    if (context) {\n      this.baseLogger.child(context).debug(message);\n    } else {\n      this.baseLogger.debug(message);\n    }\n  }\n\n  /**\n   * Log info message\n   */\n  info(message: string, context?: LogContext): void {\n    if (context) {\n      this.baseLogger.child(context).info(message);\n    } else {\n      this.baseLogger.info(message);\n    }\n  }\n\n  /**\n   * Log warning message\n   */\n  warn(message: string, context?: LogContext): void {\n    if (context) {\n      this.baseLogger.child(context).warn(message);\n    } else {\n      this.baseLogger.warn(message);\n    }\n  }\n\n  /**\n   * Log error message\n   */\n  error(message: string, error?: Error | unknown, context?: LogContext): void {\n    const logData = error ? { err: error } : {};\n    if (context) {\n      this.baseLogger.child({ ...context, ...logData }).error(message);\n    } else {\n      this.baseLogger.error(logData, message);\n    }\n  }\n\n  /**\n   * Log fatal message\n   */\n  fatal(message: string, error?: Error | unknown, context?: LogContext): void {\n    const logData = error ? { err: error } : {};\n    if (context) {\n      this.baseLogger.child({ ...context, ...logData }).fatal(message);\n    } else {\n      this.baseLogger.fatal(logData, message);\n    }\n  }\n}\n\n// Export singleton instance\nexport const logger = LoggerService.getInstance();\n\n// Export factory function for creating component loggers\nexport function createLogger(component: string, baseContext?: LogContext): CUILogger {\n  const context = { component, ...baseContext };\n  return logger.child(context);\n}",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import pino, { Logger as PinoLogger } from 'pino';\nimport { PassThrough } from 'stream';\nimport { LogFormatter } from './log-formatter.js';\n\n/**\n * Context metadata attached to log entries for filtering and correlation.\n *\n * LogContext provides structured metadata fields that enrich log entries with\n * contextual information about the component, session, stream, or request being logged.\n * This enables powerful log filtering, aggregation, and distributed tracing capabilities.\n *\n * @example Basic component context\n * ```typescript\n * const logger = createLogger('MCPService');\n * logger.info('MCP server started', { serverName: 'filesystem' });\n * // Output: [INFO] [MCPService] MCP server started { serverName: 'filesystem' }\n * ```\n *\n * @example Session tracking\n * ```typescript\n * const logger = createLogger('ChatService', { sessionId: 'session-123' });\n * logger.debug('Processing message', { messageId: 'msg-456' });\n * // Output: [DEBUG] [ChatService] [session-123] Processing message { messageId: 'msg-456' }\n * ```\n *\n * @example Streaming context\n * ```typescript\n * const logger = createLogger('ClaudeSdkService', {\n *   sessionId: 'session-123',\n *   streamingId: 'stream-789'\n * });\n * logger.info('Streaming response chunk', { chunkSize: 512 });\n * // All streaming logs now tagged with streamingId for correlation\n * ```\n *\n * @example Request tracing\n * ```typescript\n * const logger = createLogger('ApiHandler', { requestId: req.id });\n * logger.info('API request received', { method: 'POST', path: '/chat/message' });\n * // Trace all logs for a specific request\n * ```\n *\n * @see {@link createLogger} for factory function creating loggers with context\n * @see {@link CUILogger.child} for creating child loggers with additional context\n */\nexport interface LogContext {\n  /** Component name (e.g., 'ChatService', 'MCPService', 'ClaudeSdkService') */\n  component?: string;\n  /** Chat session identifier for correlating logs across a conversation */\n  sessionId?: string;\n  /** Stream identifier for tracking SDK streaming response logs */\n  streamingId?: string;\n  /** HTTP request identifier for distributed tracing */\n  requestId?: string;\n  /** Additional custom context fields for domain-specific metadata */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n}\n\n/**\n * Claude UI Logger - Ergonomic wrapper around Pino logger with intuitive parameter order.\n *\n * CUILogger wraps the Pino logger to provide a more developer-friendly API by accepting\n * parameters in a natural order: `logger.method(message, context)` instead of Pino's\n * `logger.method(context, message)`. This wrapper maintains full Pino performance while\n * improving code readability and reducing parameter order mistakes.\n *\n * ## Key Features\n *\n * - **Intuitive API**: Natural parameter order (message, then context)\n * - **Full Pino Integration**: Zero performance overhead, direct Pino delegation\n * - **Log Levels**: Supports debug, info, warn, error, fatal levels\n * - **Context Binding**: Create child loggers with persistent context metadata\n * - **Error Handling**: Automatic Error object serialization with stack traces\n * - **TypeScript Support**: Fully typed with generic context parameters\n *\n * ## Log Levels (from lowest to highest priority)\n *\n * 1. **debug**: Verbose diagnostic information for development and troubleshooting\n * 2. **info**: General informational messages about application operation\n * 3. **warn**: Warning messages for potentially harmful situations\n * 4. **error**: Error events that might still allow the app to continue running\n * 5. **fatal**: Critical errors causing application shutdown or severe failures\n *\n * Log level is controlled by the `LOG_LEVEL` environment variable (default: 'info').\n * Only messages at or above the configured level are output.\n *\n * ## Pino Integration\n *\n * CUILogger is a thin wrapper around Pino (https://getpino.io/), a fast JSON logger\n * for Node.js. Pino advantages:\n * - **Performance**: 5x faster than alternatives (minimal overhead)\n * - **JSON Output**: Structured logging for easy parsing and analysis\n * - **Stream-Based**: Outputs to streams (stdout, files, log aggregation services)\n * - **Child Loggers**: Context binding with zero duplication\n *\n * @example Basic logging with different levels\n * ```typescript\n * const logger = createLogger('MyComponent');\n *\n * logger.debug('Detailed debug information', { stepNumber: 1 });\n * logger.info('User logged in', { userId: '123' });\n * logger.warn('Deprecated API usage', { api: 'oldMethod' });\n * logger.error('Failed to save file', new Error('Disk full'), { filename: 'data.json' });\n * logger.fatal('Database connection lost', new Error('Connection timeout'));\n * ```\n *\n * @example Context binding with child loggers\n * ```typescript\n * const baseLogger = createLogger('ChatService');\n * const sessionLogger = baseLogger.child({ sessionId: 'session-123' });\n *\n * // All logs from sessionLogger automatically include sessionId\n * sessionLogger.info('Message received');\n * sessionLogger.info('Message processed', { messageId: 'msg-456' });\n *\n * // Create deeper nesting\n * const streamLogger = sessionLogger.child({ streamingId: 'stream-789' });\n * streamLogger.debug('Streaming chunk', { chunkSize: 512 });\n * // Output includes: component, sessionId, streamingId\n * ```\n *\n * @example Error logging with stack traces\n * ```typescript\n * const logger = createLogger('ApiHandler');\n *\n * try {\n *   await riskyOperation();\n * } catch (error) {\n *   // Error object automatically serialized with stack trace\n *   logger.error('Operation failed', error, { operation: 'riskyOperation' });\n * }\n * ```\n *\n * @example Using warn() method variants\n * ```typescript\n * const logger = createLogger('ValidationService');\n *\n * // Variant 1: Message only\n * logger.warn('Validation threshold exceeded');\n *\n * // Variant 2: Message with context\n * logger.warn('Validation threshold exceeded', { count: 150, threshold: 100 });\n *\n * // Variant 3: Message with Error\n * logger.warn('Network unstable', new Error('Timeout'));\n *\n * // Variant 4: Message with Error and context\n * logger.warn('Network unstable', new Error('Timeout'), { retryCount: 3 });\n * ```\n *\n * @example Integration with service classes\n * ```typescript\n * class MCPService {\n *   private logger = createLogger('MCPService');\n *\n *   async testServer(serverId: string) {\n *     this.logger.info('Testing MCP server', { serverId });\n *\n *     try {\n *       const result = await this.performTest(serverId);\n *       this.logger.info('Server test completed', { serverId, success: true });\n *       return result;\n *     } catch (error) {\n *       this.logger.error('Server test failed', error, { serverId });\n *       throw error;\n *     }\n *   }\n * }\n * ```\n *\n * @see {@link createLogger} for factory function creating CUILogger instances\n * @see {@link LoggerService} for singleton logger service managing logger lifecycle\n * @see {@link LogContext} for context metadata structure\n * @see https://getpino.io/ for Pino documentation\n */\n// Re-export CUILogger as Logger for backward compatibility\nexport type Logger = CUILogger;\n\nexport class CUILogger {\n  /**\n   * Creates a CUILogger instance wrapping a Pino logger.\n   *\n   * Note: Use {@link createLogger} factory function instead of direct instantiation.\n   * The factory function creates loggers through LoggerService for proper configuration.\n   *\n   * @param pinoLogger - Pino logger instance to wrap\n   * @private\n   */\n  constructor(private pinoLogger: PinoLogger) {}\n\n  /**\n   * Log a debug-level message with optional context metadata.\n   *\n   * Debug logs provide verbose diagnostic information for development and troubleshooting.\n   * Use for detailed tracing of application flow, variable values, and internal state.\n   * Debug logs are typically disabled in production (`LOG_LEVEL=info` or higher).\n   *\n   * @param message - Human-readable log message\n   * @param context - Optional metadata object attached to the log entry\n   *\n   * @example Basic debug logging\n   * ```typescript\n   * const logger = createLogger('ChatService');\n   * logger.debug('Processing user message');\n   * ```\n   *\n   * @example Debug with context\n   * ```typescript\n   * logger.debug('Loading MCP server config', {\n   *   serverId: 'mcp-123',\n   *   configPath: '/path/to/config'\n   * });\n   * ```\n   *\n   * @example Debug with detailed state\n   * ```typescript\n   * logger.debug('State transition', {\n   *   from: 'idle',\n   *   to: 'processing',\n   *   queueSize: 5,\n   *   activeConnections: 3\n   * });\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  debug(message: string, context?: any): void {\n    if (context !== undefined) {\n      this.pinoLogger.debug(context, message);\n    } else {\n      this.pinoLogger.debug(message);\n    }\n  }\n\n  /**\n   * Log an info-level message with optional context metadata.\n   *\n   * Info logs record general informational messages about normal application operation.\n   * Use for significant events like service startup, user actions, or operational milestones.\n   * Info is the default log level for production environments.\n   *\n   * @param message - Human-readable log message\n   * @param context - Optional metadata object attached to the log entry\n   *\n   * @example Basic info logging\n   * ```typescript\n   * const logger = createLogger('MCPService');\n   * logger.info('MCP server started successfully');\n   * ```\n   *\n   * @example Info with context\n   * ```typescript\n   * logger.info('User authenticated', {\n   *   userId: '123',\n   *   method: 'oauth',\n   *   provider: 'github'\n   * });\n   * ```\n   *\n   * @example Info for operational events\n   * ```typescript\n   * logger.info('Chat session created', {\n   *   sessionId: 'session-123',\n   *   agentId: 'agent-456',\n   *   timestamp: new Date().toISOString()\n   * });\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  info(message: string, context?: any): void {\n    if (context !== undefined) {\n      this.pinoLogger.info(context, message);\n    } else {\n      this.pinoLogger.info(message);\n    }\n  }\n\n  /**\n   * Log a warning-level message with optional Error object and context metadata.\n   *\n   * Warning logs indicate potentially harmful situations that don't prevent operation\n   * but may require attention. Use for deprecated features, fallback behavior, or\n   * recoverable issues that might indicate underlying problems.\n   *\n   * Method supports multiple call signatures for flexible usage:\n   * - `warn(message)` - Simple warning\n   * - `warn(message, context)` - Warning with metadata\n   * - `warn(message, error)` - Warning with Error object\n   * - `warn(message, error, context)` - Warning with Error and metadata\n   *\n   * @param message - Human-readable log message\n   * @param error - Optional Error object (auto-serialized with stack trace) or context object\n   * @param context - Optional metadata object (if error parameter is an Error object)\n   *\n   * @example Simple warning\n   * ```typescript\n   * const logger = createLogger('ConfigService');\n   * logger.warn('Using default configuration');\n   * ```\n   *\n   * @example Warning with context\n   * ```typescript\n   * logger.warn('Cache miss, loading from database', {\n   *   key: 'user:123',\n   *   cacheTtl: 300\n   * });\n   * ```\n   *\n   * @example Warning with Error\n   * ```typescript\n   * try {\n   *   await loadOptionalPlugin();\n   * } catch (error) {\n   *   logger.warn('Optional plugin failed to load', error);\n   * }\n   * ```\n   *\n   * @example Warning with Error and context\n   * ```typescript\n   * try {\n   *   await connectToSecondaryDb();\n   * } catch (error) {\n   *   logger.warn('Secondary database unavailable, using primary only', error, {\n   *     dbHost: 'db-secondary.example.com',\n   *     fallbackEnabled: true\n   *   });\n   * }\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  warn(message: string, error?: Error | unknown, context?: any): void {\n    if (error instanceof Error) {\n      const logData = { err: error, ...context };\n      this.pinoLogger.warn(logData, message);\n    } else if (error !== undefined && context !== undefined) {\n      // error is actually context, context is extra data\n      const logData = { ...error, ...context };\n      this.pinoLogger.warn(logData, message);\n    } else if (error !== undefined) {\n      // error is context\n      this.pinoLogger.warn(error, message);\n    } else {\n      this.pinoLogger.warn(message);\n    }\n  }\n\n  /**\n   * Log an error-level message with optional Error object and context metadata.\n   *\n   * Error logs record error events that might still allow the application to continue\n   * running. Use for handled exceptions, failed operations, or error conditions that\n   * don't require immediate shutdown. Error objects are automatically serialized with\n   * full stack traces for debugging.\n   *\n   * Method supports multiple call signatures for flexible usage:\n   * - `error(message)` - Simple error\n   * - `error(message, context)` - Error with metadata\n   * - `error(message, error)` - Error with Error object\n   * - `error(message, error, context)` - Error with Error and metadata\n   *\n   * @param message - Human-readable log message\n   * @param error - Optional Error object (auto-serialized with stack trace) or context object\n   * @param context - Optional metadata object (if error parameter is an Error object)\n   *\n   * @example Simple error\n   * ```typescript\n   * const logger = createLogger('ApiHandler');\n   * logger.error('Request validation failed');\n   * ```\n   *\n   * @example Error with context\n   * ```typescript\n   * logger.error('Database query failed', {\n   *   query: 'SELECT * FROM users',\n   *   duration: 5000\n   * });\n   * ```\n   *\n   * @example Error with Error object\n   * ```typescript\n   * try {\n   *   await processPayment();\n   * } catch (error) {\n   *   logger.error('Payment processing failed', error);\n   *   throw error; // Re-throw for upstream handling\n   * }\n   * ```\n   *\n   * @example Error with Error and context\n   * ```typescript\n   * try {\n   *   await sendNotification(userId, message);\n   * } catch (error) {\n   *   logger.error('Notification delivery failed', error, {\n   *     userId,\n   *     messageType: 'push',\n   *     retryable: true\n   *   });\n   * }\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error(message: string, error?: Error | unknown, context?: any): void {\n    if (error instanceof Error) {\n      const logData = { err: error, ...context };\n      this.pinoLogger.error(logData, message);\n    } else if (error !== undefined && context !== undefined) {\n      // error is actually context, context is extra data\n      const logData = { ...error, ...context };\n      this.pinoLogger.error(logData, message);\n    } else if (error !== undefined) {\n      // error is context\n      this.pinoLogger.error(error, message);\n    } else {\n      this.pinoLogger.error(message);\n    }\n  }\n\n  /**\n   * Log a fatal-level message with optional Error object and context metadata.\n   *\n   * Fatal logs record critical errors that cause application shutdown or severe failures\n   * preventing normal operation. Use for unrecoverable errors like database connection\n   * failures, corrupted critical data, or missing required configuration. Fatal logs\n   * typically trigger alerts and immediate investigation.\n   *\n   * Method supports multiple call signatures for flexible usage:\n   * - `fatal(message)` - Simple fatal error\n   * - `fatal(message, context)` - Fatal error with metadata\n   * - `fatal(message, error)` - Fatal error with Error object\n   * - `fatal(message, error, context)` - Fatal error with Error and metadata\n   *\n   * @param message - Human-readable log message\n   * @param error - Optional Error object (auto-serialized with stack trace) or context object\n   * @param context - Optional metadata object (if error parameter is an Error object)\n   *\n   * @example Simple fatal error\n   * ```typescript\n   * const logger = createLogger('DatabaseService');\n   * logger.fatal('Database connection pool exhausted');\n   * process.exit(1);\n   * ```\n   *\n   * @example Fatal error with context\n   * ```typescript\n   * logger.fatal('Configuration file corrupted', {\n   *   configPath: '/etc/app/config.json',\n   *   parseError: 'Unexpected token',\n   *   canRecover: false\n   * });\n   * ```\n   *\n   * @example Fatal error with Error object\n   * ```typescript\n   * try {\n   *   await initializeCriticalService();\n   * } catch (error) {\n   *   logger.fatal('Critical service initialization failed', error);\n   *   process.exit(1);\n   * }\n   * ```\n   *\n   * @example Fatal error with Error and context\n   * ```typescript\n   * try {\n   *   await connectToDatabase();\n   * } catch (error) {\n   *   logger.fatal('Database connection failed after all retries', error, {\n   *     host: process.env.DB_HOST,\n   *     retryCount: 5,\n   *     lastAttempt: new Date().toISOString()\n   *   });\n   *   process.exit(1);\n   * }\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  fatal(message: string, error?: Error | unknown, context?: any): void {\n    if (error instanceof Error) {\n      const logData = { err: error, ...context };\n      this.pinoLogger.fatal(logData, message);\n    } else if (error !== undefined && context !== undefined) {\n      // error is actually context, context is extra data\n      const logData = { ...error, ...context };\n      this.pinoLogger.fatal(logData, message);\n    } else if (error !== undefined) {\n      // error is context\n      this.pinoLogger.fatal(error, message);\n    } else {\n      this.pinoLogger.fatal(message);\n    }\n  }\n\n  /**\n   * Create a child logger with persistent context metadata.\n   *\n   * Child loggers inherit the parent logger's configuration and automatically include\n   * the provided context in all log entries. This enables context binding without\n   * passing context to every log call. Child loggers are efficient (Pino uses\n   * prototypal inheritance) and can be nested for hierarchical context.\n   *\n   * Common use cases:\n   * - Binding component/class name to all logs within a service\n   * - Tracking session/request ID across async operations\n   * - Adding user context to authentication flows\n   * - Correlating logs for distributed tracing\n   *\n   * @param context - Context metadata automatically included in all child logger logs\n   * @returns New CUILogger instance with bound context\n   *\n   * @example Component-level context\n   * ```typescript\n   * const baseLogger = createLogger('ChatService');\n   * const sessionLogger = baseLogger.child({ sessionId: 'session-123' });\n   *\n   * sessionLogger.info('Message received'); // Includes sessionId\n   * sessionLogger.info('Message processed'); // Includes sessionId\n   * ```\n   *\n   * @example Nested child loggers\n   * ```typescript\n   * const serviceLogger = createLogger('ClaudeSdkService');\n   * const sessionLogger = serviceLogger.child({ sessionId: 'session-123' });\n   * const streamLogger = sessionLogger.child({ streamingId: 'stream-789' });\n   *\n   * streamLogger.debug('Chunk received', { size: 512 });\n   * // Output includes: component, sessionId, streamingId, size\n   * ```\n   *\n   * @example Request tracing\n   * ```typescript\n   * async function handleRequest(req, res) {\n   *   const logger = createLogger('ApiHandler').child({ requestId: req.id });\n   *\n   *   logger.info('Request started', { method: req.method, path: req.path });\n   *\n   *   try {\n   *     const result = await processRequest(req, logger);\n   *     logger.info('Request completed', { status: 200 });\n   *     res.json(result);\n   *   } catch (error) {\n   *     logger.error('Request failed', error);\n   *     res.status(500).json({ error: 'Internal server error' });\n   *   }\n   * }\n   * ```\n   *\n   * @example User context binding\n   * ```typescript\n   * class AuthService {\n   *   private logger = createLogger('AuthService');\n   *\n   *   async authenticate(userId: string) {\n   *     const userLogger = this.logger.child({ userId });\n   *\n   *     userLogger.info('Authentication started');\n   *     const token = await this.generateToken(userId);\n   *     userLogger.info('Token generated', { tokenExpiry: token.expiresAt });\n   *\n   *     return token;\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link LogContext} for context metadata structure\n   */\n  // Support for creating child loggers\n  child(context: LogContext): CUILogger {\n    return new CUILogger(this.pinoLogger.child(context));\n  }\n}\n\n/**\n * Centralized logger service using Pino for consistent logging across all CUI components.\n *\n * LoggerService is a singleton that manages the application's logging infrastructure,\n * providing a unified logging interface with support for multiple output streams,\n * structured logging, context binding, and real-time log streaming. The service\n * integrates Pino for high-performance logging with custom formatters for console\n * output and log stream buffering for real-time UI updates.\n *\n * ## Architecture\n *\n * - **Singleton Pattern**: Single shared instance ensures consistent configuration\n * - **Multi-Stream Output**: Logs to both console (formatted) and buffer (raw JSON)\n * - **Child Logger Caching**: Reuses child loggers for same context (performance optimization)\n * - **Lazy Loading**: Log stream buffer loaded on-demand to avoid circular dependencies\n * - **Environment-Driven**: Log level controlled by `LOG_LEVEL` environment variable\n *\n * ## Log Level Configuration\n *\n * Set the `LOG_LEVEL` environment variable to control logging verbosity:\n * - `debug`: All logs (verbose, for development)\n * - `info`: Informational and above (default, for production)\n * - `warn`: Warnings and above (quiet production)\n * - `error`: Errors and fatal only (minimal logging)\n * - `fatal`: Fatal errors only (critical failures)\n *\n * ## Multi-Stream Architecture\n *\n * LoggerService outputs logs to multiple destinations simultaneously:\n *\n * 1. **Console Stream** (via LogFormatter):\n *    - Human-readable colored output for development\n *    - Custom formatting with timestamps and context\n *    - Piped to process.stdout\n *\n * 2. **Intercept Stream** (via PassThrough):\n *    - Raw JSON logs for programmatic consumption\n *    - Forwarded to LogStreamBuffer for real-time UI streaming\n *    - Enables live log viewing in web interface\n *\n * ## Pino Integration Features\n *\n * - **ISO Timestamps**: Consistent timestamp format across all logs\n * - **Level Formatting**: Custom level formatter for readability\n * - **Error Serialization**: Automatic stack trace capture for Error objects\n * - **Child Logger Optimization**: Prototypal inheritance for zero-copy context binding\n * - **Test Mode Support**: Logging can be suppressed in test environment\n *\n * ## Environment Variables\n *\n * - `LOG_LEVEL`: Log level threshold (default: 'info')\n * - `NODE_ENV`: Environment mode ('test' disables logging unless LOG_LEVEL=debug)\n *\n * @example Basic usage via singleton\n * ```typescript\n * import { logger } from '@/services/logger';\n *\n * logger.info('Application started');\n * logger.debug('Debug information', { step: 1 });\n * logger.error('Error occurred', new Error('Something failed'));\n * ```\n *\n * @example Creating component logger with factory\n * ```typescript\n * import { createLogger } from '@/services/logger';\n *\n * const logger = createLogger('ChatService');\n * logger.info('Chat service initialized');\n * ```\n *\n * @example Using child loggers for context binding\n * ```typescript\n * const logger = LoggerService.getInstance();\n * const sessionLogger = logger.child({ sessionId: 'session-123' });\n *\n * sessionLogger.info('Message received');\n * sessionLogger.debug('Processing message', { messageId: 'msg-456' });\n * ```\n *\n * @example Direct method calls on singleton\n * ```typescript\n * const logger = LoggerService.getInstance();\n *\n * logger.debug('Debugging info', { component: 'MCPService' });\n * logger.info('Operation completed', { duration: 150 });\n * logger.warn('Deprecated method used', { method: 'oldApi' });\n * logger.error('Operation failed', new Error('Network timeout'), { retryCount: 3 });\n * logger.fatal('Critical failure', new Error('Database unavailable'));\n * ```\n *\n * @see {@link createLogger} for recommended factory function\n * @see {@link CUILogger} for logger wrapper API\n * @see {@link LogContext} for context metadata structure\n * @see {@link LogFormatter} for console output formatting\n * @see https://getpino.io/ for Pino documentation\n */\nclass LoggerService {\n  /** Singleton instance of LoggerService */\n  private static instance: LoggerService;\n  /** Base Pino logger instance with multi-stream configuration */\n  private baseLogger: PinoLogger;\n  /** PassThrough stream for intercepting logs and forwarding to LogStreamBuffer */\n  private logInterceptStream: PassThrough;\n  /** Cache of child loggers keyed by serialized context (performance optimization) */\n  private childLoggers: Map<string, PinoLogger> = new Map();\n\n  private constructor() {\n    // Get log level from environment variable, default to 'info'\n    const logLevel = process.env.LOG_LEVEL || 'info';\n    \n    // Create a pass-through stream to intercept logs\n    this.logInterceptStream = new PassThrough();\n    \n    // Forward logs to the log buffer (lazy loaded to avoid circular dependency)\n    this.logInterceptStream.on('data', (chunk) => {\n      const logLine = chunk.toString().trim();\n      if (logLine) {\n        // Lazy load to avoid circular dependency\n        import('@/services/log-stream-buffer').then(({ logStreamBuffer }) => {\n          logStreamBuffer.addLog(logLine);\n        }).catch(() => {\n          // Silently ignore if log buffer is not available\n        });\n      }\n    });\n    \n    const formatter = new LogFormatter();\n    formatter.pipe(process.stdout);\n    \n    // Create multi-stream configuration with formatter\n    const streams = [\n      { level: logLevel as pino.Level, stream: formatter },\n      { level: logLevel as pino.Level, stream: this.logInterceptStream }\n    ];\n    \n    this.baseLogger = pino({\n      level: logLevel,\n      formatters: {\n        level: (label) => {\n          return { level: label };\n        }\n      },\n      timestamp: pino.stdTimeFunctions.isoTime,\n      // Enable in test environment if debug level, otherwise suppress\n      enabled: process.env.NODE_ENV !== 'test' || logLevel === 'debug'\n    }, pino.multistream(streams));\n  }\n\n  /**\n   * Get the singleton LoggerService instance.\n   *\n   * Returns the shared LoggerService instance, creating it on first access.\n   * The singleton pattern ensures consistent logging configuration across\n   * the entire application.\n   *\n   * Note: Most code should use {@link createLogger} factory function instead\n   * of accessing LoggerService directly.\n   *\n   * @returns The singleton LoggerService instance\n   *\n   * @example Getting singleton instance\n   * ```typescript\n   * const logger = LoggerService.getInstance();\n   * logger.info('Using singleton instance directly');\n   * ```\n   *\n   * @example Creating child logger from singleton\n   * ```typescript\n   * const logger = LoggerService.getInstance();\n   * const componentLogger = logger.child({ component: 'MyService' });\n   * componentLogger.info('Component initialized');\n   * ```\n   *\n   * @see {@link createLogger} for recommended factory function\n   */\n  static getInstance(): LoggerService {\n    if (!LoggerService.instance) {\n      LoggerService.instance = new LoggerService();\n    }\n    return LoggerService.instance;\n  }\n\n  /**\n   * Create a child logger with persistent context metadata.\n   *\n   * Creates a new CUILogger with bound context that's automatically included in\n   * all log entries. Child loggers are cached for performance - identical context\n   * objects reuse the same underlying Pino logger.\n   *\n   * Caching Strategy:\n   * - Context is serialized to JSON and used as cache key\n   * - Identical context objects return the same child logger\n   * - Reduces memory overhead and improves performance\n   *\n   * @param context - Context metadata automatically included in all logs\n   * @returns CUILogger instance with bound context\n   *\n   * @example Creating child logger with component context\n   * ```typescript\n   * const logger = LoggerService.getInstance();\n   * const chatLogger = logger.child({ component: 'ChatService' });\n   *\n   * chatLogger.info('Service started');\n   * chatLogger.debug('Processing message', { messageId: 'msg-123' });\n   * ```\n   *\n   * @example Child logger caching\n   * ```typescript\n   * const logger = LoggerService.getInstance();\n   *\n   * const logger1 = logger.child({ component: 'MCPService' });\n   * const logger2 = logger.child({ component: 'MCPService' });\n   * // logger1 and logger2 share the same underlying Pino logger (cached)\n   * ```\n   *\n   * @example Nested context\n   * ```typescript\n   * const logger = LoggerService.getInstance();\n   * const serviceLogger = logger.child({ component: 'ClaudeSdkService' });\n   * const sessionLogger = serviceLogger.child({ sessionId: 'session-123' });\n   *\n   * sessionLogger.info('Message processed');\n   * // Output includes: component=ClaudeSdkService, sessionId=session-123\n   * ```\n   *\n   * @see {@link createLogger} for factory function with component name\n   * @see {@link CUILogger.child} for creating child loggers from CUILogger instances\n   * @see {@link LogContext} for context metadata structure\n   */\n  child(context: LogContext): CUILogger {\n    const contextKey = JSON.stringify(context);\n    if (!this.childLoggers.has(contextKey)) {\n      this.childLoggers.set(contextKey, this.baseLogger.child(context));\n    }\n    return new CUILogger(this.childLoggers.get(contextKey)!);\n  }\n\n  /**\n   * Get the base CUILogger instance without context binding.\n   *\n   * Returns a CUILogger wrapping the base Pino logger. For most use cases,\n   * prefer {@link createLogger} factory function or {@link child} method\n   * to create loggers with component context.\n   *\n   * @returns CUILogger instance wrapping base Pino logger\n   *\n   * @example Getting base logger\n   * ```typescript\n   * const logger = LoggerService.getInstance().getLogger();\n   * logger.info('Using base logger');\n   * ```\n   *\n   * @example Prefer createLogger instead\n   * ```typescript\n   * // Better: Use createLogger for automatic component context\n   * const logger = createLogger('MyComponent');\n   * logger.info('Component initialized');\n   * ```\n   *\n   * @see {@link createLogger} for recommended factory function\n   * @see {@link child} for creating logger with context\n   */\n  getLogger(): CUILogger {\n    return new CUILogger(this.baseLogger);\n  }\n\n  /**\n   * Log a debug-level message directly on the singleton instance.\n   *\n   * Convenience method for debug logging without creating a logger instance.\n   * For repeated logging within a component, prefer {@link createLogger} or\n   * {@link child} to create a reusable logger with bound context.\n   *\n   * @param message - Human-readable log message\n   * @param context - Optional context metadata attached to this log entry only\n   *\n   * @example Simple debug logging\n   * ```typescript\n   * LoggerService.getInstance().debug('Processing started');\n   * ```\n   *\n   * @example Debug with context\n   * ```typescript\n   * LoggerService.getInstance().debug('Config loaded', {\n   *   component: 'ConfigService',\n   *   configPath: '/etc/app/config.json'\n   * });\n   * ```\n   *\n   * @see {@link CUILogger.debug} for CUILogger debug method documentation\n   */\n  debug(message: string, context?: LogContext): void {\n    if (context) {\n      this.baseLogger.child(context).debug(message);\n    } else {\n      this.baseLogger.debug(message);\n    }\n  }\n\n  /**\n   * Log an info-level message directly on the singleton instance.\n   *\n   * Convenience method for info logging without creating a logger instance.\n   * For repeated logging within a component, prefer {@link createLogger} or\n   * {@link child} to create a reusable logger with bound context.\n   *\n   * @param message - Human-readable log message\n   * @param context - Optional context metadata attached to this log entry only\n   *\n   * @example Simple info logging\n   * ```typescript\n   * LoggerService.getInstance().info('Application started');\n   * ```\n   *\n   * @example Info with context\n   * ```typescript\n   * LoggerService.getInstance().info('User logged in', {\n   *   component: 'AuthService',\n   *   userId: '123',\n   *   method: 'oauth'\n   * });\n   * ```\n   *\n   * @see {@link CUILogger.info} for CUILogger info method documentation\n   */\n  info(message: string, context?: LogContext): void {\n    if (context) {\n      this.baseLogger.child(context).info(message);\n    } else {\n      this.baseLogger.info(message);\n    }\n  }\n\n  /**\n   * Log a warning-level message directly on the singleton instance.\n   *\n   * Convenience method for warning logging without creating a logger instance.\n   * For repeated logging within a component, prefer {@link createLogger} or\n   * {@link child} to create a reusable logger with bound context.\n   *\n   * @param message - Human-readable log message\n   * @param context - Optional context metadata attached to this log entry only\n   *\n   * @example Simple warning\n   * ```typescript\n   * LoggerService.getInstance().warn('Cache miss, using database');\n   * ```\n   *\n   * @example Warning with context\n   * ```typescript\n   * LoggerService.getInstance().warn('Deprecated API used', {\n   *   component: 'ApiHandler',\n   *   endpoint: '/api/v1/users',\n   *   replacement: '/api/v2/users'\n   * });\n   * ```\n   *\n   * @see {@link CUILogger.warn} for CUILogger warn method documentation\n   */\n  warn(message: string, context?: LogContext): void {\n    if (context) {\n      this.baseLogger.child(context).warn(message);\n    } else {\n      this.baseLogger.warn(message);\n    }\n  }\n\n  /**\n   * Log an error-level message directly on the singleton instance.\n   *\n   * Convenience method for error logging without creating a logger instance.\n   * For repeated logging within a component, prefer {@link createLogger} or\n   * {@link child} to create a reusable logger with bound context.\n   *\n   * @param message - Human-readable log message\n   * @param error - Optional Error object (auto-serialized with stack trace)\n   * @param context - Optional context metadata attached to this log entry only\n   *\n   * @example Simple error\n   * ```typescript\n   * LoggerService.getInstance().error('Database query failed');\n   * ```\n   *\n   * @example Error with Error object\n   * ```typescript\n   * try {\n   *   await connectToDatabase();\n   * } catch (error) {\n   *   LoggerService.getInstance().error('Connection failed', error);\n   * }\n   * ```\n   *\n   * @example Error with Error and context\n   * ```typescript\n   * try {\n   *   await processPayment(orderId);\n   * } catch (error) {\n   *   LoggerService.getInstance().error('Payment failed', error, {\n   *     component: 'PaymentService',\n   *     orderId,\n   *     amount: 99.99\n   *   });\n   * }\n   * ```\n   *\n   * @see {@link CUILogger.error} for CUILogger error method documentation\n   */\n  error(message: string, error?: Error | unknown, context?: LogContext): void {\n    const logData = error ? { err: error } : {};\n    if (context) {\n      this.baseLogger.child({ ...context, ...logData }).error(message);\n    } else {\n      this.baseLogger.error(logData, message);\n    }\n  }\n\n  /**\n   * Log a fatal-level message directly on the singleton instance.\n   *\n   * Convenience method for fatal error logging without creating a logger instance.\n   * For repeated logging within a component, prefer {@link createLogger} or\n   * {@link child} to create a reusable logger with bound context.\n   *\n   * @param message - Human-readable log message\n   * @param error - Optional Error object (auto-serialized with stack trace)\n   * @param context - Optional context metadata attached to this log entry only\n   *\n   * @example Simple fatal error\n   * ```typescript\n   * LoggerService.getInstance().fatal('Critical service unavailable');\n   * process.exit(1);\n   * ```\n   *\n   * @example Fatal error with Error object\n   * ```typescript\n   * try {\n   *   await initializeDatabase();\n   * } catch (error) {\n   *   LoggerService.getInstance().fatal('Database initialization failed', error);\n   *   process.exit(1);\n   * }\n   * ```\n   *\n   * @example Fatal error with Error and context\n   * ```typescript\n   * try {\n   *   await loadCriticalConfig();\n   * } catch (error) {\n   *   LoggerService.getInstance().fatal('Configuration load failed', error, {\n   *     component: 'ConfigService',\n   *     configPath: process.env.CONFIG_PATH,\n   *     canRecover: false\n   *   });\n   *   process.exit(1);\n   * }\n   * ```\n   *\n   * @see {@link CUILogger.fatal} for CUILogger fatal method documentation\n   */\n  fatal(message: string, error?: Error | unknown, context?: LogContext): void {\n    const logData = error ? { err: error } : {};\n    if (context) {\n      this.baseLogger.child({ ...context, ...logData }).fatal(message);\n    } else {\n      this.baseLogger.fatal(logData, message);\n    }\n  }\n}\n\n/**\n * Singleton instance of LoggerService for global logging access.\n *\n * The exported `logger` instance provides direct access to the LoggerService\n * singleton for convenience logging. For component-specific logging, prefer\n * using {@link createLogger} factory function to create loggers with bound\n * component context.\n *\n * @example Using singleton logger instance\n * ```typescript\n * import { logger } from '@/services/logger';\n *\n * logger.info('Application started');\n * logger.debug('Environment', { NODE_ENV: process.env.NODE_ENV });\n * ```\n *\n * @see {@link createLogger} for recommended factory function with component context\n * @see {@link LoggerService} for LoggerService class documentation\n */\nexport const logger = LoggerService.getInstance();\n\n/**\n * Factory function for creating component loggers with bound context.\n *\n * Creates a CUILogger instance with automatic component name binding and optional\n * additional context. This is the **recommended way** to create loggers in service\n * classes, controllers, and other components. The component name is automatically\n * included in all log entries for easy filtering and debugging.\n *\n * ## Why Use createLogger?\n *\n * - **Automatic Context**: Component name automatically included in all logs\n * - **Type Safety**: TypeScript ensures component name is provided\n * - **Consistent Pattern**: Standardized logging approach across codebase\n * - **Performance**: Child logger caching reduces overhead\n * - **Readability**: Clean, self-documenting code\n *\n * ## Best Practices\n *\n * 1. **One Logger Per Class**: Create logger in constructor or as class field\n * 2. **Component Naming**: Use class/module name as component (e.g., 'ChatService')\n * 3. **Additional Context**: Include persistent context like service ID or tenant ID\n * 4. **Child Loggers**: Create child loggers for request/session-specific context\n *\n * @param component - Component name automatically included in all log entries (e.g., 'ChatService', 'MCPService')\n * @param baseContext - Optional additional context metadata bound to the logger\n * @returns CUILogger instance with component name and additional context bound\n *\n * @example Basic component logger\n * ```typescript\n * import { createLogger } from '@/services/logger';\n *\n * class ChatService {\n *   private logger = createLogger('ChatService');\n *\n *   async sendMessage(message: string) {\n *     this.logger.info('Sending message', { messageLength: message.length });\n *     // ... implementation\n *   }\n * }\n * ```\n *\n * @example Logger with additional base context\n * ```typescript\n * class TenantService {\n *   private logger = createLogger('TenantService', { tenantId: this.tenantId });\n *\n *   processRequest(requestId: string) {\n *     // All logs automatically include component and tenantId\n *     this.logger.info('Processing request', { requestId });\n *   }\n * }\n * ```\n *\n * @example Creating child loggers for request tracking\n * ```typescript\n * class ApiHandler {\n *   private logger = createLogger('ApiHandler');\n *\n *   async handleRequest(req, res) {\n *     const requestLogger = this.logger.child({ requestId: req.id });\n *\n *     requestLogger.info('Request received', { method: req.method, path: req.path });\n *\n *     try {\n *       const result = await this.processRequest(req);\n *       requestLogger.info('Request completed', { status: 200 });\n *       res.json(result);\n *     } catch (error) {\n *       requestLogger.error('Request failed', error);\n *       res.status(500).json({ error: 'Internal server error' });\n *     }\n *   }\n * }\n * ```\n *\n * @example Module-level logger\n * ```typescript\n * // utils/helper.ts\n * import { createLogger } from '@/services/logger';\n *\n * const logger = createLogger('HelperUtils');\n *\n * export function processData(data: unknown) {\n *   logger.debug('Processing data', { dataType: typeof data });\n *   // ... implementation\n *   logger.info('Data processed successfully');\n * }\n * ```\n *\n * @example Logger with service-specific context\n * ```typescript\n * class MCPService {\n *   private logger = createLogger('MCPService', { version: '1.0.0' });\n *\n *   async testServer(serverId: string) {\n *     const serverLogger = this.logger.child({ serverId });\n *\n *     serverLogger.info('Testing MCP server');\n *     try {\n *       await this.performTest(serverId);\n *       serverLogger.info('Server test passed');\n *     } catch (error) {\n *       serverLogger.error('Server test failed', error);\n *       throw error;\n *     }\n *   }\n * }\n * ```\n *\n * @see {@link CUILogger} for logger API documentation\n * @see {@link LogContext} for context metadata structure\n * @see {@link LoggerService.child} for child logger creation\n */\nexport function createLogger(component: string, baseContext?: LogContext): CUILogger {\n  const context = { component, ...baseContext };\n  return logger.child(context);\n}",
        "last_modified": "2026-01-02T15:10:07.671226"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.588324",
  "last_updated": "2026-01-02T14:06:15.600503"
}