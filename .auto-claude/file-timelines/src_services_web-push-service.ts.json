{
  "file_path": "src/services/web-push-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport Database from 'better-sqlite3';\nimport webpush, { PushSubscription } from 'web-push';\nimport { createLogger, type Logger } from './logger.js';\nimport { ConfigService } from './config-service.js';\n\nexport interface WebPushPayload {\n  title: string;\n  message: string;\n  tag?: string;\n  data?: Record<string, unknown>;\n}\n\ninterface SubscriptionRow {\n  endpoint: string;\n  p256dh: string;\n  auth: string;\n  user_agent: string;\n  created_at: string;\n  last_seen: string;\n  expired: number;\n}\n\nexport class WebPushService {\n  private static instance: WebPushService;\n  private logger: Logger;\n  private db!: Database.Database;\n  private dbPath!: string;\n  private configDir!: string;\n  private isInitialized = false;\n  private configService: ConfigService;\n\n  private insertStmt!: Database.Statement;\n  private deleteStmt!: Database.Statement;\n  private upsertSeenStmt!: Database.Statement;\n  private listStmt!: Database.Statement;\n  private countStmt!: Database.Statement;\n\n  private constructor(customConfigDir?: string) {\n    this.logger = createLogger('WebPushService');\n    this.configService = ConfigService.getInstance();\n    this.initializePaths(customConfigDir);\n  }\n\n  static getInstance(): WebPushService {\n    if (!WebPushService.instance) {\n      WebPushService.instance = new WebPushService();\n    }\n    return WebPushService.instance;\n  }\n\n  private initializePaths(customConfigDir?: string): void {\n    const baseConfigDir = customConfigDir || path.join(os.homedir(), '.cui');\n    this.configDir = baseConfigDir;\n    this.dbPath = path.join(baseConfigDir, 'web-push.db');\n    this.logger.debug('Initialized web push database paths', {\n      dir: this.configDir,\n      dbPath: this.dbPath,\n    });\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n    try {\n      if (this.dbPath !== ':memory:' && !fs.existsSync(this.configDir)) {\n        fs.mkdirSync(this.configDir, { recursive: true });\n      }\n      this.db = new Database(this.dbPath);\n      this.db.pragma('journal_mode = WAL');\n      this.db.exec(`\n        CREATE TABLE IF NOT EXISTS subscriptions (\n          endpoint TEXT PRIMARY KEY,\n          p256dh TEXT NOT NULL,\n          auth TEXT NOT NULL,\n          user_agent TEXT NOT NULL DEFAULT '',\n          created_at TEXT NOT NULL,\n          last_seen TEXT NOT NULL,\n          expired INTEGER NOT NULL DEFAULT 0\n        );\n      `);\n\n      this.prepareStatements();\n      this.configureVapid();\n      this.isInitialized = true;\n    } catch (error) {\n      this.logger.error('Failed to initialize web push database', error);\n      throw new Error(`WebPush database initialization failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  private prepareStatements(): void {\n    this.insertStmt = this.db.prepare(\n      'INSERT OR REPLACE INTO subscriptions (endpoint, p256dh, auth, user_agent, created_at, last_seen, expired) VALUES (?, ?, ?, ?, COALESCE((SELECT created_at FROM subscriptions WHERE endpoint = ?), ?), ?, 0)'\n    );\n    this.deleteStmt = this.db.prepare('DELETE FROM subscriptions WHERE endpoint = ?');\n    this.upsertSeenStmt = this.db.prepare('UPDATE subscriptions SET last_seen = ?, expired = ? WHERE endpoint = ?');\n    this.listStmt = this.db.prepare('SELECT * FROM subscriptions WHERE expired = 0');\n    this.countStmt = this.db.prepare('SELECT COUNT(*) as count FROM subscriptions WHERE expired = 0');\n  }\n\n  private configureVapid(): void {\n    const config = this.configService.getConfig();\n    let subject = config.interface.notifications?.webPush?.subject || 'mailto:admin@example.com';\n    let publicKey = config.interface.notifications?.webPush?.vapidPublicKey;\n    let privateKey = config.interface.notifications?.webPush?.vapidPrivateKey;\n\n    // Auto-generate VAPID keys if missing and notifications enabled\n    let generated = false;\n    if (this.getEnabled() && (!publicKey || !privateKey)) {\n      try {\n        const keys = webpush.generateVAPIDKeys();\n        publicKey = keys.publicKey;\n        privateKey = keys.privateKey;\n        // Persist into config (partial update preserves other interface fields)\n        void this.configService.updateConfig({\n          interface: {\n            ...config.interface,\n            notifications: {\n              ...(config.interface.notifications || { enabled: true }),\n              webPush: {\n                subject,\n                vapidPublicKey: publicKey,\n                vapidPrivateKey: privateKey,\n              },\n            },\n          },\n        }).catch((_err: unknown) => {\n          this.logger.warn('Failed to persist generated VAPID keys to config');\n        });\n        this.logger.info('Generated and applied VAPID keys');\n        generated = true;\n      } catch (_e) {\n        this.logger.error('Failed to generate VAPID keys');\n      }\n    }\n\n    if (!publicKey || !privateKey) {\n      this.logger.warn('Web Push VAPID keys are not configured. Native push will be disabled until set in config');\n      return;\n    }\n\n    webpush.setVapidDetails(subject, publicKey, privateKey);\n\n    // If keys were generated just now, expire existing subscriptions to force re-register\n    if (generated) {\n      try {\n        this.db.prepare('UPDATE subscriptions SET expired = 1').run();\n        this.logger.info('Expired all existing web push subscriptions due to VAPID key generation');\n      } catch (_e) {\n        this.logger.warn('Failed to expire existing subscriptions after VAPID key generation');\n      }\n    }\n  }\n\n  getPublicKey(): string | null {\n    const publicKey = this.configService.getConfig().interface.notifications?.webPush?.vapidPublicKey || null;\n    return publicKey || null;\n  }\n\n  getEnabled(): boolean {\n    const enabled = this.configService.getConfig().interface.notifications?.enabled ?? false;\n    return enabled;\n  }\n\n  getSubscriptionCount(): number {\n    const row = this.countStmt.get() as { count: number };\n    return row?.count || 0;\n  }\n\n  addOrUpdateSubscription(subscription: PushSubscription, userAgent = ''): void {\n    const now = new Date().toISOString();\n    const { endpoint, keys } = subscription as unknown as { endpoint: string; keys: { p256dh: string; auth: string } };\n    if (!endpoint || !keys?.p256dh || !keys?.auth) {\n      throw new Error('Invalid subscription payload: missing endpoint/keys');\n    }\n\n    this.insertStmt.run(endpoint, keys.p256dh, keys.auth, userAgent || '', endpoint, now, now);\n  }\n\n  removeSubscriptionByEndpoint(endpoint: string): void {\n    this.deleteStmt.run(endpoint);\n  }\n\n  listSubscriptions(): SubscriptionRow[] {\n    return this.listStmt.all() as SubscriptionRow[];\n  }\n\n  async broadcast(payload: WebPushPayload): Promise<{ sent: number; failed: number }>{\n    await this.initialize();\n    const subs = this.listSubscriptions();\n    let sent = 0;\n    let failed = 0;\n    await Promise.all(\n      subs.map(async (row) => {\n        const sub: PushSubscription = {\n          endpoint: row.endpoint,\n          expirationTime: null,\n          keys: { p256dh: row.p256dh, auth: row.auth },\n        } as unknown as PushSubscription;\n        try {\n          await webpush.sendNotification(sub, JSON.stringify(payload), { TTL: 60 });\n          this.upsertSeenStmt.run(new Date().toISOString(), 0, row.endpoint);\n          sent += 1;\n        } catch (_err: unknown) {\n          failed += 1;\n          // 410 Gone or 404 Not Found => expire subscription\n          const status = undefined;\n          if (status === 404 || status === 410) {\n            this.upsertSeenStmt.run(new Date().toISOString(), 1, row.endpoint);\n            this.logger.info('Expired web push subscription removed', { endpoint: row.endpoint, status });\n          } else {\n            this.logger.error('Failed sending web push notification', { endpoint: row.endpoint, statusCode: status });\n          }\n        }\n      })\n    );\n    return { sent, failed };\n  }\n}\n\n\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport Database from 'better-sqlite3';\nimport webpush, { PushSubscription } from 'web-push';\nimport { createLogger, type Logger } from './logger.js';\nimport { ConfigService } from './config-service.js';\n\n/**\n * Payload for Web Push notifications sent to browser clients\n *\n * @description\n * Represents a structured notification payload for native browser push notifications via the Web Push API.\n * The payload conforms to the Notification API structure and is sent to subscribed browser clients.\n *\n * @example\n * ```typescript\n * // Basic task completion notification\n * const payload: WebPushPayload = {\n *   title: 'Task Complete',\n *   message: 'Your AI agent finished processing the request'\n * };\n * await webPushService.broadcast(payload);\n * ```\n *\n * @example\n * ```typescript\n * // Notification with tag for grouping/replacing\n * const payload: WebPushPayload = {\n *   title: 'Build Status',\n *   message: 'Build #42 completed successfully',\n *   tag: 'build-status', // Replace previous build notifications\n *   data: { buildId: 42, status: 'success', duration: 120 }\n * };\n * ```\n *\n * @example\n * ```typescript\n * // Permission request notification with custom data\n * const payload: WebPushPayload = {\n *   title: 'Permission Required',\n *   message: 'EnterPlanMode tool requires approval',\n *   tag: 'permission-request',\n *   data: {\n *     requestId: 'perm-123',\n *     toolName: 'EnterPlanMode',\n *     sessionId: 'sess-abc123'\n *   }\n * };\n * ```\n */\nexport interface WebPushPayload {\n  /** Notification title displayed prominently in browser notification UI */\n  title: string;\n  /** Notification message body with task details or summary */\n  message: string;\n  /** Optional tag for grouping/replacing notifications (same tag replaces previous notification) */\n  tag?: string;\n  /** Optional custom data object attached to notification (accessible in service worker) */\n  data?: Record<string, unknown>;\n}\n\n/**\n * Database row representation for Web Push subscriptions\n *\n * @description\n * Internal interface representing a subscription row stored in the SQLite database.\n * Contains the Push API subscription keys and metadata for tracking subscription lifecycle.\n *\n * @private\n */\ninterface SubscriptionRow {\n  /** Web Push endpoint URL (unique identifier for subscription) */\n  endpoint: string;\n  /** P256DH key for encryption (public key for message encryption) */\n  p256dh: string;\n  /** Auth secret for authentication (used with p256dh for message encryption) */\n  auth: string;\n  /** User agent string from browser (for debugging and analytics) */\n  user_agent: string;\n  /** ISO 8601 timestamp of subscription creation */\n  created_at: string;\n  /** ISO 8601 timestamp of last successful notification delivery */\n  last_seen: string;\n  /** Expired flag (0 = active, 1 = expired/removed by 410 Gone or 404 Not Found) */\n  expired: number;\n}\n\n/**\n * WebPushService - Native browser push notification delivery via Web Push API\n *\n * @description\n * The WebPushService manages native browser push notifications using the Web Push API standard.\n * It handles subscription management, VAPID key configuration, and notification broadcasting to\n * subscribed browser clients. Uses SQLite for persistent subscription storage.\n *\n * **Key Responsibilities:**\n * - Manage Web Push subscriptions (subscribe, unsubscribe)\n * - Auto-generate VAPID keys on first run (if notifications enabled)\n * - Store subscriptions in SQLite database with WAL mode for performance\n * - Broadcast notifications to all active subscriptions\n * - Track subscription lifecycle (creation, last_seen, expiration)\n * - Handle expired subscriptions (410 Gone, 404 Not Found)\n * - Integrate with ConfigService for VAPID key persistence\n *\n * **Architecture:**\n * - **SQLite Backend**: Persistent subscription storage in `~/.cui/web-push.db`\n * - **WAL Mode**: Write-Ahead Logging for better concurrency\n * - **Singleton Pattern**: Ensures single database connection across application\n * - **Prepared Statements**: Performance optimization for frequent queries\n * - **VAPID Keys**: Auto-generated on first run, persisted to config\n * - **Subscription Lifecycle**: Active (expired=0) vs Expired (expired=1)\n *\n * **Database Schema:**\n * ```sql\n * CREATE TABLE subscriptions (\n *   endpoint TEXT PRIMARY KEY,           -- Web Push endpoint URL (unique)\n *   p256dh TEXT NOT NULL,                -- P256DH encryption key\n *   auth TEXT NOT NULL,                  -- Auth secret\n *   user_agent TEXT NOT NULL DEFAULT '', -- Browser user agent\n *   created_at TEXT NOT NULL,            -- ISO 8601 timestamp\n *   last_seen TEXT NOT NULL,             -- Last successful delivery\n *   expired INTEGER NOT NULL DEFAULT 0   -- 0 = active, 1 = expired\n * );\n * ```\n *\n * **VAPID Key Management:**\n * VAPID (Voluntary Application Server Identification) keys authenticate push notifications.\n * The service auto-generates keys on first run if notifications are enabled:\n *\n * 1. **First Run**: If `config.interface.notifications.enabled = true` and keys missing\n *    - Generate VAPID key pair using `webpush.generateVAPIDKeys()`\n *    - Persist keys to `~/.cui/config.json`\n *    - Expire all existing subscriptions (keys changed, re-subscribe required)\n * 2. **Subsequent Runs**: Load VAPID keys from config\n * 3. **Public Key Sharing**: `getPublicKey()` returns VAPID public key for client subscription\n *\n * **Subscription Lifecycle:**\n * 1. **Subscribe**: Browser calls `addOrUpdateSubscription()` with PushSubscription\n * 2. **Active**: Subscription stored with `expired=0`\n * 3. **Notification**: `broadcast()` sends notifications, updates `last_seen`\n * 4. **Expiration**: 410 Gone or 404 Not Found marks subscription as `expired=1`\n * 5. **Unsubscribe**: Browser calls `removeSubscriptionByEndpoint()`\n *\n * **Use Cases:**\n * - Task completion notifications for browser clients\n * - Permission request alerts in web UI\n * - Real-time status updates to subscribed browsers\n * - Multi-device notification delivery (each browser = separate subscription)\n *\n * @example\n * ```typescript\n * // Basic usage - initialize and broadcast notification\n * import { WebPushService } from './web-push-service';\n *\n * const webPushService = WebPushService.getInstance();\n * await webPushService.initialize();\n *\n * const payload = {\n *   title: 'Task Complete',\n *   message: 'Your AI agent finished the request'\n * };\n * const { sent, failed } = await webPushService.broadcast(payload);\n * console.log(`Sent to ${sent} subscribers, ${failed} failures`);\n * ```\n *\n * @example\n * ```typescript\n * // Client-side subscription workflow\n * // 1. Get VAPID public key from server\n * const publicKey = webPushService.getPublicKey();\n * if (!publicKey) {\n *   console.error('Web Push not configured');\n *   return;\n * }\n *\n * // 2. Subscribe in browser (client-side code)\n * const registration = await navigator.serviceWorker.ready;\n * const subscription = await registration.pushManager.subscribe({\n *   userVisibleOnly: true,\n *   applicationServerKey: urlBase64ToUint8Array(publicKey)\n * });\n *\n * // 3. Send subscription to server\n * await fetch('/api/web-push/subscribe', {\n *   method: 'POST',\n *   headers: { 'Content-Type': 'application/json' },\n *   body: JSON.stringify(subscription)\n * });\n *\n * // Server-side: Store subscription\n * webPushService.addOrUpdateSubscription(subscription, req.headers['user-agent']);\n * ```\n *\n * @example\n * ```typescript\n * // Monitor subscription count\n * const count = webPushService.getSubscriptionCount();\n * console.log(`Active subscriptions: ${count}`);\n *\n * const subscriptions = webPushService.listSubscriptions();\n * subscriptions.forEach(sub => {\n *   console.log(`Endpoint: ${sub.endpoint}`);\n *   console.log(`Created: ${sub.created_at}`);\n *   console.log(`Last seen: ${sub.last_seen}`);\n *   console.log(`User agent: ${sub.user_agent}`);\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Unsubscribe workflow\n * // 1. Client-side: Unsubscribe from push manager\n * const subscription = await registration.pushManager.getSubscription();\n * if (subscription) {\n *   await subscription.unsubscribe();\n *\n *   // 2. Notify server to remove subscription\n *   await fetch('/api/web-push/unsubscribe', {\n *     method: 'POST',\n *     headers: { 'Content-Type': 'application/json' },\n *     body: JSON.stringify({ endpoint: subscription.endpoint })\n *   });\n * }\n *\n * // Server-side: Remove subscription\n * webPushService.removeSubscriptionByEndpoint(endpoint);\n * ```\n *\n * @example\n * ```typescript\n * // Check if Web Push is enabled\n * if (webPushService.getEnabled()) {\n *   console.log('Web Push notifications are enabled');\n *   const publicKey = webPushService.getPublicKey();\n *   console.log(`VAPID public key: ${publicKey}`);\n * } else {\n *   console.log('Web Push disabled in config');\n * }\n * ```\n *\n * @see {@link https://web.dev/push-notifications-overview/ | Web Push Notifications Overview}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Push_API | Push API - MDN}\n * @see {@link https://github.com/web-push-libs/web-push | web-push library}\n */\nexport class WebPushService {\n  /** Singleton instance */\n  private static instance: WebPushService;\n  /** Logger instance for WebPushService */\n  private logger: Logger;\n  /** SQLite database connection */\n  private db!: Database.Database;\n  /** Path to web-push.db SQLite database file */\n  private dbPath!: string;\n  /** Base configuration directory (~/.cui) */\n  private configDir!: string;\n  /** Initialization state flag */\n  private isInitialized = false;\n  /** ConfigService instance for VAPID key persistence */\n  private configService: ConfigService;\n\n  /** Prepared statement for inserting/updating subscriptions */\n  private insertStmt!: Database.Statement;\n  /** Prepared statement for deleting subscriptions by endpoint */\n  private deleteStmt!: Database.Statement;\n  /** Prepared statement for updating last_seen and expired status */\n  private upsertSeenStmt!: Database.Statement;\n  /** Prepared statement for listing active subscriptions */\n  private listStmt!: Database.Statement;\n  /** Prepared statement for counting active subscriptions */\n  private countStmt!: Database.Statement;\n\n  private constructor(customConfigDir?: string) {\n    this.logger = createLogger('WebPushService');\n    this.configService = ConfigService.getInstance();\n    this.initializePaths(customConfigDir);\n  }\n\n  /**\n   * Get singleton instance of WebPushService\n   *\n   * @description\n   * Returns the singleton instance of WebPushService, creating it if necessary.\n   * Ensures single database connection across the application.\n   *\n   * @returns WebPushService singleton instance\n   *\n   * @example\n   * ```typescript\n   * // Get singleton instance\n   * const webPushService = WebPushService.getInstance();\n   * await webPushService.initialize();\n   * ```\n   */\n  static getInstance(): WebPushService {\n    if (!WebPushService.instance) {\n      WebPushService.instance = new WebPushService();\n    }\n    return WebPushService.instance;\n  }\n\n  private initializePaths(customConfigDir?: string): void {\n    const baseConfigDir = customConfigDir || path.join(os.homedir(), '.cui');\n    this.configDir = baseConfigDir;\n    this.dbPath = path.join(baseConfigDir, 'web-push.db');\n    this.logger.debug('Initialized web push database paths', {\n      dir: this.configDir,\n      dbPath: this.dbPath,\n    });\n  }\n\n  /**\n   * Initialize Web Push service and database\n   *\n   * @description\n   * Initializes the Web Push service by creating the SQLite database, setting up WAL mode,\n   * creating the subscriptions table, preparing statements, and configuring VAPID keys.\n   * Idempotent - safe to call multiple times.\n   *\n   * **Initialization Workflow:**\n   * 1. Check if already initialized (early return if true)\n   * 2. Create config directory if needed (~/.cui)\n   * 3. Open SQLite database with WAL mode for concurrency\n   * 4. Create subscriptions table if not exists\n   * 5. Prepare SQL statements for performance\n   * 6. Configure VAPID keys (auto-generate on first run if enabled)\n   * 7. Set initialized flag\n   *\n   * **VAPID Key Auto-Generation:**\n   * If notifications are enabled and VAPID keys are missing, the service will:\n   * - Generate a new VAPID key pair\n   * - Persist keys to `~/.cui/config.json`\n   * - Expire all existing subscriptions (keys changed, clients must re-subscribe)\n   *\n   * @throws {Error} If database initialization fails (permissions, corruption, etc.)\n   *\n   * @example\n   * ```typescript\n   * // Basic initialization\n   * const webPushService = WebPushService.getInstance();\n   * await webPushService.initialize();\n   * console.log('Web Push service ready');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Server startup initialization with error handling\n   * try {\n   *   const webPushService = WebPushService.getInstance();\n   *   await webPushService.initialize();\n   *   if (webPushService.getEnabled()) {\n   *     console.log('Web Push enabled');\n   *     console.log(`VAPID public key: ${webPushService.getPublicKey()}`);\n   *   } else {\n   *     console.log('Web Push disabled in config');\n   *   }\n   * } catch (error) {\n   *   console.error('Failed to initialize Web Push:', error);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Idempotent initialization (safe to call multiple times)\n   * await webPushService.initialize(); // First call: creates DB\n   * await webPushService.initialize(); // Second call: returns immediately\n   * await webPushService.initialize(); // Third call: returns immediately\n   * ```\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n    try {\n      if (this.dbPath !== ':memory:' && !fs.existsSync(this.configDir)) {\n        fs.mkdirSync(this.configDir, { recursive: true });\n      }\n      this.db = new Database(this.dbPath);\n      this.db.pragma('journal_mode = WAL');\n      this.db.exec(`\n        CREATE TABLE IF NOT EXISTS subscriptions (\n          endpoint TEXT PRIMARY KEY,\n          p256dh TEXT NOT NULL,\n          auth TEXT NOT NULL,\n          user_agent TEXT NOT NULL DEFAULT '',\n          created_at TEXT NOT NULL,\n          last_seen TEXT NOT NULL,\n          expired INTEGER NOT NULL DEFAULT 0\n        );\n      `);\n\n      this.prepareStatements();\n      this.configureVapid();\n      this.isInitialized = true;\n    } catch (error) {\n      this.logger.error('Failed to initialize web push database', error);\n      throw new Error(`WebPush database initialization failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  private prepareStatements(): void {\n    this.insertStmt = this.db.prepare(\n      'INSERT OR REPLACE INTO subscriptions (endpoint, p256dh, auth, user_agent, created_at, last_seen, expired) VALUES (?, ?, ?, ?, COALESCE((SELECT created_at FROM subscriptions WHERE endpoint = ?), ?), ?, 0)'\n    );\n    this.deleteStmt = this.db.prepare('DELETE FROM subscriptions WHERE endpoint = ?');\n    this.upsertSeenStmt = this.db.prepare('UPDATE subscriptions SET last_seen = ?, expired = ? WHERE endpoint = ?');\n    this.listStmt = this.db.prepare('SELECT * FROM subscriptions WHERE expired = 0');\n    this.countStmt = this.db.prepare('SELECT COUNT(*) as count FROM subscriptions WHERE expired = 0');\n  }\n\n  private configureVapid(): void {\n    const config = this.configService.getConfig();\n    let subject = config.interface.notifications?.webPush?.subject || 'mailto:admin@example.com';\n    let publicKey = config.interface.notifications?.webPush?.vapidPublicKey;\n    let privateKey = config.interface.notifications?.webPush?.vapidPrivateKey;\n\n    // Auto-generate VAPID keys if missing and notifications enabled\n    let generated = false;\n    if (this.getEnabled() && (!publicKey || !privateKey)) {\n      try {\n        const keys = webpush.generateVAPIDKeys();\n        publicKey = keys.publicKey;\n        privateKey = keys.privateKey;\n        // Persist into config (partial update preserves other interface fields)\n        void this.configService.updateConfig({\n          interface: {\n            ...config.interface,\n            notifications: {\n              ...(config.interface.notifications || { enabled: true }),\n              webPush: {\n                subject,\n                vapidPublicKey: publicKey,\n                vapidPrivateKey: privateKey,\n              },\n            },\n          },\n        }).catch((_err: unknown) => {\n          this.logger.warn('Failed to persist generated VAPID keys to config');\n        });\n        this.logger.info('Generated and applied VAPID keys');\n        generated = true;\n      } catch (_e) {\n        this.logger.error('Failed to generate VAPID keys');\n      }\n    }\n\n    if (!publicKey || !privateKey) {\n      this.logger.warn('Web Push VAPID keys are not configured. Native push will be disabled until set in config');\n      return;\n    }\n\n    webpush.setVapidDetails(subject, publicKey, privateKey);\n\n    // If keys were generated just now, expire existing subscriptions to force re-register\n    if (generated) {\n      try {\n        this.db.prepare('UPDATE subscriptions SET expired = 1').run();\n        this.logger.info('Expired all existing web push subscriptions due to VAPID key generation');\n      } catch (_e) {\n        this.logger.warn('Failed to expire existing subscriptions after VAPID key generation');\n      }\n    }\n  }\n\n  /**\n   * Get VAPID public key for client-side subscription\n   *\n   * @description\n   * Returns the VAPID public key required for browser clients to subscribe to push notifications.\n   * The public key is stored in `~/.cui/config.json` and auto-generated on first run if notifications\n   * are enabled. Clients use this key with the Push API `subscribe()` method.\n   *\n   * @returns VAPID public key string, or null if not configured\n   *\n   * @example\n   * ```typescript\n   * // API endpoint to share public key with client\n   * app.get('/api/web-push/public-key', (req, res) => {\n   *   const publicKey = webPushService.getPublicKey();\n   *   if (!publicKey) {\n   *     return res.status(503).json({ error: 'Web Push not configured' });\n   *   }\n   *   res.json({ publicKey });\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Client-side: Fetch public key and subscribe\n   * const response = await fetch('/api/web-push/public-key');\n   * const { publicKey } = await response.json();\n   *\n   * const registration = await navigator.serviceWorker.ready;\n   * const subscription = await registration.pushManager.subscribe({\n   *   userVisibleOnly: true,\n   *   applicationServerKey: urlBase64ToUint8Array(publicKey)\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Check if VAPID keys are configured\n   * const publicKey = webPushService.getPublicKey();\n   * if (!publicKey) {\n   *   console.error('VAPID keys not configured. Set notifications.enabled=true in config');\n   * } else {\n   *   console.log(`VAPID public key: ${publicKey.substring(0, 20)}...`);\n   * }\n   * ```\n   */\n  getPublicKey(): string | null {\n    const publicKey = this.configService.getConfig().interface.notifications?.webPush?.vapidPublicKey || null;\n    return publicKey || null;\n  }\n\n  /**\n   * Check if Web Push notifications are enabled\n   *\n   * @description\n   * Returns whether Web Push notifications are enabled via configuration.\n   * Controlled by `config.interface.notifications.enabled` in `~/.cui/config.json`.\n   *\n   * @returns true if notifications enabled, false otherwise\n   *\n   * @example\n   * ```typescript\n   * // Conditional notification delivery\n   * if (webPushService.getEnabled()) {\n   *   await webPushService.broadcast({\n   *     title: 'Task Complete',\n   *     message: 'Your request finished successfully'\n   *   });\n   * } else {\n   *   console.log('Web Push disabled, skipping notification');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // API endpoint to check availability\n   * app.get('/api/web-push/available', (req, res) => {\n   *   res.json({ available: webPushService.getEnabled() });\n   * });\n   * ```\n   */\n  getEnabled(): boolean {\n    const enabled = this.configService.getConfig().interface.notifications?.enabled ?? false;\n    return enabled;\n  }\n\n  /**\n   * Get count of active Web Push subscriptions\n   *\n   * @description\n   * Returns the number of active subscriptions (expired=0).\n   * Useful for monitoring, analytics, and debugging.\n   *\n   * @returns Number of active subscriptions\n   *\n   * @example\n   * ```typescript\n   * // Monitor subscription count\n   * const count = webPushService.getSubscriptionCount();\n   * console.log(`Active Web Push subscribers: ${count}`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // API endpoint for admin dashboard\n   * app.get('/api/web-push/stats', (req, res) => {\n   *   res.json({\n   *     enabled: webPushService.getEnabled(),\n   *     subscriptions: webPushService.getSubscriptionCount()\n   *   });\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Skip broadcast if no subscribers\n   * if (webPushService.getSubscriptionCount() === 0) {\n   *   console.log('No Web Push subscribers, skipping broadcast');\n   *   return;\n   * }\n   * await webPushService.broadcast(payload);\n   * ```\n   */\n  getSubscriptionCount(): number {\n    const row = this.countStmt.get() as { count: number };\n    return row?.count || 0;\n  }\n\n  /**\n   * Subscribe browser client to Web Push notifications\n   *\n   * @description\n   * Stores a browser's PushSubscription in the database, enabling notification delivery.\n   * If the subscription already exists (same endpoint), updates it with new keys and user agent.\n   * Preserves the original `created_at` timestamp for existing subscriptions.\n   *\n   * **Subscription Workflow:**\n   * 1. Extract endpoint, p256dh, and auth keys from PushSubscription object\n   * 2. Validate required fields (endpoint, p256dh, auth)\n   * 3. Insert or update subscription in database\n   * 4. Set `expired=0` (active) and update `last_seen` to current time\n   * 5. Preserve `created_at` for existing subscriptions, set to now for new ones\n   *\n   * **PushSubscription Format:**\n   * ```typescript\n   * {\n   *   endpoint: 'https://fcm.googleapis.com/fcm/send/...',\n   *   expirationTime: null,\n   *   keys: {\n   *     p256dh: 'BASE64_ENCODED_KEY',\n   *     auth: 'BASE64_ENCODED_SECRET'\n   *   }\n   * }\n   * ```\n   *\n   * @param subscription - PushSubscription object from browser's `pushManager.subscribe()`\n   * @param userAgent - Optional user agent string from browser for debugging/analytics\n   *\n   * @throws {Error} If subscription payload is invalid (missing endpoint or keys)\n   *\n   * @example\n   * ```typescript\n   * // API endpoint to handle subscription from client\n   * app.post('/api/web-push/subscribe', (req, res) => {\n   *   try {\n   *     const subscription = req.body; // PushSubscription from client\n   *     const userAgent = req.headers['user-agent'] || '';\n   *     webPushService.addOrUpdateSubscription(subscription, userAgent);\n   *     res.json({ success: true });\n   *   } catch (error) {\n   *     res.status(400).json({ error: error.message });\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Client-side subscription workflow\n   * const registration = await navigator.serviceWorker.ready;\n   * const subscription = await registration.pushManager.subscribe({\n   *   userVisibleOnly: true,\n   *   applicationServerKey: urlBase64ToUint8Array(publicKey)\n   * });\n   *\n   * // Send subscription to server\n   * await fetch('/api/web-push/subscribe', {\n   *   method: 'POST',\n   *   headers: { 'Content-Type': 'application/json' },\n   *   body: JSON.stringify(subscription)\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Update existing subscription (re-subscribe)\n   * // If user already subscribed with same endpoint, updates keys and user agent\n   * webPushService.addOrUpdateSubscription(newSubscription, 'Mozilla/5.0...');\n   * console.log('Subscription updated successfully');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle invalid subscription\n   * try {\n   *   webPushService.addOrUpdateSubscription({ endpoint: '' } as any, '');\n   * } catch (error) {\n   *   console.error('Invalid subscription:', error.message);\n   *   // Output: Invalid subscription payload: missing endpoint/keys\n   * }\n   * ```\n   */\n  addOrUpdateSubscription(subscription: PushSubscription, userAgent = ''): void {\n    const now = new Date().toISOString();\n    const { endpoint, keys } = subscription as unknown as { endpoint: string; keys: { p256dh: string; auth: string } };\n    if (!endpoint || !keys?.p256dh || !keys?.auth) {\n      throw new Error('Invalid subscription payload: missing endpoint/keys');\n    }\n\n    this.insertStmt.run(endpoint, keys.p256dh, keys.auth, userAgent || '', endpoint, now, now);\n  }\n\n  /**\n   * Unsubscribe browser client from Web Push notifications\n   *\n   * @description\n   * Permanently removes a subscription from the database by its endpoint URL.\n   * Called when a browser client unsubscribes from push notifications.\n   * Idempotent - safe to call with non-existent endpoints (no error thrown).\n   *\n   * @param endpoint - Web Push endpoint URL (unique identifier for subscription)\n   *\n   * @example\n   * ```typescript\n   * // API endpoint to handle unsubscribe from client\n   * app.post('/api/web-push/unsubscribe', (req, res) => {\n   *   const { endpoint } = req.body;\n   *   webPushService.removeSubscriptionByEndpoint(endpoint);\n   *   res.json({ success: true });\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Client-side unsubscribe workflow\n   * const registration = await navigator.serviceWorker.ready;\n   * const subscription = await registration.pushManager.getSubscription();\n   * if (subscription) {\n   *   await subscription.unsubscribe();\n   *\n   *   // Notify server to remove subscription\n   *   await fetch('/api/web-push/unsubscribe', {\n   *     method: 'POST',\n   *     headers: { 'Content-Type': 'application/json' },\n   *     body: JSON.stringify({ endpoint: subscription.endpoint })\n   *   });\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Remove specific subscription by endpoint\n   * const endpoint = 'https://fcm.googleapis.com/fcm/send/abc123...';\n   * webPushService.removeSubscriptionByEndpoint(endpoint);\n   * console.log('Subscription removed');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Idempotent behavior - safe to call multiple times\n   * webPushService.removeSubscriptionByEndpoint(endpoint); // Deletes subscription\n   * webPushService.removeSubscriptionByEndpoint(endpoint); // No error, does nothing\n   * ```\n   */\n  removeSubscriptionByEndpoint(endpoint: string): void {\n    this.deleteStmt.run(endpoint);\n  }\n\n  /**\n   * List all active Web Push subscriptions\n   *\n   * @description\n   * Returns all active subscriptions (expired=0) from the database.\n   * Useful for monitoring, debugging, and manual subscription management.\n   * Each subscription includes endpoint, encryption keys, timestamps, and user agent.\n   *\n   * @returns Array of active subscription rows\n   *\n   * @example\n   * ```typescript\n   * // List all subscriptions\n   * const subscriptions = webPushService.listSubscriptions();\n   * console.log(`Total active subscriptions: ${subscriptions.length}`);\n   * subscriptions.forEach(sub => {\n   *   console.log(`Endpoint: ${sub.endpoint}`);\n   *   console.log(`Created: ${sub.created_at}`);\n   *   console.log(`Last seen: ${sub.last_seen}`);\n   *   console.log(`User agent: ${sub.user_agent}`);\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // API endpoint for admin dashboard\n   * app.get('/api/web-push/subscriptions', (req, res) => {\n   *   const subscriptions = webPushService.listSubscriptions();\n   *   res.json({\n   *     count: subscriptions.length,\n   *     subscriptions: subscriptions.map(sub => ({\n   *       endpoint: sub.endpoint,\n   *       createdAt: sub.created_at,\n   *       lastSeen: sub.last_seen,\n   *       userAgent: sub.user_agent\n   *     }))\n   *   });\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Find stale subscriptions (not seen in 30 days)\n   * const subscriptions = webPushService.listSubscriptions();\n   * const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n   * const stale = subscriptions.filter(sub =>\n   *   new Date(sub.last_seen) < thirtyDaysAgo\n   * );\n   * console.log(`Stale subscriptions: ${stale.length}`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Group subscriptions by browser type\n   * const subscriptions = webPushService.listSubscriptions();\n   * const byBrowser = subscriptions.reduce((acc, sub) => {\n   *   const browser = sub.user_agent.includes('Chrome') ? 'Chrome' :\n   *                   sub.user_agent.includes('Firefox') ? 'Firefox' :\n   *                   sub.user_agent.includes('Safari') ? 'Safari' : 'Other';\n   *   acc[browser] = (acc[browser] || 0) + 1;\n   *   return acc;\n   * }, {} as Record<string, number>);\n   * console.log('Subscriptions by browser:', byBrowser);\n   * ```\n   */\n  listSubscriptions(): SubscriptionRow[] {\n    return this.listStmt.all() as SubscriptionRow[];\n  }\n\n  /**\n   * Broadcast push notification to all active subscriptions\n   *\n   * @description\n   * Sends a push notification to all active browser subscriptions in parallel.\n   * Automatically handles subscription expiration (410 Gone, 404 Not Found) by marking\n   * subscriptions as expired. Updates `last_seen` timestamp on successful delivery.\n   *\n   * **Broadcast Workflow:**\n   * 1. Ensure service is initialized (auto-initialize if needed)\n   * 2. Retrieve all active subscriptions from database\n   * 3. Send notifications in parallel using `Promise.all()`\n   * 4. For each subscription:\n   *    - Reconstruct PushSubscription object from database row\n   *    - Send notification via web-push library (TTL: 60 seconds)\n   *    - On success: Update `last_seen` timestamp, increment `sent` counter\n   *    - On 410/404: Mark subscription as `expired=1`, increment `failed` counter\n   *    - On other error: Log error, increment `failed` counter\n   * 5. Return summary: `{ sent, failed }`\n   *\n   * **Error Handling:**\n   * - **410 Gone**: Subscription no longer valid (user unsubscribed or endpoint expired)\n   * - **404 Not Found**: Push service endpoint no longer exists\n   * - Both 410/404 automatically expire the subscription (no manual cleanup needed)\n   * - Other errors (network, timeout): Logged but subscription remains active\n   *\n   * **TTL (Time To Live):**\n   * - Set to 60 seconds for all notifications\n   * - If delivery fails within 60s, push service discards notification\n   * - Prevents stale notifications from being delivered hours later\n   *\n   * @param payload - Notification payload with title, message, tag, and data\n   * @returns Object with `sent` (successful) and `failed` (failed) counts\n   *\n   * @example\n   * ```typescript\n   * // Basic broadcast - task completion notification\n   * const payload = {\n   *   title: 'Task Complete',\n   *   message: 'Your AI agent finished processing the request'\n   * };\n   * const { sent, failed } = await webPushService.broadcast(payload);\n   * console.log(`Sent to ${sent} subscribers, ${failed} failures`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Broadcast with tag for notification grouping/replacing\n   * const payload = {\n   *   title: 'Build Status',\n   *   message: 'Build #42 completed successfully',\n   *   tag: 'build-status', // Replace previous build notifications\n   *   data: { buildId: 42, status: 'success' }\n   * };\n   * await webPushService.broadcast(payload);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Permission request notification\n   * const payload = {\n   *   title: 'Permission Required',\n   *   message: 'EnterPlanMode tool requires approval',\n   *   tag: 'permission-request',\n   *   data: {\n   *     requestId: 'perm-123',\n   *     toolName: 'EnterPlanMode',\n   *     sessionId: 'sess-abc123',\n   *     streamingId: 'stream-xyz789'\n   *   }\n   * };\n   * await webPushService.broadcast(payload);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Integration with NotificationService\n   * import { NotificationService } from './notification-service';\n   *\n   * async function notifyTaskComplete(sessionId: string, summary: string) {\n   *   // Send to ntfy.sh (primary channel)\n   *   await notificationService.sendConversationEndNotification(sessionId, summary);\n   *\n   *   // Send to Web Push (best-effort, browser clients)\n   *   const { sent, failed } = await webPushService.broadcast({\n   *     title: 'Task Complete',\n   *     message: summary,\n   *     tag: 'task-complete',\n   *     data: { sessionId }\n   *   });\n   *   console.log(`Web Push: ${sent} sent, ${failed} failed`);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Skip broadcast if no subscriptions\n   * if (webPushService.getSubscriptionCount() === 0) {\n   *   console.log('No Web Push subscribers, skipping broadcast');\n   *   return;\n   * }\n   *\n   * const { sent, failed } = await webPushService.broadcast(payload);\n   * if (sent === 0 && failed > 0) {\n   *   console.log('All subscriptions failed, may need manual cleanup');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Monitor broadcast success rate\n   * const { sent, failed } = await webPushService.broadcast(payload);\n   * const total = sent + failed;\n   * const successRate = total > 0 ? (sent / total) * 100 : 0;\n   * console.log(`Broadcast success rate: ${successRate.toFixed(1)}%`);\n   *\n   * if (successRate < 80) {\n   *   console.warn('Low success rate, check subscription health');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Conditional broadcast based on subscription count\n   * const count = webPushService.getSubscriptionCount();\n   * if (count > 0) {\n   *   const result = await webPushService.broadcast({\n   *     title: 'New Message',\n   *     message: 'You have a new message from the AI agent'\n   *   });\n   *   console.log(`Notified ${result.sent}/${count} subscribers`);\n   * }\n   * ```\n   */\n  async broadcast(payload: WebPushPayload): Promise<{ sent: number; failed: number }>{\n    await this.initialize();\n    const subs = this.listSubscriptions();\n    let sent = 0;\n    let failed = 0;\n    await Promise.all(\n      subs.map(async (row) => {\n        const sub: PushSubscription = {\n          endpoint: row.endpoint,\n          expirationTime: null,\n          keys: { p256dh: row.p256dh, auth: row.auth },\n        } as unknown as PushSubscription;\n        try {\n          await webpush.sendNotification(sub, JSON.stringify(payload), { TTL: 60 });\n          this.upsertSeenStmt.run(new Date().toISOString(), 0, row.endpoint);\n          sent += 1;\n        } catch (_err: unknown) {\n          failed += 1;\n          // 410 Gone or 404 Not Found => expire subscription\n          const status = undefined;\n          if (status === 404 || status === 410) {\n            this.upsertSeenStmt.run(new Date().toISOString(), 1, row.endpoint);\n            this.logger.info('Expired web push subscription removed', { endpoint: row.endpoint, status });\n          } else {\n            this.logger.error('Failed sending web push notification', { endpoint: row.endpoint, statusCode: status });\n          }\n        }\n      })\n    );\n    return { sent, failed };\n  }\n}\n\n\n",
        "last_modified": "2026-01-02T15:10:07.681222"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.700608",
  "last_updated": "2026-01-02T14:06:15.711738"
}