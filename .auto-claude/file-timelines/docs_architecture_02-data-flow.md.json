{
  "file_path": "docs/architecture/02-data-flow.md",
  "main_branch_history": [],
  "task_views": {
    "003-create-architecture-documentation-with-system-diag": {
      "task_id": "003-create-architecture-documentation-with-system-diag",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "",
        "timestamp": "2026-01-02T10:53:08.483278"
      },
      "worktree_state": {
        "content": "# Data Flow Architecture\n\n## Introduction\n\nThis document provides detailed diagrams and explanations of the major data flows within the Claude Agent UI system. Understanding these flows is crucial for debugging, optimization, and feature development.\n\n## Overview\n\nThe system has four primary data flow patterns:\n\n1. **Agent Execution Flow** - Real-time SSE streaming from agent execution\n2. **CRUD Operations Flow** - Data persistence through Strapi CMS\n3. **MCP Tool Invocation Flow** - External tool integration via MCP protocol\n4. **Chat/Conversation Flow** - Interactive chat sessions with streaming\n\n---\n\n## 1. Agent Execution Flow with SSE Streaming\n\nThis flow shows how an agent executes a task and streams results back to the frontend in real-time using Server-Sent Events (SSE).\n\n```mermaid\nsequenceDiagram\n    participant User as Web Browser\n    participant React as React Frontend\n    participant Nginx as Nginx Proxy\n    participant Express as Express Server\n    participant SDK as Claude SDK Service\n    participant Strapi as Strapi CMS\n    participant DB as PostgreSQL\n    participant Claude as Anthropic API\n    participant MCP as MCP Servers\n\n    User->>React: Click \"Execute Agent\"\n    React->>React: Open EventSource connection\n    React->>Nginx: POST /api/execute/agent/:id<br/>{message, conversationId}\n    Nginx->>Express: Forward to Express:3001\n\n    Note over Express: execution.routes.ts\n    Express->>Express: Set SSE headers<br/>(text/event-stream)\n    Express->>Strapi: GET /api/agents/:id\n    Strapi->>DB: SELECT from agents\n    DB-->>Strapi: Agent data\n    Strapi-->>Express: Agent config\n\n    Express->>Strapi: GET /api/skills?ids=...\n    Strapi->>DB: SELECT from skills\n    DB-->>Strapi: Skills data\n    Strapi-->>Express: Skills array\n\n    Express->>Strapi: GET /api/mcp-servers?ids=...\n    Strapi->>DB: SELECT from mcp_servers\n    DB-->>Strapi: MCP servers data\n    Strapi-->>Express: MCP servers array\n\n    Express->>Express: skillSyncService.syncAllSkills()<br/>Write to .claude/skills/\n\n    Express->>React: SSE: {\"type\":\"status\",\"status\":\"Starting agent\"}\n\n    Express->>SDK: startConversation({<br/>  initialPrompt,<br/>  systemPrompt,<br/>  model,<br/>  skills,<br/>  mcpServers<br/>})\n\n    SDK->>SDK: Load MCP servers<br/>(3-tier discovery)\n    SDK->>MCP: Initialize & discover tools\n    MCP-->>SDK: Available tools\n\n    SDK->>Claude: POST /v1/messages<br/>Stream: true\n\n    loop For each Claude response chunk\n        Claude-->>SDK: Stream chunk\n        SDK->>SDK: Parse SDK message\n        SDK->>Express: Emit 'claude-message' event\n        Express->>React: SSE: {\"type\":\"message\",\"content\":{...}}\n        React->>User: Update UI in real-time\n    end\n\n    opt Tool Invocation\n        Claude-->>SDK: tool_use message\n        SDK->>Express: Emit tool_use event\n        Express->>React: SSE: {\"type\":\"message\",\"content\":{\"type\":\"tool_use\"}}\n        SDK->>MCP: Execute tool via JSON-RPC\n        MCP-->>SDK: Tool result\n        SDK->>Express: Emit tool_result event\n        Express->>React: SSE: {\"type\":\"message\",\"content\":{\"type\":\"tool_result\"}}\n        SDK->>Claude: Continue with tool result\n    end\n\n    Claude-->>SDK: Final response\n    SDK->>SDK: Calculate usage metrics\n    SDK->>Express: Emit 'process-closed' event\n    Express->>Express: Calculate cost & duration\n    Express->>React: SSE: {\"type\":\"completion\",\"tokens\":...,\"cost\":...}\n    Express->>React: SSE: done\n    React->>User: Show completion status\n```\n\n### Key Points\n\n- **SSE Headers**: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`\n- **Keep-Alive**: 30-second ping intervals to maintain connection\n- **Event Types**: `status`, `message`, `completion`, `error`, `done`\n- **Tool Execution**: Synchronous within the conversation flow\n- **Error Handling**: Errors sent as SSE events if stream started, otherwise JSON response\n\n### SSE Event Format\n\n```typescript\n// Status event\ndata: {\"type\":\"status\",\"status\":\"Starting agent: MyAgent\",\"timestamp\":\"...\"}\n\n// Message event (assistant text)\ndata: {\"type\":\"message\",\"content\":{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"text\",\"text\":\"...\"}]}}}\n\n// Tool use event\ndata: {\"type\":\"message\",\"content\":{\"type\":\"tool_use\",\"id\":\"...\",\"name\":\"read_file\",\"input\":{...}}}\n\n// Tool result event\ndata: {\"type\":\"message\",\"content\":{\"type\":\"tool_result\",\"tool_use_id\":\"...\",\"content\":\"...\"}}\n\n// Completion event\ndata: {\"type\":\"completion\",\"tokens\":{\"input\":100,\"output\":50},\"cost\":0.0025,\"duration\":5.2}\n\n// Done event\ndata: done\n```\n\n---\n\n## 2. CRUD Operations Flow Through Strapi\n\nThis flow shows how data is created, read, updated, and deleted through the Strapi CMS layer.\n\n```mermaid\nsequenceDiagram\n    participant React as React Frontend\n    participant Nginx as Nginx Proxy\n    participant Express as Express Server\n    participant Cache as LRU Cache<br/>(5-min TTL)\n    participant Strapi as Strapi Client\n    participant StrapiAPI as Strapi CMS API\n    participant DB as PostgreSQL\n\n    Note over React,DB: CREATE Operation (Agent)\n    React->>Nginx: POST /api/strapi/agents<br/>{name, systemPrompt, ...}\n    Nginx->>Express: Forward request\n\n    Note over Express: manager.routes.strapi.ts\n    Express->>Express: Validate request body\n    Express->>Strapi: strapiClient.createAgent(data)\n\n    Note over Strapi: strapi-client.ts\n    Strapi->>Strapi: Transform to Strapi format\n    Strapi->>StrapiAPI: POST /api/agents<br/>Content-Type: application/json\n    StrapiAPI->>StrapiAPI: Validate schema\n    StrapiAPI->>DB: INSERT INTO agents\n    DB-->>StrapiAPI: New agent record\n    StrapiAPI-->>Strapi: Response with populated relations\n    Strapi->>Strapi: Transform to domain model\n    Strapi->>Cache: Invalidate agents cache\n    Strapi-->>Express: Agent object\n    Express-->>React: 201 Created<br/>{agent: {...}}\n\n    Note over React,DB: READ Operation (List Agents)\n    React->>Nginx: GET /api/strapi/agents?enabled=true&sort=name\n    Nginx->>Express: Forward request\n    Express->>Strapi: strapiClient.getAllAgents({<br/>  filters: {enabled: true},<br/>  sort: 'name'<br/>})\n\n    Strapi->>Cache: Check cache key<br/>\"agents:enabled=true&sort=name\"\n\n    alt Cache Hit\n        Cache-->>Strapi: Cached data (< 5 min old)\n        Strapi-->>Express: Agents array\n    else Cache Miss\n        Strapi->>StrapiAPI: GET /api/agents?<br/>filters[enabled][$eq]=true&<br/>sort=name&<br/>populate=*\n        StrapiAPI->>DB: SELECT * FROM agents<br/>WHERE enabled=true<br/>ORDER BY name\n        DB-->>StrapiAPI: Agent records with relations\n        StrapiAPI-->>Strapi: Response data\n        Strapi->>Strapi: Transform each agent\n        Strapi->>Cache: Store in cache (5 min TTL)\n        Strapi-->>Express: Agents array\n    end\n\n    Express-->>React: 200 OK<br/>{agents: [...]}\n\n    Note over React,DB: UPDATE Operation (Agent)\n    React->>Nginx: PUT /api/strapi/agents/:id<br/>{systemPrompt: \"Updated\"}\n    Nginx->>Express: Forward request\n    Express->>Strapi: strapiClient.updateAgent(id, data)\n    Strapi->>Strapi: Transform to Strapi format\n    Strapi->>StrapiAPI: PUT /api/agents/:id\n    StrapiAPI->>DB: UPDATE agents<br/>SET system_prompt='Updated'<br/>WHERE id=:id\n    DB-->>StrapiAPI: Updated record\n    StrapiAPI-->>Strapi: Response data\n    Strapi->>Strapi: Transform to domain model\n    Strapi->>Cache: Invalidate all agents cache\n    Strapi-->>Express: Updated agent\n    Express-->>React: 200 OK<br/>{agent: {...}}\n\n    Note over React,DB: DELETE Operation (Agent)\n    React->>Nginx: DELETE /api/strapi/agents/:id\n    Nginx->>Express: Forward request\n    Express->>Strapi: strapiClient.deleteAgent(id)\n    Strapi->>StrapiAPI: DELETE /api/agents/:id\n    StrapiAPI->>DB: DELETE FROM agents<br/>WHERE id=:id\n    DB-->>StrapiAPI: Deleted record\n    StrapiAPI-->>Strapi: Response data\n    Strapi->>Cache: Invalidate agents cache\n    Strapi-->>Express: Success response\n    Express-->>React: 200 OK<br/>{success: true}\n```\n\n### Strapi Content Types\n\nThe following content types are managed through this CRUD flow:\n\n| Content Type | Endpoints | Relations |\n|-------------|-----------|-----------|\n| **Agents** | `/api/strapi/agents` | skills (M2M), mcpServers (M2M) |\n| **Skills** | `/api/strapi/skills` | agents (M2M), mcpConfig (component) |\n| **MCP Servers** | `/api/strapi/mcp-servers` | agents (M2M), tools (1-to-M) |\n| **MCP Tools** | `/api/strapi/mcp-tools` | mcpServer (M-to-1) |\n| **Chat Sessions** | `/api/strapi/chat-sessions` | messages (1-to-M) |\n| **Chat Messages** | `/api/strapi/chat-messages` | session (M-to-1) |\n| **Tasks** | `/api/strapi/tasks` | agent (M-to-1) |\n\n### Caching Strategy\n\n- **Cache Type**: LRU (Least Recently Used) with 5-minute TTL\n- **Cache Keys**: Generated from query parameters\n- **Invalidation**: On all CREATE, UPDATE, DELETE operations\n- **Benefits**: Reduces Strapi API calls by ~70% for read-heavy operations\n\n---\n\n## 3. MCP Tool Invocation Flow\n\nThis flow shows how MCP (Model Context Protocol) tools are discovered and executed.\n\n```mermaid\nsequenceDiagram\n    participant SDK as Claude SDK Service\n    participant MCP as MCP Service\n    participant Config as .mcp.json\n    participant StrapiDB as Strapi Database\n    participant Process as MCP Server Process\n    participant Tool as Tool Implementation\n\n    Note over SDK,Tool: Phase 1: MCP Server Discovery (3-Tier)\n\n    SDK->>SDK: buildSdkOptions()<br/>Prepare MCP config\n\n    SDK->>Config: Load project-level config\n    Config-->>SDK: .mcp.json servers<br/>(Priority: Low)\n\n    SDK->>StrapiDB: loadMcpServersFromStrapi()<br/>Agent-level MCP servers\n    StrapiDB-->>SDK: Agent's MCP servers<br/>(Priority: Medium)\n\n    SDK->>StrapiDB: loadMcpServersFromSkills()<br/>Skill-level MCP servers\n    StrapiDB-->>SDK: Skills' MCP servers<br/>(Priority: High)\n\n    SDK->>SDK: Merge configs<br/>(Skill > Agent > Project)\n    SDK->>SDK: Filter disabled servers\n    SDK->>SDK: Convert to SDK format\n\n    Note over SDK,Tool: Phase 2: Tool Discovery via JSON-RPC\n\n    SDK->>MCP: Initialize MCP servers\n\n    loop For each MCP server\n        MCP->>Process: Spawn process<br/>command + args + env\n        Process-->>MCP: Process ready (stdio)\n\n        MCP->>Process: JSON-RPC: initialize<br/>{protocolVersion, capabilities}\n        Process->>Process: Start MCP server\n        Process-->>MCP: JSON-RPC: initialized\n\n        MCP->>Process: JSON-RPC: tools/list\n        Process->>Tool: Query available tools\n        Tool-->>Process: Tool schemas\n        Process-->>MCP: JSON-RPC: {tools: [...]}\n\n        MCP->>MCP: Parse tool schemas<br/>(name, description, inputSchema)\n    end\n\n    MCP-->>SDK: All discovered tools\n    SDK->>SDK: Pass tools to Anthropic API\n\n    Note over SDK,Tool: Phase 3: Tool Execution\n\n    SDK->>SDK: Receive tool_use from Claude\n    SDK->>MCP: Execute tool<br/>{name, arguments}\n\n    MCP->>MCP: Find server for tool\n    MCP->>Process: JSON-RPC: tools/call<br/>{name, arguments}\n    Process->>Tool: Execute tool logic\n    Tool->>Tool: Perform operation<br/>(e.g., read_file)\n    Tool-->>Process: Tool result\n    Process-->>MCP: JSON-RPC: {result: ...}\n    MCP-->>SDK: Tool result\n\n    SDK->>SDK: Format as tool_result message\n    SDK->>SDK: Send back to Claude API\n```\n\n### MCP Server Configuration Examples\n\n**stdio Server (Most Common)**\n```json\n{\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/dir\"],\n    \"env\": {\n      \"ALLOWED_PATHS\": \"${HOME}/Documents\"\n    }\n  }\n}\n```\n\n**SSE Server (Remote)**\n```json\n{\n  \"remote-search\": {\n    \"type\": \"sse\",\n    \"url\": \"https://search-api.example.com/sse\",\n    \"headers\": {\n      \"Authorization\": \"Bearer ${API_KEY}\"\n    }\n  }\n}\n```\n\n**SDK Server (In-Process)**\n```typescript\n// Registered in code\nmcpService.registerSdkServer('my-server', {\n  name: 'My Custom Server',\n  version: '1.0.0',\n  tools: [...]\n});\n```\n\n### JSON-RPC Protocol Messages\n\n**Initialize Request**\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"initialize\",\n  \"params\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {},\n    \"clientInfo\": {\n      \"name\": \"claude-agent-ui\",\n      \"version\": \"1.0.0\"\n    }\n  }\n}\n```\n\n**Tools List Request**\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"tools/list\",\n  \"params\": {}\n}\n```\n\n**Tools List Response**\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"tools\": [\n      {\n        \"name\": \"read_file\",\n        \"description\": \"Read the contents of a file\",\n        \"inputSchema\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"path\": {\"type\": \"string\"}\n          },\n          \"required\": [\"path\"]\n        }\n      }\n    ]\n  }\n}\n```\n\n**Tool Call Request**\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"read_file\",\n    \"arguments\": {\n      \"path\": \"/home/user/document.txt\"\n    }\n  }\n}\n```\n\n**Tool Call Response**\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"File contents here...\"\n      }\n    ]\n  }\n}\n```\n\n### MCP Server Transport Types\n\n| Type | Connection | Use Case | Example |\n|------|-----------|----------|---------|\n| **stdio** | Process stdin/stdout | CLI tools, local servers | `npx @modelcontextprotocol/server-filesystem` |\n| **sse** | HTTP Server-Sent Events | Remote services | API endpoints with SSE |\n| **http** | HTTP polling | Remote services | RESTful APIs |\n| **sdk** | In-process TypeScript | Custom tools | Directly imported modules |\n\n---\n\n## 4. Chat/Conversation Data Flow\n\nThis flow shows how interactive chat sessions work with real-time streaming.\n\n```mermaid\nsequenceDiagram\n    participant User as Web Browser\n    participant React as React Frontend\n    participant Express as Express Server\n    participant ChatSvc as Chat Service\n    participant Strapi as Strapi Client\n    participant SDK as Claude SDK Service\n    participant DB as PostgreSQL\n    participant Claude as Anthropic API\n\n    Note over User,Claude: Session Creation\n    User->>React: Click \"New Chat\"\n    React->>Express: POST /api/chat/sessions<br/>{title, skillIds, agentId}\n    Express->>ChatSvc: createChatSession(data)\n    ChatSvc->>Strapi: createChatSession(data)\n    Strapi->>DB: INSERT INTO chat_sessions\n    DB-->>Strapi: New session record\n    Strapi-->>ChatSvc: Session object\n    ChatSvc-->>Express: Session\n    Express-->>React: 201 Created<br/>{session: {...}}\n    React->>User: Show empty chat UI\n\n    Note over User,Claude: Send Message with Streaming\n    User->>React: Type message & send\n    React->>React: Open EventSource<br/>/api/chat/sessions/:id/messages\n    React->>Express: POST /api/chat/sessions/:id/messages<br/>{message, attachments}\n\n    Note over Express: Set SSE headers\n    Express->>ChatSvc: sendMessage(sessionId, data)<br/>Returns async generator\n\n    ChatSvc->>Strapi: getChatSession(sessionId)\n    Strapi->>DB: SELECT from chat_sessions<br/>with relations\n    DB-->>Strapi: Session data\n    Strapi-->>ChatSvc: Session config\n\n    ChatSvc->>Strapi: createChatMessage({<br/>  session: sessionId,<br/>  role: 'user',<br/>  content: message<br/>})\n    Strapi->>DB: INSERT INTO chat_messages\n    DB-->>Strapi: User message record\n    Strapi-->>ChatSvc: Message saved\n\n    ChatSvc->>Express: yield {type: 'user_message_saved'}\n    Express->>React: SSE: user_message_saved\n    React->>User: Show user message\n\n    ChatSvc->>ChatSvc: Load skills from session\n    ChatSvc->>ChatSvc: skillSyncService.syncAllSkills()\n\n    ChatSvc->>SDK: query({<br/>  prompt: message,<br/>  systemPrompt,<br/>  skills,<br/>  model,<br/>  conversationId<br/>})<br/>Returns async generator\n\n    SDK->>Claude: POST /v1/messages<br/>Stream: true<br/>Previous messages as context\n\n    ChatSvc->>Express: yield {type: 'stream_id', streamId}\n    Express->>React: SSE: stream_id event\n\n    ChatSvc->>Strapi: createChatMessage({<br/>  session: sessionId,<br/>  role: 'assistant',<br/>  content: '',<br/>  streamId<br/>})\n    Strapi->>DB: INSERT INTO chat_messages<br/>(empty content initially)\n    DB-->>Strapi: Assistant message record\n    Strapi-->>ChatSvc: Message ID\n\n    ChatSvc->>Express: yield {type: 'assistant_message_start'}\n    Express->>React: SSE: assistant_message_start\n    React->>User: Show typing indicator\n\n    loop For each Claude chunk\n        Claude-->>SDK: Stream chunk\n        SDK->>SDK: Parse SDK message\n        SDK->>ChatSvc: yield message event\n        ChatSvc->>ChatSvc: Accumulate content\n        ChatSvc->>Express: yield {type: 'assistant_message_delta'}\n        Express->>React: SSE: delta event\n        React->>User: Append text incrementally\n    end\n\n    opt Tool Usage in Chat\n        Claude-->>SDK: tool_use message\n        SDK->>ChatSvc: yield tool_use event\n        ChatSvc->>Express: yield SDK message\n        Express->>React: SSE: tool_use event\n        React->>User: Show tool execution\n\n        Note over SDK: Execute tool via MCP\n        SDK->>ChatSvc: yield tool_result event\n        ChatSvc->>Express: yield SDK message\n        Express->>React: SSE: tool_result event\n        React->>User: Show tool result\n    end\n\n    ChatSvc->>Strapi: updateChatMessage(messageId, {<br/>  content: fullContent,<br/>  metadata: {tokens, model}<br/>})\n    Strapi->>DB: UPDATE chat_messages<br/>SET content=...\n    DB-->>Strapi: Updated record\n    Strapi-->>ChatSvc: Success\n\n    ChatSvc->>Express: yield {type: 'assistant_message_saved'}\n    Express->>React: SSE: message_saved event\n\n    ChatSvc->>Express: yield {type: 'done'}\n    Express->>React: SSE: done event\n    Express->>Express: Close SSE stream\n    React->>User: Hide typing indicator\n\n    Note over User,Claude: Load Chat History\n    User->>React: Click on chat session\n    React->>Express: GET /api/chat/sessions/:id/messages\n    Express->>ChatSvc: getChatMessages(sessionId)\n    ChatSvc->>Strapi: getChatMessages(sessionId)\n    Strapi->>DB: SELECT from chat_messages<br/>WHERE session_id=:id<br/>ORDER BY created_at\n    DB-->>Strapi: Message records\n    Strapi-->>ChatSvc: Messages array\n    ChatSvc-->>Express: Messages\n    Express-->>React: 200 OK<br/>{messages: [...]}\n    React->>User: Display conversation history\n\n    Note over User,Claude: Cancel Ongoing Stream\n    User->>React: Click \"Cancel\"\n    React->>Express: POST /api/chat/sessions/:sessionId/messages/:streamId/cancel\n    Express->>ChatSvc: cancelMessage(streamId)\n    ChatSvc->>ChatSvc: AbortController.abort()\n    ChatSvc->>SDK: Abort SDK query\n    SDK->>SDK: Stop streaming\n    ChatSvc-->>Express: {success: true}\n    Express-->>React: 200 OK\n    Express->>Express: Close SSE stream\n    React->>User: Show \"Cancelled\" status\n```\n\n### Chat Message Structure\n\n```typescript\ninterface ChatMessage {\n  id: string;\n  session: string; // Session ID\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  attachments?: Array<{\n    filename: string;\n    mimeType: string;\n    data: string; // base64\n  }>;\n  metadata?: {\n    model?: string;\n    tokens?: {\n      input: number;\n      output: number;\n    };\n    streamId?: string;\n    toolUses?: Array<{\n      name: string;\n      input: any;\n      result: any;\n    }>;\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n```\n\n### Chat Session Configuration\n\n```typescript\ninterface ChatSession {\n  id: string;\n  title: string;\n  agentId?: string;\n  skillIds: string[];\n  customSystemPrompt?: string;\n  workingDirectory?: string;\n  permissionMode?: 'default' | 'bypassPermissions' | 'denyAll';\n  isArchived: boolean;\n  conversationId?: string; // For SDK history\n  messageCount: number;\n  lastMessageAt?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n```\n\n### SSE Events in Chat Flow\n\n| Event Type | Description | Data |\n|-----------|-------------|------|\n| `user_message_saved` | User message saved to DB | `{messageId, content}` |\n| `stream_id` | Stream identifier for cancellation | `{streamId}` |\n| `assistant_message_start` | Assistant begins responding | `{messageId}` |\n| `assistant_message_delta` | Incremental content chunk | `{delta: string}` |\n| `sdk_message` | Raw SDK message (tool_use, result, etc.) | `{content: {...}}` |\n| `assistant_message_saved` | Full response saved to DB | `{messageId, content}` |\n| `done` | Stream complete | `{}` |\n| `error` | Error occurred | `{error: string}` |\n\n---\n\n## Data Flow Patterns Summary\n\n### Request-Response Pattern\n- Used for: CRUD operations, session management\n- Benefits: Simple, reliable, cacheable\n- Example: GET /api/strapi/agents\n\n### Server-Sent Events (SSE) Pattern\n- Used for: Agent execution, chat streaming, task execution\n- Benefits: Real-time updates, unidirectional, HTTP-compatible\n- Example: POST /api/execute/agent/:id (with SSE response)\n\n### Event-Driven Pattern\n- Used for: Internal service communication\n- Benefits: Loose coupling, extensibility\n- Example: claude-sdk-service emits events \u2192 route handlers consume\n\n### Async Generator Pattern\n- Used for: Streaming data transformation\n- Benefits: Backpressure handling, memory efficient\n- Example: chatService.sendMessage() yields events\n\n---\n\n## Performance Considerations\n\n### Caching\n- **Strapi Client**: 5-minute LRU cache reduces database load\n- **Nginx**: Static asset caching with long TTL\n- **PostgreSQL**: Query result caching at database level\n\n### Streaming\n- **SSE Keep-Alive**: 30-second ping prevents connection timeout\n- **Backpressure**: Async generators handle slow consumers\n- **Chunked Transfer**: Large responses streamed incrementally\n\n### Database Optimization\n- **Indexes**: On frequently queried fields (agent.name, session.conversationId)\n- **Populate Strategy**: Only load relations when needed\n- **Connection Pooling**: Reuse database connections\n\n---\n\n## Error Handling\n\n### SSE Error Handling\n```typescript\n// If stream started\nres.write(`data: ${JSON.stringify({type: 'error', error: 'Message'})}\\n\\n`);\nres.end();\n\n// If stream not started\nres.status(500).json({error: 'Message'});\n```\n\n### Database Error Handling\n```typescript\ntry {\n  await strapiClient.createAgent(data);\n} catch (error) {\n  if (error.response?.status === 400) {\n    // Validation error\n  } else if (error.response?.status === 404) {\n    // Not found\n  } else {\n    // Server error\n  }\n}\n```\n\n### MCP Error Handling\n```typescript\n// MCP server fails to start\ncatch (error) {\n  console.error(`Failed to start MCP server: ${error.message}`);\n  // Continue with other servers\n}\n\n// Tool execution fails\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"error\": {\n    \"code\": -32603,\n    \"message\": \"Internal error\",\n    \"data\": {...}\n  }\n}\n```\n\n---\n\n## Security Considerations\n\n### Data Flow Security\n\n1. **Authentication**\n   - Strapi API requires authentication tokens\n   - Tokens passed in `Authorization: Bearer ${token}` header\n\n2. **Input Validation**\n   - Request body validation at Express route level\n   - Strapi schema validation at CMS level\n   - SQL injection prevention via ORM\n\n3. **Environment Variables**\n   - Sensitive credentials (API keys, DB passwords) in `.env`\n   - Environment variable substitution in MCP configs\n   - Never exposed to frontend\n\n4. **Network Isolation**\n   - Database only accessible from backend network\n   - Express validates origin for SSE connections\n   - CORS configured for trusted origins\n\n---\n\n## Next Steps\n\nFor more detailed information, see:\n\n- [System Overview](./01-system-overview.md) - High-level architecture\n- [Deployment Topology](./03-deployment.md) - Docker infrastructure\n- [Component Details](./04-components.md) - Service layer architecture\n- [Sequence Diagrams](./05-sequences.md) - Step-by-step interaction flows\n",
        "last_modified": "2026-01-02T11:16:07.577839"
      },
      "task_intent": {
        "title": "003-create-architecture-documentation-with-system-diag",
        "description": "Create comprehensive visual documentation showing how the hybrid architecture components (React + Express + Strapi + PostgreSQL + Claude SDK + MCP) interact, including data flow, service communication, and deployment topology.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T10:53:08.866180",
  "last_updated": "2026-01-02T10:53:08.896946"
}