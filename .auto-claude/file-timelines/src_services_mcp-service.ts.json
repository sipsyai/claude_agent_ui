{
  "file_path": "src/services/mcp-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\nimport { spawn } from 'child_process';\nimport { createLogger, type Logger } from './logger.js';\nimport {\n  type MCPConfig,\n  type MCPServerConfig,\n  type MCPStdioServerConfig,\n  isStdioServer,\n  isSdkServer,\n} from '../types/mcp-types.js';\nimport { type MCPServer, type MCPTool } from '../types/agent.types.js';\nimport {\n  substituteEnvVarsInObject,\n  hasEnvVarPattern,\n} from '../utils/env-substitution.js';\n\n/**\n * Internal MCP Server type for .mcp.json handling\n * Includes config property for backward compatibility\n */\ninterface MCPServerInternal {\n  id: string;\n  name: string;\n  type: 'stdio' | 'sdk' | 'sse' | 'http';\n  config: MCPServerConfig;\n  disabled?: boolean;\n}\n\n/**\n * Service for managing MCP server configurations (SDK-aligned)\n * @see https://docs.anthropic.com/en/api/agent-sdk/mcp\n */\nexport class MCPService {\n  private logger: Logger;\n  private sdkServers: Map<string, any> = new Map();\n\n  constructor() {\n    this.logger = createLogger('MCPService');\n  }\n\n  /**\n   * Get project MCP config path (.mcp.json at project root)\n   * SDK-aligned location\n   */\n  private getMCPConfigPath(projectPath: string): string {\n    return path.join(projectPath, '.mcp.json');\n  }\n\n  /**\n   * Check for legacy config locations and auto-migrate if found\n   */\n  private async checkAndMigrateLegacyConfigs(projectPath: string): Promise<void> {\n    const legacyPath = path.join(projectPath, '.claude', 'mcp.json');\n\n    if (!existsSync(legacyPath)) {\n      return; // No legacy config, nothing to do\n    }\n\n    try {\n      // Read legacy config\n      const legacyConfig = await this.readMCPConfig(legacyPath);\n      if (!legacyConfig || !legacyConfig.mcpServers || Object.keys(legacyConfig.mcpServers).length === 0) {\n        // Empty legacy config, just delete it\n        await fs.unlink(legacyPath);\n        this.logger.info('Removed empty legacy MCP config', { legacyPath });\n        return;\n      }\n\n      // Get current config path\n      const newConfigPath = this.getMCPConfigPath(projectPath);\n\n      // Read existing new config\n      let newConfig = await this.readMCPConfig(newConfigPath);\n\n      if (!newConfig) {\n        // No new config exists, just move the legacy one\n        await this.writeMCPConfig(newConfigPath, legacyConfig);\n        await fs.unlink(legacyPath);\n        this.logger.info(\n          '\u2713 Migrated legacy MCP config to .mcp.json',\n          {\n            from: legacyPath,\n            to: newConfigPath,\n            serverCount: Object.keys(legacyConfig.mcpServers).length\n          }\n        );\n      } else {\n        // Both configs exist, merge them (new config takes precedence)\n        const mergedServers = {\n          ...legacyConfig.mcpServers,\n          ...newConfig.mcpServers, // New config overwrites legacy\n        };\n\n        const mergedConfig: MCPConfig = {\n          mcpServers: mergedServers,\n        };\n\n        await this.writeMCPConfig(newConfigPath, mergedConfig);\n        await fs.unlink(legacyPath);\n        this.logger.info(\n          '\u2713 Merged and migrated legacy MCP config to .mcp.json',\n          {\n            from: legacyPath,\n            to: newConfigPath,\n            totalServers: Object.keys(mergedServers).length\n          }\n        );\n      }\n    } catch (error) {\n      this.logger.error(\n        'Failed to migrate legacy MCP config. Please manually move .claude/mcp.json to .mcp.json',\n        { legacyPath, error }\n      );\n    }\n  }\n\n  /**\n   * Read MCP config from file with env var substitution\n   */\n  private async readMCPConfig(configPath: string): Promise<MCPConfig | null> {\n    try {\n      if (!existsSync(configPath)) {\n        return null;\n      }\n\n      const content = await fs.readFile(configPath, 'utf-8');\n      let config = JSON.parse(content) as MCPConfig;\n\n      // Apply environment variable substitution\n      config = substituteEnvVarsInObject(config);\n\n      return config;\n    } catch (error) {\n      this.logger.error('Failed to read MCP config', { path: configPath, error });\n      return null;\n    }\n  }\n\n  /**\n   * Write MCP config to file\n   */\n  private async writeMCPConfig(configPath: string, config: MCPConfig): Promise<void> {\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(configPath);\n      await fs.mkdir(dir, { recursive: true });\n\n      // Write config\n      await fs.writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8');\n\n      this.logger.info('MCP config written', { path: configPath });\n    } catch (error) {\n      this.logger.error('Failed to write MCP config', { path: configPath, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Convert MCP config entries to MCPServer objects\n   */\n  private configToServers(config: MCPConfig | null): MCPServerInternal[] {\n    if (!config || !config.mcpServers) {\n      return [];\n    }\n\n    return Object.entries(config.mcpServers).map(([name, serverConfig]) => {\n      // Determine transport type\n      const type = serverConfig.type || 'stdio';\n\n      return {\n        id: name,\n        name,\n        type,\n        config: serverConfig,\n        disabled: serverConfig.disabled,\n      };\n    });\n  }\n\n  /**\n   * Register an SDK MCP server (in-process)\n   */\n  registerSdkServer(name: string, instance: any): void {\n    this.sdkServers.set(name, instance);\n    this.logger.info('SDK MCP server registered', { name });\n  }\n\n  /**\n   * Unregister an SDK MCP server\n   */\n  unregisterSdkServer(name: string): void {\n    this.sdkServers.delete(name);\n    this.logger.info('SDK MCP server unregistered', { name });\n  }\n\n  /**\n   * Get all MCP servers from project config\n   */\n  async getMCPServers(projectPath?: string): Promise<MCPServerInternal[]> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    // Auto-migrate legacy configs if found\n    await this.checkAndMigrateLegacyConfigs(projectPath);\n\n    const configPath = this.getMCPConfigPath(projectPath);\n    const config = await this.readMCPConfig(configPath);\n    const servers = this.configToServers(config);\n\n    this.logger.debug('Retrieved MCP servers', {\n      total: servers.length,\n      configPath,\n    });\n\n    return servers;\n  }\n\n  /**\n   * Get a specific MCP server by ID\n   */\n  async getMCPServerById(id: string, projectPath?: string): Promise<MCPServerInternal | null> {\n    const servers = await this.getMCPServers(projectPath);\n    const server = servers.find(s => s.id === id);\n\n    if (!server) {\n      this.logger.warn('MCP server not found', { id });\n      return null;\n    }\n\n    return server;\n  }\n\n  /**\n   * Add a new MCP server\n   */\n  async addMCPServer(\n    name: string,\n    serverConfig: MCPServerConfig,\n    projectPath?: string\n  ): Promise<MCPServerInternal> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    // Read existing config\n    let config = await this.readMCPConfig(configPath);\n    if (!config) {\n      config = { mcpServers: {} };\n    }\n\n    // Check if server already exists\n    if (config.mcpServers[name]) {\n      throw new Error(`MCP server \"${name}\" already exists`);\n    }\n\n    // Add new server\n    config.mcpServers[name] = serverConfig;\n\n    // Write config\n    await this.writeMCPConfig(configPath, config);\n\n    this.logger.info('MCP server added', { name });\n\n    const type = serverConfig.type || 'stdio';\n    return {\n      id: name,\n      name,\n      type,\n      config: serverConfig,\n      disabled: serverConfig.disabled,\n    };\n  }\n\n  /**\n   * Update an existing MCP server\n   */\n  async updateMCPServer(\n    id: string,\n    serverConfig: MCPServerConfig,\n    projectPath?: string\n  ): Promise<MCPServerInternal> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    // Read existing config\n    const config = await this.readMCPConfig(configPath);\n    if (!config || !config.mcpServers[id]) {\n      throw new Error(`MCP server \"${id}\" not found`);\n    }\n\n    // Update server\n    config.mcpServers[id] = serverConfig;\n\n    // Write config\n    await this.writeMCPConfig(configPath, config);\n\n    this.logger.info('MCP server updated', { id });\n\n    const type = serverConfig.type || 'stdio';\n    return {\n      id,\n      name: id,\n      type,\n      config: serverConfig,\n      disabled: serverConfig.disabled,\n    };\n  }\n\n  /**\n   * Delete an MCP server\n   */\n  async deleteMCPServer(id: string, projectPath?: string): Promise<void> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    // Read existing config\n    const config = await this.readMCPConfig(configPath);\n    if (!config || !config.mcpServers[id]) {\n      throw new Error(`MCP server \"${id}\" not found`);\n    }\n\n    // Delete server\n    delete config.mcpServers[id];\n\n    // Write config\n    await this.writeMCPConfig(configPath, config);\n\n    this.logger.info('MCP server deleted', { id });\n  }\n\n  /**\n   * Test an MCP server\n   */\n  async testMCPServer(id: string, projectPath?: string): Promise<{\n    success: boolean;\n    message: string;\n    error?: string;\n  }> {\n    try {\n      const server = await this.getMCPServerById(id, projectPath);\n      if (!server) {\n        return {\n          success: false,\n          message: 'Server not found',\n          error: 'MCP server not found',\n        };\n      }\n\n      // Test based on transport type\n      if (isStdioServer(server.config)) {\n        return await this.testStdioServer(server.config);\n      } else if (isSdkServer(server.config)) {\n        return await this.testSdkServer(server.config);\n      } else {\n        return {\n          success: false,\n          message: 'Unsupported transport type',\n          error: `Transport type \"${server.config.type}\" not yet implemented`,\n        };\n      }\n    } catch (error) {\n      this.logger.error('Failed to test MCP server', { id, error });\n      return {\n        success: false,\n        message: 'Test failed',\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Test stdio MCP server\n   */\n  private async testStdioServer(config: MCPServerConfig): Promise<{\n    success: boolean;\n    message: string;\n    error?: string;\n  }> {\n    if (!isStdioServer(config)) {\n      return {\n        success: false,\n        message: 'Invalid server config',\n        error: 'Not a stdio server',\n      };\n    }\n\n    return new Promise((resolve) => {\n      const timeout = 10000; // 10 seconds\n      let resolved = false;\n\n      const child = spawn(config.command, config.args || [], {\n        env: { ...process.env, ...config.env },\n        stdio: ['pipe', 'pipe', 'pipe'],\n        shell: true,\n      });\n\n      const timeoutId = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          child.kill();\n          resolve({\n            success: false,\n            message: 'Test timeout',\n            error: 'MCP server did not respond within 10 seconds',\n          });\n        }\n      }, timeout);\n\n      child.on('error', (error) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeoutId);\n          child.kill();\n          resolve({\n            success: false,\n            message: 'Failed to start',\n            error: error.message,\n          });\n        }\n      });\n\n      child.on('spawn', () => {\n        // Successfully spawned, kill it after a brief moment\n        setTimeout(() => {\n          if (!resolved) {\n            resolved = true;\n            clearTimeout(timeoutId);\n            child.kill();\n            resolve({\n              success: true,\n              message: 'MCP server started successfully',\n            });\n          }\n        }, 1000);\n      });\n\n      child.on('exit', (code) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeoutId);\n          if (code === 0 || code === null) {\n            resolve({\n              success: true,\n              message: 'MCP server started and exited cleanly',\n            });\n          } else {\n            resolve({\n              success: false,\n              message: 'MCP server exited with error',\n              error: `Exit code: ${code}`,\n            });\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Test SDK MCP server\n   */\n  private async testSdkServer(config: MCPServerConfig): Promise<{\n    success: boolean;\n    message: string;\n    error?: string;\n  }> {\n    if (!isSdkServer(config)) {\n      return {\n        success: false,\n        message: 'Invalid server config',\n        error: 'Not an SDK server',\n      };\n    }\n\n    const instance = this.sdkServers.get(config.name);\n    if (!instance) {\n      return {\n        success: false,\n        message: 'SDK server not registered',\n        error: `SDK server \"${config.name}\" instance not found. Use registerSdkServer() first.`,\n      };\n    }\n\n    // Check if instance has required methods\n    if (typeof instance.listTools !== 'function') {\n      return {\n        success: false,\n        message: 'Invalid SDK server',\n        error: 'SDK server instance must implement listTools() method',\n      };\n    }\n\n    return {\n      success: true,\n      message: 'SDK server is registered and valid',\n    };\n  }\n\n  /**\n   * Export MCP configuration\n   */\n  async exportMCPConfig(projectPath?: string): Promise<MCPConfig | null> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n    return await this.readMCPConfig(configPath);\n  }\n\n  /**\n   * Import MCP configuration\n   */\n  async importMCPConfig(\n    config: MCPConfig,\n    mode: 'merge' | 'overwrite',\n    projectPath?: string\n  ): Promise<void> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    if (mode === 'overwrite') {\n      // Direct overwrite\n      await this.writeMCPConfig(configPath, config);\n      this.logger.info('MCP config imported (overwrite)');\n    } else {\n      // Merge with existing\n      const existingConfig = await this.readMCPConfig(configPath);\n      const mergedConfig: MCPConfig = {\n        mcpServers: {\n          ...(existingConfig?.mcpServers || {}),\n          ...config.mcpServers,\n        },\n      };\n\n      await this.writeMCPConfig(configPath, mergedConfig);\n      this.logger.info('MCP config imported (merge)');\n    }\n  }\n\n  /**\n   * Bulk delete MCP servers\n   */\n  async bulkDeleteMCPServers(\n    serverIds: string[],\n    projectPath?: string\n  ): Promise<{ success: number; failed: number; errors: string[] }> {\n    let success = 0;\n    let failed = 0;\n    const errors: string[] = [];\n\n    for (const id of serverIds) {\n      try {\n        await this.deleteMCPServer(id, projectPath);\n        success++;\n      } catch (error) {\n        failed++;\n        errors.push(`${id}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n\n    this.logger.info('Bulk delete completed', { success, failed });\n\n    return { success, failed, errors };\n  }\n\n  /**\n   * Toggle MCP server enabled/disabled state\n   */\n  async toggleMCPServer(id: string, projectPath?: string): Promise<{\n    success: boolean;\n    disabled: boolean;\n    message: string;\n  }> {\n    try {\n      if (!projectPath) {\n        projectPath = process.cwd();\n      }\n\n      const configPath = this.getMCPConfigPath(projectPath);\n      const config = await this.readMCPConfig(configPath);\n\n      if (!config || !config.mcpServers || !config.mcpServers[id]) {\n        return {\n          success: false,\n          disabled: false,\n          message: 'MCP server not found',\n        };\n      }\n\n      // Toggle disabled state\n      const currentState = config.mcpServers[id].disabled || false;\n      config.mcpServers[id].disabled = !currentState;\n\n      await this.writeMCPConfig(configPath, config);\n\n      const newState = config.mcpServers[id].disabled || false;\n      this.logger.info('MCP server toggled', { id, disabled: newState });\n\n      return {\n        success: true,\n        disabled: newState,\n        message: `MCP server ${newState ? 'disabled' : 'enabled'} successfully`,\n      };\n    } catch (error) {\n      this.logger.error('Failed to toggle MCP server', { id, error });\n      return {\n        success: false,\n        disabled: false,\n        message: error instanceof Error ? error.message : 'Failed to toggle server',\n      };\n    }\n  }\n\n  /**\n   * List tools provided by an MCP server\n   */\n  async listMCPServerTools(id: string, projectPath?: string): Promise<{\n    success: boolean;\n    tools: MCPTool[];\n    error?: string;\n  }> {\n    try {\n      const server = await this.getMCPServerById(id, projectPath);\n      if (!server) {\n        return {\n          success: false,\n          tools: [],\n          error: 'MCP server not found',\n        };\n      }\n\n      // Fetch tools based on transport type\n      let tools: MCPTool[] = [];\n\n      if (isStdioServer(server.config)) {\n        tools = await this.fetchToolsFromStdioServer(server.config);\n      } else if (isSdkServer(server.config)) {\n        tools = await this.fetchToolsFromSdkServer(server.config);\n      } else {\n        return {\n          success: false,\n          tools: [],\n          error: `Transport type \"${server.config.type}\" not yet implemented`,\n        };\n      }\n\n      this.logger.info('Listed MCP server tools', { id, toolCount: tools.length });\n\n      return {\n        success: true,\n        tools,\n      };\n    } catch (error) {\n      this.logger.error('Failed to list MCP server tools', { id, error });\n      return {\n        success: false,\n        tools: [],\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Fetch tools from stdio MCP server via JSON-RPC\n   */\n  private async fetchToolsFromStdioServer(config: MCPServerConfig): Promise<MCPTool[]> {\n    if (!isStdioServer(config)) {\n      throw new Error('Not a stdio server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = 15000; // 15 seconds\n      let resolved = false;\n      const tools: MCPTool[] = [];\n      let initialized = false;\n\n      const child = spawn(config.command, config.args || [], {\n        env: { ...process.env, ...config.env },\n        stdio: ['pipe', 'pipe', 'pipe'],\n        shell: true,\n      });\n\n      const timeoutId = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          child.kill();\n          reject(new Error('Timeout fetching tools from MCP server'));\n        }\n      }, timeout);\n\n      let stdout = '';\n\n      child.stdout?.on('data', (data) => {\n        stdout += data.toString();\n\n        // Try to parse each line as it comes\n        const lines = stdout.split('\\n');\n        for (const line of lines) {\n          if (!line.trim()) continue;\n\n          try {\n            const response = JSON.parse(line);\n\n            // Check if this is initialize response\n            if (!initialized && response.result && response.id === 1) {\n              initialized = true;\n              // Send tools/list request after initialization\n              const toolsRequest = {\n                jsonrpc: '2.0',\n                id: 2,\n                method: 'tools/list',\n                params: {},\n              };\n              child.stdin?.write(JSON.stringify(toolsRequest) + '\\n');\n            }\n\n            // Check if this is tools/list response\n            if (response.result && response.id === 2 && Array.isArray(response.result.tools)) {\n              tools.push(...response.result.tools.map((tool: any) => ({\n                name: tool.name,\n                description: tool.description,\n                inputSchema: tool.inputSchema,\n              })));\n\n              // Success! Clean up and resolve\n              if (!resolved) {\n                resolved = true;\n                clearTimeout(timeoutId);\n                child.kill();\n                resolve(tools);\n              }\n            }\n          } catch (e) {\n            // Skip non-JSON lines or parsing errors\n          }\n        }\n      });\n\n      child.on('error', (error) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeoutId);\n          reject(error);\n        }\n      });\n\n      child.on('spawn', () => {\n        // Send initialize request first (MCP protocol requirement)\n        const initRequest = {\n          jsonrpc: '2.0',\n          id: 1,\n          method: 'initialize',\n          params: {\n            protocolVersion: '2024-11-05',\n            capabilities: {},\n            clientInfo: {\n              name: 'cui-manager',\n              version: '1.0.0',\n            },\n          },\n        };\n        child.stdin?.write(JSON.stringify(initRequest) + '\\n');\n      });\n\n      child.on('close', (code) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeoutId);\n\n          // If we got tools, resolve with them\n          if (tools.length > 0) {\n            resolve(tools);\n          } else {\n            resolve([]); // Return empty array instead of rejecting\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Fetch tools from SDK MCP server\n   */\n  private async fetchToolsFromSdkServer(config: MCPServerConfig): Promise<MCPTool[]> {\n    if (!isSdkServer(config)) {\n      throw new Error('Not an SDK server');\n    }\n\n    const instance = this.sdkServers.get(config.name);\n    if (!instance) {\n      throw new Error(`SDK server \"${config.name}\" not registered`);\n    }\n\n    if (typeof instance.listTools !== 'function') {\n      throw new Error('SDK server does not implement listTools() method');\n    }\n\n    try {\n      const tools = await instance.listTools();\n      return tools.map((tool: any) => ({\n        name: tool.name,\n        description: tool.description,\n        inputSchema: tool.inputSchema,\n      }));\n    } catch (error) {\n      this.logger.error('Failed to list tools from SDK server', { name: config.name, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Sync MCP servers to .mcp.json file\n   * Converts Strapi format to SDK format\n   */\n  async syncToMcpJson(\n    servers: Array<{\n      name: string;\n      command: string;\n      args?: string[];\n      env?: Record<string, string>;\n      disabled?: boolean;\n      transport?: string;\n    }>,\n    projectPath?: string\n  ): Promise<void> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    // Build MCP config object\n    const mcpServers: Record<string, MCPServerConfig> = {};\n\n    for (const server of servers) {\n      // Skip disabled servers (they won't be in .mcp.json)\n      if (server.disabled) {\n        continue;\n      }\n\n      // Convert to MCP config format\n      const serverConfig: MCPStdioServerConfig = {\n        command: server.command,\n        args: server.args || [],\n        env: server.env || {},\n      };\n\n      // Add type if not stdio\n      if (server.transport && server.transport !== 'stdio') {\n        (serverConfig as any).type = server.transport;\n      }\n\n      mcpServers[server.name] = serverConfig;\n    }\n\n    const config: MCPConfig = { mcpServers };\n\n    // Write to .mcp.json\n    await this.writeMCPConfig(configPath, config);\n\n    this.logger.info('Synced MCP servers to .mcp.json', {\n      serverCount: Object.keys(mcpServers).length,\n      configPath,\n    });\n  }\n\n  /**\n   * Sync MCP servers from .mcp.json file\n   * Returns servers in format suitable for Strapi\n   */\n  async syncFromMcpJson(projectPath?: string): Promise<\n    Array<{\n      name: string;\n      command: string;\n      args: string[];\n      env: Record<string, string>;\n      disabled: boolean;\n      transport: string;\n    }>\n  > {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n    const config = await this.readMCPConfig(configPath);\n\n    if (!config || !config.mcpServers) {\n      return [];\n    }\n\n    const servers = [];\n\n    for (const [name, serverConfig] of Object.entries(config.mcpServers)) {\n      // Only handle stdio servers for now\n      if (isStdioServer(serverConfig)) {\n        servers.push({\n          name,\n          command: serverConfig.command,\n          args: serverConfig.args || [],\n          env: serverConfig.env || {},\n          disabled: serverConfig.disabled || false,\n          transport: serverConfig.type || 'stdio',\n        });\n      }\n    }\n\n    this.logger.info('Synced MCP servers from .mcp.json', {\n      serverCount: servers.length,\n      configPath,\n    });\n\n    return servers;\n  }\n}\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\nimport { spawn } from 'child_process';\nimport { createLogger, type Logger } from './logger.js';\nimport {\n  type MCPConfig,\n  type MCPServerConfig,\n  type MCPStdioServerConfig,\n  isStdioServer,\n  isSdkServer,\n} from '../types/mcp-types.js';\nimport { type MCPServer, type MCPTool } from '../types/agent.types.js';\nimport {\n  substituteEnvVarsInObject,\n  hasEnvVarPattern,\n} from '../utils/env-substitution.js';\n\n/**\n * Internal MCP Server type for .mcp.json configuration handling\n *\n * @description\n * Represents an MCP server configuration as stored in and retrieved from the\n * .mcp.json file. This interface extends the basic MCPServerConfig with additional\n * metadata needed for runtime server management.\n *\n * The interface maintains backward compatibility with legacy .claude/mcp.json files\n * while supporting the SDK-aligned .mcp.json format at the project root.\n *\n * @property {string} id - Unique identifier for the MCP server (typically the server name)\n * @property {string} name - Human-readable name of the MCP server\n * @property {'stdio' | 'sdk' | 'sse' | 'http'} type - Transport type for MCP communication\n *   - 'stdio': Standard I/O transport (spawns external process)\n *   - 'sdk': In-process SDK server (registered JavaScript/TypeScript instance)\n *   - 'sse': Server-Sent Events transport (not yet implemented)\n *   - 'http': HTTP transport (not yet implemented)\n * @property {MCPServerConfig} config - Complete server configuration including command, args, env\n * @property {boolean} [disabled] - Whether the server is disabled (excluded from active use)\n *\n * @example\n * ```typescript\n * const server: MCPServerInternal = {\n *   id: 'filesystem',\n *   name: 'filesystem',\n *   type: 'stdio',\n *   config: {\n *     command: 'npx',\n *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n *     env: { DEBUG: 'true' }\n *   },\n *   disabled: false\n * };\n * ```\n *\n * @see {@link https://docs.anthropic.com/en/api/agent-sdk/mcp | Anthropic MCP Documentation}\n */\ninterface MCPServerInternal {\n  id: string;\n  name: string;\n  type: 'stdio' | 'sdk' | 'sse' | 'http';\n  config: MCPServerConfig;\n  disabled?: boolean;\n}\n\n/**\n * MCPService - Service for managing Model Context Protocol (MCP) server configurations\n *\n * @description\n * Manages MCP server configurations in SDK-aligned format, providing CRUD operations,\n * configuration file management, server testing, and bidirectional synchronization.\n * This service bridges the gap between the application's MCP server management needs\n * and Anthropic's Claude Agent SDK MCP integration requirements.\n *\n * Key responsibilities:\n * - Read/write .mcp.json configuration files at project root (SDK-aligned location)\n * - Auto-migrate legacy .claude/mcp.json configs to new .mcp.json format\n * - Manage MCP server lifecycle (add, update, delete, toggle enabled/disabled)\n * - Test MCP server connectivity and tool availability\n * - Support both stdio (external process) and SDK (in-process) transport types\n * - Register and manage in-process SDK MCP server instances\n * - Fetch available tools from MCP servers via JSON-RPC protocol\n * - Handle environment variable substitution in server configurations\n * - Provide bidirectional sync with Strapi database (syncToMcpJson/syncFromMcpJson)\n * - Support bulk operations (bulk delete, import/export configs)\n *\n * Configuration Format:\n * The service manages .mcp.json files in the format expected by Claude Agent SDK:\n * ```json\n * {\n *   \"mcpServers\": {\n *     \"server-name\": {\n *       \"command\": \"npx\",\n *       \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path\"],\n *       \"env\": { \"DEBUG\": \"true\" },\n *       \"disabled\": false\n *     }\n *   }\n * }\n * ```\n *\n * Transport Types:\n * - stdio: Spawns external MCP server process, communicates via JSON-RPC over stdin/stdout\n * - sdk: Manages in-process JavaScript/TypeScript MCP server instances\n * - sse/http: Reserved for future implementation\n *\n * Architecture:\n * - Uses internal Map to track registered SDK server instances\n * - Automatically migrates legacy configs from .claude/mcp.json to .mcp.json\n * - Applies environment variable substitution (${ENV_VAR} syntax) on config read\n * - Integrates with Claude Agent SDK's MCP server configuration format\n * - Provides both file-based and programmatic server management\n *\n * @example\n * ```typescript\n * // Initialize the service\n * const mcpService = new MCPService();\n *\n * // Add a new stdio MCP server\n * const filesystemServer = await mcpService.addMCPServer(\n *   'filesystem',\n *   {\n *     command: 'npx',\n *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n *     env: { DEBUG: 'true' }\n *   },\n *   '/path/to/project'\n * );\n *\n * // Test server connectivity\n * const testResult = await mcpService.testMCPServer('filesystem', '/path/to/project');\n * console.log(testResult.success ? 'Server OK' : testResult.error);\n *\n * // List available tools\n * const toolsResult = await mcpService.listMCPServerTools('filesystem', '/path/to/project');\n * console.log('Available tools:', toolsResult.tools);\n *\n * // Register an in-process SDK server\n * import { MyMCPServer } from './my-mcp-server.js';\n * const sdkServer = new MyMCPServer();\n * mcpService.registerSdkServer('my-sdk-server', sdkServer);\n *\n * // Add SDK server to config\n * await mcpService.addMCPServer(\n *   'my-sdk-server',\n *   { type: 'sdk', name: 'my-sdk-server' },\n *   '/path/to/project'\n * );\n *\n * // Toggle server enabled/disabled\n * const toggleResult = await mcpService.toggleMCPServer('filesystem', '/path/to/project');\n * console.log(`Server now ${toggleResult.disabled ? 'disabled' : 'enabled'}`);\n *\n * // Get all configured servers\n * const servers = await mcpService.getMCPServers('/path/to/project');\n * console.log(`Found ${servers.length} MCP servers`);\n *\n * // Sync servers to .mcp.json (from Strapi format)\n * await mcpService.syncToMcpJson([\n *   {\n *     name: 'github',\n *     command: 'npx',\n *     args: ['-y', '@modelcontextprotocol/server-github'],\n *     env: { GITHUB_TOKEN: '${GITHUB_TOKEN}' }\n *   }\n * ], '/path/to/project');\n *\n * // Export configuration for backup\n * const config = await mcpService.exportMCPConfig('/path/to/project');\n * await fs.writeFile('backup.json', JSON.stringify(config, null, 2));\n * ```\n *\n * @see {@link https://docs.anthropic.com/en/api/agent-sdk/mcp | Anthropic MCP Documentation}\n * @see {@link https://modelcontextprotocol.io | Model Context Protocol Specification}\n */\nexport class MCPService {\n  /** Logger instance for debugging and operational logging */\n  private logger: Logger;\n\n  /** Registry of in-process SDK MCP server instances, keyed by server name */\n  private sdkServers: Map<string, any> = new Map();\n\n  constructor() {\n    this.logger = createLogger('MCPService');\n  }\n\n  /**\n   * Get project MCP config path (.mcp.json at project root)\n   *\n   * @description\n   * Returns the absolute path to the .mcp.json configuration file at the project root.\n   * This location is SDK-aligned with Anthropic's Claude Agent SDK expectations, which\n   * looks for MCP server configurations at the project root rather than in .claude/ subdirectory.\n   *\n   * The .mcp.json file is the canonical location for MCP server configurations that are\n   * automatically loaded by the Claude Agent SDK. This service reads/writes this file to\n   * manage server configurations programmatically.\n   *\n   * @param projectPath - Absolute path to the project directory\n   *\n   * @returns Absolute path to the .mcp.json file (e.g., '/path/to/project/.mcp.json')\n   *\n   * @example\n   * ```typescript\n   * const configPath = this.getMCPConfigPath('/Users/dev/my-project');\n   * // Returns: '/Users/dev/my-project/.mcp.json'\n   * ```\n   *\n   * @private\n   */\n  private getMCPConfigPath(projectPath: string): string {\n    return path.join(projectPath, '.mcp.json');\n  }\n\n  /**\n   * Check for legacy config locations and auto-migrate if found\n   *\n   * @description\n   * Automatically detects and migrates legacy MCP configurations from the old\n   * .claude/mcp.json location to the new SDK-aligned .mcp.json location at project root.\n   *\n   * This method implements a smart migration strategy:\n   * 1. If no legacy config exists: No action taken\n   * 2. If legacy config is empty: Delete legacy file\n   * 3. If only legacy config exists: Move to new location\n   * 4. If both exist: Merge configs (new config takes precedence), then delete legacy\n   *\n   * The migration is automatic and transparent to users. After migration, the legacy\n   * .claude/mcp.json file is deleted to avoid confusion. All migrations are logged\n   * with server counts for audit purposes.\n   *\n   * This ensures backward compatibility for projects using the old config location\n   * while transitioning to the SDK-aligned format expected by Claude Agent SDK.\n   *\n   * @param projectPath - Absolute path to the project directory to check for legacy configs\n   *\n   * @returns Promise that resolves when migration is complete (or skipped if no legacy config)\n   *\n   * @example\n   * ```typescript\n   * // Before migration:\n   * // .claude/mcp.json exists with { \"mcpServers\": { \"filesystem\": {...} } }\n   * // .mcp.json doesn't exist\n   *\n   * await this.checkAndMigrateLegacyConfigs('/path/to/project');\n   *\n   * // After migration:\n   * // .claude/mcp.json is deleted\n   * // .mcp.json now contains { \"mcpServers\": { \"filesystem\": {...} } }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Merge scenario - both configs exist\n   * // .claude/mcp.json: { \"mcpServers\": { \"old-server\": {...}, \"shared\": { version: 1 } } }\n   * // .mcp.json: { \"mcpServers\": { \"new-server\": {...}, \"shared\": { version: 2 } } }\n   *\n   * await this.checkAndMigrateLegacyConfigs('/path/to/project');\n   *\n   * // Result in .mcp.json:\n   * // { \"mcpServers\": { \"old-server\": {...}, \"new-server\": {...}, \"shared\": { version: 2 } } }\n   * // Note: new config's \"shared\" server overwrites legacy version\n   * ```\n   *\n   * @private\n   */\n  private async checkAndMigrateLegacyConfigs(projectPath: string): Promise<void> {\n    const legacyPath = path.join(projectPath, '.claude', 'mcp.json');\n\n    if (!existsSync(legacyPath)) {\n      return; // No legacy config, nothing to do\n    }\n\n    try {\n      // Read legacy config\n      const legacyConfig = await this.readMCPConfig(legacyPath);\n      if (!legacyConfig || !legacyConfig.mcpServers || Object.keys(legacyConfig.mcpServers).length === 0) {\n        // Empty legacy config, just delete it\n        await fs.unlink(legacyPath);\n        this.logger.info('Removed empty legacy MCP config', { legacyPath });\n        return;\n      }\n\n      // Get current config path\n      const newConfigPath = this.getMCPConfigPath(projectPath);\n\n      // Read existing new config\n      let newConfig = await this.readMCPConfig(newConfigPath);\n\n      if (!newConfig) {\n        // No new config exists, just move the legacy one\n        await this.writeMCPConfig(newConfigPath, legacyConfig);\n        await fs.unlink(legacyPath);\n        this.logger.info(\n          '\u2713 Migrated legacy MCP config to .mcp.json',\n          {\n            from: legacyPath,\n            to: newConfigPath,\n            serverCount: Object.keys(legacyConfig.mcpServers).length\n          }\n        );\n      } else {\n        // Both configs exist, merge them (new config takes precedence)\n        const mergedServers = {\n          ...legacyConfig.mcpServers,\n          ...newConfig.mcpServers, // New config overwrites legacy\n        };\n\n        const mergedConfig: MCPConfig = {\n          mcpServers: mergedServers,\n        };\n\n        await this.writeMCPConfig(newConfigPath, mergedConfig);\n        await fs.unlink(legacyPath);\n        this.logger.info(\n          '\u2713 Merged and migrated legacy MCP config to .mcp.json',\n          {\n            from: legacyPath,\n            to: newConfigPath,\n            totalServers: Object.keys(mergedServers).length\n          }\n        );\n      }\n    } catch (error) {\n      this.logger.error(\n        'Failed to migrate legacy MCP config. Please manually move .claude/mcp.json to .mcp.json',\n        { legacyPath, error }\n      );\n    }\n  }\n\n  /**\n   * Read MCP config from file with env var substitution\n   *\n   * @description\n   * Reads and parses an MCP configuration file (.mcp.json), applying environment\n   * variable substitution to all string values. This enables secure configuration\n   * management by allowing sensitive values (like API keys) to be stored in\n   * environment variables rather than committed to version control.\n   *\n   * The method performs the following steps:\n   * 1. Check if config file exists (returns null if not found)\n   * 2. Read file contents as UTF-8 text\n   * 3. Parse JSON into MCPConfig object\n   * 4. Apply environment variable substitution using ${VAR_NAME} syntax\n   * 5. Return the fully-resolved configuration\n   *\n   * Environment variable substitution supports the format:\n   * - ${VAR_NAME} - Replaced with process.env.VAR_NAME value\n   * - If environment variable is not set, the literal string is preserved\n   *\n   * Errors during read/parse are logged and null is returned, allowing the\n   * application to gracefully handle missing or invalid configurations.\n   *\n   * @param configPath - Absolute path to the MCP configuration file to read\n   *\n   * @returns Promise resolving to parsed MCPConfig with env vars substituted,\n   *          or null if file doesn't exist or parsing fails\n   *\n   * @example\n   * ```typescript\n   * // Config file at /project/.mcp.json:\n   * // {\n   * //   \"mcpServers\": {\n   * //     \"github\": {\n   * //       \"command\": \"npx\",\n   * //       \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n   * //       \"env\": { \"GITHUB_TOKEN\": \"${GITHUB_TOKEN}\" }\n   * //     }\n   * //   }\n   * // }\n   *\n   * // With environment variable: GITHUB_TOKEN=ghp_abc123\n   * const config = await this.readMCPConfig('/project/.mcp.json');\n   *\n   * // Result:\n   * // {\n   * //   mcpServers: {\n   * //     github: {\n   * //       command: \"npx\",\n   * //       args: [\"-y\", \"@modelcontextprotocol/server-github\"],\n   * //       env: { GITHUB_TOKEN: \"ghp_abc123\" }  // <- Substituted!\n   * //     }\n   * //   }\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // File doesn't exist\n   * const config = await this.readMCPConfig('/nonexistent/.mcp.json');\n   * console.log(config); // null\n   * ```\n   *\n   * @private\n   */\n  private async readMCPConfig(configPath: string): Promise<MCPConfig | null> {\n    try {\n      if (!existsSync(configPath)) {\n        return null;\n      }\n\n      const content = await fs.readFile(configPath, 'utf-8');\n      let config = JSON.parse(content) as MCPConfig;\n\n      // Apply environment variable substitution\n      config = substituteEnvVarsInObject(config);\n\n      return config;\n    } catch (error) {\n      this.logger.error('Failed to read MCP config', { path: configPath, error });\n      return null;\n    }\n  }\n\n  /**\n   * Write MCP config to file\n   *\n   * @description\n   * Writes an MCPConfig object to disk as a formatted JSON file. This method ensures\n   * the configuration is persisted in a human-readable format with proper indentation\n   * (2 spaces) and UTF-8 encoding.\n   *\n   * The method performs the following operations:\n   * 1. Ensure parent directory exists (creates recursively if needed)\n   * 2. Serialize config object to formatted JSON (2-space indentation)\n   * 3. Write to file with UTF-8 encoding\n   * 4. Log success with file path\n   *\n   * If the write operation fails (e.g., due to permission issues), the error is\n   * logged and re-thrown to allow the caller to handle it appropriately.\n   *\n   * This method does NOT perform environment variable substitution in reverse -\n   * it writes the config exactly as provided. Callers are responsible for ensuring\n   * sensitive values use ${VAR_NAME} placeholders if desired.\n   *\n   * @param configPath - Absolute path to the MCP configuration file to write\n   * @param config - MCPConfig object to serialize and write to disk\n   *\n   * @returns Promise that resolves when the file is successfully written\n   *\n   * @throws Error if directory creation fails or file write operation fails\n   *\n   * @example\n   * ```typescript\n   * const config: MCPConfig = {\n   *   mcpServers: {\n   *     filesystem: {\n   *       command: 'npx',\n   *       args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *       env: { DEBUG: 'true' }\n   *     }\n   *   }\n   * };\n   *\n   * await this.writeMCPConfig('/project/.mcp.json', config);\n   *\n   * // File written to /project/.mcp.json:\n   * // {\n   * //   \"mcpServers\": {\n   * //     \"filesystem\": {\n   * //       \"command\": \"npx\",\n   * //       \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/tmp\"],\n   * //       \"env\": { \"DEBUG\": \"true\" }\n   * //     }\n   * //   }\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Writing to nested directory (auto-creates parent dirs)\n   * const config: MCPConfig = { mcpServers: {} };\n   * await this.writeMCPConfig('/project/configs/mcp/.mcp.json', config);\n   * // Creates /project/configs/mcp/ directory if it doesn't exist\n   * ```\n   *\n   * @private\n   */\n  private async writeMCPConfig(configPath: string, config: MCPConfig): Promise<void> {\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(configPath);\n      await fs.mkdir(dir, { recursive: true });\n\n      // Write config\n      await fs.writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8');\n\n      this.logger.info('MCP config written', { path: configPath });\n    } catch (error) {\n      this.logger.error('Failed to write MCP config', { path: configPath, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Convert MCP config entries to MCPServer objects\n   *\n   * @description\n   * Transforms the raw MCPConfig object (from .mcp.json file) into a normalized array\n   * of MCPServerInternal objects. This method flattens the key-value structure of\n   * mcpServers into a consistent array format that's easier to work with programmatically.\n   *\n   * The transformation process:\n   * 1. Extracts server name from object keys\n   * 2. Determines transport type (stdio, sdk, sse, http) from config or defaults to 'stdio'\n   * 3. Creates MCPServerInternal objects with normalized structure\n   * 4. Preserves all original config properties (command, args, env, disabled)\n   * 5. Uses server name as both 'id' and 'name' for consistency\n   *\n   * This method safely handles null or empty configs by returning an empty array,\n   * making it safe to use in all contexts without null checks.\n   *\n   * The resulting MCPServerInternal[] array is the internal representation used\n   * throughout the service for server management operations.\n   *\n   * @param config - MCPConfig object read from file, or null if file doesn't exist\n   *\n   * @returns Array of MCPServerInternal objects with normalized structure.\n   *          Returns empty array if config is null or has no servers.\n   *\n   * @example\n   * ```typescript\n   * const config: MCPConfig = {\n   *   mcpServers: {\n   *     filesystem: {\n   *       command: 'npx',\n   *       args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *       env: { DEBUG: 'true' }\n   *     },\n   *     github: {\n   *       command: 'npx',\n   *       args: ['-y', '@modelcontextprotocol/server-github'],\n   *       env: { GITHUB_TOKEN: '${GITHUB_TOKEN}' },\n   *       disabled: true\n   *     },\n   *     customSdk: {\n   *       type: 'sdk',\n   *       name: 'customSdk'\n   *     }\n   *   }\n   * };\n   *\n   * const servers = this.configToServers(config);\n   *\n   * // Result:\n   * // [\n   * //   {\n   * //     id: 'filesystem',\n   * //     name: 'filesystem',\n   * //     type: 'stdio',  // <- Inferred from missing 'type' field\n   * //     config: { command: 'npx', args: [...], env: {...} },\n   * //     disabled: undefined\n   * //   },\n   * //   {\n   * //     id: 'github',\n   * //     name: 'github',\n   * //     type: 'stdio',\n   * //     config: { command: 'npx', args: [...], env: {...}, disabled: true },\n   * //     disabled: true\n   * //   },\n   * //   {\n   * //     id: 'customSdk',\n   * //     name: 'customSdk',\n   * //     type: 'sdk',  // <- Explicit type from config\n   * //     config: { type: 'sdk', name: 'customSdk' },\n   * //     disabled: undefined\n   * //   }\n   * // ]\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handling null/empty configs\n   * const servers1 = this.configToServers(null);\n   * console.log(servers1); // []\n   *\n   * const servers2 = this.configToServers({ mcpServers: {} });\n   * console.log(servers2); // []\n   * ```\n   *\n   * @private\n   */\n  private configToServers(config: MCPConfig | null): MCPServerInternal[] {\n    if (!config || !config.mcpServers) {\n      return [];\n    }\n\n    return Object.entries(config.mcpServers).map(([name, serverConfig]) => {\n      // Determine transport type\n      const type = serverConfig.type || 'stdio';\n\n      return {\n        id: name,\n        name,\n        type,\n        config: serverConfig,\n        disabled: serverConfig.disabled,\n      };\n    });\n  }\n\n  /**\n   * Register an in-process SDK MCP server instance\n   *\n   * @description\n   * Registers a JavaScript/TypeScript MCP server instance for in-process execution.\n   * SDK servers run directly within the Node.js process, avoiding the overhead of\n   * spawning external processes and providing faster tool execution.\n   *\n   * This method stores the server instance in an internal registry (Map) keyed by\n   * server name. Once registered, the SDK server can be:\n   * - Added to .mcp.json configuration with type 'sdk'\n   * - Tested for validity using testMCPServer()\n   * - Queried for available tools using listMCPServerTools()\n   * - Used by Claude Agent SDK for in-process tool execution\n   *\n   * The server instance must implement the MCP server interface, specifically:\n   * - listTools(): Promise<Tool[]> - Returns array of available tools\n   * - Additional methods as required by MCP protocol\n   *\n   * Registration is a prerequisite for SDK server functionality. Attempting to use\n   * an SDK server before registration will result in \"server not registered\" errors\n   * when testing or listing tools.\n   *\n   * @param name - Unique identifier for the SDK server (must match config name)\n   * @param instance - MCP server instance implementing listTools() and other MCP methods\n   *\n   * @example\n   * ```typescript\n   * import { MyCustomMCPServer } from './my-mcp-server.js';\n   *\n   * const mcpService = new MCPService();\n   *\n   * // Create and register SDK server instance\n   * const myServer = new MyCustomMCPServer({\n   *   config: { apiKey: process.env.API_KEY }\n   * });\n   *\n   * mcpService.registerSdkServer('my-custom-server', myServer);\n   *\n   * // Now add to configuration\n   * await mcpService.addMCPServer(\n   *   'my-custom-server',\n   *   { type: 'sdk', name: 'my-custom-server' },\n   *   '/path/to/project'\n   * );\n   *\n   * // Test the registered server\n   * const result = await mcpService.testMCPServer('my-custom-server', '/path/to/project');\n   * console.log(result.success); // true\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Multiple SDK servers\n   * const weatherServer = new WeatherMCPServer();\n   * const databaseServer = new DatabaseMCPServer();\n   *\n   * mcpService.registerSdkServer('weather', weatherServer);\n   * mcpService.registerSdkServer('database', databaseServer);\n   *\n   * // Both servers now available for in-process execution\n   * ```\n   */\n  registerSdkServer(name: string, instance: any): void {\n    this.sdkServers.set(name, instance);\n    this.logger.info('SDK MCP server registered', { name });\n  }\n\n  /**\n   * Unregister an in-process SDK MCP server instance\n   *\n   * @description\n   * Removes a previously registered SDK MCP server instance from the internal registry.\n   * This effectively disables in-process execution for the specified server.\n   *\n   * After unregistration:\n   * - The server instance is removed from the internal Map\n   * - Testing the server will return \"SDK server not registered\" error\n   * - Attempting to list tools will fail with \"server not registered\" error\n   * - The server config may still exist in .mcp.json but won't function\n   *\n   * This method is useful for:\n   * - Hot-reloading server implementations during development\n   * - Cleaning up resources before application shutdown\n   * - Temporarily disabling SDK servers without modifying .mcp.json\n   * - Replacing server instances with updated versions\n   *\n   * Note: This method only affects the in-process registry. To completely remove\n   * the server, you should also call deleteMCPServer() to remove it from .mcp.json.\n   *\n   * @param name - Name of the SDK server to unregister (must match registration name)\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   * const myServer = new MyMCPServer();\n   *\n   * // Register server\n   * mcpService.registerSdkServer('my-server', myServer);\n   *\n   * // Later, unregister it\n   * mcpService.unregisterSdkServer('my-server');\n   *\n   * // Server is no longer available for in-process execution\n   * const result = await mcpService.testMCPServer('my-server', '/path/to/project');\n   * console.log(result.success); // false\n   * console.log(result.error); // \"SDK server \"my-server\" instance not found...\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Hot-reload pattern: replace server instance with updated version\n   * mcpService.unregisterSdkServer('my-server');\n   *\n   * // Load updated server code\n   * const updatedServer = new MyMCPServerV2();\n   * mcpService.registerSdkServer('my-server', updatedServer);\n   * ```\n   */\n  unregisterSdkServer(name: string): void {\n    this.sdkServers.delete(name);\n    this.logger.info('SDK MCP server unregistered', { name });\n  }\n\n  /**\n   * Get all MCP servers from project configuration\n   *\n   * @description\n   * Retrieves all MCP servers configured in the project's .mcp.json file, returning\n   * them as an array of normalized MCPServerInternal objects. This is the primary\n   * method for listing all available MCP servers in a project.\n   *\n   * The method performs the following operations:\n   * 1. Auto-detect and migrate legacy .claude/mcp.json configs to .mcp.json (if found)\n   * 2. Read .mcp.json from project root with environment variable substitution\n   * 3. Transform raw config into normalized MCPServerInternal[] array\n   * 4. Return all servers (both enabled and disabled)\n   *\n   * The returned servers include both stdio (external process) and SDK (in-process)\n   * transport types. Each server object contains:\n   * - id and name (typically the same, derived from config key)\n   * - type (stdio, sdk, sse, http)\n   * - config (complete server configuration)\n   * - disabled flag (if true, server won't be loaded by Claude SDK)\n   *\n   * If no .mcp.json file exists or the file is empty, an empty array is returned.\n   * This method never throws errors - file read failures are logged and result in\n   * an empty array return.\n   *\n   * @param projectPath - Absolute path to project directory containing .mcp.json.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to array of MCPServerInternal objects.\n   *          Returns empty array if no config exists or config is invalid.\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Get all servers in current project\n   * const servers = await mcpService.getMCPServers();\n   * console.log(`Found ${servers.length} MCP servers`);\n   *\n   * servers.forEach(server => {\n   *   console.log(`- ${server.name} (${server.type})${server.disabled ? ' [disabled]' : ''}`);\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Get servers for specific project\n   * const servers = await mcpService.getMCPServers('/Users/dev/my-project');\n   *\n   * // Filter enabled stdio servers\n   * const enabledStdioServers = servers.filter(s =>\n   *   s.type === 'stdio' && !s.disabled\n   * );\n   *\n   * // Check if specific server exists\n   * const hasFilesystem = servers.some(s => s.name === 'filesystem');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // List all servers with their tools\n   * const servers = await mcpService.getMCPServers();\n   *\n   * for (const server of servers) {\n   *   if (!server.disabled) {\n   *     const toolsResult = await mcpService.listMCPServerTools(server.id);\n   *     console.log(`${server.name}: ${toolsResult.tools.length} tools`);\n   *   }\n   * }\n   * ```\n   */\n  async getMCPServers(projectPath?: string): Promise<MCPServerInternal[]> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    // Auto-migrate legacy configs if found\n    await this.checkAndMigrateLegacyConfigs(projectPath);\n\n    const configPath = this.getMCPConfigPath(projectPath);\n    const config = await this.readMCPConfig(configPath);\n    const servers = this.configToServers(config);\n\n    this.logger.debug('Retrieved MCP servers', {\n      total: servers.length,\n      configPath,\n    });\n\n    return servers;\n  }\n\n  /**\n   * Get a specific MCP server by its unique identifier\n   *\n   * @description\n   * Retrieves a single MCP server configuration by ID from the project's .mcp.json file.\n   * This is a convenience method that wraps getMCPServers() and filters by ID.\n   *\n   * The method:\n   * 1. Calls getMCPServers() to load all servers (including legacy migration)\n   * 2. Searches for a server with matching ID (case-sensitive exact match)\n   * 3. Returns the server if found, or null if not found\n   * 4. Logs a warning if server is not found\n   *\n   * The ID corresponds to the server name as defined in .mcp.json. For example,\n   * if .mcp.json contains { \"mcpServers\": { \"filesystem\": {...} } }, the ID is \"filesystem\".\n   *\n   * Returns null (rather than throwing) for missing servers, allowing callers to\n   * gracefully handle non-existent servers without try/catch blocks.\n   *\n   * @param id - Unique identifier of the MCP server (must match config key exactly)\n   * @param projectPath - Absolute path to project directory containing .mcp.json.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to MCPServerInternal if found, or null if server\n   *          with specified ID doesn't exist in configuration.\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Get specific server\n   * const server = await mcpService.getMCPServerById('filesystem');\n   *\n   * if (server) {\n   *   console.log(`Found ${server.name}`);\n   *   console.log(`Type: ${server.type}`);\n   *   console.log(`Disabled: ${server.disabled || false}`);\n   *\n   *   if (isStdioServer(server.config)) {\n   *     console.log(`Command: ${server.config.command}`);\n   *     console.log(`Args: ${server.config.args?.join(' ')}`);\n   *   }\n   * } else {\n   *   console.log('Server not found');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Check if server exists before testing\n   * const server = await mcpService.getMCPServerById('github', '/path/to/project');\n   *\n   * if (!server) {\n   *   console.error('GitHub MCP server not configured');\n   *   return;\n   * }\n   *\n   * // Server exists, safe to test\n   * const testResult = await mcpService.testMCPServer('github', '/path/to/project');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Update server if exists, add if not\n   * const existingServer = await mcpService.getMCPServerById('custom-server');\n   *\n   * if (existingServer) {\n   *   await mcpService.updateMCPServer('custom-server', newConfig);\n   * } else {\n   *   await mcpService.addMCPServer('custom-server', newConfig);\n   * }\n   * ```\n   */\n  async getMCPServerById(id: string, projectPath?: string): Promise<MCPServerInternal | null> {\n    const servers = await this.getMCPServers(projectPath);\n    const server = servers.find(s => s.id === id);\n\n    if (!server) {\n      this.logger.warn('MCP server not found', { id });\n      return null;\n    }\n\n    return server;\n  }\n\n  /**\n   * Add a new MCP server to project configuration\n   *\n   * @description\n   * Creates a new MCP server entry in the project's .mcp.json configuration file.\n   * This method adds the server to the persistent configuration, making it available\n   * for use by the Claude Agent SDK.\n   *\n   * The method performs the following operations:\n   * 1. Read existing .mcp.json (or create new config if file doesn't exist)\n   * 2. Validate that server name doesn't already exist (throws if duplicate)\n   * 3. Add new server configuration to mcpServers object\n   * 4. Write updated config back to .mcp.json\n   * 5. Return normalized MCPServerInternal object representing the new server\n   *\n   * Server Configuration Types:\n   * - Stdio server: Requires command, optional args and env\n   *   ```typescript\n   *   {\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *     env: { DEBUG: 'true' }\n   *   }\n   *   ```\n   *\n   * - SDK server: Requires type 'sdk' and name (instance must be registered first)\n   *   ```typescript\n   *   { type: 'sdk', name: 'my-sdk-server' }\n   *   ```\n   *\n   * The server is added in enabled state by default. To add a disabled server,\n   * include `disabled: true` in the serverConfig.\n   *\n   * @param name - Unique name for the MCP server (becomes the config key in .mcp.json)\n   * @param serverConfig - Complete server configuration including transport details\n   * @param projectPath - Absolute path to project directory.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to MCPServerInternal object representing the newly added server\n   *\n   * @throws Error if server with the same name already exists in configuration\n   * @throws Error if .mcp.json write operation fails (e.g., permission issues)\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Add a stdio MCP server\n   * const filesystemServer = await mcpService.addMCPServer(\n   *   'filesystem',\n   *   {\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *     env: { DEBUG: 'true' }\n   *   },\n   *   '/path/to/project'\n   * );\n   *\n   * console.log(`Added ${filesystemServer.name} (${filesystemServer.type})`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Add SDK server (must register instance first)\n   * const myServer = new MyCustomMCPServer();\n   * mcpService.registerSdkServer('custom-sdk', myServer);\n   *\n   * const sdkServer = await mcpService.addMCPServer(\n   *   'custom-sdk',\n   *   { type: 'sdk', name: 'custom-sdk' }\n   * );\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Add server with environment variables\n   * const githubServer = await mcpService.addMCPServer(\n   *   'github',\n   *   {\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-github'],\n   *     env: {\n   *       GITHUB_TOKEN: '${GITHUB_TOKEN}',  // Will be substituted from env\n   *       GITHUB_ORG: 'my-org'\n   *     }\n   *   }\n   * );\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Add disabled server (won't be loaded by SDK until enabled)\n   * const disabledServer = await mcpService.addMCPServer(\n   *   'experimental-server',\n   *   {\n   *     command: 'node',\n   *     args: ['./experimental-mcp-server.js'],\n   *     disabled: true\n   *   }\n   * );\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling for duplicate names\n   * try {\n   *   await mcpService.addMCPServer('filesystem', { command: 'test' });\n   * } catch (error) {\n   *   console.error('Server already exists:', error.message);\n   *   // Error: MCP server \"filesystem\" already exists\n   * }\n   * ```\n   */\n  async addMCPServer(\n    name: string,\n    serverConfig: MCPServerConfig,\n    projectPath?: string\n  ): Promise<MCPServerInternal> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    // Read existing config\n    let config = await this.readMCPConfig(configPath);\n    if (!config) {\n      config = { mcpServers: {} };\n    }\n\n    // Check if server already exists\n    if (config.mcpServers[name]) {\n      throw new Error(`MCP server \"${name}\" already exists`);\n    }\n\n    // Add new server\n    config.mcpServers[name] = serverConfig;\n\n    // Write config\n    await this.writeMCPConfig(configPath, config);\n\n    this.logger.info('MCP server added', { name });\n\n    const type = serverConfig.type || 'stdio';\n    return {\n      id: name,\n      name,\n      type,\n      config: serverConfig,\n      disabled: serverConfig.disabled,\n    };\n  }\n\n  /**\n   * Update an existing MCP server configuration\n   *\n   * @description\n   * Modifies the configuration of an existing MCP server in the project's .mcp.json file.\n   * This method performs a complete replacement of the server's configuration with the\n   * new serverConfig provided.\n   *\n   * The method performs the following operations:\n   * 1. Read existing .mcp.json configuration\n   * 2. Validate that server with specified ID exists (throws if not found)\n   * 3. Replace server configuration with new serverConfig (complete replacement, not merge)\n   * 4. Write updated config back to .mcp.json\n   * 5. Return normalized MCPServerInternal object with updated configuration\n   *\n   * Important: This is a full replacement operation. Any properties in the old\n   * configuration that are not included in the new serverConfig will be lost.\n   * If you need to modify specific properties while preserving others, retrieve\n   * the existing config first, modify it, then pass the merged result.\n   *\n   * The update affects the persistent configuration and will take effect the next\n   * time Claude Agent SDK loads MCP servers. Active server connections are not\n   * automatically restarted - the application may need to restart for changes to\n   * take effect.\n   *\n   * @param id - Unique identifier of the MCP server to update (must exist in config)\n   * @param serverConfig - New complete server configuration (replaces existing config)\n   * @param projectPath - Absolute path to project directory.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to MCPServerInternal object with updated configuration\n   *\n   * @throws Error if server with specified ID is not found in configuration\n   * @throws Error if .mcp.json write operation fails (e.g., permission issues)\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Update server's command and args\n   * const updatedServer = await mcpService.updateMCPServer(\n   *   'filesystem',\n   *   {\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/home/user'],\n   *     env: { DEBUG: 'true', LOG_LEVEL: 'info' }\n   *   },\n   *   '/path/to/project'\n   * );\n   *\n   * console.log('Server updated:', updatedServer.name);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Disable a server by updating its config\n   * await mcpService.updateMCPServer(\n   *   'github',\n   *   {\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-github'],\n   *     disabled: true  // Server will not be loaded\n   *   }\n   * );\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Safe update: merge with existing config to preserve properties\n   * const existingServer = await mcpService.getMCPServerById('filesystem');\n   *\n   * if (existingServer && isStdioServer(existingServer.config)) {\n   *   // Merge new args with existing config\n   *   const updatedConfig = {\n   *     ...existingServer.config,\n   *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/new/path']\n   *   };\n   *\n   *   await mcpService.updateMCPServer('filesystem', updatedConfig);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Update environment variables\n   * const githubServer = await mcpService.getMCPServerById('github');\n   *\n   * if (githubServer && isStdioServer(githubServer.config)) {\n   *   await mcpService.updateMCPServer('github', {\n   *     ...githubServer.config,\n   *     env: {\n   *       ...githubServer.config.env,\n   *       GITHUB_TOKEN: '${NEW_GITHUB_TOKEN}',  // Update token reference\n   *       GITHUB_API_URL: 'https://api.github.com'\n   *     }\n   *   });\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling for non-existent server\n   * try {\n   *   await mcpService.updateMCPServer('nonexistent', { command: 'test' });\n   * } catch (error) {\n   *   console.error('Cannot update:', error.message);\n   *   // Error: MCP server \"nonexistent\" not found\n   * }\n   * ```\n   */\n  async updateMCPServer(\n    id: string,\n    serverConfig: MCPServerConfig,\n    projectPath?: string\n  ): Promise<MCPServerInternal> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    // Read existing config\n    const config = await this.readMCPConfig(configPath);\n    if (!config || !config.mcpServers[id]) {\n      throw new Error(`MCP server \"${id}\" not found`);\n    }\n\n    // Update server\n    config.mcpServers[id] = serverConfig;\n\n    // Write config\n    await this.writeMCPConfig(configPath, config);\n\n    this.logger.info('MCP server updated', { id });\n\n    const type = serverConfig.type || 'stdio';\n    return {\n      id,\n      name: id,\n      type,\n      config: serverConfig,\n      disabled: serverConfig.disabled,\n    };\n  }\n\n  /**\n   * Delete an MCP server from project configuration\n   *\n   * @description\n   * Permanently removes an MCP server entry from the project's .mcp.json configuration file.\n   * This method deletes the server from persistent storage, making it unavailable for\n   * future use by the Claude Agent SDK.\n   *\n   * The method performs the following operations:\n   * 1. Read existing .mcp.json configuration\n   * 2. Validate that server with specified ID exists (throws if not found)\n   * 3. Remove server entry from mcpServers object using JavaScript delete operator\n   * 4. Write updated config back to .mcp.json\n   * 5. Log successful deletion\n   *\n   * Important Considerations:\n   * - This is a permanent deletion - the server configuration cannot be recovered\n   *   unless you have a backup of .mcp.json\n   * - Active server connections are not automatically terminated - the application\n   *   may need to restart for changes to take effect\n   * - For SDK servers, this only removes the config entry - the registered instance\n   *   remains in memory until unregisterSdkServer() is called\n   * - Consider using toggleMCPServer() to disable instead of delete if you may\n   *   need to re-enable the server later\n   *\n   * The deletion affects only the .mcp.json configuration. For SDK servers, you\n   * should also call unregisterSdkServer() to clean up the in-memory instance.\n   *\n   * @param id - Unique identifier of the MCP server to delete (must exist in config)\n   * @param projectPath - Absolute path to project directory.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise that resolves when server is successfully deleted\n   *\n   * @throws Error if server with specified ID is not found in configuration\n   * @throws Error if .mcp.json write operation fails (e.g., permission issues)\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Delete a server\n   * await mcpService.deleteMCPServer('filesystem', '/path/to/project');\n   * console.log('Filesystem server deleted');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Check if server exists before deleting\n   * const server = await mcpService.getMCPServerById('old-server');\n   *\n   * if (server) {\n   *   await mcpService.deleteMCPServer('old-server');\n   *   console.log('Old server removed');\n   * } else {\n   *   console.log('Server not found, nothing to delete');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Delete SDK server: remove both registration and config\n   * mcpService.unregisterSdkServer('my-sdk-server');  // Remove instance\n   * await mcpService.deleteMCPServer('my-sdk-server'); // Remove config\n   * console.log('SDK server fully removed');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling for non-existent server\n   * try {\n   *   await mcpService.deleteMCPServer('nonexistent');\n   * } catch (error) {\n   *   console.error('Cannot delete:', error.message);\n   *   // Error: MCP server \"nonexistent\" not found\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Conditional delete: remove if disabled\n   * const servers = await mcpService.getMCPServers();\n   *\n   * for (const server of servers) {\n   *   if (server.disabled) {\n   *     await mcpService.deleteMCPServer(server.id);\n   *     console.log(`Deleted disabled server: ${server.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Safe deletion with backup\n   * const mcpService = new MCPService();\n   *\n   * // Backup config before deleting\n   * const config = await mcpService.exportMCPConfig('/path/to/project');\n   * await fs.writeFile('mcp-backup.json', JSON.stringify(config, null, 2));\n   *\n   * // Now safe to delete\n   * await mcpService.deleteMCPServer('experimental-server');\n   * ```\n   */\n  async deleteMCPServer(id: string, projectPath?: string): Promise<void> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    // Read existing config\n    const config = await this.readMCPConfig(configPath);\n    if (!config || !config.mcpServers[id]) {\n      throw new Error(`MCP server \"${id}\" not found`);\n    }\n\n    // Delete server\n    delete config.mcpServers[id];\n\n    // Write config\n    await this.writeMCPConfig(configPath, config);\n\n    this.logger.info('MCP server deleted', { id });\n  }\n\n  /**\n   * Test MCP server connectivity and validity\n   *\n   * @description\n   * Validates that an MCP server is properly configured and can be successfully\n   * initialized. This method performs a comprehensive test of the server based on\n   * its transport type, ensuring the server is ready for use by the Claude Agent SDK.\n   *\n   * The testing process:\n   * 1. Retrieves server configuration from .mcp.json by ID\n   * 2. Determines transport type (stdio or SDK)\n   * 3. Delegates to type-specific test method:\n   *    - Stdio servers: Spawns process, verifies it starts successfully\n   *    - SDK servers: Checks instance is registered and implements required methods\n   * 4. Returns detailed test result with success/failure status and error details\n   *\n   * Testing Behavior by Transport Type:\n   *\n   * **Stdio Servers:**\n   * - Spawns the external process using configured command and args\n   * - Waits for successful spawn event (up to 10 seconds)\n   * - Kills process after 1 second if spawn succeeds\n   * - Returns success if process spawns without errors\n   * - Returns failure if process fails to spawn, times out, or exits with error\n   *\n   * **SDK Servers:**\n   * - Checks if server instance is registered in internal registry\n   * - Validates instance implements required listTools() method\n   * - Returns success if instance exists and is valid\n   * - Returns failure if instance not registered or missing required methods\n   *\n   * This method is safe to call repeatedly and does not affect server state.\n   * It's designed for configuration validation and troubleshooting.\n   *\n   * @param id - Unique identifier of the MCP server to test (must exist in .mcp.json)\n   * @param projectPath - Absolute path to project directory.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to test result object:\n   *          - success: boolean indicating if test passed\n   *          - message: Human-readable test result description\n   *          - error: Optional error message if test failed\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Test a stdio server\n   * const result = await mcpService.testMCPServer('filesystem', '/path/to/project');\n   *\n   * if (result.success) {\n   *   console.log('\u2713', result.message);\n   *   // Output: \"\u2713 MCP server started successfully\"\n   * } else {\n   *   console.error('\u2717', result.message, ':', result.error);\n   *   // Output: \"\u2717 Failed to start : Command 'npx' not found\"\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Test SDK server (requires prior registration)\n   * const myServer = new MyMCPServer();\n   * mcpService.registerSdkServer('my-server', myServer);\n   *\n   * await mcpService.addMCPServer(\n   *   'my-server',\n   *   { type: 'sdk', name: 'my-server' }\n   * );\n   *\n   * const result = await mcpService.testMCPServer('my-server');\n   * console.log(result.message);\n   * // Output: \"SDK server is registered and valid\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Test all configured servers\n   * const servers = await mcpService.getMCPServers();\n   *\n   * for (const server of servers) {\n   *   const result = await mcpService.testMCPServer(server.id);\n   *   console.log(`${server.name}: ${result.success ? '\u2713' : '\u2717'} ${result.message}`);\n   * }\n   *\n   * // Output:\n   * // filesystem: \u2713 MCP server started successfully\n   * // github: \u2717 Failed to start : GITHUB_TOKEN not set\n   * // custom-sdk: \u2713 SDK server is registered and valid\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle test failures gracefully\n   * const result = await mcpService.testMCPServer('experimental-server');\n   *\n   * if (!result.success) {\n   *   if (result.error?.includes('not found')) {\n   *     console.log('Server not configured - add it first');\n   *   } else if (result.error?.includes('timeout')) {\n   *     console.log('Server timed out - check command and args');\n   *   } else if (result.error?.includes('not registered')) {\n   *     console.log('SDK server needs registration');\n   *   } else {\n   *     console.log('Unknown error:', result.error);\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Test before using in production\n   * async function enableServerIfValid(serverId: string) {\n   *   const testResult = await mcpService.testMCPServer(serverId);\n   *\n   *   if (testResult.success) {\n   *     // Server is valid, ensure it's enabled\n   *     const server = await mcpService.getMCPServerById(serverId);\n   *     if (server?.disabled) {\n   *       await mcpService.toggleMCPServer(serverId);\n   *       console.log(`${serverId} enabled and ready to use`);\n   *     }\n   *   } else {\n   *     console.error(`Cannot enable ${serverId}:`, testResult.error);\n   *   }\n   * }\n   * ```\n   */\n  async testMCPServer(id: string, projectPath?: string): Promise<{\n    success: boolean;\n    message: string;\n    error?: string;\n  }> {\n    try {\n      const server = await this.getMCPServerById(id, projectPath);\n      if (!server) {\n        return {\n          success: false,\n          message: 'Server not found',\n          error: 'MCP server not found',\n        };\n      }\n\n      // Test based on transport type\n      if (isStdioServer(server.config)) {\n        return await this.testStdioServer(server.config);\n      } else if (isSdkServer(server.config)) {\n        return await this.testSdkServer(server.config);\n      } else {\n        return {\n          success: false,\n          message: 'Unsupported transport type',\n          error: `Transport type \"${server.config.type}\" not yet implemented`,\n        };\n      }\n    } catch (error) {\n      this.logger.error('Failed to test MCP server', { id, error });\n      return {\n        success: false,\n        message: 'Test failed',\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Test stdio MCP server by spawning external process\n   *\n   * @description\n   * Validates a stdio-based MCP server by spawning its external process and verifying\n   * it starts successfully. This method performs a shallow connectivity test without\n   * attempting full MCP protocol initialization.\n   *\n   * The testing process:\n   * 1. Validates config is a stdio server configuration\n   * 2. Spawns external process using configured command, args, and env\n   * 3. Monitors process events with 10-second timeout:\n   *    - 'spawn': Process started successfully \u2192 wait 1s, then kill and return success\n   *    - 'error': Process failed to spawn \u2192 return failure with error message\n   *    - 'exit': Process exited \u2192 success if code 0/null, failure otherwise\n   *    - timeout: No response after 10s \u2192 kill process and return timeout error\n   * 4. Cleans up spawned process in all cases\n   *\n   * This is a \"smoke test\" to verify the server can be launched, not a full functional test.\n   * It does NOT test MCP protocol compliance or tool availability - use listMCPServerTools()\n   * for comprehensive validation.\n   *\n   * The method uses Promise-based async handling with proper cleanup to ensure spawned\n   * processes are always terminated, preventing orphaned child processes.\n   *\n   * @param config - MCP server configuration (must be stdio type with command property)\n   *\n   * @returns Promise resolving to test result object:\n   *          - success: true if process spawned successfully, false otherwise\n   *          - message: Human-readable description of test result\n   *          - error: Optional error details if test failed\n   *\n   * @example\n   * ```typescript\n   * const config: MCPStdioServerConfig = {\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *   env: { DEBUG: 'true' }\n   * };\n   *\n   * const result = await this.testStdioServer(config);\n   *\n   * // Success case:\n   * // { success: true, message: 'MCP server started successfully' }\n   *\n   * // Failure case:\n   * // { success: false, message: 'Failed to start', error: 'Command not found' }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Timeout scenario (server takes too long to start)\n   * const slowConfig: MCPStdioServerConfig = {\n   *   command: 'slow-mcp-server',\n   *   args: ['--delay', '20000']\n   * };\n   *\n   * const result = await this.testStdioServer(slowConfig);\n   * // { success: false, message: 'Test timeout', error: 'MCP server did not respond within 10 seconds' }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Invalid config handling\n   * const sdkConfig = { type: 'sdk', name: 'my-server' } as MCPServerConfig;\n   *\n   * const result = await this.testStdioServer(sdkConfig);\n   * // { success: false, message: 'Invalid server config', error: 'Not a stdio server' }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Environment variable issues\n   * const githubConfig: MCPStdioServerConfig = {\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-github'],\n   *   env: { GITHUB_TOKEN: '${GITHUB_TOKEN}' }  // Not set in environment\n   * };\n   *\n   * const result = await this.testStdioServer(githubConfig);\n   * // May succeed at spawn but fail during actual use when token is required\n   * ```\n   *\n   * @private\n   */\n  private async testStdioServer(config: MCPServerConfig): Promise<{\n    success: boolean;\n    message: string;\n    error?: string;\n  }> {\n    if (!isStdioServer(config)) {\n      return {\n        success: false,\n        message: 'Invalid server config',\n        error: 'Not a stdio server',\n      };\n    }\n\n    return new Promise((resolve) => {\n      const timeout = 10000; // 10 seconds\n      let resolved = false;\n\n      const child = spawn(config.command, config.args || [], {\n        env: { ...process.env, ...config.env },\n        stdio: ['pipe', 'pipe', 'pipe'],\n        shell: true,\n      });\n\n      const timeoutId = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          child.kill();\n          resolve({\n            success: false,\n            message: 'Test timeout',\n            error: 'MCP server did not respond within 10 seconds',\n          });\n        }\n      }, timeout);\n\n      child.on('error', (error) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeoutId);\n          child.kill();\n          resolve({\n            success: false,\n            message: 'Failed to start',\n            error: error.message,\n          });\n        }\n      });\n\n      child.on('spawn', () => {\n        // Successfully spawned, kill it after a brief moment\n        setTimeout(() => {\n          if (!resolved) {\n            resolved = true;\n            clearTimeout(timeoutId);\n            child.kill();\n            resolve({\n              success: true,\n              message: 'MCP server started successfully',\n            });\n          }\n        }, 1000);\n      });\n\n      child.on('exit', (code) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeoutId);\n          if (code === 0 || code === null) {\n            resolve({\n              success: true,\n              message: 'MCP server started and exited cleanly',\n            });\n          } else {\n            resolve({\n              success: false,\n              message: 'MCP server exited with error',\n              error: `Exit code: ${code}`,\n            });\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Test SDK MCP server instance validity\n   *\n   * @description\n   * Validates an in-process SDK MCP server by checking that the instance is properly\n   * registered and implements the required MCP server interface. This is a synchronous\n   * validation (no process spawning) that verifies the server is ready for in-process use.\n   *\n   * The validation process:\n   * 1. Validates config is an SDK server configuration\n   * 2. Checks if server instance exists in internal registry (sdkServers Map)\n   * 3. Validates instance implements required listTools() method\n   * 4. Returns success if all checks pass\n   *\n   * This test does NOT invoke listTools() or any other server methods - it only\n   * verifies the interface is implemented. For functional testing of tool availability,\n   * use listMCPServerTools() which actually calls the server's methods.\n   *\n   * SDK servers must be registered using registerSdkServer() before they can be tested.\n   * Attempting to test an unregistered SDK server will return a failure with instructions\n   * to register the instance first.\n   *\n   * @param config - MCP server configuration (must be SDK type with name property)\n   *\n   * @returns Promise resolving to test result object:\n   *          - success: true if instance registered and valid, false otherwise\n   *          - message: Human-readable description of test result\n   *          - error: Optional error details if validation failed\n   *\n   * @example\n   * ```typescript\n   * // Successful SDK server test\n   * const myServer = new MyMCPServer();\n   * mcpService.registerSdkServer('my-server', myServer);\n   *\n   * const config = { type: 'sdk', name: 'my-server' } as MCPServerConfig;\n   * const result = await this.testSdkServer(config);\n   *\n   * // { success: true, message: 'SDK server is registered and valid' }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Unregistered SDK server\n   * const config = { type: 'sdk', name: 'unregistered-server' } as MCPServerConfig;\n   * const result = await this.testSdkServer(config);\n   *\n   * // {\n   * //   success: false,\n   * //   message: 'SDK server not registered',\n   * //   error: 'SDK server \"unregistered-server\" instance not found. Use registerSdkServer() first.'\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Invalid SDK server (missing required methods)\n   * const invalidServer = { someMethod: () => {} };\n   * mcpService.registerSdkServer('invalid', invalidServer);\n   *\n   * const config = { type: 'sdk', name: 'invalid' } as MCPServerConfig;\n   * const result = await this.testSdkServer(config);\n   *\n   * // {\n   * //   success: false,\n   * //   message: 'Invalid SDK server',\n   * //   error: 'SDK server instance must implement listTools() method'\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Wrong config type\n   * const stdioConfig: MCPStdioServerConfig = {\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp']\n   * };\n   *\n   * const result = await this.testSdkServer(stdioConfig);\n   * // { success: false, message: 'Invalid server config', error: 'Not an SDK server' }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Complete SDK server registration and testing flow\n   * import { MyMCPServer } from './my-mcp-server.js';\n   *\n   * const server = new MyMCPServer({ apiKey: process.env.API_KEY });\n   * mcpService.registerSdkServer('my-server', server);\n   *\n   * const config = { type: 'sdk', name: 'my-server' } as MCPServerConfig;\n   * const testResult = await this.testSdkServer(config);\n   *\n   * if (testResult.success) {\n   *   console.log('SDK server is valid and ready for use');\n   *   // Now safe to add to .mcp.json\n   *   await mcpService.addMCPServer('my-server', config);\n   * } else {\n   *   console.error('SDK server validation failed:', testResult.error);\n   * }\n   * ```\n   *\n   * @private\n   */\n  private async testSdkServer(config: MCPServerConfig): Promise<{\n    success: boolean;\n    message: string;\n    error?: string;\n  }> {\n    if (!isSdkServer(config)) {\n      return {\n        success: false,\n        message: 'Invalid server config',\n        error: 'Not an SDK server',\n      };\n    }\n\n    const instance = this.sdkServers.get(config.name);\n    if (!instance) {\n      return {\n        success: false,\n        message: 'SDK server not registered',\n        error: `SDK server \"${config.name}\" instance not found. Use registerSdkServer() first.`,\n      };\n    }\n\n    // Check if instance has required methods\n    if (typeof instance.listTools !== 'function') {\n      return {\n        success: false,\n        message: 'Invalid SDK server',\n        error: 'SDK server instance must implement listTools() method',\n      };\n    }\n\n    return {\n      success: true,\n      message: 'SDK server is registered and valid',\n    };\n  }\n\n  /**\n   * Export MCP configuration\n   */\n  async exportMCPConfig(projectPath?: string): Promise<MCPConfig | null> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n    return await this.readMCPConfig(configPath);\n  }\n\n  /**\n   * Import MCP configuration\n   */\n  async importMCPConfig(\n    config: MCPConfig,\n    mode: 'merge' | 'overwrite',\n    projectPath?: string\n  ): Promise<void> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    if (mode === 'overwrite') {\n      // Direct overwrite\n      await this.writeMCPConfig(configPath, config);\n      this.logger.info('MCP config imported (overwrite)');\n    } else {\n      // Merge with existing\n      const existingConfig = await this.readMCPConfig(configPath);\n      const mergedConfig: MCPConfig = {\n        mcpServers: {\n          ...(existingConfig?.mcpServers || {}),\n          ...config.mcpServers,\n        },\n      };\n\n      await this.writeMCPConfig(configPath, mergedConfig);\n      this.logger.info('MCP config imported (merge)');\n    }\n  }\n\n  /**\n   * Delete multiple MCP servers in a single operation\n   *\n   * @description\n   * Removes multiple MCP servers from the project's .mcp.json configuration file in\n   * one operation. This method provides efficient batch deletion with detailed error\n   * reporting for each server that fails to delete.\n   *\n   * The deletion process:\n   * 1. Iterates through the array of server IDs\n   * 2. For each ID, calls deleteMCPServer() which:\n   *    - Reads current .mcp.json\n   *    - Removes the server entry\n   *    - Writes updated config back to disk\n   * 3. Tracks success/failure for each deletion\n   * 4. Collects error messages for failed deletions\n   * 5. Returns summary with success count, failed count, and error details\n   *\n   * Important Considerations:\n   * - Each deletion is independent - if one fails, others continue\n   * - Deletions are NOT atomic - partial completion is possible\n   * - The method reads/writes .mcp.json once per server (not optimized for large batches)\n   * - Failed deletions include the server ID and error message in errors array\n   * - Server IDs that don't exist will result in \"not found\" errors\n   *\n   * Performance Notes:\n   * - For deleting many servers (10+), consider manual implementation that reads once,\n   *   modifies, and writes once for better performance\n   * - Current implementation prioritizes error reporting over performance\n   *\n   * Use Cases:\n   * - Cleaning up obsolete MCP servers\n   * - Removing all disabled servers at once\n   * - Clearing test/development servers from configuration\n   * - Implementing \"delete selected\" functionality in UI\n   *\n   * @param serverIds - Array of server IDs (names) to delete from configuration\n   * @param projectPath - Absolute path to project directory containing .mcp.json.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to result object:\n   *          - success: Number of servers successfully deleted\n   *          - failed: Number of servers that failed to delete\n   *          - errors: Array of error messages in format \"serverId: error message\"\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Delete multiple servers\n   * const result = await mcpService.bulkDeleteMCPServers(\n   *   ['old-server-1', 'old-server-2', 'test-server'],\n   *   '/path/to/project'\n   * );\n   *\n   * console.log(`Deleted ${result.success} servers`);\n   * console.log(`Failed to delete ${result.failed} servers`);\n   *\n   * if (result.errors.length > 0) {\n   *   console.log('Errors:');\n   *   result.errors.forEach(error => console.log(`  - ${error}`));\n   * }\n   *\n   * // Output:\n   * // Deleted 2 servers\n   * // Failed to delete 1 servers\n   * // Errors:\n   * //   - test-server: MCP server \"test-server\" not found\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Delete all disabled servers\n   * const servers = await mcpService.getMCPServers();\n   * const disabledIds = servers\n   *   .filter(s => s.disabled)\n   *   .map(s => s.id);\n   *\n   * if (disabledIds.length > 0) {\n   *   const result = await mcpService.bulkDeleteMCPServers(disabledIds);\n   *   console.log(`Removed ${result.success} disabled servers`);\n   * } else {\n   *   console.log('No disabled servers to remove');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Delete with error handling and retry\n   * const idsToDelete = ['server-1', 'server-2', 'server-3'];\n   * let result = await mcpService.bulkDeleteMCPServers(idsToDelete);\n   *\n   * // Retry failed deletions once\n   * if (result.failed > 0) {\n   *   console.log(`Retrying ${result.failed} failed deletions...`);\n   *\n   *   // Extract IDs that failed\n   *   const failedIds = result.errors\n   *     .map(err => err.split(':')[0])\n   *     .filter(id => id !== 'undefined');\n   *\n   *   const retryResult = await mcpService.bulkDeleteMCPServers(failedIds);\n   *   console.log(`Retry: ${retryResult.success} succeeded, ${retryResult.failed} still failed`);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Delete servers by pattern (all servers starting with 'test-')\n   * const servers = await mcpService.getMCPServers();\n   * const testServerIds = servers\n   *   .filter(s => s.name.startsWith('test-'))\n   *   .map(s => s.id);\n   *\n   * const result = await mcpService.bulkDeleteMCPServers(testServerIds);\n   * console.log(`Removed ${result.success} test servers`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle complete success vs partial failure\n   * const result = await mcpService.bulkDeleteMCPServers(['server-1', 'server-2']);\n   *\n   * if (result.failed === 0) {\n   *   console.log('\u2713 All servers deleted successfully');\n   * } else if (result.success === 0) {\n   *   console.error('\u2717 All deletions failed');\n   *   result.errors.forEach(err => console.error(`  ${err}`));\n   * } else {\n   *   console.warn(`\u26a0 Partial success: ${result.success} deleted, ${result.failed} failed`);\n   *   result.errors.forEach(err => console.error(`  ${err}`));\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Empty array handling\n   * const result = await mcpService.bulkDeleteMCPServers([]);\n   * console.log(result);\n   * // { success: 0, failed: 0, errors: [] }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // UI integration: delete selected servers from checkbox list\n   * async function handleDeleteSelected(selectedIds: string[]) {\n   *   if (selectedIds.length === 0) {\n   *     alert('No servers selected');\n   *     return;\n   *   }\n   *\n   *   const confirmed = confirm(`Delete ${selectedIds.length} servers?`);\n   *   if (!confirmed) return;\n   *\n   *   const result = await mcpService.bulkDeleteMCPServers(selectedIds);\n   *\n   *   if (result.failed === 0) {\n   *     alert(`Successfully deleted ${result.success} servers`);\n   *   } else {\n   *     alert(\n   *       `Deleted ${result.success} servers\\n` +\n   *       `Failed to delete ${result.failed} servers:\\n` +\n   *       result.errors.join('\\n')\n   *     );\n   *   }\n   *\n   *   // Refresh server list\n   *   await refreshServerList();\n   * }\n   * ```\n   */\n  async bulkDeleteMCPServers(\n    serverIds: string[],\n    projectPath?: string\n  ): Promise<{ success: number; failed: number; errors: string[] }> {\n    let success = 0;\n    let failed = 0;\n    const errors: string[] = [];\n\n    for (const id of serverIds) {\n      try {\n        await this.deleteMCPServer(id, projectPath);\n        success++;\n      } catch (error) {\n        failed++;\n        errors.push(`${id}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n\n    this.logger.info('Bulk delete completed', { success, failed });\n\n    return { success, failed, errors };\n  }\n\n  /**\n   * Toggle MCP server between enabled and disabled states\n   *\n   * @description\n   * Flips the disabled flag of an MCP server in the project's .mcp.json configuration.\n   * This provides a non-destructive way to temporarily disable servers without deleting\n   * their configuration, allowing easy re-enabling later.\n   *\n   * The toggle operation:\n   * 1. Reads current .mcp.json configuration\n   * 2. Validates server exists in configuration\n   * 3. Reads current disabled state (defaults to false if not set)\n   * 4. Inverts the disabled flag (!currentState)\n   * 5. Writes updated config back to .mcp.json\n   * 6. Returns new state with success indicator\n   *\n   * State Transitions:\n   * - enabled (disabled: false or undefined) \u2192 disabled (disabled: true)\n   * - disabled (disabled: true) \u2192 enabled (disabled: false)\n   *\n   * Disabled Server Behavior:\n   * - Disabled servers are excluded from .mcp.json when synced via syncToMcpJson()\n   * - Claude Agent SDK will not load disabled servers\n   * - Server configuration is preserved in .mcp.json (can be re-enabled anytime)\n   * - Disabled state is stored as 'disabled: true' in config\n   *\n   * This method is preferable to deleteMCPServer() when you:\n   * - Want to temporarily disable a server for testing/debugging\n   * - Need to disable a problematic server without losing its configuration\n   * - Want to keep server config for future re-enabling\n   * - Are implementing UI with enable/disable checkboxes\n   *\n   * @param id - Unique identifier of the MCP server to toggle (must exist in config)\n   * @param projectPath - Absolute path to project directory containing .mcp.json.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to result object:\n   *          - success: boolean indicating if toggle operation succeeded\n   *          - disabled: boolean representing the NEW state (true if now disabled, false if now enabled)\n   *          - message: Human-readable description of the result\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Toggle a server's state\n   * const result = await mcpService.toggleMCPServer('filesystem', '/path/to/project');\n   *\n   * if (result.success) {\n   *   console.log(`Server is now ${result.disabled ? 'disabled' : 'enabled'}`);\n   *   console.log(result.message);\n   * } else {\n   *   console.error('Toggle failed:', result.message);\n   * }\n   *\n   * // Output:\n   * // Server is now disabled\n   * // MCP server disabled successfully\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Toggle multiple times (enable \u2192 disable \u2192 enable)\n   * let result = await mcpService.toggleMCPServer('github');\n   * console.log(`First toggle: ${result.disabled ? 'disabled' : 'enabled'}`);\n   * // Output: First toggle: disabled\n   *\n   * result = await mcpService.toggleMCPServer('github');\n   * console.log(`Second toggle: ${result.disabled ? 'disabled' : 'enabled'}`);\n   * // Output: Second toggle: enabled\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Conditional toggling based on current state\n   * const server = await mcpService.getMCPServerById('filesystem');\n   *\n   * if (server?.disabled) {\n   *   console.log('Server is currently disabled, enabling it...');\n   *   await mcpService.toggleMCPServer('filesystem');\n   * } else {\n   *   console.log('Server is already enabled');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle non-existent server\n   * const result = await mcpService.toggleMCPServer('nonexistent');\n   *\n   * if (!result.success) {\n   *   console.error(result.message);\n   *   // Output: MCP server not found\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // UI integration: checkbox toggle handler\n   * async function handleServerToggle(serverId: string, checkbox: HTMLInputElement) {\n   *   const result = await mcpService.toggleMCPServer(serverId);\n   *\n   *   if (result.success) {\n   *     // Update checkbox to match new state\n   *     checkbox.checked = !result.disabled;\n   *\n   *     // Show notification\n   *     showNotification(\n   *       `Server ${result.disabled ? 'disabled' : 'enabled'} successfully`,\n   *       'success'\n   *     );\n   *   } else {\n   *     // Revert checkbox on failure\n   *     checkbox.checked = !checkbox.checked;\n   *     showNotification(`Failed to toggle server: ${result.message}`, 'error');\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Disable all servers except one\n   * const servers = await mcpService.getMCPServers();\n   * const keepEnabled = 'filesystem';\n   *\n   * for (const server of servers) {\n   *   if (server.id !== keepEnabled && !server.disabled) {\n   *     const result = await mcpService.toggleMCPServer(server.id);\n   *     console.log(`Disabled ${server.name}: ${result.success}`);\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Enable all disabled servers\n   * const servers = await mcpService.getMCPServers();\n   * const disabledServers = servers.filter(s => s.disabled);\n   *\n   * console.log(`Enabling ${disabledServers.length} disabled servers...`);\n   *\n   * for (const server of disabledServers) {\n   *   const result = await mcpService.toggleMCPServer(server.id);\n   *   if (result.success) {\n   *     console.log(`\u2713 Enabled ${server.name}`);\n   *   } else {\n   *     console.error(`\u2717 Failed to enable ${server.name}: ${result.message}`);\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Toggle with confirmation dialog\n   * async function toggleServerWithConfirmation(serverId: string) {\n   *   const server = await mcpService.getMCPServerById(serverId);\n   *   if (!server) {\n   *     alert('Server not found');\n   *     return;\n   *   }\n   *\n   *   const action = server.disabled ? 'enable' : 'disable';\n   *   const confirmed = confirm(`Are you sure you want to ${action} ${server.name}?`);\n   *\n   *   if (!confirmed) return;\n   *\n   *   const result = await mcpService.toggleMCPServer(serverId);\n   *\n   *   if (result.success) {\n   *     alert(`Successfully ${action}d ${server.name}`);\n   *   } else {\n   *     alert(`Failed to ${action} server: ${result.message}`);\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Batch toggle pattern (enable/disable multiple servers)\n   * async function setServersEnabled(serverIds: string[], enabled: boolean) {\n   *   const results = [];\n   *\n   *   for (const id of serverIds) {\n   *     const server = await mcpService.getMCPServerById(id);\n   *     if (!server) continue;\n   *\n   *     // Only toggle if current state doesn't match desired state\n   *     const shouldToggle = server.disabled === enabled;\n   *\n   *     if (shouldToggle) {\n   *       const result = await mcpService.toggleMCPServer(id);\n   *       results.push({ id, success: result.success });\n   *     }\n   *   }\n   *\n   *   return results;\n   * }\n   *\n   * // Usage\n   * await setServersEnabled(['server-1', 'server-2'], true);  // Enable servers\n   * await setServersEnabled(['server-3', 'server-4'], false); // Disable servers\n   * ```\n   */\n  async toggleMCPServer(id: string, projectPath?: string): Promise<{\n    success: boolean;\n    disabled: boolean;\n    message: string;\n  }> {\n    try {\n      if (!projectPath) {\n        projectPath = process.cwd();\n      }\n\n      const configPath = this.getMCPConfigPath(projectPath);\n      const config = await this.readMCPConfig(configPath);\n\n      if (!config || !config.mcpServers || !config.mcpServers[id]) {\n        return {\n          success: false,\n          disabled: false,\n          message: 'MCP server not found',\n        };\n      }\n\n      // Toggle disabled state\n      const currentState = config.mcpServers[id].disabled || false;\n      config.mcpServers[id].disabled = !currentState;\n\n      await this.writeMCPConfig(configPath, config);\n\n      const newState = config.mcpServers[id].disabled || false;\n      this.logger.info('MCP server toggled', { id, disabled: newState });\n\n      return {\n        success: true,\n        disabled: newState,\n        message: `MCP server ${newState ? 'disabled' : 'enabled'} successfully`,\n      };\n    } catch (error) {\n      this.logger.error('Failed to toggle MCP server', { id, error });\n      return {\n        success: false,\n        disabled: false,\n        message: error instanceof Error ? error.message : 'Failed to toggle server',\n      };\n    }\n  }\n\n  /**\n   * List all tools provided by an MCP server\n   *\n   * @description\n   * Retrieves the complete list of tools available from an MCP server by querying the\n   * server using the appropriate transport protocol. This method performs a full server\n   * interaction, returning actual tool metadata including names, descriptions, and input schemas.\n   *\n   * The retrieval process:\n   * 1. Retrieves server configuration from .mcp.json by ID\n   * 2. Determines transport type (stdio or SDK)\n   * 3. Delegates to transport-specific tool fetching method:\n   *    - Stdio servers: Spawns process, performs MCP protocol handshake, sends tools/list request\n   *    - SDK servers: Calls listTools() method on registered instance\n   * 4. Normalizes tool metadata into consistent MCPTool[] format\n   * 5. Returns tools array with success status\n   *\n   * Tool Fetching by Transport Type:\n   *\n   * **Stdio Servers:**\n   * - Spawns external process via JSON-RPC over stdin/stdout\n   * - Sends MCP protocol 'initialize' request (required handshake)\n   * - Sends 'tools/list' request after successful initialization\n   * - Parses JSON-RPC responses to extract tool metadata\n   * - Times out after 15 seconds if no response\n   * - Cleans up spawned process when complete\n   *\n   * **SDK Servers:**\n   * - Retrieves registered server instance from internal registry\n   * - Directly calls instance.listTools() method\n   * - No process spawning or protocol handshake required\n   * - Faster than stdio servers due to in-process execution\n   *\n   * Each returned MCPTool contains:\n   * - name: Unique identifier for the tool\n   * - description: Human-readable explanation of tool functionality\n   * - inputSchema: JSON Schema defining expected input parameters\n   *\n   * This method is useful for:\n   * - Discovering what tools an MCP server provides\n   * - Validating server is functional and responding correctly\n   * - Building UI for tool selection or documentation\n   * - Syncing tool metadata to Strapi database\n   *\n   * @param id - Unique identifier of the MCP server (must exist in .mcp.json)\n   * @param projectPath - Absolute path to project directory.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to result object:\n   *          - success: boolean indicating if tools were retrieved successfully\n   *          - tools: Array of MCPTool objects with name, description, inputSchema\n   *          - error: Optional error message if retrieval failed\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // List tools from a stdio server\n   * const result = await mcpService.listMCPServerTools('filesystem', '/path/to/project');\n   *\n   * if (result.success) {\n   *   console.log(`Found ${result.tools.length} tools:`);\n   *   result.tools.forEach(tool => {\n   *     console.log(`- ${tool.name}: ${tool.description}`);\n   *   });\n   * } else {\n   *   console.error('Failed to list tools:', result.error);\n   * }\n   *\n   * // Output:\n   * // Found 3 tools:\n   * // - read_file: Read the complete contents of a file from the file system\n   * // - write_file: Create a new file or completely overwrite an existing file\n   * // - list_directory: Get a detailed listing of all files and directories\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // List tools from SDK server\n   * const myServer = new MyMCPServer();\n   * mcpService.registerSdkServer('my-server', myServer);\n   * await mcpService.addMCPServer('my-server', { type: 'sdk', name: 'my-server' });\n   *\n   * const result = await mcpService.listMCPServerTools('my-server');\n   *\n   * console.log('SDK server tools:', result.tools);\n   * // Output: SDK server tools: [{ name: 'custom_tool', description: '...', inputSchema: {...} }]\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Examine tool input schemas\n   * const result = await mcpService.listMCPServerTools('filesystem');\n   *\n   * if (result.success) {\n   *   result.tools.forEach(tool => {\n   *     console.log(`\\n${tool.name}:`);\n   *     console.log('Parameters:', JSON.stringify(tool.inputSchema, null, 2));\n   *   });\n   * }\n   *\n   * // Output:\n   * // read_file:\n   * // Parameters: {\n   * //   \"type\": \"object\",\n   * //   \"properties\": {\n   * //     \"path\": { \"type\": \"string\", \"description\": \"Path to file\" }\n   * //   },\n   * //   \"required\": [\"path\"]\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // List tools for all configured servers\n   * const servers = await mcpService.getMCPServers();\n   *\n   * for (const server of servers) {\n   *   if (!server.disabled) {\n   *     const result = await mcpService.listMCPServerTools(server.id);\n   *     console.log(`${server.name}: ${result.success ? result.tools.length : 'ERROR'} tools`);\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle errors gracefully\n   * const result = await mcpService.listMCPServerTools('github');\n   *\n   * if (!result.success) {\n   *   if (result.error?.includes('not found')) {\n   *     console.log('Server not configured');\n   *   } else if (result.error?.includes('Timeout')) {\n   *     console.log('Server timed out - check connectivity');\n   *   } else if (result.error?.includes('not registered')) {\n   *     console.log('SDK server needs registration first');\n   *   } else {\n   *     console.log('Unknown error:', result.error);\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Sync tools to Strapi database\n   * const result = await mcpService.listMCPServerTools('filesystem');\n   *\n   * if (result.success && result.tools.length > 0) {\n   *   // Sync to database using Strapi client\n   *   await strapiClient.bulkSyncMCPTools(serverId, result.tools);\n   *   console.log(`Synced ${result.tools.length} tools to database`);\n   * }\n   * ```\n   */\n  async listMCPServerTools(id: string, projectPath?: string): Promise<{\n    success: boolean;\n    tools: MCPTool[];\n    error?: string;\n  }> {\n    try {\n      const server = await this.getMCPServerById(id, projectPath);\n      if (!server) {\n        return {\n          success: false,\n          tools: [],\n          error: 'MCP server not found',\n        };\n      }\n\n      // Fetch tools based on transport type\n      let tools: MCPTool[] = [];\n\n      if (isStdioServer(server.config)) {\n        tools = await this.fetchToolsFromStdioServer(server.config);\n      } else if (isSdkServer(server.config)) {\n        tools = await this.fetchToolsFromSdkServer(server.config);\n      } else {\n        return {\n          success: false,\n          tools: [],\n          error: `Transport type \"${server.config.type}\" not yet implemented`,\n        };\n      }\n\n      this.logger.info('Listed MCP server tools', { id, toolCount: tools.length });\n\n      return {\n        success: true,\n        tools,\n      };\n    } catch (error) {\n      this.logger.error('Failed to list MCP server tools', { id, error });\n      return {\n        success: false,\n        tools: [],\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Fetch tools from stdio MCP server via JSON-RPC protocol\n   *\n   * @description\n   * Retrieves tool metadata from an external stdio-based MCP server by spawning the\n   * process and performing a complete MCP protocol handshake followed by a tools/list\n   * request. This method implements the full MCP JSON-RPC communication flow.\n   *\n   * The MCP protocol communication sequence:\n   * 1. Spawns external process with configured command, args, and env\n   * 2. Sends 'initialize' JSON-RPC request (MCP protocol handshake requirement)\n   *    - Includes protocol version, capabilities, and client info\n   *    - Waits for successful initialization response (id: 1)\n   * 3. After initialization, sends 'tools/list' JSON-RPC request (id: 2)\n   * 4. Parses 'tools/list' response to extract tool metadata array\n   * 5. Normalizes tools into MCPTool[] format with name, description, inputSchema\n   * 6. Terminates spawned process and cleans up resources\n   * 7. Times out after 15 seconds if server doesn't respond\n   *\n   * JSON-RPC Communication Format:\n   * - Requests and responses are newline-delimited JSON\n   * - Each request includes: jsonrpc, id, method, params\n   * - Responses include: jsonrpc, id, result/error\n   * - Communication happens over stdin (write) and stdout (read)\n   *\n   * The method handles:\n   * - Line-by-line JSON parsing from stdout stream\n   * - Non-JSON output (skipped/ignored)\n   * - Process spawn errors\n   * - Timeout scenarios\n   * - Early process termination\n   * - Proper cleanup in all cases\n   *\n   * Returns empty array instead of throwing on most errors to allow graceful\n   * handling of servers with no tools or communication issues.\n   *\n   * @param config - MCP stdio server configuration (must have command property)\n   *\n   * @returns Promise resolving to array of MCPTool objects with name, description,\n   *          and inputSchema. Returns empty array if:\n   *          - Server has no tools\n   *          - Communication fails\n   *          - Process exits before sending tools\n   *          - Invalid config type\n   *\n   * @throws Error if config is not a stdio server configuration\n   * @throws Error if process spawn fails immediately\n   * @throws Error if timeout occurs (15 seconds)\n   *\n   * @example\n   * ```typescript\n   * const config: MCPStdioServerConfig = {\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *   env: { DEBUG: 'true' }\n   * };\n   *\n   * const tools = await this.fetchToolsFromStdioServer(config);\n   *\n   * console.log('Available tools:');\n   * tools.forEach(tool => {\n   *   console.log(`- ${tool.name}: ${tool.description}`);\n   *   console.log(`  Schema:`, JSON.stringify(tool.inputSchema, null, 2));\n   * });\n   *\n   * // Output:\n   * // Available tools:\n   * // - read_file: Read the complete contents of a file\n   * //   Schema: { type: \"object\", properties: { path: {...} }, required: [\"path\"] }\n   * // - write_file: Create a new file or overwrite existing\n   * //   Schema: { type: \"object\", properties: { path: {...}, content: {...} } }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle servers with no tools (returns empty array)\n   * const config: MCPStdioServerConfig = {\n   *   command: 'node',\n   *   args: ['./empty-mcp-server.js']\n   * };\n   *\n   * const tools = await this.fetchToolsFromStdioServer(config);\n   * console.log(`Tool count: ${tools.length}`); // 0\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Timeout handling (15 second limit)\n   * const slowConfig: MCPStdioServerConfig = {\n   *   command: 'slow-mcp-server',\n   *   args: ['--delay', '30000']  // 30 second delay\n   * };\n   *\n   * try {\n   *   const tools = await this.fetchToolsFromStdioServer(slowConfig);\n   * } catch (error) {\n   *   console.error('Error:', error.message);\n   *   // Error: Timeout fetching tools from MCP server\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Invalid config type handling\n   * const sdkConfig = { type: 'sdk', name: 'my-server' } as MCPServerConfig;\n   *\n   * try {\n   *   const tools = await this.fetchToolsFromStdioServer(sdkConfig);\n   * } catch (error) {\n   *   console.error('Error:', error.message);\n   *   // Error: Not a stdio server\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // MCP protocol flow visualization\n   * // Client (this method)          Server Process\n   * //    |                               |\n   * //    |-- initialize request -------->|\n   * //    |  (id: 1, protocol version)    |\n   * //    |                               |\n   * //    |<-- initialize response -------|\n   * //    |  (id: 1, capabilities)        |\n   * //    |                               |\n   * //    |-- tools/list request -------->|\n   * //    |  (id: 2)                      |\n   * //    |                               |\n   * //    |<-- tools/list response -------|\n   * //    |  (id: 2, tools: [...])        |\n   * //    |                               |\n   * //    |-- SIGTERM (cleanup) --------->|\n   * //    |                               X\n   * ```\n   *\n   * @private\n   */\n  private async fetchToolsFromStdioServer(config: MCPServerConfig): Promise<MCPTool[]> {\n    if (!isStdioServer(config)) {\n      throw new Error('Not a stdio server');\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = 15000; // 15 seconds\n      let resolved = false;\n      const tools: MCPTool[] = [];\n      let initialized = false;\n\n      const child = spawn(config.command, config.args || [], {\n        env: { ...process.env, ...config.env },\n        stdio: ['pipe', 'pipe', 'pipe'],\n        shell: true,\n      });\n\n      const timeoutId = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          child.kill();\n          reject(new Error('Timeout fetching tools from MCP server'));\n        }\n      }, timeout);\n\n      let stdout = '';\n\n      child.stdout?.on('data', (data) => {\n        stdout += data.toString();\n\n        // Try to parse each line as it comes\n        const lines = stdout.split('\\n');\n        for (const line of lines) {\n          if (!line.trim()) continue;\n\n          try {\n            const response = JSON.parse(line);\n\n            // Check if this is initialize response\n            if (!initialized && response.result && response.id === 1) {\n              initialized = true;\n              // Send tools/list request after initialization\n              const toolsRequest = {\n                jsonrpc: '2.0',\n                id: 2,\n                method: 'tools/list',\n                params: {},\n              };\n              child.stdin?.write(JSON.stringify(toolsRequest) + '\\n');\n            }\n\n            // Check if this is tools/list response\n            if (response.result && response.id === 2 && Array.isArray(response.result.tools)) {\n              tools.push(...response.result.tools.map((tool: any) => ({\n                name: tool.name,\n                description: tool.description,\n                inputSchema: tool.inputSchema,\n              })));\n\n              // Success! Clean up and resolve\n              if (!resolved) {\n                resolved = true;\n                clearTimeout(timeoutId);\n                child.kill();\n                resolve(tools);\n              }\n            }\n          } catch (e) {\n            // Skip non-JSON lines or parsing errors\n          }\n        }\n      });\n\n      child.on('error', (error) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeoutId);\n          reject(error);\n        }\n      });\n\n      child.on('spawn', () => {\n        // Send initialize request first (MCP protocol requirement)\n        const initRequest = {\n          jsonrpc: '2.0',\n          id: 1,\n          method: 'initialize',\n          params: {\n            protocolVersion: '2024-11-05',\n            capabilities: {},\n            clientInfo: {\n              name: 'cui-manager',\n              version: '1.0.0',\n            },\n          },\n        };\n        child.stdin?.write(JSON.stringify(initRequest) + '\\n');\n      });\n\n      child.on('close', (code) => {\n        if (!resolved) {\n          resolved = true;\n          clearTimeout(timeoutId);\n\n          // If we got tools, resolve with them\n          if (tools.length > 0) {\n            resolve(tools);\n          } else {\n            resolve([]); // Return empty array instead of rejecting\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Fetch tools from in-process SDK MCP server\n   *\n   * @description\n   * Retrieves tool metadata from an in-process SDK MCP server instance by directly\n   * calling its listTools() method. This is significantly faster than stdio servers\n   * as it avoids process spawning and JSON-RPC protocol overhead.\n   *\n   * The retrieval process:\n   * 1. Validates config is an SDK server configuration\n   * 2. Retrieves server instance from internal registry (sdkServers Map)\n   * 3. Validates instance implements required listTools() method\n   * 4. Calls instance.listTools() to get tool metadata\n   * 5. Normalizes tool objects into consistent MCPTool[] format\n   * 6. Returns tools array\n   *\n   * SDK Server Requirements:\n   * - Must be registered via registerSdkServer() before calling this method\n   * - Must implement listTools() method that returns Promise<Tool[]>\n   * - Each tool must have: name, description, inputSchema properties\n   *\n   * This method is synchronous (no I/O or process spawning) and executes in-process,\n   * making it ideal for:\n   * - High-frequency tool queries\n   * - Low-latency requirements\n   * - Custom TypeScript/JavaScript MCP servers\n   * - Development and testing scenarios\n   *\n   * Error Handling:\n   * - Throws if config is not SDK type\n   * - Throws if server instance not registered\n   * - Throws if instance doesn't implement listTools()\n   * - Re-throws any errors from instance.listTools() call\n   *\n   * @param config - MCP SDK server configuration (must have type 'sdk' and name property)\n   *\n   * @returns Promise resolving to array of MCPTool objects with name, description,\n   *          and inputSchema properties\n   *\n   * @throws Error if config is not an SDK server configuration\n   * @throws Error if server instance not registered (need to call registerSdkServer first)\n   * @throws Error if server instance doesn't implement listTools() method\n   * @throws Error propagated from instance.listTools() if that method fails\n   *\n   * @example\n   * ```typescript\n   * // Basic SDK server tool fetching\n   * const myServer = new MyMCPServer();\n   * mcpService.registerSdkServer('my-server', myServer);\n   *\n   * const config = { type: 'sdk', name: 'my-server' } as MCPServerConfig;\n   * const tools = await this.fetchToolsFromSdkServer(config);\n   *\n   * console.log(`Found ${tools.length} tools`);\n   * tools.forEach(tool => {\n   *   console.log(`- ${tool.name}: ${tool.description}`);\n   * });\n   *\n   * // Output:\n   * // Found 2 tools\n   * // - search: Search through documents\n   * // - summarize: Generate summaries\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error: Unregistered server\n   * const config = { type: 'sdk', name: 'unregistered' } as MCPServerConfig;\n   *\n   * try {\n   *   const tools = await this.fetchToolsFromSdkServer(config);\n   * } catch (error) {\n   *   console.error(error.message);\n   *   // Output: SDK server \"unregistered\" not registered\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error: Invalid interface (missing listTools)\n   * const invalidServer = { someMethod: () => {} };\n   * mcpService.registerSdkServer('invalid', invalidServer);\n   *\n   * const config = { type: 'sdk', name: 'invalid' } as MCPServerConfig;\n   *\n   * try {\n   *   const tools = await this.fetchToolsFromSdkServer(config);\n   * } catch (error) {\n   *   console.error(error.message);\n   *   // Output: SDK server does not implement listTools() method\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error: Wrong config type\n   * const stdioConfig: MCPStdioServerConfig = {\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp']\n   * };\n   *\n   * try {\n   *   const tools = await this.fetchToolsFromSdkServer(stdioConfig);\n   * } catch (error) {\n   *   console.error(error.message);\n   *   // Output: Not an SDK server\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Complete workflow: register, fetch, and use tools\n   * import { MyCustomMCPServer } from './my-mcp-server.js';\n   *\n   * // 1. Create and register server instance\n   * const server = new MyCustomMCPServer({ apiKey: process.env.API_KEY });\n   * mcpService.registerSdkServer('custom', server);\n   *\n   * // 2. Fetch tools\n   * const config = { type: 'sdk', name: 'custom' } as MCPServerConfig;\n   * const tools = await this.fetchToolsFromSdkServer(config);\n   *\n   * // 3. Use tool metadata\n   * console.log('Available tools:');\n   * for (const tool of tools) {\n   *   console.log(`\\n${tool.name}`);\n   *   console.log(`Description: ${tool.description}`);\n   *   console.log(`Parameters: ${JSON.stringify(tool.inputSchema, null, 2)}`);\n   * }\n   * ```\n   *\n   * @private\n   */\n  private async fetchToolsFromSdkServer(config: MCPServerConfig): Promise<MCPTool[]> {\n    if (!isSdkServer(config)) {\n      throw new Error('Not an SDK server');\n    }\n\n    const instance = this.sdkServers.get(config.name);\n    if (!instance) {\n      throw new Error(`SDK server \"${config.name}\" not registered`);\n    }\n\n    if (typeof instance.listTools !== 'function') {\n      throw new Error('SDK server does not implement listTools() method');\n    }\n\n    try {\n      const tools = await instance.listTools();\n      return tools.map((tool: any) => ({\n        name: tool.name,\n        description: tool.description,\n        inputSchema: tool.inputSchema,\n      }));\n    } catch (error) {\n      this.logger.error('Failed to list tools from SDK server', { name: config.name, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Sync MCP servers to .mcp.json configuration file\n   *\n   * @description\n   * Converts MCP server data from Strapi database format to SDK-aligned .mcp.json format\n   * and writes it to disk. This enables bidirectional synchronization between the Strapi\n   * CMS and the project's MCP configuration file used by Claude Agent SDK.\n   *\n   * This method is typically called when:\n   * - Syncing MCP servers from Strapi database to local project\n   * - Exporting server configurations for use by Claude SDK\n   * - Updating .mcp.json after bulk edits in Strapi UI\n   * - Migrating server configurations across environments\n   *\n   * Conversion Process:\n   * 1. Accepts servers in Strapi format (flat structure with transport field)\n   * 2. Filters out disabled servers (disabled servers excluded from .mcp.json)\n   * 3. Transforms each server to SDK format:\n   *    - Creates key-value structure (server name as key)\n   *    - Removes Strapi-specific fields (disabled, transport if stdio)\n   *    - Preserves command, args, env for stdio servers\n   *    - Adds type field for non-stdio transports (sdk, sse, http)\n   * 4. Writes complete MCPConfig to .mcp.json at project root\n   * 5. Overwrites existing file completely (not a merge)\n   *\n   * Format Transformation:\n   * ```\n   * Input (Strapi format):\n   * [\n   *   { name: \"filesystem\", command: \"npx\", args: [...], env: {...}, disabled: false, transport: \"stdio\" }\n   * ]\n   *\n   * Output (.mcp.json SDK format):\n   * {\n   *   \"mcpServers\": {\n   *     \"filesystem\": {\n   *       \"command\": \"npx\",\n   *       \"args\": [...],\n   *       \"env\": {...}\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Important Notes:\n   * - Disabled servers are completely excluded from .mcp.json (SDK only loads enabled servers)\n   * - This is a full replacement operation (existing .mcp.json content is overwritten)\n   * - For stdio transport, the 'type' field is omitted (stdio is default)\n   * - For other transports (sdk, sse, http), the 'type' field is included\n   * - Environment variables in env field should use ${VAR_NAME} syntax for substitution\n   *\n   * @param servers - Array of MCP server objects in Strapi format with name, command,\n   *                  args, env, disabled, and transport fields\n   * @param projectPath - Absolute path to project directory where .mcp.json will be written.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise that resolves when .mcp.json file is successfully written\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Sync servers from Strapi to .mcp.json\n   * const strapiServers = [\n   *   {\n   *     name: 'filesystem',\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *     env: { DEBUG: 'true' },\n   *     disabled: false,\n   *     transport: 'stdio'\n   *   },\n   *   {\n   *     name: 'github',\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-github'],\n   *     env: { GITHUB_TOKEN: '${GITHUB_TOKEN}' },\n   *     disabled: true,  // This server will be excluded\n   *     transport: 'stdio'\n   *   }\n   * ];\n   *\n   * await mcpService.syncToMcpJson(strapiServers, '/path/to/project');\n   *\n   * // Result: .mcp.json contains only the 'filesystem' server (github excluded as disabled)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Sync from Strapi database\n   * const strapiClient = new StrapiClient();\n   * const dbServers = await strapiClient.getAllMCPServers();\n   *\n   * // Transform Strapi response to sync format\n   * const serversToSync = dbServers.map(server => ({\n   *   name: server.name,\n   *   command: server.command,\n   *   args: server.args,\n   *   env: server.env,\n   *   disabled: !server.enabled,  // Strapi uses 'enabled', sync expects 'disabled'\n   *   transport: server.transport || 'stdio'\n   * }));\n   *\n   * await mcpService.syncToMcpJson(serversToSync);\n   * console.log('Synced MCP servers from Strapi to .mcp.json');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Sync SDK server (includes type field)\n   * const sdkServers = [\n   *   {\n   *     name: 'my-sdk-server',\n   *     command: '',  // Not used for SDK servers\n   *     transport: 'sdk'\n   *   }\n   * ];\n   *\n   * await mcpService.syncToMcpJson(sdkServers);\n   *\n   * // Result in .mcp.json:\n   * // {\n   * //   \"mcpServers\": {\n   * //     \"my-sdk-server\": {\n   * //       \"type\": \"sdk\",\n   * //       \"command\": \"\",\n   * //       \"args\": [],\n   * //       \"env\": {}\n   * //     }\n   * //   }\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Complete bidirectional sync workflow\n   * const mcpService = new MCPService();\n   * const strapiClient = new StrapiClient();\n   *\n   * // 1. Fetch from Strapi\n   * const dbServers = await strapiClient.getAllMCPServers();\n   *\n   * // 2. Convert to sync format\n   * const serversToSync = dbServers\n   *   .filter(s => s.enabled)  // Only sync enabled servers\n   *   .map(s => ({\n   *     name: s.name,\n   *     command: s.command,\n   *     args: s.args,\n   *     env: s.env,\n   *     disabled: false,\n   *     transport: s.transport || 'stdio'\n   *   }));\n   *\n   * // 3. Sync to .mcp.json\n   * await mcpService.syncToMcpJson(serversToSync);\n   *\n   * console.log(`Synced ${serversToSync.length} servers to .mcp.json`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Empty sync (clears all servers from .mcp.json)\n   * await mcpService.syncToMcpJson([]);\n   *\n   * // Result: .mcp.json contains { \"mcpServers\": {} }\n   * ```\n   */\n  async syncToMcpJson(\n    servers: Array<{\n      name: string;\n      command: string;\n      args?: string[];\n      env?: Record<string, string>;\n      disabled?: boolean;\n      transport?: string;\n    }>,\n    projectPath?: string\n  ): Promise<void> {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n\n    // Build MCP config object\n    const mcpServers: Record<string, MCPServerConfig> = {};\n\n    for (const server of servers) {\n      // Skip disabled servers (they won't be in .mcp.json)\n      if (server.disabled) {\n        continue;\n      }\n\n      // Convert to MCP config format\n      const serverConfig: MCPStdioServerConfig = {\n        command: server.command,\n        args: server.args || [],\n        env: server.env || {},\n      };\n\n      // Add type if not stdio\n      if (server.transport && server.transport !== 'stdio') {\n        (serverConfig as any).type = server.transport;\n      }\n\n      mcpServers[server.name] = serverConfig;\n    }\n\n    const config: MCPConfig = { mcpServers };\n\n    // Write to .mcp.json\n    await this.writeMCPConfig(configPath, config);\n\n    this.logger.info('Synced MCP servers to .mcp.json', {\n      serverCount: Object.keys(mcpServers).length,\n      configPath,\n    });\n  }\n\n  /**\n   * Sync MCP servers from .mcp.json configuration file to Strapi format\n   *\n   * @description\n   * Reads the project's .mcp.json file and converts server configurations from SDK format\n   * to Strapi database format. This enables bidirectional synchronization by allowing\n   * changes made directly to .mcp.json to be imported back into the Strapi CMS.\n   *\n   * This method is typically called when:\n   * - Importing MCP servers from .mcp.json into Strapi database\n   * - Syncing manual changes made to .mcp.json back to CMS\n   * - Bootstrapping Strapi database from existing project configuration\n   * - Detecting and reconciling configuration drift between file and database\n   *\n   * Conversion Process:\n   * 1. Reads .mcp.json from project root with environment variable substitution\n   * 2. Extracts mcpServers object (key-value pairs)\n   * 3. Transforms each server to Strapi format:\n   *    - Extracts server name from object key\n   *    - Normalizes command, args, env fields\n   *    - Extracts disabled flag (defaults to false if not set)\n   *    - Determines transport type from 'type' field (defaults to 'stdio')\n   * 4. Returns array of server objects ready for Strapi database insertion\n   * 5. Currently only processes stdio servers (SDK servers filtered out)\n   *\n   * Format Transformation:\n   * ```\n   * Input (.mcp.json SDK format):\n   * {\n   *   \"mcpServers\": {\n   *     \"filesystem\": {\n   *       \"command\": \"npx\",\n   *       \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/tmp\"],\n   *       \"env\": { \"DEBUG\": \"true\" },\n   *       \"disabled\": false\n   *     }\n   *   }\n   * }\n   *\n   * Output (Strapi format):\n   * [\n   *   {\n   *     name: \"filesystem\",\n   *     command: \"npx\",\n   *     args: [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/tmp\"],\n   *     env: { DEBUG: \"true\" },\n   *     disabled: false,\n   *     transport: \"stdio\"\n   *   }\n   * ]\n   * ```\n   *\n   * Important Notes:\n   * - Only stdio servers are currently processed (SDK servers skipped in transformation)\n   * - Environment variables are already substituted during config read\n   * - Returns empty array if .mcp.json doesn't exist or has no servers\n   * - Disabled servers are included in output (Strapi stores all servers, enabled and disabled)\n   * - The 'disabled' field defaults to false if not present in config\n   * - The 'transport' field defaults to 'stdio' if not explicitly set\n   *\n   * @param projectPath - Absolute path to project directory containing .mcp.json.\n   *                      Defaults to process.cwd() if not provided.\n   *\n   * @returns Promise resolving to array of server objects in Strapi format:\n   *          - name: Server identifier (from config key)\n   *          - command: Executable command for stdio servers\n   *          - args: Array of command arguments\n   *          - env: Environment variables object\n   *          - disabled: Whether server is disabled\n   *          - transport: Transport type ('stdio', 'sdk', etc.)\n   *          Returns empty array if no .mcp.json exists or no stdio servers found.\n   *\n   * @example\n   * ```typescript\n   * const mcpService = new MCPService();\n   *\n   * // Read servers from .mcp.json\n   * const servers = await mcpService.syncFromMcpJson('/path/to/project');\n   *\n   * console.log(`Found ${servers.length} servers in .mcp.json:`);\n   * servers.forEach(server => {\n   *   console.log(`- ${server.name} (${server.transport})${server.disabled ? ' [disabled]' : ''}`);\n   * });\n   *\n   * // Output:\n   * // Found 2 servers in .mcp.json:\n   * // - filesystem (stdio)\n   * // - github (stdio) [disabled]\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Sync from .mcp.json to Strapi database\n   * const mcpService = new MCPService();\n   * const strapiClient = new StrapiClient();\n   *\n   * // 1. Read from .mcp.json\n   * const serversFromFile = await mcpService.syncFromMcpJson();\n   *\n   * // 2. Upsert each server to Strapi\n   * for (const server of serversFromFile) {\n   *   const existing = await strapiClient.findMCPServerByName(server.name);\n   *\n   *   if (existing) {\n   *     await strapiClient.updateMCPServer(existing.id, {\n   *       command: server.command,\n   *       args: server.args,\n   *       env: server.env,\n   *       enabled: !server.disabled,\n   *       transport: server.transport\n   *     });\n   *   } else {\n   *     await strapiClient.createMCPServer({\n   *       name: server.name,\n   *       command: server.command,\n   *       args: server.args,\n   *       env: server.env,\n   *       enabled: !server.disabled,\n   *       transport: server.transport\n   *     });\n   *   }\n   * }\n   *\n   * console.log(`Synced ${serversFromFile.length} servers to Strapi`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Detect configuration drift\n   * const serversFromFile = await mcpService.syncFromMcpJson();\n   * const serversFromDB = await strapiClient.getAllMCPServers();\n   *\n   * const fileNames = new Set(serversFromFile.map(s => s.name));\n   * const dbNames = new Set(serversFromDB.map(s => s.name));\n   *\n   * // Find servers only in file\n   * const onlyInFile = serversFromFile.filter(s => !dbNames.has(s.name));\n   * console.log('Only in .mcp.json:', onlyInFile.map(s => s.name));\n   *\n   * // Find servers only in database\n   * const onlyInDB = serversFromDB.filter(s => !fileNames.has(s.name));\n   * console.log('Only in Strapi:', onlyInDB.map(s => s.name));\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle missing .mcp.json\n   * const servers = await mcpService.syncFromMcpJson('/nonexistent/path');\n   * console.log(servers); // []\n   * console.log(`Found ${servers.length} servers`); // Found 0 servers\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Complete bidirectional sync: file \u2192 Strapi \u2192 file\n   * const mcpService = new MCPService();\n   * const strapiClient = new StrapiClient();\n   *\n   * // 1. Import from .mcp.json to Strapi\n   * const importedServers = await mcpService.syncFromMcpJson();\n   * for (const server of importedServers) {\n   *   await strapiClient.upsertMCPServer(server);\n   * }\n   * console.log(`Imported ${importedServers.length} servers to Strapi`);\n   *\n   * // 2. Make changes in Strapi UI...\n   * // (user edits servers via Strapi CMS)\n   *\n   * // 3. Export from Strapi back to .mcp.json\n   * const dbServers = await strapiClient.getAllMCPServers();\n   * const serversToExport = dbServers.map(s => ({\n   *   name: s.name,\n   *   command: s.command,\n   *   args: s.args,\n   *   env: s.env,\n   *   disabled: !s.enabled,\n   *   transport: s.transport || 'stdio'\n   * }));\n   * await mcpService.syncToMcpJson(serversToExport);\n   * console.log(`Exported ${serversToExport.length} servers to .mcp.json`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Filter and transform before syncing to Strapi\n   * const servers = await mcpService.syncFromMcpJson();\n   *\n   * // Only sync enabled servers\n   * const enabledServers = servers.filter(s => !s.disabled);\n   *\n   * // Transform to Strapi create format\n   * const strapiData = enabledServers.map(s => ({\n   *   name: s.name,\n   *   command: s.command,\n   *   args: s.args,\n   *   env: s.env,\n   *   enabled: true,\n   *   transport: s.transport,\n   *   description: `Imported from .mcp.json`\n   * }));\n   *\n   * // Bulk create in Strapi\n   * await Promise.all(strapiData.map(data => strapiClient.createMCPServer(data)));\n   * ```\n   */\n  async syncFromMcpJson(projectPath?: string): Promise<\n    Array<{\n      name: string;\n      command: string;\n      args: string[];\n      env: Record<string, string>;\n      disabled: boolean;\n      transport: string;\n    }>\n  > {\n    if (!projectPath) {\n      projectPath = process.cwd();\n    }\n\n    const configPath = this.getMCPConfigPath(projectPath);\n    const config = await this.readMCPConfig(configPath);\n\n    if (!config || !config.mcpServers) {\n      return [];\n    }\n\n    const servers = [];\n\n    for (const [name, serverConfig] of Object.entries(config.mcpServers)) {\n      // Only handle stdio servers for now\n      if (isStdioServer(serverConfig)) {\n        servers.push({\n          name,\n          command: serverConfig.command,\n          args: serverConfig.args || [],\n          env: serverConfig.env || {},\n          disabled: serverConfig.disabled || false,\n          transport: serverConfig.type || 'stdio',\n        });\n      }\n    }\n\n    this.logger.info('Synced MCP servers from .mcp.json', {\n      serverCount: servers.length,\n      configPath,\n    });\n\n    return servers;\n  }\n}\n",
        "last_modified": "2026-01-02T15:10:07.671941"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.601180",
  "last_updated": "2026-01-02T14:06:15.612737"
}