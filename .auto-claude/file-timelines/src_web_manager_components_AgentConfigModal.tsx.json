{
  "file_path": "src/web/manager/components/AgentConfigModal.tsx",
  "main_branch_history": [],
  "task_views": {
    "004-document-frontend-react-components-and-hooks": {
      "task_id": "004-document-frontend-react-components-and-hooks",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "\nimport React, { useState, useCallback, useMemo } from 'react';\nimport type { Agent, AgentInput } from '../types';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from './ui/Dialog';\nimport { Button } from './ui/Button';\nimport { Input } from './ui/Input';\nimport { Textarea } from './ui/Textarea';\nimport { Select } from './ui/Select';\nimport { SpinnerIcon, CheckCircleIcon, XCircleIcon } from './ui/Icons';\n\ninterface AgentConfigModalProps {\n  agent: Agent;\n  isOpen: boolean;\n  onClose: () => void;\n}\n\ntype ExecutionStatus = 'idle' | 'loading' | 'success' | 'error';\n\nconst AgentConfigModal: React.FC<AgentConfigModalProps> = ({ agent, isOpen, onClose }) => {\n  const initialFormState = useMemo(() => \n    agent.inputs.reduce((acc, input) => {\n      acc[input.name] = input.defaultValue ?? '';\n      return acc;\n    }, {} as Record<string, any>), \n  [agent.inputs]);\n  \n  const [formState, setFormState] = useState<Record<string, any>>(initialFormState);\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  const [executionStatus, setExecutionStatus] = useState<ExecutionStatus>('idle');\n  const [executionResult, setExecutionResult] = useState<string>('');\n\n  const handleInputChange = (name: string, value: string | File) => {\n    setFormState(prev => ({ ...prev, [name]: value }));\n    if (errors[name]) {\n      setErrors(prev => {\n        const newErrors = { ...prev };\n        delete newErrors[name];\n        return newErrors;\n      });\n    }\n  };\n\n  const renderInput = (input: AgentInput) => {\n    const value = formState[input.name];\n    const error = errors[input.name];\n\n    const label = (\n      <label htmlFor={input.name} className=\"block text-sm font-medium text-muted-foreground mb-1\">\n        {input.description}\n        {input.required && <span className=\"text-red-400 ml-1\">*</span>}\n      </label>\n    );\n\n    switch (input.type) {\n      case 'textarea':\n        return (\n          <div key={input.name}>\n            {label}\n            <Textarea\n              id={input.name}\n              value={value}\n              onChange={(e) => handleInputChange(input.name, e.target.value)}\n              placeholder={`Enter ${input.name}...`}\n              className={error ? 'border-red-500' : ''}\n            />\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n      case 'select':\n        return (\n          <div key={input.name}>\n            {label}\n            <Select\n              id={input.name}\n              value={value}\n              onChange={(e) => handleInputChange(input.name, e.target.value)}\n              className={error ? 'border-red-500' : ''}\n            >\n              {input.options?.map(option => <option key={option} value={option}>{option}</option>)}\n            </Select>\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n      case 'file':\n        return (\n          <div key={input.name}>\n            {label}\n            <Input\n              id={input.name}\n              type=\"file\"\n              onChange={(e) => handleInputChange(input.name, e.target.files?.[0] || '')}\n              className={error ? 'border-red-500' : ''}\n            />\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n      case 'number':\n         return (\n          <div key={input.name}>\n            {label}\n            <Input\n              id={input.name}\n              type=\"number\"\n              value={value}\n              onChange={(e) => handleInputChange(input.name, e.target.value)}\n              placeholder={`Enter ${input.name}...`}\n              className={error ? 'border-red-500' : ''}\n            />\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n      case 'text':\n      default:\n        return (\n          <div key={input.name}>\n            {label}\n            <Input\n              id={input.name}\n              type=\"text\"\n              value={value}\n              onChange={(e) => handleInputChange(input.name, e.target.value)}\n              placeholder={`Enter ${input.name}...`}\n              className={error ? 'border-red-500' : ''}\n            />\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n    }\n  };\n  \n  const handleRunAgent = useCallback(async () => {\n    const newErrors: Record<string, string> = {};\n    agent.inputs.forEach(input => {\n      if (input.required && !formState[input.name]) {\n        newErrors[input.name] = `${input.name} is required.`;\n      }\n    });\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors);\n      return;\n    }\n\n    setExecutionStatus('loading');\n    setExecutionResult('');\n    await new Promise(res => setTimeout(res, 2000)); // Simulate API call\n\n    // Simulate success/error\n    if (Math.random() > 0.15) {\n      setExecutionStatus('success');\n      setExecutionResult(`Agent \"${agent.name}\" ran successfully. Output has been generated.`);\n    } else {\n      setExecutionStatus('error');\n      setExecutionResult(`Agent \"${agent.name}\" failed to run. Please check the logs.`);\n    }\n  }, [agent, formState]);\n\n  const handleClose = () => {\n    setFormState(initialFormState);\n    setErrors({});\n    setExecutionStatus('idle');\n    setExecutionResult('');\n    onClose();\n  };\n\n  const renderResult = () => {\n    if (executionStatus === 'idle') return null;\n\n    const baseClasses = \"mt-4 p-4 rounded-md text-sm flex items-start space-x-3\";\n    \n    if (executionStatus === 'success') {\n      return (\n        <div className={`${baseClasses} bg-green-900/50 text-green-300`}>\n          <CheckCircleIcon className=\"h-5 w-5 mt-0.5 flex-shrink-0\" />\n          <p>{executionResult}</p>\n        </div>\n      );\n    }\n\n    if (executionStatus === 'error') {\n      return (\n        <div className={`${baseClasses} bg-red-900/50 text-red-300`}>\n          <XCircleIcon className=\"h-5 w-5 mt-0.5 flex-shrink-0\" />\n          <p>{executionResult}</p>\n        </div>\n      );\n    }\n    \n    return null;\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={(open) => !open && handleClose()}>\n      <DialogContent className=\"sm:max-w-[625px]\">\n        <DialogHeader>\n          <DialogTitle>{agent.name}</DialogTitle>\n          <DialogDescription>{agent.description}</DialogDescription>\n        </DialogHeader>\n        <div className=\"grid gap-4 py-4 max-h-[60vh] overflow-y-auto pr-3\">\n          {agent.inputs.map(renderInput)}\n        </div>\n        {renderResult()}\n        <DialogFooter>\n          <Button variant=\"secondary\" onClick={handleClose}>Cancel</Button>\n          <Button onClick={handleRunAgent} disabled={executionStatus === 'loading'}>\n            {executionStatus === 'loading' && <SpinnerIcon className=\"h-4 w-4 mr-2\" />}\n            Run Agent\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nexport default AgentConfigModal;\n   ",
        "timestamp": "2026-01-02T14:22:14.293924"
      },
      "worktree_state": {
        "content": "/**\n * @file AgentConfigModal.tsx\n * @description Modal component for configuring and running agents with dynamic form generation,\n * field validation, and execution status feedback.\n *\n * ## Features\n * - Dynamic form generation based on agent input schema\n * - Support for multiple input types (text, textarea, select, file, number)\n * - Real-time field validation with error messages\n * - Required field enforcement with visual indicators\n * - Agent execution with loading states\n * - Color-coded success/error result display\n * - Form state reset on close\n *\n * ## Agent Configuration Form\n * The component dynamically generates form fields based on the agent's `inputs` property:\n * - Each input field created from `AgentInput` schema\n * - Initial form state populated with `defaultValue` from schema\n * - Form fields rendered based on input `type` property\n * - Labels generated from input `description` property\n * - Required fields marked with red asterisk (*)\n *\n * ### Supported Input Types\n * 1. **text** (default): Single-line text input with placeholder\n * 2. **textarea**: Multi-line text input for longer content\n * 3. **select**: Dropdown with options from input schema\n * 4. **file**: File upload input\n * 5. **number**: Numeric input with type=\"number\"\n *\n * ## Validation\n * The component implements client-side validation:\n * - **Required Field Validation**: Checks all fields marked as `required: true`\n * - **Inline Error Display**: Shows error message below invalid field with red border\n * - **Real-time Error Clearing**: Errors cleared as user types in field\n * - **Pre-submit Validation**: All required fields validated before execution\n * - **Validation Feedback**: Red border and error text for invalid fields\n *\n * Validation workflow:\n * 1. User clicks \"Run Agent\" button\n * 2. `handleRunAgent` checks all required fields\n * 3. If validation fails, errors set and execution prevented\n * 4. If validation passes, agent execution begins\n *\n * ## Save Behavior\n * The component handles agent execution (not just configuration save):\n * 1. User fills out form fields\n * 2. User clicks \"Run Agent\" button\n * 3. Form validated for required fields\n * 4. If valid, execution status set to 'loading'\n * 5. Agent execution simulated (2-second delay) - **TODO: Replace with actual API call**\n * 6. Execution result displayed with success/error status\n * 7. Result shown with color-coded message (green=success, red=error)\n *\n * ### Execution States\n * - **idle**: Initial state, no execution attempted\n * - **loading**: Agent execution in progress, button disabled with spinner\n * - **success**: Execution completed successfully, green checkmark displayed\n * - **error**: Execution failed, red X icon displayed\n *\n * ## Form State Management\n * The component maintains several state variables:\n * - **formState**: Object mapping input names to current values\n * - **errors**: Object mapping input names to validation error messages\n * - **executionStatus**: Current execution state (idle/loading/success/error)\n * - **executionResult**: Result message text to display to user\n *\n * State is reset when modal closes via `handleClose`:\n * - Form state reset to initial values (default values from schema)\n * - All errors cleared\n * - Execution status reset to 'idle'\n * - Execution result cleared\n *\n * ## Styling Behavior\n * The component uses Tailwind CSS for styling:\n * - Dialog with max-width of 625px on small screens and up\n * - Form fields in grid layout with gap-4 spacing\n * - Scrollable form area with max-height 60vh\n * - Error borders: border-red-500 on invalid fields\n * - Success result: bg-green-900/50 with green-300 text\n * - Error result: bg-red-900/50 with red-300 text\n * - Required field indicator: red-400 asterisk\n * - Dialog footer with Cancel and Run Agent buttons\n *\n * @example\n * // Basic usage with agent execution\n * const [showConfig, setShowConfig] = useState(false);\n * const agent = {\n *   name: \"Data Processor\",\n *   description: \"Process CSV files and generate reports\",\n *   inputs: [\n *     { name: \"file\", type: \"file\", description: \"CSV File\", required: true },\n *     { name: \"format\", type: \"select\", description: \"Output Format\", options: [\"JSON\", \"XML\"], defaultValue: \"JSON\" }\n *   ]\n * };\n *\n * <AgentConfigModal\n *   agent={agent}\n *   isOpen={showConfig}\n *   onClose={() => setShowConfig(false)}\n * />\n *\n * @example\n * // Run agent from list with validation\n * const agents = [...]; // array of Agent objects\n * const [selectedAgent, setSelectedAgent] = useState<Agent | null>(null);\n *\n * function AgentList() {\n *   return (\n *     <div>\n *       {agents.map(agent => (\n *         <button key={agent.id} onClick={() => setSelectedAgent(agent)}>\n *           Run {agent.name}\n *         </button>\n *       ))}\n *       {selectedAgent && (\n *         <AgentConfigModal\n *           agent={selectedAgent}\n *           isOpen={!!selectedAgent}\n *           onClose={() => setSelectedAgent(null)}\n *         />\n *       )}\n *     </div>\n *   );\n * }\n *\n * @example\n * // Understanding input field types and validation\n * const complexAgent = {\n *   name: \"Content Generator\",\n *   description: \"Generate content based on parameters\",\n *   inputs: [\n *     { name: \"topic\", type: \"text\", description: \"Topic\", required: true }, // Red asterisk, validated\n *     { name: \"length\", type: \"number\", description: \"Word Count\", defaultValue: 500 },\n *     { name: \"tone\", type: \"select\", description: \"Tone\", options: [\"Formal\", \"Casual\"], required: true },\n *     { name: \"context\", type: \"textarea\", description: \"Additional Context\" } // Optional, no validation\n *   ]\n * };\n * // Required fields (topic, tone) will show error if empty on submit\n * // Optional fields (length, context) will not be validated\n *\n * @example\n * // Handle execution success/error feedback\n * // Success: Green background with CheckCircleIcon and success message\n * // Error: Red background with XCircleIcon and error message\n * // Loading: Spinner icon on \"Run Agent\" button, button disabled\n * <AgentConfigModal agent={agent} isOpen={true} onClose={handleClose} />\n * // User will see:\n * // - Loading: \"Run Agent\" button with spinner, disabled state\n * // - Success: \"\u2713 Agent 'Name' ran successfully. Output has been generated.\"\n * // - Error: \"\u2717 Agent 'Name' failed to run. Please check the logs.\"\n */\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport type { Agent, AgentInput } from '../types';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from './ui/Dialog';\nimport { Button } from './ui/Button';\nimport { Input } from './ui/Input';\nimport { Textarea } from './ui/Textarea';\nimport { Select } from './ui/Select';\nimport { SpinnerIcon, CheckCircleIcon, XCircleIcon } from './ui/Icons';\n\n/**\n * Props for the AgentConfigModal component\n */\ninterface AgentConfigModalProps {\n  /** The agent to configure and execute */\n  agent: Agent;\n  /** Controls whether the modal is visible */\n  isOpen: boolean;\n  /** Callback invoked when modal should close */\n  onClose: () => void;\n}\n\n/**\n * Type for tracking agent execution status\n * - idle: No execution in progress\n * - loading: Agent is currently executing\n * - success: Agent execution completed successfully\n * - error: Agent execution failed\n */\ntype ExecutionStatus = 'idle' | 'loading' | 'success' | 'error';\n\n/**\n * Modal component for configuring and running agents with dynamic form generation and validation\n */\nconst AgentConfigModal: React.FC<AgentConfigModalProps> = ({ agent, isOpen, onClose }) => {\n  // Memoized initial form state from agent input schema\n  const initialFormState = useMemo(() =>\n    agent.inputs.reduce((acc, input) => {\n      acc[input.name] = input.defaultValue ?? '';\n      return acc;\n    }, {} as Record<string, any>),\n  [agent.inputs]);\n\n  const [formState, setFormState] = useState<Record<string, any>>(initialFormState);\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  const [executionStatus, setExecutionStatus] = useState<ExecutionStatus>('idle');\n  const [executionResult, setExecutionResult] = useState<string>('');\n\n  /**\n   * Handles input field value changes and clears validation errors\n   *\n   * @internal\n   * @param name - Name of the input field being changed\n   * @param value - New value for the field (string for text/select/number, File for file inputs)\n   *\n   * Behavior:\n   * 1. Updates formState with new value for the specified field\n   * 2. If field has validation error, clears it immediately (real-time error clearing)\n   * 3. Allows user to see error disappear as they correct the issue\n   */\n  const handleInputChange = (name: string, value: string | File) => {\n    setFormState(prev => ({ ...prev, [name]: value }));\n    if (errors[name]) {\n      setErrors(prev => {\n        const newErrors = { ...prev };\n        delete newErrors[name];\n        return newErrors;\n      });\n    }\n  };\n\n  /**\n   * Renders appropriate input component based on input type from schema\n   *\n   * @internal\n   * @param input - AgentInput schema object defining field properties\n   * @returns React element for the input field with label and error display\n   *\n   * Supported input types:\n   * - textarea: Multi-line text input using Textarea component\n   * - select: Dropdown using Select component with options from schema\n   * - file: File upload input using Input component with type=\"file\"\n   * - number: Numeric input using Input component with type=\"number\"\n   * - text (default): Single-line text input using Input component\n   *\n   * All inputs include:\n   * - Label with description and required indicator (red asterisk)\n   * - Error border (border-red-500) if validation error exists\n   * - Error message below field in red text\n   * - onChange handler calling handleInputChange\n   */\n  const renderInput = (input: AgentInput) => {\n    const value = formState[input.name];\n    const error = errors[input.name];\n\n    const label = (\n      <label htmlFor={input.name} className=\"block text-sm font-medium text-muted-foreground mb-1\">\n        {input.description}\n        {input.required && <span className=\"text-red-400 ml-1\">*</span>}\n      </label>\n    );\n\n    switch (input.type) {\n      case 'textarea':\n        return (\n          <div key={input.name}>\n            {label}\n            <Textarea\n              id={input.name}\n              value={value}\n              onChange={(e) => handleInputChange(input.name, e.target.value)}\n              placeholder={`Enter ${input.name}...`}\n              className={error ? 'border-red-500' : ''}\n            />\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n      case 'select':\n        return (\n          <div key={input.name}>\n            {label}\n            <Select\n              id={input.name}\n              value={value}\n              onChange={(e) => handleInputChange(input.name, e.target.value)}\n              className={error ? 'border-red-500' : ''}\n            >\n              {input.options?.map(option => <option key={option} value={option}>{option}</option>)}\n            </Select>\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n      case 'file':\n        return (\n          <div key={input.name}>\n            {label}\n            <Input\n              id={input.name}\n              type=\"file\"\n              onChange={(e) => handleInputChange(input.name, e.target.files?.[0] || '')}\n              className={error ? 'border-red-500' : ''}\n            />\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n      case 'number':\n         return (\n          <div key={input.name}>\n            {label}\n            <Input\n              id={input.name}\n              type=\"number\"\n              value={value}\n              onChange={(e) => handleInputChange(input.name, e.target.value)}\n              placeholder={`Enter ${input.name}...`}\n              className={error ? 'border-red-500' : ''}\n            />\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n      case 'text':\n      default:\n        return (\n          <div key={input.name}>\n            {label}\n            <Input\n              id={input.name}\n              type=\"text\"\n              value={value}\n              onChange={(e) => handleInputChange(input.name, e.target.value)}\n              placeholder={`Enter ${input.name}...`}\n              className={error ? 'border-red-500' : ''}\n            />\n            {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n          </div>\n        );\n    }\n  };\n\n  /**\n   * Validates form and executes the agent\n   *\n   * @internal\n   *\n   * Execution workflow:\n   * 1. **Validation Phase**: Checks all required fields for values\n   *    - Iterates through agent.inputs array\n   *    - For each input marked as required, checks if formState has value\n   *    - Builds newErrors object with error messages for empty required fields\n   *    - If any errors found, sets errors state and exits early (no execution)\n   * 2. **Execution Phase**: If validation passes\n   *    - Sets executionStatus to 'loading' (disables button, shows spinner)\n   *    - Clears any previous executionResult\n   *    - Simulates API call with 2-second delay - **TODO: Replace with actual API call**\n   *    - Randomly determines success (85% chance) or error (15% chance)\n   * 3. **Result Phase**: Updates UI with execution result\n   *    - Success: Sets executionStatus to 'success', shows green success message\n   *    - Error: Sets executionStatus to 'error', shows red error message\n   *\n   * Dependencies: [agent, formState] - Re-creates callback if agent or form values change\n   */\n  const handleRunAgent = useCallback(async () => {\n    const newErrors: Record<string, string> = {};\n    agent.inputs.forEach(input => {\n      if (input.required && !formState[input.name]) {\n        newErrors[input.name] = `${input.name} is required.`;\n      }\n    });\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors);\n      return;\n    }\n\n    setExecutionStatus('loading');\n    setExecutionResult('');\n    await new Promise(res => setTimeout(res, 2000)); // Simulate API call\n\n    // Simulate success/error\n    if (Math.random() > 0.15) {\n      setExecutionStatus('success');\n      setExecutionResult(`Agent \"${agent.name}\" ran successfully. Output has been generated.`);\n    } else {\n      setExecutionStatus('error');\n      setExecutionResult(`Agent \"${agent.name}\" failed to run. Please check the logs.`);\n    }\n  }, [agent, formState]);\n\n  /**\n   * Resets form state and closes modal\n   *\n   * @internal\n   *\n   * Reset workflow:\n   * 1. Resets formState to initialFormState (default values from schema)\n   * 2. Clears all validation errors\n   * 3. Resets executionStatus to 'idle'\n   * 4. Clears executionResult message\n   * 5. Calls onClose callback to notify parent component\n   *\n   * This ensures clean state when modal reopens - no stale data from previous session\n   */\n  const handleClose = () => {\n    setFormState(initialFormState);\n    setErrors({});\n    setExecutionStatus('idle');\n    setExecutionResult('');\n    onClose();\n  };\n\n  /**\n   * Renders execution result message with color-coded styling\n   *\n   * @internal\n   * @returns React element for result display, or null if no result to show\n   *\n   * Result display by status:\n   * - **idle**: Returns null (no result to display)\n   * - **loading**: Returns null (spinner shown on button instead)\n   * - **success**: Green background (bg-green-900/50) with CheckCircleIcon and success message\n   * - **error**: Red background (bg-red-900/50) with XCircleIcon and error message\n   *\n   * Result styling:\n   * - Flexbox layout with icon and message text\n   * - Icon positioned at top with flex-shrink-0 to prevent squashing\n   * - Rounded corners (rounded-md) and padding (p-4)\n   * - Margin top (mt-4) to separate from form fields\n   */\n  const renderResult = () => {\n    if (executionStatus === 'idle') return null;\n\n    const baseClasses = \"mt-4 p-4 rounded-md text-sm flex items-start space-x-3\";\n    \n    if (executionStatus === 'success') {\n      return (\n        <div className={`${baseClasses} bg-green-900/50 text-green-300`}>\n          <CheckCircleIcon className=\"h-5 w-5 mt-0.5 flex-shrink-0\" />\n          <p>{executionResult}</p>\n        </div>\n      );\n    }\n\n    if (executionStatus === 'error') {\n      return (\n        <div className={`${baseClasses} bg-red-900/50 text-red-300`}>\n          <XCircleIcon className=\"h-5 w-5 mt-0.5 flex-shrink-0\" />\n          <p>{executionResult}</p>\n        </div>\n      );\n    }\n    \n    return null;\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={(open) => !open && handleClose()}>\n      <DialogContent className=\"sm:max-w-[625px]\">\n        <DialogHeader>\n          <DialogTitle>{agent.name}</DialogTitle>\n          <DialogDescription>{agent.description}</DialogDescription>\n        </DialogHeader>\n        <div className=\"grid gap-4 py-4 max-h-[60vh] overflow-y-auto pr-3\">\n          {agent.inputs.map(renderInput)}\n        </div>\n        {renderResult()}\n        <DialogFooter>\n          <Button variant=\"secondary\" onClick={handleClose}>Cancel</Button>\n          <Button onClick={handleRunAgent} disabled={executionStatus === 'loading'}>\n            {executionStatus === 'loading' && <SpinnerIcon className=\"h-4 w-4 mr-2\" />}\n            Run Agent\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nAgentConfigModal.displayName = 'AgentConfigModal';\n\nexport default AgentConfigModal;\n   ",
        "last_modified": "2026-01-02T15:11:36.272754"
      },
      "task_intent": {
        "title": "Document Frontend React Components and Hooks",
        "description": "Add comprehensive JSDoc documentation to all React components and custom hooks in the frontend, including prop types, usage examples, component purposes, state management, and side effects.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:01:10.769537",
  "last_updated": "2026-01-02T14:22:14.504662"
}