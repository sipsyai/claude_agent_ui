{
  "file_path": "src/services/skill-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import * as fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport type { Skill, Agent, TrainingRecord, InputField } from './claude-structure-parser';\nimport { ClaudeStructureParser } from './claude-structure-parser.js';\n\nexport interface CreateSkillRequest {\n  name: string;\n  description: string;\n  allowedTools?: string[];\n  mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n  inputFields?: InputField[]; // Input parameters for skill execution\n  content: string;\n}\n\nexport interface UpdateSkillRequest {\n  description: string;\n  allowedTools?: string[];\n  mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n  inputFields?: InputField[]; // Input parameters for skill execution\n  content: string;\n}\n\nexport interface CreateSkillResponse {\n  success: boolean;\n  skill?: Skill;\n  path?: string;\n  error?: string;\n}\n\n/**\n * Validates skill name format\n */\nfunction validateSkillName(name: string): string | null {\n  if (!name || name.trim().length === 0) {\n    return 'Skill name is required';\n  }\n\n  if (name.length > 64) {\n    return 'Skill name must be 64 characters or less';\n  }\n\n  if (!/^[a-z0-9-]+$/.test(name)) {\n    return 'Skill name must contain only lowercase letters, numbers, and hyphens';\n  }\n\n  return null;\n}\n\n/**\n * Validates skill description\n */\nfunction validateSkillDescription(description: string): string | null {\n  if (!description || description.trim().length === 0) {\n    return 'Skill description is required';\n  }\n\n  if (description.length > 1024) {\n    return 'Skill description must be 1024 characters or less';\n  }\n\n  if (!description.toLowerCase().includes('use when')) {\n    return 'Skill description should include \"Use when...\" to describe when to use this skill';\n  }\n\n  return null;\n}\n\n/**\n * Creates YAML frontmatter for SKILL.md\n */\nfunction createSkillFrontmatter(request: CreateSkillRequest): string {\n  const frontmatter = ['---', `name: ${request.name}`, `description: ${request.description}`];\n\n  if (request.allowedTools && request.allowedTools.length > 0) {\n    frontmatter.push(`allowed-tools: ${request.allowedTools.join(', ')}`);\n  }\n\n  // Add MCP tools if present\n  if (request.mcpTools && Object.keys(request.mcpTools).length > 0) {\n    frontmatter.push('mcp_tools:');\n    Object.entries(request.mcpTools).forEach(([serverId, tools]) => {\n      if (Array.isArray(tools) && tools.length > 0) {\n        frontmatter.push(`  ${serverId}:`);\n        tools.forEach((toolName: string) => {\n          frontmatter.push(`    - ${toolName}`);\n        });\n      }\n    });\n  }\n\n  frontmatter.push('---');\n\n  return frontmatter.join('\\n');\n}\n\n/**\n * Creates a new skill in the .claude/skills/ directory\n */\nexport async function createSkill(\n  request: CreateSkillRequest,\n  projectRoot: string\n): Promise<CreateSkillResponse> {\n  try {\n    // Validate name\n    const nameError = validateSkillName(request.name);\n    if (nameError) {\n      return { success: false, error: nameError };\n    }\n\n    // Validate description\n    const descError = validateSkillDescription(request.description);\n    if (descError) {\n      return { success: false, error: descError };\n    }\n\n    // Validate content\n    if (!request.content || request.content.trim().length === 0) {\n      return { success: false, error: 'Skill content/instructions are required' };\n    }\n\n    // Determine skill directory path\n    const skillsDir = path.join(projectRoot, '.claude', 'skills');\n    const skillDir = path.join(skillsDir, request.name);\n    const skillMdPath = path.join(skillDir, 'SKILL.md');\n\n    // Check if skill already exists\n    if (existsSync(skillDir)) {\n      return {\n        success: false,\n        error: `Skill \"${request.name}\" already exists at ${skillDir}`,\n      };\n    }\n\n    // Create skills directory if it doesn't exist\n    await fs.mkdir(skillDir, { recursive: true });\n\n    // Create SKILL.md content\n    const frontmatter = createSkillFrontmatter(request);\n    const skillContent = `${frontmatter}\\n\\n${request.content}`;\n\n    // Write SKILL.md file\n    await fs.writeFile(skillMdPath, skillContent, 'utf-8');\n\n    // Write skill.config.json if inputFields are provided\n    if (request.inputFields && request.inputFields.length > 0) {\n      const configPath = path.join(skillDir, 'skill.config.json');\n      const configData = {\n        inputs: request.inputFields,\n      };\n      await fs.writeFile(configPath, JSON.stringify(configData, null, 2), 'utf-8');\n    }\n\n    // Parse and return the created skill\n    const skill: Skill = {\n      id: request.name,\n      name: request.name,\n      description: request.description,\n      path: skillDir,\n      skillMdPath,\n      content: request.content,\n      metadata: (request.allowedTools || request.mcpTools || request.inputFields)\n        ? {\n            ...(request.allowedTools ? { allowedTools: request.allowedTools } : {}),\n            ...(request.mcpTools ? { mcpTools: request.mcpTools } : {}),\n            ...(request.inputFields ? { inputFields: request.inputFields } : {}),\n          }\n        : undefined,\n    };\n\n    return {\n      success: true,\n      skill,\n      path: skillMdPath,\n    };\n  } catch (error) {\n    console.error('Error creating skill:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Creates YAML frontmatter for SKILL.md during update\n */\nfunction updateSkillFrontmatter(name: string, request: UpdateSkillRequest): string {\n  const frontmatter = ['---', `name: ${name}`, `description: ${request.description}`];\n\n  if (request.allowedTools && request.allowedTools.length > 0) {\n    frontmatter.push(`allowed-tools: ${request.allowedTools.join(', ')}`);\n  }\n\n  // Add MCP tools if present\n  if (request.mcpTools && Object.keys(request.mcpTools).length > 0) {\n    frontmatter.push('mcp_tools:');\n    Object.entries(request.mcpTools).forEach(([serverId, tools]) => {\n      if (Array.isArray(tools) && tools.length > 0) {\n        frontmatter.push(`  ${serverId}:`);\n        tools.forEach((toolName: string) => {\n          frontmatter.push(`    - ${toolName}`);\n        });\n      }\n    });\n  }\n\n  frontmatter.push('---');\n\n  return frontmatter.join('\\n');\n}\n\n/**\n * Updates an existing skill in the .claude/skills/ directory\n */\nexport async function updateSkill(\n  skillId: string,\n  request: UpdateSkillRequest,\n  projectRoot: string\n): Promise<CreateSkillResponse> {\n  try {\n    // Validate description\n    const descError = validateSkillDescription(request.description);\n    if (descError) {\n      return { success: false, error: descError };\n    }\n\n    // Validate content\n    if (!request.content || request.content.trim().length === 0) {\n      return { success: false, error: 'Skill content/instructions are required' };\n    }\n\n    // Determine skill directory path\n    const skillsDir = path.join(projectRoot, '.claude', 'skills');\n    const skillDir = path.join(skillsDir, skillId);\n    const skillMdPath = path.join(skillDir, 'SKILL.md');\n\n    // Check if skill exists\n    if (!existsSync(skillDir)) {\n      return {\n        success: false,\n        error: `Skill \"${skillId}\" does not exist`,\n      };\n    }\n\n    // Create SKILL.md content with updated frontmatter\n    const frontmatter = updateSkillFrontmatter(skillId, request);\n    const skillContent = `${frontmatter}\\n\\n${request.content}`;\n\n    // Write updated SKILL.md file\n    await fs.writeFile(skillMdPath, skillContent, 'utf-8');\n\n    // Update or remove skill.config.json\n    const configPath = path.join(skillDir, 'skill.config.json');\n    if (request.inputFields && request.inputFields.length > 0) {\n      // Write/update config file\n      const configData = {\n        inputs: request.inputFields,\n      };\n      await fs.writeFile(configPath, JSON.stringify(configData, null, 2), 'utf-8');\n    } else if (existsSync(configPath)) {\n      // Remove config file if no input fields\n      await fs.unlink(configPath);\n    }\n\n    // Parse and return the updated skill\n    const skill: Skill = {\n      id: skillId,\n      name: skillId,\n      description: request.description,\n      path: skillDir,\n      skillMdPath,\n      content: request.content,\n      metadata: (request.allowedTools || request.mcpTools || request.inputFields)\n        ? {\n            ...(request.allowedTools ? { allowedTools: request.allowedTools } : {}),\n            ...(request.mcpTools ? { mcpTools: request.mcpTools } : {}),\n            ...(request.inputFields ? { inputFields: request.inputFields } : {}),\n          }\n        : undefined,\n    };\n\n    return {\n      success: true,\n      skill,\n      path: skillMdPath,\n    };\n  } catch (error) {\n    console.error('Error updating skill:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Checks if a skill exists\n */\nexport async function skillExists(name: string, projectRoot: string): Promise<boolean> {\n  const skillDir = path.join(projectRoot, '.claude', 'skills', name);\n  return existsSync(skillDir);\n}\n\n/**\n * Deletes a skill\n */\nexport async function deleteSkill(name: string, projectRoot: string): Promise<CreateSkillResponse> {\n  try {\n    const skillDir = path.join(projectRoot, '.claude', 'skills', name);\n\n    if (!existsSync(skillDir)) {\n      return {\n        success: false,\n        error: `Skill \"${name}\" does not exist`,\n      };\n    }\n\n    await fs.rm(skillDir, { recursive: true, force: true });\n\n    return {\n      success: true,\n      path: skillDir,\n    };\n  } catch (error) {\n    console.error('Error deleting skill:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Validates that skill references exist\n * Returns array of invalid skill names, empty array if all valid\n */\nexport async function validateSkillReferences(\n  skillNames: string[],\n  projectRoot: string\n): Promise<{ valid: boolean; invalidSkills: string[] }> {\n  if (!skillNames || skillNames.length === 0) {\n    return { valid: true, invalidSkills: [] };\n  }\n\n  const invalidSkills: string[] = [];\n\n  for (const skillName of skillNames) {\n    const exists = await skillExists(skillName, projectRoot);\n    if (!exists) {\n      invalidSkills.push(skillName);\n    }\n  }\n\n  return {\n    valid: invalidSkills.length === 0,\n    invalidSkills,\n  };\n}\n\n/**\n * Gets usage information for a specific skill\n * Returns list of agent IDs that use this skill\n */\nexport async function getSkillUsage(\n  skillName: string,\n  projectRoot: string\n): Promise<{ agentIds: string[]; count: number }> {\n  const parser = new ClaudeStructureParser();\n  const agents = await parser.parseAgents(projectRoot);\n\n  const agentIds = agents\n    .filter((agent) => agent.metadata?.skills?.includes(skillName))\n    .map((agent) => agent.id);\n\n  return {\n    agentIds,\n    count: agentIds.length,\n  };\n}\n\n/**\n * Gets all skills with usage information\n * Returns skills array with usedInAgents and usageCount populated\n */\nexport async function getSkillsWithUsageInfo(projectRoot: string): Promise<Skill[]> {\n  const parser = new ClaudeStructureParser();\n  const [skills, agents] = await Promise.all([\n    parser.parseSkills(projectRoot),\n    parser.parseAgents(projectRoot),\n  ]);\n\n  // Build a map of skill usage\n  const usageMap = new Map<string, string[]>();\n\n  agents.forEach((agent) => {\n    if (agent.metadata?.skills) {\n      agent.metadata.skills.forEach((skillId) => {\n        if (!usageMap.has(skillId)) {\n          usageMap.set(skillId, []);\n        }\n        usageMap.get(skillId)!.push(agent.id);\n      });\n    }\n  });\n\n  // Enhance skills with usage info\n  return skills.map((skill) => ({\n    ...skill,\n    usedInAgents: usageMap.get(skill.id) || [],\n    usageCount: usageMap.get(skill.id)?.length || 0,\n  }));\n}\n\n/**\n * Updates skill experience score and training history\n */\nexport async function updateSkillExperience(\n  skillId: string,\n  newScore: number,\n  trainingRecord: TrainingRecord,\n  projectRoot: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const skillMdPath = path.join(projectRoot, '.claude', 'skills', skillId, 'SKILL.md');\n\n    if (!existsSync(skillMdPath)) {\n      return { success: false, error: `Skill \"${skillId}\" does not exist` };\n    }\n\n    // Read current SKILL.md\n    const content = await fs.readFile(skillMdPath, 'utf-8');\n\n    // Split frontmatter and body\n    const lines = content.split('\\n');\n    let frontmatterEndIndex = -1;\n    let frontmatterStartIndex = -1;\n\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].trim() === '---') {\n        if (frontmatterStartIndex === -1) {\n          frontmatterStartIndex = i;\n        } else {\n          frontmatterEndIndex = i;\n          break;\n        }\n      }\n    }\n\n    if (frontmatterStartIndex === -1 || frontmatterEndIndex === -1) {\n      return { success: false, error: 'Invalid SKILL.md format: missing frontmatter' };\n    }\n\n    // Parse frontmatter\n    const frontmatterText = lines.slice(frontmatterStartIndex + 1, frontmatterEndIndex).join('\\n');\n    const frontmatterData = yaml.load(frontmatterText) as any;\n\n    // Update experience score\n    frontmatterData.experience_score = Math.round(newScore);\n\n    // Update training history (keep last 10 records)\n    if (!frontmatterData.training_history) {\n      frontmatterData.training_history = [];\n    }\n    frontmatterData.training_history.unshift(trainingRecord);\n    if (frontmatterData.training_history.length > 10) {\n      frontmatterData.training_history = frontmatterData.training_history.slice(0, 10);\n    }\n\n    // Rebuild frontmatter\n    const newFrontmatter = yaml.dump(frontmatterData, { indent: 2 });\n\n    // Reconstruct file content\n    const body = lines.slice(frontmatterEndIndex + 1).join('\\n');\n    const newContent = `---\\n${newFrontmatter}---${body}`;\n\n    // Write updated file\n    await fs.writeFile(skillMdPath, newContent, 'utf-8');\n\n    return { success: true };\n  } catch (error) {\n    console.error('Error updating skill experience:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Gets training history for a skill\n */\nexport async function getSkillTrainingHistory(\n  skillId: string,\n  projectRoot: string\n): Promise<{ success: boolean; history?: TrainingRecord[]; error?: string }> {\n  try {\n    const parser = new ClaudeStructureParser();\n    const skills = await parser.parseSkills(projectRoot);\n    const skill = skills.find((s) => s.id === skillId);\n\n    if (!skill) {\n      return { success: false, error: `Skill \"${skillId}\" not found` };\n    }\n\n    return {\n      success: true,\n      history: skill.trainingHistory || [],\n    };\n  } catch (error) {\n    console.error('Error getting skill training history:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import * as fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport type { Skill, Agent, TrainingRecord, InputField } from './claude-structure-parser';\nimport { ClaudeStructureParser } from './claude-structure-parser.js';\n\n/**\n * Request payload for creating a new skill in the `.claude/skills/` directory\n *\n * @description\n * Defines the structure for creating a new skill file with YAML frontmatter and markdown content.\n * Skills are stored as `SKILL.md` files in `.claude/skills/{name}/` with optional `skill.config.json`\n * for input field definitions.\n *\n * @example\n * // Basic skill creation\n * const request: CreateSkillRequest = {\n *   name: 'pdf-analyzer',\n *   description: 'Use when you need to analyze PDF documents and extract key information',\n *   content: 'Analyze the PDF document and extract:\\n- Main topics\\n- Key findings\\n- Action items'\n * };\n *\n * @example\n * // Skill with allowed tools and MCP tools\n * const request: CreateSkillRequest = {\n *   name: 'web-scraper',\n *   description: 'Use when you need to fetch and parse web pages',\n *   allowedTools: ['WebFetch', 'Read', 'Write'],\n *   mcpTools: {\n *     'playwright-server': ['navigate', 'screenshot', 'extract_text'],\n *     'cheerio-server': ['parse_html', 'select_elements']\n *   },\n *   content: 'Steps:\\n1. Fetch the URL\\n2. Parse HTML\\n3. Extract data\\n4. Save results'\n * };\n *\n * @example\n * // Skill with input fields for parameterization\n * const request: CreateSkillRequest = {\n *   name: 'code-reviewer',\n *   description: 'Use when you need to review code for quality and best practices',\n *   allowedTools: ['Read', 'Grep', 'Glob'],\n *   inputFields: [\n *     {\n *       name: 'language',\n *       type: 'string',\n *       description: 'Programming language to review',\n *       required: true\n *     },\n *     {\n *       name: 'focus_areas',\n *       type: 'array',\n *       description: 'Areas to focus on (security, performance, readability)',\n *       required: false\n *     }\n *   ],\n *   content: 'Review the code for:\\n- Security vulnerabilities\\n- Performance issues\\n- Code style\\n- Best practices'\n * };\n */\nexport interface CreateSkillRequest {\n  /** Skill identifier (lowercase, hyphens, numbers only, max 64 chars) */\n  name: string;\n  /** Brief description including \"Use when...\" guidance (max 1024 chars) */\n  description: string;\n  /** Optional array of allowed Claude SDK tool names */\n  allowedTools?: string[];\n  /** Optional MCP tools organized by server ID: { serverId: [toolName1, toolName2] } */\n  mcpTools?: Record<string, string[]>;\n  /** Optional input parameters for skill execution (stored in skill.config.json) */\n  inputFields?: InputField[];\n  /** Skill instructions/content in markdown format */\n  content: string;\n}\n\n/**\n * Request payload for updating an existing skill\n *\n * @description\n * Defines the structure for updating an existing skill's YAML frontmatter and markdown content.\n * The skill name (ID) cannot be changed; use deleteSkill + createSkill to rename.\n * Updates replace the entire SKILL.md file and skill.config.json (if inputFields provided).\n *\n * @example\n * // Update skill description and content\n * const request: UpdateSkillRequest = {\n *   description: 'Use when you need to analyze PDF documents for compliance',\n *   content: 'Updated instructions:\\n1. Check compliance\\n2. Extract findings\\n3. Generate report'\n * };\n *\n * @example\n * // Update skill with new allowed tools\n * const request: UpdateSkillRequest = {\n *   description: 'Use when you need to scrape web data with rate limiting',\n *   allowedTools: ['WebFetch', 'Read', 'Write', 'Bash'],\n *   content: 'Steps:\\n1. Fetch with delays\\n2. Parse\\n3. Save'\n * };\n *\n * @example\n * // Update skill with modified MCP tools and input fields\n * const request: UpdateSkillRequest = {\n *   description: 'Use when you need to review code with custom rules',\n *   allowedTools: ['Read', 'Grep', 'Glob'],\n *   mcpTools: {\n *     'eslint-server': ['lint', 'fix'],\n *     'prettier-server': ['format']\n *   },\n *   inputFields: [\n *     {\n *       name: 'language',\n *       type: 'string',\n *       description: 'Programming language',\n *       required: true\n *     },\n *     {\n *       name: 'severity',\n *       type: 'string',\n *       description: 'Minimum severity level (error, warning, info)',\n *       required: false\n *     }\n *   ],\n *   content: 'Review with custom rules:\\n- Run linter\\n- Check formatting\\n- Report issues'\n * };\n */\nexport interface UpdateSkillRequest {\n  /** Updated brief description including \"Use when...\" guidance (max 1024 chars) */\n  description: string;\n  /** Optional array of allowed Claude SDK tool names (replaces existing) */\n  allowedTools?: string[];\n  /** Optional MCP tools organized by server ID (replaces existing) */\n  mcpTools?: Record<string, string[]>;\n  /** Optional input parameters (replaces existing skill.config.json or removes if empty) */\n  inputFields?: InputField[];\n  /** Updated skill instructions/content in markdown format */\n  content: string;\n}\n\n/**\n * Response payload for skill creation, update, and deletion operations\n *\n * @description\n * Standard response format for skill management operations.\n * On success: `success=true` with optional `skill` and `path` data.\n * On failure: `success=false` with `error` message describing what went wrong.\n *\n * @example\n * // Successful skill creation\n * const response: CreateSkillResponse = {\n *   success: true,\n *   skill: {\n *     id: 'pdf-analyzer',\n *     name: 'pdf-analyzer',\n *     description: 'Use when you need to analyze PDF documents',\n *     path: '/project/.claude/skills/pdf-analyzer',\n *     skillMdPath: '/project/.claude/skills/pdf-analyzer/SKILL.md',\n *     content: 'Analyze the PDF...',\n *     metadata: {\n *       allowedTools: ['Read', 'Write']\n *     }\n *   },\n *   path: '/project/.claude/skills/pdf-analyzer/SKILL.md'\n * };\n *\n * @example\n * // Failed skill creation (validation error)\n * const response: CreateSkillResponse = {\n *   success: false,\n *   error: 'Skill name must contain only lowercase letters, numbers, and hyphens'\n * };\n *\n * @example\n * // Failed skill creation (already exists)\n * const response: CreateSkillResponse = {\n *   success: false,\n *   error: 'Skill \"pdf-analyzer\" already exists at /project/.claude/skills/pdf-analyzer'\n * };\n *\n * @example\n * // Successful skill deletion\n * const response: CreateSkillResponse = {\n *   success: true,\n *   path: '/project/.claude/skills/pdf-analyzer'\n * };\n */\nexport interface CreateSkillResponse {\n  /** Whether the operation succeeded */\n  success: boolean;\n  /** Parsed skill object (on create/update success) */\n  skill?: Skill;\n  /** File system path to SKILL.md or skill directory */\n  path?: string;\n  /** Error message (on failure) describing what went wrong */\n  error?: string;\n}\n\n/**\n * Validates skill name format against naming rules\n *\n * @description\n * Validates that a skill name conforms to the required naming rules for `.claude/skills/` directory structure.\n * The name is used as both the directory name and the skill identifier, so it must be filesystem-safe\n * and URL-friendly.\n *\n * **Validation Rules:**\n * - Required: Must be non-empty after trimming whitespace\n * - Length: Maximum 64 characters\n * - Format: Lowercase letters (a-z), numbers (0-9), and hyphens (-) only\n * - Regex: `/^[a-z0-9-]+$/`\n *\n * **Common Issues:**\n * - Uppercase letters: Use lowercase only (e.g., \"PDF-Analyzer\" \u2192 \"pdf-analyzer\")\n * - Spaces: Replace with hyphens (e.g., \"web scraper\" \u2192 \"web-scraper\")\n * - Underscores: Replace with hyphens (e.g., \"code_review\" \u2192 \"code-review\")\n * - Special characters: Remove or replace (e.g., \"skill@v2\" \u2192 \"skill-v2\")\n *\n * @param name - Skill name to validate\n * @returns Error message string if validation fails, null if valid\n *\n * @private\n *\n * @example\n * // Valid skill names\n * validateSkillName('pdf-analyzer');  // null (valid)\n * validateSkillName('web-scraper');   // null (valid)\n * validateSkillName('skill-v2');      // null (valid)\n * validateSkillName('code123');       // null (valid)\n * validateSkillName('a');             // null (valid - single char)\n *\n * @example\n * // Invalid: Empty or whitespace-only\n * validateSkillName('');          // 'Skill name is required'\n * validateSkillName('   ');       // 'Skill name is required'\n * validateSkillName(null as any); // 'Skill name is required'\n *\n * @example\n * // Invalid: Too long (>64 chars)\n * const longName = 'a'.repeat(65);\n * validateSkillName(longName);\n * // Returns: 'Skill name must be 64 characters or less'\n *\n * @example\n * // Invalid: Contains uppercase letters\n * validateSkillName('PDF-Analyzer');\n * // Returns: 'Skill name must contain only lowercase letters, numbers, and hyphens'\n * validateSkillName('WebScraper');\n * // Returns: 'Skill name must contain only lowercase letters, numbers, and hyphens'\n *\n * @example\n * // Invalid: Contains spaces or special characters\n * validateSkillName('web scraper');\n * // Returns: 'Skill name must contain only lowercase letters, numbers, and hyphens'\n * validateSkillName('code_review');\n * // Returns: 'Skill name must contain only lowercase letters, numbers, and hyphens'\n * validateSkillName('skill@v2');\n * // Returns: 'Skill name must contain only lowercase letters, numbers, and hyphens'\n * validateSkillName('skill.config');\n * // Returns: 'Skill name must contain only lowercase letters, numbers, and hyphens'\n *\n * @example\n * // Usage in createSkill validation\n * const nameError = validateSkillName(request.name);\n * if (nameError) {\n *   return { success: false, error: nameError };\n * }\n * // Proceed with skill creation...\n *\n * @example\n * // User-friendly validation with suggestions\n * const name = 'PDF Analyzer';\n * const error = validateSkillName(name);\n *\n * if (error) {\n *   // Suggest corrected name\n *   const suggested = name.toLowerCase().replace(/\\s+/g, '-');\n *   console.log(`Invalid name: ${name}`);\n *   console.log(`Error: ${error}`);\n *   console.log(`Suggestion: ${suggested}`);\n *   // Output:\n *   // Invalid name: PDF Analyzer\n *   // Error: Skill name must contain only lowercase letters, numbers, and hyphens\n *   // Suggestion: pdf-analyzer\n * }\n */\nfunction validateSkillName(name: string): string | null {\n  if (!name || name.trim().length === 0) {\n    return 'Skill name is required';\n  }\n\n  if (name.length > 64) {\n    return 'Skill name must be 64 characters or less';\n  }\n\n  if (!/^[a-z0-9-]+$/.test(name)) {\n    return 'Skill name must contain only lowercase letters, numbers, and hyphens';\n  }\n\n  return null;\n}\n\n/**\n * Validates skill description content and format\n *\n * @description\n * Validates that a skill description provides clear guidance on when to use the skill.\n * The description is displayed to Claude and helps the AI agent decide when to activate\n * the skill, so it must be descriptive and include usage context.\n *\n * **Validation Rules:**\n * - Required: Must be non-empty after trimming whitespace\n * - Length: Maximum 1024 characters\n * - Content: Must include \"Use when\" phrase (case-insensitive) for usage guidance\n *\n * **Best Practices:**\n * - Start with \"Use when you need to...\" for clarity\n * - Be specific about the skill's purpose and use cases\n * - Include key scenarios or contexts where the skill applies\n * - Avoid vague descriptions like \"A useful skill\" or \"Does stuff\"\n *\n * @param description - Skill description to validate\n * @returns Error message string if validation fails, null if valid\n *\n * @private\n *\n * @example\n * // Valid descriptions\n * validateSkillDescription('Use when you need to analyze PDF documents');\n * // null (valid)\n *\n * validateSkillDescription('Use when you need to scrape websites and extract structured data');\n * // null (valid)\n *\n * validateSkillDescription('Use when reviewing code for security vulnerabilities and best practices');\n * // null (valid)\n *\n * @example\n * // Valid: Case-insensitive \"use when\" check\n * validateSkillDescription('USE WHEN you need to process images');\n * // null (valid)\n *\n * validateSkillDescription('You should use when analyzing logs');\n * // null (valid - contains \"use when\")\n *\n * validateSkillDescription('This skill is helpful to use when debugging');\n * // null (valid - contains \"use when\")\n *\n * @example\n * // Invalid: Empty or whitespace-only\n * validateSkillDescription('');\n * // Returns: 'Skill description is required'\n *\n * validateSkillDescription('   ');\n * // Returns: 'Skill description is required'\n *\n * validateSkillDescription(null as any);\n * // Returns: 'Skill description is required'\n *\n * @example\n * // Invalid: Too long (>1024 chars)\n * const longDesc = 'Use when you need to ' + 'a'.repeat(1020);\n * validateSkillDescription(longDesc);\n * // Returns: 'Skill description must be 1024 characters or less'\n *\n * @example\n * // Invalid: Missing \"Use when\" guidance\n * validateSkillDescription('A helpful skill for PDF processing');\n * // Returns: 'Skill description should include \"Use when...\" to describe when to use this skill'\n *\n * validateSkillDescription('Analyzes documents and extracts data');\n * // Returns: 'Skill description should include \"Use when...\" to describe when to use this skill'\n *\n * validateSkillDescription('This is a web scraper');\n * // Returns: 'Skill description should include \"Use when...\" to describe when to use this skill'\n *\n * @example\n * // Usage in createSkill validation\n * const descError = validateSkillDescription(request.description);\n * if (descError) {\n *   return { success: false, error: descError };\n * }\n * // Proceed with skill creation...\n *\n * @example\n * // User-friendly validation with suggestions\n * const description = 'Analyzes PDF documents';\n * const error = validateSkillDescription(description);\n *\n * if (error) {\n *   // Suggest corrected description\n *   const suggested = `Use when you need to ${description.toLowerCase()}`;\n *   console.log(`Invalid description: ${description}`);\n *   console.log(`Error: ${error}`);\n *   console.log(`Suggestion: ${suggested}`);\n *   // Output:\n *   // Invalid description: Analyzes PDF documents\n *   // Error: Skill description should include \"Use when...\" to describe when to use this skill\n *   // Suggestion: Use when you need to analyzes pdf documents\n * }\n *\n * @example\n * // Comprehensive validation flow\n * function validateDescription(desc: string): string {\n *   const error = validateSkillDescription(desc);\n *   if (error) {\n *     throw new Error(`Invalid description: ${error}`);\n *   }\n *   return desc;\n * }\n *\n * try {\n *   validateDescription('Use when analyzing code');\n *   console.log('Valid description');\n * } catch (err) {\n *   console.error(err.message);\n * }\n */\nfunction validateSkillDescription(description: string): string | null {\n  if (!description || description.trim().length === 0) {\n    return 'Skill description is required';\n  }\n\n  if (description.length > 1024) {\n    return 'Skill description must be 1024 characters or less';\n  }\n\n  if (!description.toLowerCase().includes('use when')) {\n    return 'Skill description should include \"Use when...\" to describe when to use this skill';\n  }\n\n  return null;\n}\n\n/**\n * Creates YAML frontmatter block for SKILL.md file\n *\n * @description\n * Generates the YAML frontmatter section that appears at the top of SKILL.md files.\n * The frontmatter contains skill metadata including name, description, allowed tools,\n * and MCP tool configurations. This metadata is parsed by ClaudeStructureParser and\n * used by Claude agents to understand skill capabilities and tool permissions.\n *\n * **YAML Frontmatter Format:**\n * ```yaml\n * ---\n * name: skill-name\n * description: Use when you need to...\n * allowed-tools: Tool1, Tool2, Tool3\n * mcp_tools:\n *   server-id-1:\n *     - tool-name-1\n *     - tool-name-2\n *   server-id-2:\n *     - tool-name-3\n * ---\n * ```\n *\n * **Field Descriptions:**\n * - `name`: Skill identifier (matches directory name, lowercase-hyphenated)\n * - `description`: Usage guidance (must include \"Use when\" phrase)\n * - `allowed-tools`: Optional comma-separated list of Claude SDK tool names (Read, Write, Bash, etc.)\n * - `mcp_tools`: Optional nested structure mapping MCP server IDs to their tool names\n *\n * **Important Notes:**\n * - The frontmatter is wrapped in `---` delimiters (YAML fence)\n * - allowed-tools is omitted if no tools are specified\n * - mcp_tools uses nested YAML structure with 2-space indentation\n * - Server IDs in mcp_tools match MCP server configuration IDs\n * - Tool names must match those exposed by the MCP server\n *\n * @param request - Skill creation request with name, description, and optional tool configurations\n * @returns YAML frontmatter string with `---` delimiters and newline-separated fields\n *\n * @private\n *\n * @example\n * // Basic skill frontmatter (no tools)\n * const frontmatter = createSkillFrontmatter({\n *   name: 'pdf-analyzer',\n *   description: 'Use when you need to analyze PDF documents',\n *   content: '...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: pdf-analyzer\n * // description: Use when you need to analyze PDF documents\n * // ---\n *\n * @example\n * // Skill with allowed Claude SDK tools\n * const frontmatter = createSkillFrontmatter({\n *   name: 'web-scraper',\n *   description: 'Use when you need to fetch and parse web pages',\n *   allowedTools: ['WebFetch', 'Read', 'Write'],\n *   content: '...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: web-scraper\n * // description: Use when you need to fetch and parse web pages\n * // allowed-tools: WebFetch, Read, Write\n * // ---\n *\n * @example\n * // Skill with MCP tools only\n * const frontmatter = createSkillFrontmatter({\n *   name: 'browser-automation',\n *   description: 'Use when you need to automate browser interactions',\n *   mcpTools: {\n *     'playwright-server': ['navigate', 'screenshot', 'extract_text'],\n *     'cheerio-server': ['parse_html', 'select_elements']\n *   },\n *   content: '...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: browser-automation\n * // description: Use when you need to automate browser interactions\n * // mcp_tools:\n * //   playwright-server:\n * //     - navigate\n * //     - screenshot\n * //     - extract_text\n * //   cheerio-server:\n * //     - parse_html\n * //     - select_elements\n * // ---\n *\n * @example\n * // Skill with both allowed tools and MCP tools\n * const frontmatter = createSkillFrontmatter({\n *   name: 'code-reviewer',\n *   description: 'Use when you need to review code for quality and best practices',\n *   allowedTools: ['Read', 'Grep', 'Glob'],\n *   mcpTools: {\n *     'eslint-server': ['lint', 'fix'],\n *     'prettier-server': ['format']\n *   },\n *   content: '...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: code-reviewer\n * // description: Use when you need to review code for quality and best practices\n * // allowed-tools: Read, Grep, Glob\n * // mcp_tools:\n * //   eslint-server:\n * //     - lint\n * //     - fix\n * //   prettier-server:\n * //     - format\n * // ---\n *\n * @example\n * // Empty tool arrays are filtered out (no output for empty mcpTools server)\n * const frontmatter = createSkillFrontmatter({\n *   name: 'data-processor',\n *   description: 'Use when processing data files',\n *   allowedTools: [],  // Empty array - not included in output\n *   mcpTools: {\n *     'valid-server': ['tool1', 'tool2'],\n *     'empty-server': []  // Empty array - filtered out\n *   },\n *   content: '...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: data-processor\n * // description: Use when processing data files\n * // mcp_tools:\n * //   valid-server:\n * //     - tool1\n * //     - tool2\n * // ---\n *\n * @example\n * // Usage in createSkill workflow\n * const request: CreateSkillRequest = {\n *   name: 'api-tester',\n *   description: 'Use when you need to test REST APIs',\n *   allowedTools: ['WebFetch', 'Read', 'Write'],\n *   content: 'Steps:\\n1. Send request\\n2. Validate response\\n3. Log results'\n * };\n *\n * const frontmatter = createSkillFrontmatter(request);\n * const skillContent = `${frontmatter}\\n\\n${request.content}`;\n * await fs.writeFile('SKILL.md', skillContent, 'utf-8');\n *\n * @example\n * // Parsing generated frontmatter\n * import * as yaml from 'js-yaml';\n *\n * const frontmatter = createSkillFrontmatter({\n *   name: 'test-skill',\n *   description: 'Use when testing',\n *   allowedTools: ['Read'],\n *   content: '...'\n * });\n *\n * // Extract YAML content (between --- delimiters)\n * const lines = frontmatter.split('\\n');\n * const yamlContent = lines.slice(1, -1).join('\\n');\n * const parsed = yaml.load(yamlContent);\n *\n * console.log(parsed);\n * // Output:\n * // {\n * //   name: 'test-skill',\n * //   description: 'Use when testing',\n * //   'allowed-tools': 'Read'\n * // }\n */\nfunction createSkillFrontmatter(request: CreateSkillRequest): string {\n  const frontmatter = ['---', `name: ${request.name}`, `description: ${request.description}`];\n\n  if (request.allowedTools && request.allowedTools.length > 0) {\n    frontmatter.push(`allowed-tools: ${request.allowedTools.join(', ')}`);\n  }\n\n  // Add MCP tools if present\n  if (request.mcpTools && Object.keys(request.mcpTools).length > 0) {\n    frontmatter.push('mcp_tools:');\n    Object.entries(request.mcpTools).forEach(([serverId, tools]) => {\n      if (Array.isArray(tools) && tools.length > 0) {\n        frontmatter.push(`  ${serverId}:`);\n        tools.forEach((toolName: string) => {\n          frontmatter.push(`    - ${toolName}`);\n        });\n      }\n    });\n  }\n\n  frontmatter.push('---');\n\n  return frontmatter.join('\\n');\n}\n\n/**\n * Creates a new skill in the `.claude/skills/` directory\n *\n * @description\n * Creates a new skill by generating a directory structure with SKILL.md (containing YAML frontmatter\n * and markdown content) and optionally skill.config.json (if inputFields are provided). The skill\n * name serves as both the directory name and the skill identifier.\n *\n * **File Structure:**\n * ```\n * .claude/skills/{name}/\n *   \u251c\u2500\u2500 SKILL.md           # YAML frontmatter + markdown content\n *   \u2514\u2500\u2500 skill.config.json  # Optional: input field definitions\n * ```\n *\n * **SKILL.md Format:**\n * ```markdown\n * ---\n * name: skill-name\n * description: Use when you need to...\n * allowed-tools: Read, Write, Grep\n * mcp_tools:\n *   server-id:\n *     - tool-name\n * ---\n *\n * # Skill instructions (markdown content)\n * ```\n *\n * **Validation Rules:**\n * - Name: Required, 1-64 chars, lowercase letters/numbers/hyphens only, must match /^[a-z0-9-]+$/\n * - Description: Required, 1-1024 chars, must include \"Use when\" (case-insensitive)\n * - Content: Required, non-empty markdown instructions\n * - Uniqueness: Skill name must not already exist in `.claude/skills/`\n *\n * @param request - Skill creation request with name, description, content, and optional metadata\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to CreateSkillResponse with success status, skill data, and path\n *\n * @example\n * // Basic skill creation\n * const response = await createSkill(\n *   {\n *     name: 'pdf-analyzer',\n *     description: 'Use when you need to analyze PDF documents and extract key information',\n *     content: 'Analyze the PDF document and extract:\\n- Main topics\\n- Key findings\\n- Action items'\n *   },\n *   '/Users/john/projects/my-app'\n * );\n *\n * if (response.success) {\n *   console.log('Created skill:', response.skill.name);\n *   console.log('Location:', response.path);\n *   // Output:\n *   // Created skill: pdf-analyzer\n *   // Location: /Users/john/projects/my-app/.claude/skills/pdf-analyzer/SKILL.md\n * } else {\n *   console.error('Error:', response.error);\n * }\n *\n * @example\n * // Skill with allowed tools and MCP tools\n * const response = await createSkill(\n *   {\n *     name: 'web-scraper',\n *     description: 'Use when you need to fetch and parse web pages',\n *     allowedTools: ['WebFetch', 'Read', 'Write'],\n *     mcpTools: {\n *       'playwright-server': ['navigate', 'screenshot', 'extract_text'],\n *       'cheerio-server': ['parse_html', 'select_elements']\n *     },\n *     content: 'Steps:\\n1. Fetch the URL using WebFetch\\n2. Parse HTML\\n3. Extract data\\n4. Save results'\n *   },\n *   process.cwd()\n * );\n *\n * // Generated SKILL.md:\n * // ---\n * // name: web-scraper\n * // description: Use when you need to fetch and parse web pages\n * // allowed-tools: WebFetch, Read, Write\n * // mcp_tools:\n * //   playwright-server:\n * //     - navigate\n * //     - screenshot\n * //     - extract_text\n * //   cheerio-server:\n * //     - parse_html\n * //     - select_elements\n * // ---\n * //\n * // Steps:\n * // 1. Fetch the URL using WebFetch\n * // 2. Parse HTML\n * // 3. Extract data\n * // 4. Save results\n *\n * @example\n * // Skill with input fields (creates skill.config.json)\n * const response = await createSkill(\n *   {\n *     name: 'code-reviewer',\n *     description: 'Use when you need to review code for quality and best practices',\n *     allowedTools: ['Read', 'Grep', 'Glob'],\n *     inputFields: [\n *       {\n *         name: 'language',\n *         type: 'string',\n *         description: 'Programming language to review',\n *         required: true\n *       },\n *       {\n *         name: 'focus_areas',\n *         type: 'array',\n *         description: 'Areas to focus on (security, performance, readability)',\n *         required: false\n *       }\n *     ],\n *     content: 'Review the code for:\\n- Security vulnerabilities\\n- Performance issues\\n- Code style\\n- Best practices'\n *   },\n *   '/Users/john/projects/my-app'\n * );\n *\n * // Creates two files:\n * // .claude/skills/code-reviewer/SKILL.md\n * // .claude/skills/code-reviewer/skill.config.json (contains inputFields)\n *\n * @example\n * // Handling validation errors\n * const response = await createSkill(\n *   {\n *     name: 'Invalid Name!',  // Contains invalid characters\n *     description: 'This is a skill',  // Missing \"Use when\"\n *     content: ''  // Empty content\n *   },\n *   process.cwd()\n * );\n *\n * // response.success === false\n * // response.error === 'Skill name must contain only lowercase letters, numbers, and hyphens'\n *\n * @example\n * // Handling duplicate skill names\n * // First creation succeeds\n * await createSkill(\n *   {\n *     name: 'pdf-analyzer',\n *     description: 'Use when analyzing PDFs',\n *     content: 'Instructions...'\n *   },\n *   process.cwd()\n * );\n *\n * // Second creation with same name fails\n * const response = await createSkill(\n *   {\n *     name: 'pdf-analyzer',\n *     description: 'Use when analyzing PDFs v2',\n *     content: 'Different instructions...'\n *   },\n *   process.cwd()\n * );\n *\n * // response.success === false\n * // response.error === 'Skill \"pdf-analyzer\" already exists at /path/.claude/skills/pdf-analyzer'\n */\nexport async function createSkill(\n  request: CreateSkillRequest,\n  projectRoot: string\n): Promise<CreateSkillResponse> {\n  try {\n    // Validate name\n    const nameError = validateSkillName(request.name);\n    if (nameError) {\n      return { success: false, error: nameError };\n    }\n\n    // Validate description\n    const descError = validateSkillDescription(request.description);\n    if (descError) {\n      return { success: false, error: descError };\n    }\n\n    // Validate content\n    if (!request.content || request.content.trim().length === 0) {\n      return { success: false, error: 'Skill content/instructions are required' };\n    }\n\n    // Determine skill directory path\n    const skillsDir = path.join(projectRoot, '.claude', 'skills');\n    const skillDir = path.join(skillsDir, request.name);\n    const skillMdPath = path.join(skillDir, 'SKILL.md');\n\n    // Check if skill already exists\n    if (existsSync(skillDir)) {\n      return {\n        success: false,\n        error: `Skill \"${request.name}\" already exists at ${skillDir}`,\n      };\n    }\n\n    // Create skills directory if it doesn't exist\n    await fs.mkdir(skillDir, { recursive: true });\n\n    // Create SKILL.md content\n    const frontmatter = createSkillFrontmatter(request);\n    const skillContent = `${frontmatter}\\n\\n${request.content}`;\n\n    // Write SKILL.md file\n    await fs.writeFile(skillMdPath, skillContent, 'utf-8');\n\n    // Write skill.config.json if inputFields are provided\n    if (request.inputFields && request.inputFields.length > 0) {\n      const configPath = path.join(skillDir, 'skill.config.json');\n      const configData = {\n        inputs: request.inputFields,\n      };\n      await fs.writeFile(configPath, JSON.stringify(configData, null, 2), 'utf-8');\n    }\n\n    // Parse and return the created skill\n    const skill: Skill = {\n      id: request.name,\n      name: request.name,\n      description: request.description,\n      path: skillDir,\n      skillMdPath,\n      content: request.content,\n      metadata: (request.allowedTools || request.mcpTools || request.inputFields)\n        ? {\n            ...(request.allowedTools ? { allowedTools: request.allowedTools } : {}),\n            ...(request.mcpTools ? { mcpTools: request.mcpTools } : {}),\n            ...(request.inputFields ? { inputFields: request.inputFields } : {}),\n          }\n        : undefined,\n    };\n\n    return {\n      success: true,\n      skill,\n      path: skillMdPath,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Creates updated YAML frontmatter block for SKILL.md during skill updates\n *\n * @description\n * Generates a new YAML frontmatter section for updating existing SKILL.md files.\n * Similar to createSkillFrontmatter but takes the skill name separately since it cannot\n * be changed during updates (name is derived from the existing skill directory).\n *\n * **Key Differences from createSkillFrontmatter:**\n * - Name parameter is separate (preserves existing skill ID)\n * - Used exclusively by updateSkill() function\n * - Replaces all existing frontmatter fields (full replacement, not partial merge)\n *\n * **YAML Frontmatter Format:**\n * ```yaml\n * ---\n * name: skill-name\n * description: Use when you need to...\n * allowed-tools: Tool1, Tool2, Tool3\n * mcp_tools:\n *   server-id-1:\n *     - tool-name-1\n *     - tool-name-2\n * ---\n * ```\n *\n * **Update Semantics:**\n * - All fields are replaced (not merged) with values from UpdateSkillRequest\n * - If allowedTools is undefined/empty, the field is omitted from frontmatter\n * - If mcpTools is undefined/empty, the field is omitted from frontmatter\n * - This enables removing previously configured tools by omitting them from the update request\n *\n * @param name - Skill identifier (preserved from existing skill, cannot be changed)\n * @param request - Skill update request with description and optional tool configurations\n * @returns YAML frontmatter string with `---` delimiters and newline-separated fields\n *\n * @private\n *\n * @example\n * // Update description only (removes any existing allowed tools and MCP tools)\n * const frontmatter = updateSkillFrontmatter('pdf-analyzer', {\n *   description: 'Use when you need to analyze PDF documents for compliance',\n *   content: 'Updated instructions...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: pdf-analyzer\n * // description: Use when you need to analyze PDF documents for compliance\n * // ---\n *\n * @example\n * // Update with new allowed tools (replaces existing tools)\n * const frontmatter = updateSkillFrontmatter('web-scraper', {\n *   description: 'Use when you need to scrape web data with rate limiting',\n *   allowedTools: ['WebFetch', 'Read', 'Write', 'Bash'],  // Replaced tool list\n *   content: 'Updated steps...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: web-scraper\n * // description: Use when you need to scrape web data with rate limiting\n * // allowed-tools: WebFetch, Read, Write, Bash\n * // ---\n *\n * @example\n * // Update with modified MCP tools (replaces existing MCP configuration)\n * const frontmatter = updateSkillFrontmatter('code-reviewer', {\n *   description: 'Use when you need to review code with custom linting rules',\n *   allowedTools: ['Read', 'Grep', 'Glob'],\n *   mcpTools: {\n *     'eslint-server': ['lint', 'fix'],\n *     'prettier-server': ['format']\n *   },\n *   content: 'Updated review steps...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: code-reviewer\n * // description: Use when you need to review code with custom linting rules\n * // allowed-tools: Read, Grep, Glob\n * // mcp_tools:\n * //   eslint-server:\n * //     - lint\n * //     - fix\n * //   prettier-server:\n * //     - format\n * // ---\n *\n * @example\n * // Remove all tools from skill (omit allowedTools and mcpTools)\n * const frontmatter = updateSkillFrontmatter('browser-automation', {\n *   description: 'Use when you need basic browser automation',\n *   // allowedTools: undefined - not included in frontmatter\n *   // mcpTools: undefined - not included in frontmatter\n *   content: 'Simplified instructions...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: browser-automation\n * // description: Use when you need basic browser automation\n * // ---\n *\n * @example\n * // Empty arrays are treated as \"remove\" (not included in frontmatter)\n * const frontmatter = updateSkillFrontmatter('data-processor', {\n *   description: 'Use when processing data files',\n *   allowedTools: [],  // Empty - field omitted\n *   mcpTools: {},      // Empty - field omitted\n *   content: 'Process data...'\n * });\n *\n * console.log(frontmatter);\n * // Output:\n * // ---\n * // name: data-processor\n * // description: Use when processing data files\n * // ---\n *\n * @example\n * // Usage in updateSkill workflow\n * const skillId = 'pdf-analyzer';\n * const request: UpdateSkillRequest = {\n *   description: 'Use when you need to analyze PDF documents for compliance',\n *   allowedTools: ['Read', 'Write'],\n *   content: 'New instructions:\\n1. Check compliance\\n2. Extract findings\\n3. Generate report'\n * };\n *\n * const frontmatter = updateSkillFrontmatter(skillId, request);\n * const skillContent = `${frontmatter}\\n\\n${request.content}`;\n * const skillMdPath = path.join(projectRoot, '.claude', 'skills', skillId, 'SKILL.md');\n * await fs.writeFile(skillMdPath, skillContent, 'utf-8');\n *\n * @example\n * // Comparison: Name handling in create vs update\n * // Create: Name comes from request\n * const createFrontmatter = createSkillFrontmatter({\n *   name: 'new-skill',  // Name in request\n *   description: 'Use when...',\n *   content: '...'\n * });\n *\n * // Update: Name passed separately (from skillId parameter to updateSkill)\n * const updateFrontmatter = updateSkillFrontmatter(\n *   'existing-skill',  // Name preserved from existing directory\n *   {\n *     description: 'Use when...',\n *     content: '...'\n *     // No 'name' field in UpdateSkillRequest\n *   }\n * );\n *\n * @example\n * // Full replacement semantics example\n * // Original SKILL.md frontmatter:\n * // ---\n * // name: web-scraper\n * // description: Use when you need to scrape websites\n * // allowed-tools: WebFetch, Read\n * // mcp_tools:\n * //   playwright-server:\n * //     - navigate\n * // ---\n *\n * // Update with new MCP tools (playwright-server is removed, cheerio-server is added)\n * const frontmatter = updateSkillFrontmatter('web-scraper', {\n *   description: 'Use when you need to parse HTML',\n *   allowedTools: ['Read', 'Write'],  // WebFetch removed, Write added\n *   mcpTools: {\n *     'cheerio-server': ['parse_html', 'select']  // playwright-server gone\n *   },\n *   content: 'Parse HTML...'\n * });\n *\n * // New frontmatter completely replaces old:\n * // ---\n * // name: web-scraper\n * // description: Use when you need to parse HTML\n * // allowed-tools: Read, Write\n * // mcp_tools:\n * //   cheerio-server:\n * //     - parse_html\n * //     - select\n * // ---\n */\nfunction updateSkillFrontmatter(name: string, request: UpdateSkillRequest): string {\n  const frontmatter = ['---', `name: ${name}`, `description: ${request.description}`];\n\n  if (request.allowedTools && request.allowedTools.length > 0) {\n    frontmatter.push(`allowed-tools: ${request.allowedTools.join(', ')}`);\n  }\n\n  // Add MCP tools if present\n  if (request.mcpTools && Object.keys(request.mcpTools).length > 0) {\n    frontmatter.push('mcp_tools:');\n    Object.entries(request.mcpTools).forEach(([serverId, tools]) => {\n      if (Array.isArray(tools) && tools.length > 0) {\n        frontmatter.push(`  ${serverId}:`);\n        tools.forEach((toolName: string) => {\n          frontmatter.push(`    - ${toolName}`);\n        });\n      }\n    });\n  }\n\n  frontmatter.push('---');\n\n  return frontmatter.join('\\n');\n}\n\n/**\n * Updates an existing skill in the `.claude/skills/` directory\n *\n * @description\n * Updates an existing skill by replacing its SKILL.md file with new frontmatter and content.\n * If inputFields are provided, skill.config.json is created/updated; if omitted, the config\n * file is deleted. The skill name (ID) cannot be changed; use deleteSkill + createSkill to rename.\n *\n * **Update Behavior:**\n * - SKILL.md: Entire file is replaced (frontmatter + content)\n * - skill.config.json: Created/updated if inputFields provided, deleted if inputFields empty/undefined\n * - Skill name: Preserved (cannot be changed via update)\n * - All frontmatter fields: Replaced with new values from request\n *\n * **Validation Rules:**\n * - Description: Required, 1-1024 chars, must include \"Use when\" (case-insensitive)\n * - Content: Required, non-empty markdown instructions\n * - Skill existence: Skill must exist in `.claude/skills/{skillId}/`\n *\n * @param skillId - Skill identifier (directory name in .claude/skills/)\n * @param request - Skill update request with description, content, and optional metadata\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to CreateSkillResponse with success status, updated skill data, and path\n *\n * @example\n * // Basic skill update (description and content only)\n * const response = await updateSkill(\n *   'pdf-analyzer',\n *   {\n *     description: 'Use when you need to analyze PDF documents for compliance and regulations',\n *     content: 'Updated instructions:\\n1. Check compliance\\n2. Extract findings\\n3. Generate report'\n *   },\n *   '/Users/john/projects/my-app'\n * );\n *\n * if (response.success) {\n *   console.log('Updated skill:', response.skill.name);\n *   console.log('New description:', response.skill.description);\n * } else {\n *   console.error('Error:', response.error);\n * }\n *\n * @example\n * // Update skill with new allowed tools\n * const response = await updateSkill(\n *   'web-scraper',\n *   {\n *     description: 'Use when you need to scrape web data with rate limiting',\n *     allowedTools: ['WebFetch', 'Read', 'Write', 'Bash'],  // Added 'Bash'\n *     content: 'Steps:\\n1. Fetch with delays\\n2. Parse\\n3. Save'\n *   },\n *   process.cwd()\n * );\n *\n * // Updated SKILL.md frontmatter now includes 'Bash' in allowed-tools\n *\n * @example\n * // Update skill with modified MCP tools and input fields\n * const response = await updateSkill(\n *   'code-reviewer',\n *   {\n *     description: 'Use when you need to review code with custom linting rules',\n *     allowedTools: ['Read', 'Grep', 'Glob'],\n *     mcpTools: {\n *       'eslint-server': ['lint', 'fix'],\n *       'prettier-server': ['format']\n *     },\n *     inputFields: [\n *       {\n *         name: 'language',\n *         type: 'string',\n *         description: 'Programming language',\n *         required: true\n *       },\n *       {\n *         name: 'severity',\n *         type: 'string',\n *         description: 'Minimum severity level (error, warning, info)',\n *         required: false\n *       }\n *     ],\n *     content: 'Review with custom rules:\\n- Run linter\\n- Check formatting\\n- Report issues'\n *   },\n *   process.cwd()\n * );\n *\n * // Updates both SKILL.md and skill.config.json\n *\n * @example\n * // Remove input fields from skill (deletes skill.config.json)\n * const response = await updateSkill(\n *   'code-reviewer',\n *   {\n *     description: 'Use when you need to review code',\n *     allowedTools: ['Read', 'Grep', 'Glob'],\n *     // inputFields omitted or set to undefined\n *     content: 'Review the code for best practices'\n *   },\n *   process.cwd()\n * );\n *\n * // skill.config.json is deleted if it existed\n *\n * @example\n * // Handling validation errors\n * const response = await updateSkill(\n *   'pdf-analyzer',\n *   {\n *     description: 'This is a skill',  // Missing \"Use when\"\n *     content: ''  // Empty content\n *   },\n *   process.cwd()\n * );\n *\n * // response.success === false\n * // response.error === 'Skill description should include \"Use when...\" to describe when to use this skill'\n *\n * @example\n * // Handling non-existent skill\n * const response = await updateSkill(\n *   'nonexistent-skill',\n *   {\n *     description: 'Use when needed',\n *     content: 'Instructions...'\n *   },\n *   process.cwd()\n * );\n *\n * // response.success === false\n * // response.error === 'Skill \"nonexistent-skill\" does not exist'\n *\n * @example\n * // Complete workflow: Update and verify\n * const response = await updateSkill(\n *   'web-scraper',\n *   {\n *     description: 'Use when you need to scrape websites with retry logic',\n *     allowedTools: ['WebFetch', 'Read', 'Write', 'Bash'],\n *     mcpTools: {\n *       'playwright-server': ['navigate', 'screenshot', 'extract_text', 'wait_for_selector']\n *     },\n *     content: 'Scraping with retries:\\n1. Set retry count\\n2. Fetch URL\\n3. Retry on failure\\n4. Parse and save'\n *   },\n *   process.cwd()\n * );\n *\n * if (response.success) {\n *   // Verify the update\n *   const parser = new ClaudeStructureParser();\n *   const skills = await parser.parseSkills(process.cwd());\n *   const updatedSkill = skills.find(s => s.id === 'web-scraper');\n *   console.log('Allowed tools:', updatedSkill.metadata?.allowedTools);\n *   console.log('MCP tools:', updatedSkill.metadata?.mcpTools);\n * }\n */\nexport async function updateSkill(\n  skillId: string,\n  request: UpdateSkillRequest,\n  projectRoot: string\n): Promise<CreateSkillResponse> {\n  try {\n    // Validate description\n    const descError = validateSkillDescription(request.description);\n    if (descError) {\n      return { success: false, error: descError };\n    }\n\n    // Validate content\n    if (!request.content || request.content.trim().length === 0) {\n      return { success: false, error: 'Skill content/instructions are required' };\n    }\n\n    // Determine skill directory path\n    const skillsDir = path.join(projectRoot, '.claude', 'skills');\n    const skillDir = path.join(skillsDir, skillId);\n    const skillMdPath = path.join(skillDir, 'SKILL.md');\n\n    // Check if skill exists\n    if (!existsSync(skillDir)) {\n      return {\n        success: false,\n        error: `Skill \"${skillId}\" does not exist`,\n      };\n    }\n\n    // Create SKILL.md content with updated frontmatter\n    const frontmatter = updateSkillFrontmatter(skillId, request);\n    const skillContent = `${frontmatter}\\n\\n${request.content}`;\n\n    // Write updated SKILL.md file\n    await fs.writeFile(skillMdPath, skillContent, 'utf-8');\n\n    // Update or remove skill.config.json\n    const configPath = path.join(skillDir, 'skill.config.json');\n    if (request.inputFields && request.inputFields.length > 0) {\n      // Write/update config file\n      const configData = {\n        inputs: request.inputFields,\n      };\n      await fs.writeFile(configPath, JSON.stringify(configData, null, 2), 'utf-8');\n    } else if (existsSync(configPath)) {\n      // Remove config file if no input fields\n      await fs.unlink(configPath);\n    }\n\n    // Parse and return the updated skill\n    const skill: Skill = {\n      id: skillId,\n      name: skillId,\n      description: request.description,\n      path: skillDir,\n      skillMdPath,\n      content: request.content,\n      metadata: (request.allowedTools || request.mcpTools || request.inputFields)\n        ? {\n            ...(request.allowedTools ? { allowedTools: request.allowedTools } : {}),\n            ...(request.mcpTools ? { mcpTools: request.mcpTools } : {}),\n            ...(request.inputFields ? { inputFields: request.inputFields } : {}),\n          }\n        : undefined,\n    };\n\n    return {\n      success: true,\n      skill,\n      path: skillMdPath,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Checks if a skill exists in the `.claude/skills/` directory\n *\n * @description\n * Verifies whether a skill directory exists at `.claude/skills/{name}/`.\n * This is a synchronous filesystem check that only validates directory existence,\n * not SKILL.md validity or content structure.\n *\n * **Use Cases:**\n * - Pre-flight validation before creating a skill (prevent duplicates)\n * - Validate skill references in agent configurations\n * - Batch validation of skill dependencies\n * - Cleanup verification after deletion\n *\n * @param name - Skill identifier (directory name in .claude/skills/)\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to true if skill directory exists, false otherwise\n *\n * @example\n * // Check if skill exists before creation\n * const exists = await skillExists('pdf-analyzer', process.cwd());\n * if (exists) {\n *   console.log('Skill already exists, choose a different name');\n * } else {\n *   // Proceed with creation\n *   await createSkill({ name: 'pdf-analyzer', ... }, process.cwd());\n * }\n *\n * @example\n * // Validate skill references in agent config\n * const agentSkills = ['pdf-analyzer', 'web-scraper', 'code-reviewer'];\n * const validationResults = await Promise.all(\n *   agentSkills.map(async (skillName) => ({\n *     skill: skillName,\n *     exists: await skillExists(skillName, '/Users/john/projects/my-app')\n *   }))\n * );\n *\n * const missingSkills = validationResults.filter(r => !r.exists);\n * if (missingSkills.length > 0) {\n *   console.error('Missing skills:', missingSkills.map(r => r.skill));\n * }\n * // Output: Missing skills: ['code-reviewer']\n *\n * @example\n * // Verify deletion completed successfully\n * await deleteSkill('old-skill', process.cwd());\n * const stillExists = await skillExists('old-skill', process.cwd());\n * console.log('Deletion verified:', !stillExists);\n * // Output: Deletion verified: true\n *\n * @example\n * // Batch validation for UI display\n * const skillNames = ['skill1', 'skill2', 'skill3'];\n * const existenceMap = new Map();\n *\n * for (const name of skillNames) {\n *   existenceMap.set(name, await skillExists(name, process.cwd()));\n * }\n *\n * // Display with status indicators\n * skillNames.forEach(name => {\n *   const status = existenceMap.get(name) ? '\u2713' : '\u2717';\n *   console.log(`${status} ${name}`);\n * });\n * // Output:\n * // \u2713 skill1\n * // \u2717 skill2\n * // \u2713 skill3\n */\nexport async function skillExists(name: string, projectRoot: string): Promise<boolean> {\n  const skillDir = path.join(projectRoot, '.claude', 'skills', name);\n  return existsSync(skillDir);\n}\n\n/**\n * Deletes a skill from the `.claude/skills/` directory\n *\n * @description\n * Permanently deletes a skill by removing its entire directory (`.claude/skills/{name}/`),\n * including SKILL.md, skill.config.json, and any other files within the skill directory.\n * This operation is irreversible and uses recursive deletion with force flag.\n *\n * **Deletion Behavior:**\n * - Removes entire skill directory and all contents recursively\n * - Force flag ensures no errors if directory contains unexpected files\n * - Does NOT update agent configurations that reference this skill\n * - Does NOT update Strapi database (use SkillSyncService.removeSkill for sync)\n *\n * **Important Notes:**\n * - This is a filesystem-only operation; Strapi sync must be handled separately\n * - Agent configurations may contain broken references after deletion\n * - Consider backing up skills before deletion if you may need to restore them\n * - Use validateSkillReferences() on agents after deletion to find broken references\n *\n * @param name - Skill identifier (directory name in .claude/skills/)\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to CreateSkillResponse with success status and path\n *\n * @example\n * // Basic skill deletion\n * const response = await deleteSkill('pdf-analyzer', process.cwd());\n *\n * if (response.success) {\n *   console.log('Deleted skill at:', response.path);\n *   // Output: Deleted skill at: /Users/john/projects/my-app/.claude/skills/pdf-analyzer\n * } else {\n *   console.error('Error:', response.error);\n * }\n *\n * @example\n * // Safe deletion with confirmation and backup\n * const skillName = 'web-scraper';\n *\n * // Step 1: Verify skill exists\n * const exists = await skillExists(skillName, process.cwd());\n * if (!exists) {\n *   console.log('Skill does not exist');\n *   return;\n * }\n *\n * // Step 2: Check if skill is used by agents\n * const usage = await getSkillUsage(skillName, process.cwd());\n * if (usage.count > 0) {\n *   console.warn(`Warning: Skill is used by ${usage.count} agent(s): ${usage.agentIds.join(', ')}`);\n *   const confirmDelete = await getUserConfirmation('Delete anyway?');\n *   if (!confirmDelete) return;\n * }\n *\n * // Step 3: Backup skill before deletion\n * const parser = new ClaudeStructureParser();\n * const skills = await parser.parseSkills(process.cwd());\n * const skillToDelete = skills.find(s => s.id === skillName);\n * const backup = JSON.stringify(skillToDelete, null, 2);\n * await fs.writeFile(`backup-${skillName}.json`, backup);\n *\n * // Step 4: Delete skill\n * const response = await deleteSkill(skillName, process.cwd());\n * console.log('Deletion result:', response.success ? 'Success' : response.error);\n *\n * @example\n * // Handling non-existent skill\n * const response = await deleteSkill('nonexistent-skill', process.cwd());\n *\n * // response.success === false\n * // response.error === 'Skill \"nonexistent-skill\" does not exist'\n *\n * @example\n * // Bulk deletion with error handling\n * const skillsToDelete = ['old-skill-1', 'old-skill-2', 'old-skill-3'];\n * const results = await Promise.all(\n *   skillsToDelete.map(async (name) => {\n *     const response = await deleteSkill(name, process.cwd());\n *     return {\n *       skill: name,\n *       success: response.success,\n *       error: response.error\n *     };\n *   })\n * );\n *\n * const successful = results.filter(r => r.success);\n * const failed = results.filter(r => !r.success);\n *\n * console.log(`Deleted ${successful.length} skills`);\n * if (failed.length > 0) {\n *   console.error('Failed to delete:', failed.map(r => `${r.skill} (${r.error})`));\n * }\n *\n * @example\n * // Delete and verify cleanup\n * const skillName = 'temporary-skill';\n *\n * // Delete skill\n * const deleteResponse = await deleteSkill(skillName, process.cwd());\n * console.log('Deleted:', deleteResponse.success);\n *\n * // Verify deletion\n * const stillExists = await skillExists(skillName, process.cwd());\n * console.log('Cleanup verified:', !stillExists);\n *\n * // Output:\n * // Deleted: true\n * // Cleanup verified: true\n *\n * @example\n * // Complete workflow: Delete skill and update agents\n * const skillName = 'deprecated-skill';\n *\n * // Step 1: Find agents using this skill\n * const usage = await getSkillUsage(skillName, process.cwd());\n * console.log(`Skill used by ${usage.count} agents:`, usage.agentIds);\n *\n * // Step 2: Delete skill\n * await deleteSkill(skillName, process.cwd());\n *\n * // Step 3: Update affected agents (remove broken reference)\n * // Note: This requires agent update logic (not shown here)\n * for (const agentId of usage.agentIds) {\n *   console.log(`TODO: Remove \"${skillName}\" from agent \"${agentId}\" configuration`);\n * }\n */\nexport async function deleteSkill(name: string, projectRoot: string): Promise<CreateSkillResponse> {\n  try {\n    const skillDir = path.join(projectRoot, '.claude', 'skills', name);\n\n    if (!existsSync(skillDir)) {\n      return {\n        success: false,\n        error: `Skill \"${name}\" does not exist`,\n      };\n    }\n\n    await fs.rm(skillDir, { recursive: true, force: true });\n\n    return {\n      success: true,\n      path: skillDir,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Validates that all referenced skill names exist in the `.claude/skills/` directory\n *\n * @description\n * Validates an array of skill names to ensure they all exist in the project's `.claude/skills/`\n * directory. This is essential for verifying agent configurations, skill dependencies, and\n * preventing broken references when skills are deleted or renamed.\n *\n * **Validation Workflow:**\n * 1. Returns immediately if skill array is empty or undefined (valid: true)\n * 2. Iterates through each skill name\n * 3. Checks if skill directory exists at `.claude/skills/{skillName}/`\n * 4. Collects invalid (non-existent) skill names\n * 5. Returns validation result with list of invalid skills\n *\n * **Use Cases:**\n * - Validate agent configuration before saving (ensure all referenced skills exist)\n * - Pre-flight validation before deleting a skill (check if it would break agent configs)\n * - Batch validation of skill dependencies across multiple agents\n * - UI validation in agent editor (highlight missing skills in real-time)\n * - Database integrity checks after skill sync operations\n *\n * **Important Notes:**\n * - Empty skill arrays are considered valid (agents don't need skills)\n * - Only checks directory existence, not SKILL.md validity or content\n * - Does not validate skill names format (assumes valid skill IDs)\n * - Synchronous filesystem checks (may be slow for large skill arrays)\n *\n * @param skillNames - Array of skill identifiers to validate (directory names in .claude/skills/)\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to validation result with validity flag and array of invalid skill names\n *\n * @example\n * // Valid skill references (all skills exist)\n * const result = await validateSkillReferences(\n *   ['pdf-analyzer', 'web-scraper', 'code-reviewer'],\n *   process.cwd()\n * );\n *\n * console.log('Valid:', result.valid);           // true\n * console.log('Invalid skills:', result.invalidSkills);  // []\n *\n * @example\n * // Invalid skill references (some skills don't exist)\n * const result = await validateSkillReferences(\n *   ['pdf-analyzer', 'nonexistent-skill', 'web-scraper'],\n *   '/Users/john/projects/my-app'\n * );\n *\n * console.log('Valid:', result.valid);           // false\n * console.log('Invalid skills:', result.invalidSkills);  // ['nonexistent-skill']\n *\n * @example\n * // Empty skill array (valid - agents don't need skills)\n * const result = await validateSkillReferences([], process.cwd());\n *\n * console.log('Valid:', result.valid);           // true\n * console.log('Invalid skills:', result.invalidSkills);  // []\n *\n * @example\n * // Validate agent configuration before saving\n * const agentConfig = {\n *   id: 'my-agent',\n *   name: 'My Agent',\n *   skills: ['pdf-analyzer', 'web-scraper', 'data-processor']\n * };\n *\n * const validation = await validateSkillReferences(\n *   agentConfig.skills,\n *   process.cwd()\n * );\n *\n * if (!validation.valid) {\n *   console.error('Cannot save agent: Missing skills:', validation.invalidSkills.join(', '));\n *   // UI: Display error message with missing skill names\n *   throw new Error(`Missing skills: ${validation.invalidSkills.join(', ')}`);\n * }\n *\n * // Proceed with saving agent configuration\n * await saveAgentConfig(agentConfig);\n *\n * @example\n * // Real-time validation in agent editor UI\n * async function validateAgentSkills(selectedSkills: string[]) {\n *   const validation = await validateSkillReferences(selectedSkills, process.cwd());\n *\n *   if (!validation.valid) {\n *     // Highlight missing skills in red\n *     validation.invalidSkills.forEach(skillName => {\n *       document.querySelector(`[data-skill=\"${skillName}\"]`)?.classList.add('invalid');\n *     });\n *\n *     // Show warning message\n *     showWarning(`Missing skills: ${validation.invalidSkills.join(', ')}`);\n *   }\n * }\n *\n * @example\n * // Check if deleting a skill would break agent configurations\n * const skillToDelete = 'pdf-analyzer';\n *\n * // Step 1: Get all agents\n * const parser = new ClaudeStructureParser();\n * const agents = await parser.parseAgents(process.cwd());\n *\n * // Step 2: Check each agent's remaining skills (excluding the one to delete)\n * const brokenAgents = [];\n *\n * for (const agent of agents) {\n *   if (agent.metadata?.skills?.includes(skillToDelete)) {\n *     // Get skills that would remain after deletion\n *     const remainingSkills = agent.metadata.skills.filter(s => s !== skillToDelete);\n *\n *     // Validate remaining skills\n *     const validation = await validateSkillReferences(remainingSkills, process.cwd());\n *\n *     if (!validation.valid) {\n *       brokenAgents.push({\n *         agent: agent.id,\n *         brokenSkills: validation.invalidSkills\n *       });\n *     }\n *   }\n * }\n *\n * if (brokenAgents.length > 0) {\n *   console.warn('Deleting skill would break:', brokenAgents);\n * }\n *\n * @example\n * // Batch validation for skill dependencies\n * const agentConfigurations = [\n *   { id: 'agent1', skills: ['skill1', 'skill2'] },\n *   { id: 'agent2', skills: ['skill2', 'skill3'] },\n *   { id: 'agent3', skills: ['skill4', 'skill5'] }\n * ];\n *\n * const validationResults = await Promise.all(\n *   agentConfigurations.map(async (config) => ({\n *     agent: config.id,\n *     validation: await validateSkillReferences(config.skills, process.cwd())\n *   }))\n * );\n *\n * const invalidAgents = validationResults.filter(r => !r.validation.valid);\n *\n * if (invalidAgents.length > 0) {\n *   console.error('Invalid agent configurations:');\n *   invalidAgents.forEach(({ agent, validation }) => {\n *     console.error(`  ${agent}: Missing skills [${validation.invalidSkills.join(', ')}]`);\n *   });\n * }\n * // Output:\n * // Invalid agent configurations:\n * //   agent3: Missing skills [skill4, skill5]\n *\n * @example\n * // Database integrity check after skill sync\n * import { strapiClient } from './strapi-client';\n *\n * async function validateDatabaseIntegrity() {\n *   // Get all agents from database\n *   const agents = await strapiClient.getAllAgents();\n *\n *   const integrityIssues = [];\n *\n *   for (const agent of agents) {\n *     const skillIds = agent.skillSelection?.skills?.map(s => s.id) || [];\n *\n *     if (skillIds.length > 0) {\n *       const validation = await validateSkillReferences(skillIds, process.cwd());\n *\n *       if (!validation.valid) {\n *         integrityIssues.push({\n *           agentId: agent.id,\n *           agentName: agent.name,\n *           missingSkills: validation.invalidSkills\n *         });\n *       }\n *     }\n *   }\n *\n *   if (integrityIssues.length > 0) {\n *     console.error('Database integrity issues detected:');\n *     integrityIssues.forEach(issue => {\n *       console.error(`  Agent \"${issue.agentName}\" references missing skills: ${issue.missingSkills.join(', ')}`);\n *     });\n *\n *     // Auto-fix: Remove missing skills from agent configurations\n *     // (implementation depends on requirements)\n *   }\n *\n *   return integrityIssues;\n * }\n *\n * @example\n * // User-friendly error messages\n * async function createAgentWithValidation(agentConfig: any) {\n *   const validation = await validateSkillReferences(\n *     agentConfig.skills || [],\n *     process.cwd()\n *   );\n *\n *   if (!validation.valid) {\n *     const errorMessage = validation.invalidSkills.length === 1\n *       ? `Skill \"${validation.invalidSkills[0]}\" does not exist`\n *       : `Skills ${validation.invalidSkills.map(s => `\"${s}\"`).join(', ')} do not exist`;\n *\n *     throw new Error(errorMessage);\n *   }\n *\n *   // Create agent...\n * }\n *\n * try {\n *   await createAgentWithValidation({\n *     id: 'my-agent',\n *     skills: ['pdf-analyzer', 'missing-skill']\n *   });\n * } catch (err) {\n *   console.error(err.message);\n *   // Output: Skill \"missing-skill\" does not exist\n * }\n */\nexport async function validateSkillReferences(\n  skillNames: string[],\n  projectRoot: string\n): Promise<{ valid: boolean; invalidSkills: string[] }> {\n  if (!skillNames || skillNames.length === 0) {\n    return { valid: true, invalidSkills: [] };\n  }\n\n  const invalidSkills: string[] = [];\n\n  for (const skillName of skillNames) {\n    const exists = await skillExists(skillName, projectRoot);\n    if (!exists) {\n      invalidSkills.push(skillName);\n    }\n  }\n\n  return {\n    valid: invalidSkills.length === 0,\n    invalidSkills,\n  };\n}\n\n/**\n * Gets usage information for a specific skill across all agents\n *\n * @description\n * Analyzes all agents in the `.claude/agents/` directory to find which ones reference a specific skill.\n * Returns a list of agent IDs that use the skill and a count of total usages. This is useful for\n * understanding skill dependencies, preventing orphaned skills, and validating deletion safety.\n *\n * **Analysis Workflow:**\n * 1. Parse all agents from `.claude/agents/` directory using ClaudeStructureParser\n * 2. Filter agents that have the specified skill in their `metadata.skills` array\n * 3. Extract agent IDs from matching agents\n * 4. Return array of agent IDs and count\n *\n * **Use Cases:**\n * - Check if a skill is used before deletion (prevent breaking agent configurations)\n * - Display \"Used by N agents\" badge in skill management UI\n * - Find skill dependencies for documentation generation\n * - Identify unused skills for cleanup/archival\n * - Validate skill rename/move operations (find all references)\n * - Generate skill usage reports and analytics\n *\n * **Important Notes:**\n * - Only checks filesystem agents (`.claude/agents/`), not Strapi database\n * - Does NOT validate if the skill itself exists (may return usage for non-existent skills)\n * - Returns empty array if no agents use the skill\n * - Synchronous agent parsing (may be slow with many agents)\n * - Skill names are case-sensitive matches\n *\n * @param skillName - Skill identifier to search for (directory name in .claude/skills/)\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to usage information with agent IDs array and total count\n *\n * @example\n * // Check usage for an existing skill\n * const usage = await getSkillUsage('pdf-analyzer', process.cwd());\n *\n * console.log('Used by agents:', usage.agentIds);  // ['agent-1', 'agent-2', 'data-agent']\n * console.log('Total usage count:', usage.count);  // 3\n *\n * @example\n * // Check usage for skill not used by any agents\n * const usage = await getSkillUsage('unused-skill', process.cwd());\n *\n * console.log('Used by agents:', usage.agentIds);  // []\n * console.log('Total usage count:', usage.count);  // 0\n *\n * @example\n * // Safe skill deletion with usage check\n * const skillName = 'web-scraper';\n *\n * const usage = await getSkillUsage(skillName, process.cwd());\n *\n * if (usage.count > 0) {\n *   console.warn(\n *     `Warning: Skill \"${skillName}\" is used by ${usage.count} agent(s): ${usage.agentIds.join(', ')}`\n *   );\n *\n *   const confirmDelete = await getUserConfirmation(\n *     `Are you sure you want to delete this skill? ${usage.count} agent(s) will be affected.`\n *   );\n *\n *   if (!confirmDelete) {\n *     console.log('Deletion cancelled');\n *     return;\n *   }\n *\n *   // Optionally update agents to remove skill reference\n *   console.log('TODO: Remove skill from affected agents:', usage.agentIds);\n * }\n *\n * // Proceed with deletion\n * await deleteSkill(skillName, process.cwd());\n *\n * @example\n * // Display \"Used by N agents\" badge in skill management UI\n * async function renderSkillCard(skillName: string) {\n *   const usage = await getSkillUsage(skillName, process.cwd());\n *\n *   const badge = usage.count > 0\n *     ? `<span class=\"badge\">Used by ${usage.count} agent${usage.count === 1 ? '' : 's'}</span>`\n *     : '<span class=\"badge secondary\">Unused</span>';\n *\n *   return `\n *     <div class=\"skill-card\">\n *       <h3>${skillName}</h3>\n *       ${badge}\n *     </div>\n *   `;\n * }\n *\n * @example\n * // Find unused skills for cleanup\n * const parser = new ClaudeStructureParser();\n * const skills = await parser.parseSkills(process.cwd());\n *\n * const unusedSkills = [];\n *\n * for (const skill of skills) {\n *   const usage = await getSkillUsage(skill.id, process.cwd());\n *\n *   if (usage.count === 0) {\n *     unusedSkills.push(skill.id);\n *   }\n * }\n *\n * console.log('Unused skills:', unusedSkills);\n * // Output: Unused skills: ['old-skill', 'deprecated-skill', 'experimental-skill']\n *\n * // Optionally archive or delete unused skills\n * if (unusedSkills.length > 0) {\n *   console.log(`Found ${unusedSkills.length} unused skills. Archive or delete?`);\n * }\n *\n * @example\n * // Generate skill usage report\n * async function generateSkillUsageReport(projectRoot: string) {\n *   const parser = new ClaudeStructureParser();\n *   const skills = await parser.parseSkills(projectRoot);\n *\n *   const report = [];\n *\n *   for (const skill of skills) {\n *     const usage = await getSkillUsage(skill.id, projectRoot);\n *\n *     report.push({\n *       skill: skill.id,\n *       description: skill.description,\n *       usageCount: usage.count,\n *       usedBy: usage.agentIds,\n *       status: usage.count > 0 ? 'active' : 'unused'\n *     });\n *   }\n *\n *   // Sort by usage count (most used first)\n *   report.sort((a, b) => b.usageCount - a.usageCount);\n *\n *   console.log('=== Skill Usage Report ===');\n *   report.forEach(item => {\n *     console.log(`\\n${item.skill} (${item.usageCount} uses)`);\n *     console.log(`  Description: ${item.description}`);\n *     if (item.usedBy.length > 0) {\n *       console.log(`  Used by: ${item.usedBy.join(', ')}`);\n *     }\n *   });\n *\n *   return report;\n * }\n *\n * @example\n * // Validate skill rename operation\n * async function renameSkill(oldName: string, newName: string, projectRoot: string) {\n *   // Step 1: Find all agents using the old skill name\n *   const usage = await getSkillUsage(oldName, projectRoot);\n *\n *   console.log(`Found ${usage.count} agent(s) using skill \"${oldName}\"`);\n *\n *   // Step 2: Rename the skill directory\n *   const oldDir = path.join(projectRoot, '.claude', 'skills', oldName);\n *   const newDir = path.join(projectRoot, '.claude', 'skills', newName);\n *   await fs.rename(oldDir, newDir);\n *\n *   // Step 3: Update all agent configurations to reference new name\n *   console.log(`TODO: Update ${usage.count} agent(s) to reference \"${newName}\":`, usage.agentIds);\n *   // (Agent update implementation depends on agent config format)\n *\n *   console.log('Skill renamed successfully');\n * }\n *\n * @example\n * // Display skill details with usage information\n * async function displaySkillDetails(skillName: string) {\n *   const parser = new ClaudeStructureParser();\n *   const skills = await parser.parseSkills(process.cwd());\n *   const skill = skills.find(s => s.id === skillName);\n *\n *   if (!skill) {\n *     console.error(`Skill \"${skillName}\" not found`);\n *     return;\n *   }\n *\n *   const usage = await getSkillUsage(skillName, process.cwd());\n *\n *   console.log('=== Skill Details ===');\n *   console.log('Name:', skill.name);\n *   console.log('Description:', skill.description);\n *   console.log('Usage Count:', usage.count);\n *\n *   if (usage.count > 0) {\n *     console.log('Used by agents:');\n *     usage.agentIds.forEach((agentId, index) => {\n *       console.log(`  ${index + 1}. ${agentId}`);\n *     });\n *   } else {\n *     console.log('Status: Unused');\n *   }\n * }\n *\n * @example\n * // Bulk operation: Delete all unused skills\n * async function deleteAllUnusedSkills(projectRoot: string) {\n *   const parser = new ClaudeStructureParser();\n *   const skills = await parser.parseSkills(projectRoot);\n *\n *   const deletionResults = [];\n *\n *   for (const skill of skills) {\n *     const usage = await getSkillUsage(skill.id, projectRoot);\n *\n *     if (usage.count === 0) {\n *       console.log(`Deleting unused skill: ${skill.id}`);\n *       const result = await deleteSkill(skill.id, projectRoot);\n *       deletionResults.push({ skill: skill.id, success: result.success });\n *     }\n *   }\n *\n *   const successful = deletionResults.filter(r => r.success).length;\n *   console.log(`Deleted ${successful} unused skill(s)`);\n *\n *   return deletionResults;\n * }\n */\nexport async function getSkillUsage(\n  skillName: string,\n  projectRoot: string\n): Promise<{ agentIds: string[]; count: number }> {\n  const parser = new ClaudeStructureParser();\n  const agents = await parser.parseAgents(projectRoot);\n\n  const agentIds = agents\n    .filter((agent) => agent.metadata?.skills?.includes(skillName))\n    .map((agent) => agent.id);\n\n  return {\n    agentIds,\n    count: agentIds.length,\n  };\n}\n\n/**\n * Gets all skills with complete usage information across all agents\n *\n * @description\n * Retrieves all skills from the `.claude/skills/` directory and enriches each skill with\n * usage information by analyzing which agents reference them. Returns an array of skills\n * with `usedInAgents` and `usageCount` properties populated, enabling comprehensive skill\n * analytics and dependency visualization.\n *\n * **Processing Workflow:**\n * 1. Parse all skills from `.claude/skills/` directory using ClaudeStructureParser\n * 2. Parse all agents from `.claude/agents/` directory in parallel\n * 3. Build a skill usage map by iterating through all agent configurations\n * 4. For each agent with skills, record which skills it uses\n * 5. Enhance each skill object with `usedInAgents` (array of agent IDs) and `usageCount`\n * 6. Return enriched skills array\n *\n * **Returned Skill Properties (Enhanced):**\n * - All standard Skill interface properties (id, name, description, path, content, metadata, etc.)\n * - `usedInAgents`: string[] - Array of agent IDs that reference this skill\n * - `usageCount`: number - Total number of agents using this skill\n *\n * **Use Cases:**\n * - Display skills table with usage statistics in management UI\n * - Generate skill analytics dashboard with usage charts\n * - Identify popular vs unused skills for optimization\n * - Sort skills by popularity (most/least used)\n * - Skill cleanup: Find and archive/delete unused skills\n * - Dependency visualization: Show skill-agent relationships\n * - Export skill usage reports for documentation\n *\n * **Important Notes:**\n * - Parses both skills and agents (may be slow with large directories)\n * - Only checks filesystem (`.claude/skills/`, `.claude/agents/`), not Strapi database\n * - Usage count includes each agent only once (even if agent references skill multiple times)\n * - Skills with zero usage have empty `usedInAgents` array and `usageCount: 0`\n * - Parallel parsing of skills and agents for performance optimization\n *\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to array of Skill objects enriched with usage information\n *\n * @example\n * // Get all skills with usage information\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * skills.forEach(skill => {\n *   console.log(`${skill.name}:`);\n *   console.log(`  Used by ${skill.usageCount} agent(s)`);\n *   if (skill.usedInAgents && skill.usedInAgents.length > 0) {\n *     console.log(`  Agents: ${skill.usedInAgents.join(', ')}`);\n *   } else {\n *     console.log(`  Status: Unused`);\n *   }\n * });\n *\n * // Example output:\n * // pdf-analyzer:\n * //   Used by 3 agent(s)\n * //   Agents: agent-1, agent-2, data-agent\n * // web-scraper:\n * //   Used by 1 agent(s)\n * //   Agents: web-agent\n * // old-skill:\n * //   Used by 0 agent(s)\n * //   Status: Unused\n *\n * @example\n * // Display skills table with usage statistics\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * console.log('Skills Management Dashboard');\n * console.log('\u2501'.repeat(80));\n * console.log('Skill Name'.padEnd(30), 'Usage Count'.padEnd(15), 'Used By');\n * console.log('\u2500'.repeat(80));\n *\n * skills.forEach(skill => {\n *   const usedBy = skill.usedInAgents && skill.usedInAgents.length > 0\n *     ? skill.usedInAgents.join(', ')\n *     : '-';\n *\n *   console.log(\n *     skill.name.padEnd(30),\n *     skill.usageCount.toString().padEnd(15),\n *     usedBy\n *   );\n * });\n *\n * // Output:\n * // Skills Management Dashboard\n * // \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n * // Skill Name                    Usage Count     Used By\n * // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * // pdf-analyzer                  3               agent-1, agent-2, data-agent\n * // web-scraper                   1               web-agent\n * // code-reviewer                 2               dev-agent, qa-agent\n * // old-skill                     0               -\n *\n * @example\n * // Sort skills by popularity (most used first)\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * const sortedByPopularity = skills.sort((a, b) => b.usageCount - a.usageCount);\n *\n * console.log('Most Popular Skills:');\n * sortedByPopularity.slice(0, 5).forEach((skill, index) => {\n *   console.log(`${index + 1}. ${skill.name} (${skill.usageCount} uses)`);\n * });\n *\n * // Output:\n * // Most Popular Skills:\n * // 1. pdf-analyzer (3 uses)\n * // 2. code-reviewer (2 uses)\n * // 3. web-scraper (1 uses)\n * // 4. old-skill (0 uses)\n *\n * @example\n * // Find and list unused skills for cleanup\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * const unusedSkills = skills.filter(skill => skill.usageCount === 0);\n *\n * console.log(`Found ${unusedSkills.length} unused skill(s):`);\n * unusedSkills.forEach(skill => {\n *   console.log(`  - ${skill.name}: ${skill.description}`);\n * });\n *\n * // Prompt for cleanup action\n * if (unusedSkills.length > 0) {\n *   const action = await prompt('Archive, delete, or keep unused skills? (a/d/k):');\n *   // Handle user choice...\n * }\n *\n * @example\n * // Generate skill analytics dashboard data\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * const analytics = {\n *   total: skills.length,\n *   used: skills.filter(s => s.usageCount > 0).length,\n *   unused: skills.filter(s => s.usageCount === 0).length,\n *   averageUsage: skills.reduce((sum, s) => sum + s.usageCount, 0) / skills.length,\n *   mostPopular: skills.sort((a, b) => b.usageCount - a.usageCount)[0],\n *   usageDistribution: {\n *     '0 uses': skills.filter(s => s.usageCount === 0).length,\n *     '1-2 uses': skills.filter(s => s.usageCount >= 1 && s.usageCount <= 2).length,\n *     '3+ uses': skills.filter(s => s.usageCount >= 3).length\n *   }\n * };\n *\n * console.log('=== Skill Analytics ===');\n * console.log('Total skills:', analytics.total);\n * console.log('Used skills:', analytics.used);\n * console.log('Unused skills:', analytics.unused);\n * console.log('Average usage:', analytics.averageUsage.toFixed(2));\n * console.log('Most popular:', analytics.mostPopular?.name, `(${analytics.mostPopular?.usageCount} uses)`);\n * console.log('\\nUsage Distribution:');\n * Object.entries(analytics.usageDistribution).forEach(([range, count]) => {\n *   console.log(`  ${range}: ${count} skill(s)`);\n * });\n *\n * @example\n * // Export skill usage report to JSON\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * const report = skills.map(skill => ({\n *   name: skill.name,\n *   description: skill.description,\n *   usageCount: skill.usageCount,\n *   usedInAgents: skill.usedInAgents || [],\n *   status: skill.usageCount > 0 ? 'active' : 'unused',\n *   allowedTools: skill.metadata?.allowedTools || [],\n *   mcpTools: skill.metadata?.mcpTools || {}\n * }));\n *\n * await fs.writeFile(\n *   'skill-usage-report.json',\n *   JSON.stringify(report, null, 2),\n *   'utf-8'\n * );\n *\n * console.log('Report exported to skill-usage-report.json');\n *\n * @example\n * // Display skill dependency graph (skill -> agents)\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * console.log('=== Skill Dependency Graph ===');\n * skills.forEach(skill => {\n *   if (skill.usageCount > 0) {\n *     console.log(`\\n${skill.name}`);\n *     skill.usedInAgents?.forEach(agentId => {\n *       console.log(`  \u2514\u2500> ${agentId}`);\n *     });\n *   }\n * });\n *\n * // Output:\n * // === Skill Dependency Graph ===\n * //\n * // pdf-analyzer\n * //   \u2514\u2500> agent-1\n * //   \u2514\u2500> agent-2\n * //   \u2514\u2500> data-agent\n * //\n * // web-scraper\n * //   \u2514\u2500> web-agent\n *\n * @example\n * // Filter and display skills by usage threshold\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * const heavilyUsedSkills = skills.filter(s => s.usageCount >= 3);\n * const lightlyUsedSkills = skills.filter(s => s.usageCount > 0 && s.usageCount < 3);\n * const unusedSkills = skills.filter(s => s.usageCount === 0);\n *\n * console.log(`Heavily Used (3+ agents): ${heavilyUsedSkills.length} skill(s)`);\n * heavilyUsedSkills.forEach(s => console.log(`  - ${s.name} (${s.usageCount})`));\n *\n * console.log(`\\nLightly Used (1-2 agents): ${lightlyUsedSkills.length} skill(s)`);\n * lightlyUsedSkills.forEach(s => console.log(`  - ${s.name} (${s.usageCount})`));\n *\n * console.log(`\\nUnused: ${unusedSkills.length} skill(s)`);\n * unusedSkills.forEach(s => console.log(`  - ${s.name}`));\n *\n * @example\n * // Generate CSV export for skills with usage\n * const skills = await getSkillsWithUsageInfo(process.cwd());\n *\n * const csvHeader = 'Skill Name,Description,Usage Count,Used By\\n';\n * const csvRows = skills.map(skill =>\n *   `\"${skill.name}\",\"${skill.description}\",${skill.usageCount},\"${(skill.usedInAgents || []).join(', ')}\"`\n * ).join('\\n');\n *\n * const csv = csvHeader + csvRows;\n * await fs.writeFile('skills-usage.csv', csv, 'utf-8');\n *\n * console.log('CSV export saved to skills-usage.csv');\n */\nexport async function getSkillsWithUsageInfo(projectRoot: string): Promise<Skill[]> {\n  const parser = new ClaudeStructureParser();\n  const [skills, agents] = await Promise.all([\n    parser.parseSkills(projectRoot),\n    parser.parseAgents(projectRoot),\n  ]);\n\n  // Build a map of skill usage\n  const usageMap = new Map<string, string[]>();\n\n  agents.forEach((agent) => {\n    if (agent.metadata?.skills) {\n      agent.metadata.skills.forEach((skillId) => {\n        if (!usageMap.has(skillId)) {\n          usageMap.set(skillId, []);\n        }\n        usageMap.get(skillId)!.push(agent.id);\n      });\n    }\n  });\n\n  // Enhance skills with usage info\n  return skills.map((skill) => ({\n    ...skill,\n    usedInAgents: usageMap.get(skill.id) || [],\n    usageCount: usageMap.get(skill.id)?.length || 0,\n  }));\n}\n\n/**\n * Updates a skill's experience score and appends a new training record to its history\n *\n * @description\n * Updates the `experience_score` and `training_history` fields in a skill's SKILL.md YAML frontmatter.\n * The experience score is rounded to an integer and the training record is prepended to the history\n * array (most recent first). The training history is capped at 10 records maximum (oldest records\n * are dropped when limit is exceeded).\n *\n * **Update Workflow:**\n * 1. Verify skill exists at `.claude/skills/{skillId}/SKILL.md`\n * 2. Read and parse existing SKILL.md file content\n * 3. Extract YAML frontmatter between `---` delimiters\n * 4. Parse frontmatter YAML to JavaScript object\n * 5. Update `experience_score` field with rounded new score\n * 6. Prepend new training record to `training_history` array (create if doesn't exist)\n * 7. Trim training history to last 10 records if needed\n * 8. Rebuild YAML frontmatter with updated data\n * 9. Reconstruct file content (frontmatter + body)\n * 10. Write updated content back to SKILL.md\n *\n * **Experience Score:**\n * - Represents skill quality/effectiveness based on training outcomes\n * - Stored as integer (newScore is rounded using Math.round())\n * - Updated after each training session by training agents\n * - Higher scores indicate better-performing skills\n *\n * **Training History:**\n * - Array of TrainingRecord objects documenting skill usage and outcomes\n * - Ordered chronologically (newest first, oldest last)\n * - Limited to 10 most recent records (FIFO queue with max size 10)\n * - Each record includes: timestamp, agent, task, outcome, feedback, metrics\n * - Used for skill analytics, debugging, and improvement tracking\n *\n * **Important Notes:**\n * - Only updates SKILL.md (filesystem), not Strapi database\n * - Requires valid SKILL.md with YAML frontmatter (returns error if malformed)\n * - Score is always rounded to integer (decimals are not preserved)\n * - Training history is automatically initialized if missing\n * - Older records beyond 10 are silently dropped\n * - Preserves all other frontmatter fields unchanged\n *\n * @param skillId - Skill identifier (directory name in .claude/skills/)\n * @param newScore - New experience score (will be rounded to integer)\n * @param trainingRecord - Training record to append to history (TrainingRecord object)\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to result with success flag and optional error message\n *\n * @example\n * // Update skill experience after successful training\n * const trainingRecord: TrainingRecord = {\n *   timestamp: new Date().toISOString(),\n *   agent: 'training-agent-1',\n *   task: 'Extract data from PDF invoice',\n *   outcome: 'success',\n *   feedback: 'Successfully extracted all required fields',\n *   metrics: {\n *     accuracy: 0.95,\n *     executionTime: 3.2\n *   }\n * };\n *\n * const result = await updateSkillExperience(\n *   'pdf-analyzer',\n *   87.5,  // Rounded to 88\n *   trainingRecord,\n *   process.cwd()\n * );\n *\n * if (result.success) {\n *   console.log('Skill experience updated successfully');\n * } else {\n *   console.error('Error:', result.error);\n * }\n *\n * @example\n * // Update experience score after failed training (lower score)\n * const failedRecord: TrainingRecord = {\n *   timestamp: new Date().toISOString(),\n *   agent: 'training-agent-2',\n *   task: 'Parse complex PDF with tables',\n *   outcome: 'failure',\n *   feedback: 'Failed to extract table data correctly',\n *   metrics: {\n *     accuracy: 0.45,\n *     errors: 12\n *   }\n * };\n *\n * // Lower the score due to failure\n * const currentScore = 88;\n * const penaltyFactor = 0.9;\n * const newScore = currentScore * penaltyFactor;  // 79.2 \u2192 rounds to 79\n *\n * const result = await updateSkillExperience(\n *   'pdf-analyzer',\n *   newScore,\n *   failedRecord,\n *   process.cwd()\n * );\n *\n * @example\n * // Iterative training with experience updates\n * async function trainSkill(skillId: string, trainingTasks: any[]) {\n *   let currentScore = 50;  // Initial score\n *\n *   for (const task of trainingTasks) {\n *     // Execute training task\n *     const outcome = await executeTrainingTask(skillId, task);\n *\n *     // Calculate new score based on outcome\n *     if (outcome.success) {\n *       currentScore = Math.min(100, currentScore + outcome.improvement);\n *     } else {\n *       currentScore = Math.max(0, currentScore - 10);\n *     }\n *\n *     // Record training\n *     const record: TrainingRecord = {\n *       timestamp: new Date().toISOString(),\n *       agent: 'training-bot',\n *       task: task.description,\n *       outcome: outcome.success ? 'success' : 'failure',\n *       feedback: outcome.feedback,\n *       metrics: outcome.metrics\n *     };\n *\n *     // Update skill experience\n *     await updateSkillExperience(skillId, currentScore, record, process.cwd());\n *\n *     console.log(`Training iteration ${task.id}: Score ${currentScore}`);\n *   }\n *\n *   console.log(`Training completed. Final score: ${currentScore}`);\n * }\n *\n * @example\n * // Handling non-existent skill error\n * const result = await updateSkillExperience(\n *   'nonexistent-skill',\n *   75,\n *   { timestamp: new Date().toISOString(), agent: 'bot', task: 'test', outcome: 'success', feedback: 'ok' },\n *   process.cwd()\n * );\n *\n * if (!result.success) {\n *   console.error('Error:', result.error);\n *   // Output: Error: Skill \"nonexistent-skill\" does not exist\n * }\n *\n * @example\n * // Score rounding behavior\n * await updateSkillExperience('skill1', 87.4, record, projectRoot);  // Stored as 87\n * await updateSkillExperience('skill1', 87.5, record, projectRoot);  // Stored as 88\n * await updateSkillExperience('skill1', 87.6, record, projectRoot);  // Stored as 88\n * await updateSkillExperience('skill1', 88.0, record, projectRoot);  // Stored as 88\n *\n * @example\n * // Training history cap at 10 records\n * const skillId = 'web-scraper';\n *\n * // Skill currently has 9 training records\n * const history = await getSkillTrainingHistory(skillId, process.cwd());\n * console.log('Current history length:', history.history?.length);  // 9\n *\n * // Add 3 more records\n * for (let i = 0; i < 3; i++) {\n *   const record: TrainingRecord = {\n *     timestamp: new Date().toISOString(),\n *     agent: `agent-${i}`,\n *     task: `Task ${i}`,\n *     outcome: 'success',\n *     feedback: `Training ${i} completed`\n *   };\n *\n *   await updateSkillExperience(skillId, 85 + i, record, process.cwd());\n * }\n *\n * // History is capped at 10 (oldest 2 records were dropped)\n * const updatedHistory = await getSkillTrainingHistory(skillId, process.cwd());\n * console.log('Updated history length:', updatedHistory.history?.length);  // 10\n * console.log('Most recent task:', updatedHistory.history?.[0].task);  // 'Task 2'\n * console.log('Oldest task:', updatedHistory.history?.[9].task);  // (9th oldest record)\n *\n * @example\n * // Complete training workflow with experience tracking\n * async function runTrainingSession(skillId: string, projectRoot: string) {\n *   // Get current skill state\n *   const parser = new ClaudeStructureParser();\n *   const skills = await parser.parseSkills(projectRoot);\n *   const skill = skills.find(s => s.id === skillId);\n *\n *   const currentScore = skill?.experienceScore || 0;\n *   console.log('Starting training. Current score:', currentScore);\n *\n *   // Execute training\n *   const testCases = [\n *     { input: 'test1.pdf', expected: { fields: 5 } },\n *     { input: 'test2.pdf', expected: { fields: 8 } },\n *     { input: 'test3.pdf', expected: { fields: 3 } }\n *   ];\n *\n *   let successCount = 0;\n *\n *   for (const testCase of testCases) {\n *     const result = await testSkill(skillId, testCase);\n *     const success = result.fields === testCase.expected.fields;\n *\n *     if (success) successCount++;\n *\n *     const record: TrainingRecord = {\n *       timestamp: new Date().toISOString(),\n *       agent: 'test-runner',\n *       task: `Test ${testCase.input}`,\n *       outcome: success ? 'success' : 'failure',\n *       feedback: success ? 'All fields extracted' : `Expected ${testCase.expected.fields}, got ${result.fields}`,\n *       metrics: {\n *         accuracy: result.fields / testCase.expected.fields,\n *         fieldsExtracted: result.fields\n *       }\n *     };\n *\n *     // Calculate new score (weighted average)\n *     const accuracyRate = successCount / testCases.length;\n *     const newScore = currentScore * 0.7 + accuracyRate * 100 * 0.3;\n *\n *     await updateSkillExperience(skillId, newScore, record, projectRoot);\n *   }\n *\n *   console.log(`Training completed. Success rate: ${successCount}/${testCases.length}`);\n * }\n *\n * @example\n * // Error handling for malformed SKILL.md\n * const result = await updateSkillExperience(\n *   'broken-skill',  // Assume this has malformed frontmatter\n *   80,\n *   trainingRecord,\n *   process.cwd()\n * );\n *\n * if (!result.success) {\n *   console.error('Error:', result.error);\n *   // Possible errors:\n *   // - \"Invalid SKILL.md format: missing frontmatter\"\n *   // - \"Skill 'broken-skill' does not exist\"\n *   // - YAML parsing errors\n * }\n */\nexport async function updateSkillExperience(\n  skillId: string,\n  newScore: number,\n  trainingRecord: TrainingRecord,\n  projectRoot: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    const skillMdPath = path.join(projectRoot, '.claude', 'skills', skillId, 'SKILL.md');\n\n    if (!existsSync(skillMdPath)) {\n      return { success: false, error: `Skill \"${skillId}\" does not exist` };\n    }\n\n    // Read current SKILL.md\n    const content = await fs.readFile(skillMdPath, 'utf-8');\n\n    // Split frontmatter and body\n    const lines = content.split('\\n');\n    let frontmatterEndIndex = -1;\n    let frontmatterStartIndex = -1;\n\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].trim() === '---') {\n        if (frontmatterStartIndex === -1) {\n          frontmatterStartIndex = i;\n        } else {\n          frontmatterEndIndex = i;\n          break;\n        }\n      }\n    }\n\n    if (frontmatterStartIndex === -1 || frontmatterEndIndex === -1) {\n      return { success: false, error: 'Invalid SKILL.md format: missing frontmatter' };\n    }\n\n    // Parse frontmatter\n    const frontmatterText = lines.slice(frontmatterStartIndex + 1, frontmatterEndIndex).join('\\n');\n    const frontmatterData = yaml.load(frontmatterText) as any;\n\n    // Update experience score\n    frontmatterData.experience_score = Math.round(newScore);\n\n    // Update training history (keep last 10 records)\n    if (!frontmatterData.training_history) {\n      frontmatterData.training_history = [];\n    }\n    frontmatterData.training_history.unshift(trainingRecord);\n    if (frontmatterData.training_history.length > 10) {\n      frontmatterData.training_history = frontmatterData.training_history.slice(0, 10);\n    }\n\n    // Rebuild frontmatter\n    const newFrontmatter = yaml.dump(frontmatterData, { indent: 2 });\n\n    // Reconstruct file content\n    const body = lines.slice(frontmatterEndIndex + 1).join('\\n');\n    const newContent = `---\\n${newFrontmatter}---${body}`;\n\n    // Write updated file\n    await fs.writeFile(skillMdPath, newContent, 'utf-8');\n\n    return { success: true };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Retrieves the complete training history for a skill\n *\n * @description\n * Fetches the `training_history` field from a skill's SKILL.md YAML frontmatter, which contains\n * a chronological record of all training sessions, outcomes, and metrics. The history is limited\n * to the last 10 training records (most recent first) and is used for skill analytics, debugging,\n * and performance tracking.\n *\n * **Retrieval Workflow:**\n * 1. Parse all skills from `.claude/skills/` directory using ClaudeStructureParser\n * 2. Find skill matching the provided skillId\n * 3. Extract `trainingHistory` field from parsed skill object\n * 4. Return training records array (or empty array if no history exists)\n *\n * **Training History Structure:**\n * - Array of TrainingRecord objects in reverse chronological order (newest first)\n * - Each record contains:\n *   - `timestamp`: ISO 8601 datetime string when training occurred\n *   - `agent`: ID of the agent that performed the training\n *   - `task`: Description of the training task/scenario\n *   - `outcome`: Training result ('success' | 'failure' | 'partial')\n *   - `feedback`: Human-readable feedback about the training session\n *   - `metrics`: Optional object with performance metrics (accuracy, execution time, etc.)\n * - Maximum 10 records (older records are dropped by updateSkillExperience)\n * - Empty array if skill has never been trained\n *\n * **Use Cases:**\n * - Display training history timeline in skill details UI\n * - Analyze skill performance trends over time\n * - Debug skill failures by reviewing error patterns\n * - Generate training reports and analytics dashboards\n * - Identify improvement opportunities based on feedback\n * - Track which agents have trained the skill\n * - Calculate success rates and average metrics\n *\n * **Important Notes:**\n * - Returns empty array (not error) if skill has no training history\n * - Only retrieves from filesystem (`.claude/skills/`), not Strapi database\n * - History is capped at 10 records maximum\n * - Returns error if skill doesn't exist\n * - Uses ClaudeStructureParser (slower than direct file read for single skill)\n *\n * @param skillId - Skill identifier (directory name in .claude/skills/)\n * @param projectRoot - Absolute path to project root directory (where .claude/ is located)\n * @returns Promise resolving to result with success flag, training history array, and optional error message\n *\n * @example\n * // Get training history for a skill\n * const result = await getSkillTrainingHistory('pdf-analyzer', process.cwd());\n *\n * if (result.success && result.history) {\n *   console.log(`Found ${result.history.length} training record(s)`);\n *\n *   result.history.forEach((record, index) => {\n *     console.log(`\\n${index + 1}. ${record.task} (${record.outcome})`);\n *     console.log(`   Agent: ${record.agent}`);\n *     console.log(`   Time: ${new Date(record.timestamp).toLocaleString()}`);\n *     console.log(`   Feedback: ${record.feedback}`);\n *     if (record.metrics) {\n *       console.log(`   Metrics:`, record.metrics);\n *     }\n *   });\n * } else {\n *   console.error('Error:', result.error);\n * }\n *\n * // Example output:\n * // Found 3 training record(s)\n * //\n * // 1. Extract invoice data (success)\n * //    Agent: training-agent-1\n * //    Time: 1/2/2026, 3:45:00 PM\n * //    Feedback: Successfully extracted all fields\n * //    Metrics: { accuracy: 0.95, executionTime: 3.2 }\n * //\n * // 2. Parse complex PDF (failure)\n * //    Agent: training-agent-2\n * //    Time: 1/2/2026, 2:30:00 PM\n * //    Feedback: Failed to extract table data\n * //    Metrics: { accuracy: 0.45, errors: 12 }\n *\n * @example\n * // Display training history timeline in UI\n * async function renderTrainingTimeline(skillId: string) {\n *   const result = await getSkillTrainingHistory(skillId, process.cwd());\n *\n *   if (!result.success || !result.history || result.history.length === 0) {\n *     return '<p>No training history available</p>';\n *   }\n *\n *   const timeline = result.history.map(record => {\n *     const statusIcon = record.outcome === 'success' ? '\u2705' : '\u274c';\n *     const date = new Date(record.timestamp).toLocaleDateString();\n *\n *     return `\n *       <div class=\"timeline-item ${record.outcome}\">\n *         <span class=\"icon\">${statusIcon}</span>\n *         <div class=\"content\">\n *           <strong>${record.task}</strong>\n *           <p>${record.feedback}</p>\n *           <small>${date} by ${record.agent}</small>\n *         </div>\n *       </div>\n *     `;\n *   }).join('');\n *\n *   return `<div class=\"training-timeline\">${timeline}</div>`;\n * }\n *\n * @example\n * // Calculate skill success rate from training history\n * const result = await getSkillTrainingHistory('web-scraper', process.cwd());\n *\n * if (result.success && result.history && result.history.length > 0) {\n *   const successCount = result.history.filter(r => r.outcome === 'success').length;\n *   const failureCount = result.history.filter(r => r.outcome === 'failure').length;\n *   const partialCount = result.history.filter(r => r.outcome === 'partial').length;\n *\n *   const successRate = (successCount / result.history.length) * 100;\n *\n *   console.log('=== Training Statistics ===');\n *   console.log('Total sessions:', result.history.length);\n *   console.log('Successes:', successCount);\n *   console.log('Failures:', failureCount);\n *   console.log('Partial:', partialCount);\n *   console.log('Success rate:', successRate.toFixed(1) + '%');\n * } else {\n *   console.log('No training data available');\n * }\n *\n * // Output:\n * // === Training Statistics ===\n * // Total sessions: 10\n * // Successes: 7\n * // Failures: 2\n * // Partial: 1\n * // Success rate: 70.0%\n *\n * @example\n * // Analyze performance trends over time\n * const result = await getSkillTrainingHistory('code-reviewer', process.cwd());\n *\n * if (result.success && result.history && result.history.length > 0) {\n *   console.log('=== Performance Trend Analysis ===');\n *\n *   // Group by outcome\n *   const recentRecords = result.history.slice(0, 5);  // Last 5\n *   const olderRecords = result.history.slice(5);     // Earlier records\n *\n *   const recentSuccessRate = recentRecords.filter(r => r.outcome === 'success').length / recentRecords.length;\n *   const olderSuccessRate = olderRecords.length > 0\n *     ? olderRecords.filter(r => r.outcome === 'success').length / olderRecords.length\n *     : 0;\n *\n *   const trend = recentSuccessRate > olderSuccessRate ? '\ud83d\udcc8 Improving' :\n *                 recentSuccessRate < olderSuccessRate ? '\ud83d\udcc9 Declining' :\n *                 '\u27a1\ufe0f  Stable';\n *\n *   console.log('Recent success rate:', (recentSuccessRate * 100).toFixed(1) + '%');\n *   console.log('Earlier success rate:', (olderSuccessRate * 100).toFixed(1) + '%');\n *   console.log('Trend:', trend);\n * }\n *\n * @example\n * // Generate training report with metrics\n * async function generateTrainingReport(skillId: string, projectRoot: string) {\n *   const result = await getSkillTrainingHistory(skillId, projectRoot);\n *\n *   if (!result.success || !result.history || result.history.length === 0) {\n *     console.log('No training data available for report');\n *     return;\n *   }\n *\n *   console.log(`=== Training Report: ${skillId} ===`);\n *   console.log(`Total training sessions: ${result.history.length}`);\n *   console.log('\\nRecent Training Sessions:');\n *\n *   result.history.forEach((record, index) => {\n *     console.log(`\\n${index + 1}. ${record.task}`);\n *     console.log(`   Outcome: ${record.outcome.toUpperCase()}`);\n *     console.log(`   Agent: ${record.agent}`);\n *     console.log(`   Timestamp: ${record.timestamp}`);\n *     console.log(`   Feedback: ${record.feedback}`);\n *\n *     if (record.metrics) {\n *       console.log('   Metrics:');\n *       Object.entries(record.metrics).forEach(([key, value]) => {\n *         console.log(`     - ${key}: ${value}`);\n *       });\n *     }\n *   });\n *\n *   // Calculate average metrics\n *   const recordsWithMetrics = result.history.filter(r => r.metrics);\n *   if (recordsWithMetrics.length > 0) {\n *     console.log('\\n=== Average Metrics ===');\n *\n *     const allMetricKeys = new Set<string>();\n *     recordsWithMetrics.forEach(r => {\n *       Object.keys(r.metrics!).forEach(k => allMetricKeys.add(k));\n *     });\n *\n *     allMetricKeys.forEach(metricKey => {\n *       const values = recordsWithMetrics\n *         .map(r => r.metrics![metricKey])\n *         .filter(v => typeof v === 'number');\n *\n *       if (values.length > 0) {\n *         const avg = values.reduce((sum, v) => sum + v, 0) / values.length;\n *         console.log(`${metricKey}: ${avg.toFixed(2)}`);\n *       }\n *     });\n *   }\n * }\n *\n * @example\n * // Handle non-existent skill\n * const result = await getSkillTrainingHistory('nonexistent-skill', process.cwd());\n *\n * if (!result.success) {\n *   console.error('Error:', result.error);\n *   // Output: Error: Skill \"nonexistent-skill\" not found\n * }\n *\n * @example\n * // Handle skill with no training history\n * const result = await getSkillTrainingHistory('new-skill', process.cwd());\n *\n * if (result.success) {\n *   if (!result.history || result.history.length === 0) {\n *     console.log('Skill has not been trained yet');\n *   } else {\n *     console.log(`Found ${result.history.length} training record(s)`);\n *   }\n * }\n *\n * @example\n * // Export training history to JSON\n * async function exportTrainingHistory(skillId: string, projectRoot: string) {\n *   const result = await getSkillTrainingHistory(skillId, projectRoot);\n *\n *   if (!result.success) {\n *     console.error('Failed to retrieve training history:', result.error);\n *     return;\n *   }\n *\n *   const exportData = {\n *     skillId,\n *     exportedAt: new Date().toISOString(),\n *     recordCount: result.history?.length || 0,\n *     trainingHistory: result.history || []\n *   };\n *\n *   await fs.writeFile(\n *     `${skillId}-training-history.json`,\n *     JSON.stringify(exportData, null, 2),\n *     'utf-8'\n *   );\n *\n *   console.log(`Training history exported to ${skillId}-training-history.json`);\n * }\n *\n * @example\n * // Identify common failure patterns\n * const result = await getSkillTrainingHistory('pdf-analyzer', process.cwd());\n *\n * if (result.success && result.history) {\n *   const failures = result.history.filter(r => r.outcome === 'failure');\n *\n *   if (failures.length > 0) {\n *     console.log('=== Failure Pattern Analysis ===');\n *     console.log(`Found ${failures.length} failure(s):\\n`);\n *\n *     const failureReasons = new Map<string, number>();\n *\n *     failures.forEach(failure => {\n *       // Group by feedback message\n *       const reason = failure.feedback;\n *       failureReasons.set(reason, (failureReasons.get(reason) || 0) + 1);\n *     });\n *\n *     console.log('Most common failure reasons:');\n *     Array.from(failureReasons.entries())\n *       .sort((a, b) => b[1] - a[1])\n *       .forEach(([reason, count]) => {\n *         console.log(`  ${count}x: ${reason}`);\n *       });\n *   } else {\n *     console.log('No failures found in training history');\n *   }\n * }\n *\n * @example\n * // Track which agents have trained the skill\n * const result = await getSkillTrainingHistory('web-scraper', process.cwd());\n *\n * if (result.success && result.history) {\n *   const agentUsage = new Map<string, number>();\n *\n *   result.history.forEach(record => {\n *     agentUsage.set(record.agent, (agentUsage.get(record.agent) || 0) + 1);\n *   });\n *\n *   console.log('=== Training Agents ===');\n *   Array.from(agentUsage.entries())\n *     .sort((a, b) => b[1] - a[1])\n *     .forEach(([agent, count]) => {\n *       console.log(`${agent}: ${count} session(s)`);\n *     });\n * }\n * // Output:\n * // === Training Agents ===\n * // training-agent-1: 5 session(s)\n * // training-agent-2: 3 session(s)\n * // manual-trainer: 2 session(s)\n */\nexport async function getSkillTrainingHistory(\n  skillId: string,\n  projectRoot: string\n): Promise<{ success: boolean; history?: TrainingRecord[]; error?: string }> {\n  try {\n    const parser = new ClaudeStructureParser();\n    const skills = await parser.parseSkills(projectRoot);\n    const skill = skills.find((s) => s.id === skillId);\n\n    if (!skill) {\n      return { success: false, error: `Skill \"${skillId}\" not found` };\n    }\n\n    return {\n      success: true,\n      history: skill.trainingHistory || [],\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n",
        "last_modified": "2026-01-02T15:10:07.675501"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.651148",
  "last_updated": "2026-01-02T14:06:15.662679"
}