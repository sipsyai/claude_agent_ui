{
  "file_path": "src/web/manager/hooks/useSkillTraining.ts",
  "main_branch_history": [],
  "task_views": {
    "004-document-frontend-react-components-and-hooks": {
      "task_id": "004-document-frontend-react-components-and-hooks",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "/**\n * Hook for managing skill training with Training Agent\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\nconst API_BASE = '/api/manager';\n\ninterface Message {\n  id: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  timestamp: Date;\n  type?: 'info' | 'success' | 'warning' | 'error';\n}\n\ninterface TrainingStatus {\n  status: 'idle' | 'starting' | 'analyzing' | 'training' | 'evaluating' | 'updating' | 'completed' | 'error';\n  currentScore: number;\n  newScore?: number;\n  issuesFound?: string[];\n}\n\ninterface UseSkillTrainingOptions {\n  skillId: string;\n  directory?: string;\n  onTrainingComplete?: (oldScore: number, newScore: number) => void;\n  onError?: (error: Error) => void;\n}\n\ninterface UseSkillTrainingReturn {\n  messages: Message[];\n  trainingStatus: TrainingStatus;\n  isProcessing: boolean;\n  error: Error | null;\n  startTraining: () => Promise<void>;\n  sendMessage: (content: string) => Promise<void>;\n  reset: () => void;\n}\n\n/**\n * Get auth token from cookie\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Create fetch options with auth header\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\nexport function useSkillTraining(options: UseSkillTrainingOptions): UseSkillTrainingReturn {\n  const { skillId, directory, onTrainingComplete, onError } = options;\n\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [trainingStatus, setTrainingStatus] = useState<TrainingStatus>({\n    status: 'idle',\n    currentScore: 0,\n  });\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Track the current stream\n  const streamReaderRef = useRef<ReadableStreamDefaultReader<Uint8Array> | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Track conversation history\n  const messagesRef = useRef<Message[]>([]);\n\n  // Keep ref in sync with state\n  useEffect(() => {\n    messagesRef.current = messages;\n  }, [messages]);\n\n  /**\n   * Handle stream events from training endpoint\n   */\n  const handleStreamEvent = useCallback((data: any) => {\n    console.log('[SkillTraining] Stream event:', data);\n\n    if (data.type === 'status') {\n      // Update training status\n      setTrainingStatus((prev) => ({\n        ...prev,\n        status: data.status,\n        currentScore: data.currentScore !== undefined ? data.currentScore : prev.currentScore,\n      }));\n\n      // Add status message\n      const statusMessage: Message = {\n        id: `msg-${Date.now()}-status`,\n        role: 'system',\n        content: data.message || `Status: ${data.status}`,\n        timestamp: new Date(),\n        type: 'info',\n      };\n      setMessages((prev) => [...prev, statusMessage]);\n\n      // Check if completed\n      if (data.status === 'completed') {\n        setIsProcessing(false);\n        if (onTrainingComplete && data.newScore !== undefined) {\n          onTrainingComplete(data.currentScore || 0, data.newScore);\n        }\n      }\n    } else if (data.type === 'message' && data.messageType === 'assistant') {\n      // Assistant message from SDK\n      const content = data.content?.message?.content;\n\n      if (content && Array.isArray(content)) {\n        const textBlocks = content.filter((block: any) => block.type === 'text');\n        if (textBlocks.length > 0) {\n          const textContent = textBlocks.map((block: any) => block.text).join('\\n');\n\n          const assistantMessage: Message = {\n            id: `msg-${Date.now()}-assistant`,\n            role: 'assistant',\n            content: textContent,\n            timestamp: new Date(),\n          };\n          setMessages((prev) => [...prev, assistantMessage]);\n\n          // Parse content for training progress indicators\n          if (textContent.includes('Analyzing') || textContent.includes('Analysis')) {\n            setTrainingStatus((prev) => ({ ...prev, status: 'analyzing' }));\n          } else if (textContent.includes('Executing') || textContent.includes('Training')) {\n            setTrainingStatus((prev) => ({ ...prev, status: 'training' }));\n          } else if (textContent.includes('Evaluating') || textContent.includes('Evaluation')) {\n            setTrainingStatus((prev) => ({ ...prev, status: 'evaluating' }));\n          } else if (textContent.includes('Updating') || textContent.includes('Update')) {\n            setTrainingStatus((prev) => ({ ...prev, status: 'updating' }));\n          }\n\n          // Extract score updates from content\n          const scoreMatch = textContent.match(/Experience:\\s*(\\d+)%\\s*\u2192\\s*(\\d+)%/);\n          if (scoreMatch) {\n            const oldScore = parseInt(scoreMatch[1], 10);\n            const newScore = parseInt(scoreMatch[2], 10);\n            setTrainingStatus((prev) => ({\n              ...prev,\n              currentScore: oldScore,\n              newScore: newScore,\n            }));\n          }\n        }\n      }\n    } else if (data.type === 'message' && data.messageType === 'result') {\n      // Final result message\n      console.log('[SkillTraining] Query completed');\n      setIsProcessing(false);\n    } else if (data.type === 'complete') {\n      setIsProcessing(false);\n    } else if (data.type === 'error') {\n      // Error message\n      const err = new Error(data.message || 'Training failed');\n      setError(err);\n      setTrainingStatus((prev) => ({ ...prev, status: 'error' }));\n      setIsProcessing(false);\n\n      const errorMessage: Message = {\n        id: `msg-${Date.now()}-error`,\n        role: 'system',\n        content: data.message || 'Training failed',\n        timestamp: new Date(),\n        type: 'error',\n      };\n      setMessages((prev) => [...prev, errorMessage]);\n\n      if (onError) {\n        onError(err);\n      }\n    }\n  }, [onTrainingComplete, onError]);\n\n  /**\n   * Send a message in the training conversation\n   */\n  const sendMessageInternal = useCallback(async (content: string, currentMessages: Message[]) => {\n    try {\n      setIsProcessing(true);\n      setError(null);\n\n      // Add user message immediately\n      const userMessage: Message = {\n        id: `msg-${Date.now()}-user`,\n        role: 'user',\n        content,\n        timestamp: new Date(),\n      };\n\n      // Build conversation history (current messages + new user message)\n      const conversationHistory = [...currentMessages, userMessage].map(m => ({\n        role: m.role,\n        content: m.content\n      }));\n\n      setMessages((prev) => [...prev, userMessage]);\n\n      // NEW ENDPOINT: /train/message\n      const url = new URL(`${API_BASE}/skills/${skillId}/train/message`, window.location.origin);\n\n      const response = await fetch(url.toString(), createFetchOptions({\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          directory,\n          conversationHistory\n        }),\n      }));\n\n      if (!response.ok) {\n        throw new Error('Failed to send training message');\n      }\n\n      if (!response.body) {\n        throw new Error('No response body');\n      }\n\n      // Read SSE stream\n      const reader = response.body.getReader();\n      streamReaderRef.current = reader;\n      const decoder = new TextDecoder();\n\n      let buffer = '';\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) break;\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              try {\n                const data = JSON.parse(line.substring(6));\n                handleStreamEvent(data);\n              } catch (e) {\n                console.error('[SkillTraining] Failed to parse SSE data:', e);\n              }\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n        streamReaderRef.current = null;\n      }\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      setError(error);\n      setIsProcessing(false);\n      if (onError) {\n        onError(error);\n      }\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [skillId, directory, handleStreamEvent, onError]);\n\n  /**\n   * Public API: Send a message in the training conversation\n   */\n  const sendMessage = useCallback(async (content: string) => {\n    // Use messagesRef to get current messages without closure issues\n    const currentMessages = messagesRef.current;\n    await sendMessageInternal(content, currentMessages);\n  }, [sendMessageInternal]);\n\n  /**\n   * Start training session (sends initial message)\n   */\n  const startTraining = useCallback(async () => {\n    // Reset state\n    setMessages([]);\n    setTrainingStatus({\n      status: 'starting',\n      currentScore: 0,\n    });\n\n    // Send auto-start message\n    await sendMessageInternal('__START_TRAINING__', []);\n  }, [sendMessageInternal]);\n\n  /**\n   * Reset training state\n   */\n  const reset = useCallback(() => {\n    // Cancel ongoing stream\n    if (streamReaderRef.current) {\n      streamReaderRef.current.cancel();\n      streamReaderRef.current = null;\n    }\n\n    // Abort fetch request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n\n    setMessages([]);\n    setTrainingStatus({\n      status: 'idle',\n      currentScore: 0,\n    });\n    setIsProcessing(false);\n    setError(null);\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (streamReaderRef.current) {\n        streamReaderRef.current.cancel();\n      }\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  return {\n    messages,\n    trainingStatus,\n    isProcessing,\n    error,\n    startTraining,\n    sendMessage,\n    reset,\n  };\n}\n",
        "timestamp": "2026-01-02T14:22:14.293924"
      },
      "worktree_state": {
        "content": "/**\n * useSkillTraining Hook\n *\n * A custom React hook for managing interactive skill training with the Training Agent through\n * a conversational interface. This hook orchestrates the complete training workflow including\n * SSE streaming, message handling, status tracking, and score updates.\n *\n * ## Features\n * - **Conversational Training Workflow**: Interactive chat-based training for existing skills\n * - **SSE Streaming**: Real-time message streaming from Claude API using Server-Sent Events\n * - **State Management**: Comprehensive tracking of conversation, processing, training status, and error states\n * - **Status Transitions**: Automatic detection of training phases (analyzing, training, evaluating, updating)\n * - **Score Tracking**: Monitors skill experience score changes from old to new values\n * - **Progress Detection**: Parses assistant messages for training progress indicators\n * - **Authentication**: Automatic token-based authentication with cookie management\n * - **Error Handling**: Robust error handling with optional error callbacks\n * - **Session Management**: Complete conversation lifecycle with reset functionality\n * - **Ref-based Updates**: Uses refs to avoid closure issues with async streaming\n *\n * ## State Management\n * The hook manages the following state:\n *\n * ### Message State\n * - `messages`: Array of conversation messages (user, assistant, system)\n * - Each message includes id, role, content, timestamp, and optional type (info, success, warning, error)\n * - Messages are updated in real-time as SSE events arrive\n * - System messages indicate training status changes\n *\n * ### Processing State\n * - `isProcessing`: True when waiting for/receiving assistant response\n * - Indicates active network request and stream reading\n * - Automatically set to false when stream completes or errors\n *\n * ### Training Status State\n * - `trainingStatus`: Object tracking current training phase and scores\n * - `status`: Current phase in training workflow (idle, starting, analyzing, training, evaluating, updating, completed, error)\n * - `currentScore`: Skill's current experience score (0-100)\n * - `newScore`: Updated experience score after training completes\n * - `issuesFound`: Array of issues detected during analysis (optional)\n *\n * ### Error State\n * - `error`: Error object if any operation fails\n * - Triggers onError callback when set\n * - Can be cleared with reset()\n *\n * ## Training Workflow\n * The training process follows these phases:\n *\n * 1. **idle**: Initial state before training starts\n * 2. **starting**: Training session initiated, sending initial request\n * 3. **analyzing**: Training Agent analyzing skill implementation and test results\n * 4. **training**: Agent executing training iterations and improvements\n * 5. **evaluating**: Agent evaluating skill performance and calculating new score\n * 6. **updating**: Agent updating skill files with improvements\n * 7. **completed**: Training finished, new score available\n * 8. **error**: Training failed with error message\n *\n * ## State Transitions\n * Status transitions are detected through multiple mechanisms:\n *\n * ### Explicit Status Events\n * - Backend sends `type: 'status'` events with status field\n * - Hook updates trainingStatus.status when received\n * - System messages added to conversation for each status change\n *\n * ### Content Parsing\n * - Assistant messages analyzed for keywords: \"Analyzing\", \"Training\", \"Evaluating\", \"Updating\"\n * - Status automatically updated based on detected keywords\n * - Provides fallback when explicit status events aren't sent\n *\n * ### Score Extraction\n * - Pattern matching on assistant messages: `Experience: {old}% \u2192 {new}%`\n * - Extracts old and new scores from content\n * - Updates trainingStatus.currentScore and newScore\n *\n * ## SSE Streaming Handling\n * The hook implements a robust SSE streaming mechanism:\n *\n * ### Stream Lifecycle\n * 1. **Initiate**: POST to `/api/manager/skills/{skillId}/train/message`\n * 2. **Read**: Obtain ReadableStream reader and decode chunks\n * 3. **Parse**: Split by newlines, extract `data: ` prefixed JSON\n * 4. **Handle**: Process each event type (message, status, complete, error)\n * 5. **Cleanup**: Release reader lock when stream completes or errors\n *\n * ### Event Types\n * - **message (assistant)**: Extract text blocks from content array, parse for training progress\n * - **message (result)**: Final query completion indicator\n * - **status**: Update training status and add system message\n * - **complete**: Mark processing as finished\n * - **error**: Set error state and invoke error callback\n *\n * ### Event Handling\n * - Status events include status string, currentScore, and optional message\n * - Assistant messages parsed for text content and training keywords\n * - Completion triggers onTrainingComplete callback with old and new scores\n *\n * ### Stream Cancellation\n * - Reader reference stored in `streamReaderRef` for cleanup\n * - Automatically cancelled on component unmount or reset()\n * - Prevents memory leaks and dangling streams\n *\n * ## Lifecycle\n * The typical usage flow:\n *\n * 1. **Initialize**: Call useSkillTraining() with skillId and options\n * 2. **Start**: Call startTraining() to begin with auto-start message\n * 3. **Monitor**: Watch trainingStatus for phase transitions\n * 4. **Stream**: Hook processes SSE events, updates messages and status\n * 5. **Converse** (optional): User can sendMessage() to interact with agent\n * 6. **Complete**: Hook detects completion, updates scores, invokes callback\n * 7. **Reset** (optional): Call reset() to clear state and start over\n *\n * ## Authentication\n * The hook automatically handles authentication:\n * - Reads `cui-auth-token` cookie from document.cookie\n * - Adds `Authorization: Bearer {token}` header to all requests\n * - Token extraction and header injection via helper functions\n *\n * @example\n * // Basic usage with training completion detection\n * function SkillTrainingPanel({ skillId }: { skillId: string }) {\n *   const {\n *     messages,\n *     trainingStatus,\n *     isProcessing,\n *     error,\n *     startTraining,\n *     sendMessage,\n *     reset\n *   } = useSkillTraining({\n *     skillId,\n *     directory: '/path/to/project',\n *     onTrainingComplete: (oldScore, newScore) => {\n *       console.log(`Training complete! ${oldScore}% \u2192 ${newScore}%`);\n *       toast.success(`Skill improved from ${oldScore}% to ${newScore}%`);\n *     },\n *     onError: (err) => {\n *       console.error('Training failed:', err);\n *       toast.error(err.message);\n *     }\n *   });\n *\n *   return (\n *     <div>\n *       {trainingStatus.status === 'idle' && (\n *         <button onClick={startTraining} disabled={isProcessing}>\n *           Start Training\n *         </button>\n *       )}\n *       <div className=\"status\">\n *         Status: {trainingStatus.status}\n *         {trainingStatus.currentScore > 0 && ` (${trainingStatus.currentScore}%)`}\n *       </div>\n *       {messages.map(msg => (\n *         <div key={msg.id} className={msg.type}>\n *           {msg.role}: {msg.content}\n *         </div>\n *       ))}\n *       {error && <p className=\"error\">{error.message}</p>}\n *     </div>\n *   );\n * }\n *\n * @example\n * // With custom directory and score tracking\n * const { trainingStatus, startTraining } = useSkillTraining({\n *   skillId: 'my-skill',\n *   directory: process.env.PROJECT_ROOT,\n *   onTrainingComplete: (oldScore, newScore) => {\n *     const improvement = newScore - oldScore;\n *     if (improvement > 0) {\n *       toast.success(`Improved by ${improvement} points!`);\n *     } else if (improvement < 0) {\n *       toast.warning(`Score decreased by ${Math.abs(improvement)} points`);\n *     } else {\n *       toast.info('No score change');\n *     }\n *     refreshSkillList();\n *   },\n *   onError: (error) => {\n *     logger.error('Training error:', error);\n *     toast.error(`Training failed: ${error.message}`);\n *   }\n * });\n *\n * @example\n * // Handling user interaction during training\n * function InteractiveTrainingPanel() {\n *   const [input, setInput] = useState('');\n *   const { messages, isProcessing, trainingStatus, sendMessage } = useSkillTraining({\n *     skillId: 'data-validator'\n *   });\n *\n *   const handleSubmit = async (e: React.FormEvent) => {\n *     e.preventDefault();\n *     if (!input.trim() || isProcessing) return;\n *\n *     await sendMessage(input);\n *     setInput('');\n *   };\n *\n *   return (\n *     <div>\n *       <h3>Training: {trainingStatus.status}</h3>\n *       {messages.map(msg => <MessageBubble key={msg.id} message={msg} />)}\n *       <form onSubmit={handleSubmit}>\n *         <input\n *           value={input}\n *           onChange={(e) => setInput(e.target.value)}\n *           disabled={isProcessing}\n *           placeholder=\"Send message to training agent...\"\n *         />\n *         <button type=\"submit\" disabled={isProcessing || !input.trim()}>\n *           Send\n *         </button>\n *       </form>\n *     </div>\n *   );\n * }\n *\n * @example\n * // Reset after training completes\n * function TrainingWorkflow() {\n *   const { trainingStatus, reset, startTraining } = useSkillTraining({\n *     skillId: 'my-skill',\n *     onTrainingComplete: (oldScore, newScore) => {\n *       setTimeout(() => {\n *         if (confirm(`Training complete! ${oldScore}% \u2192 ${newScore}%. Train again?`)) {\n *           reset();\n *           startTraining();\n *         }\n *       }, 2000);\n *     }\n *   });\n *\n *   // ... render UI\n * }\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\nconst API_BASE = '/api/manager';\n\n/**\n * Message object representing a single message in the training conversation\n */\ninterface Message {\n  /** Unique message identifier (format: `msg-{timestamp}-{role}`) */\n  id: string;\n  /** Message author role */\n  role: 'user' | 'assistant' | 'system';\n  /** Message text content */\n  content: string;\n  /** Message creation timestamp */\n  timestamp: Date;\n  /** Optional message type for system messages (info, success, warning, error) */\n  type?: 'info' | 'success' | 'warning' | 'error';\n}\n\n/**\n * Training status object tracking the current training phase and scores\n */\ninterface TrainingStatus {\n  /**\n   * Current training phase\n   * - `idle`: Not started\n   * - `starting`: Initiating training session\n   * - `analyzing`: Analyzing skill implementation and test results\n   * - `training`: Executing training iterations\n   * - `evaluating`: Evaluating performance and calculating score\n   * - `updating`: Updating skill files with improvements\n   * - `completed`: Training finished successfully\n   * - `error`: Training failed\n   */\n  status: 'idle' | 'starting' | 'analyzing' | 'training' | 'evaluating' | 'updating' | 'completed' | 'error';\n\n  /** Current skill experience score (0-100) */\n  currentScore: number;\n\n  /** New skill experience score after training (set when completed) */\n  newScore?: number;\n\n  /** Array of issues found during analysis (optional) */\n  issuesFound?: string[];\n}\n\n/**\n * Configuration options for useSkillTraining hook\n */\ninterface UseSkillTrainingOptions {\n  /**\n   * ID of the skill to train\n   * Used to construct API endpoint `/api/manager/skills/{skillId}/train/message`\n   *\n   * @example 'data-validator'\n   * @example 'pdf-processor'\n   */\n  skillId: string;\n\n  /**\n   * Project directory path where skill is located\n   * Passed to the API to determine where to find skill files\n   *\n   * @example '/path/to/my/project'\n   */\n  directory?: string;\n\n  /**\n   * Callback invoked when training completes successfully\n   *\n   * @param oldScore - Skill's experience score before training (0-100)\n   * @param newScore - Skill's experience score after training (0-100)\n   *\n   * @example\n   * onTrainingComplete: (oldScore, newScore) => {\n   *   console.log(`Training improved skill from ${oldScore}% to ${newScore}%`);\n   *   refreshSkillList();\n   * }\n   */\n  onTrainingComplete?: (oldScore: number, newScore: number) => void;\n\n  /**\n   * Callback invoked when any error occurs during training\n   *\n   * @param error - Error object with message and stack trace\n   *\n   * @example\n   * onError: (err) => {\n   *   toast.error(`Training failed: ${err.message}`);\n   * }\n   */\n  onError?: (error: Error) => void;\n}\n\n/**\n * Return value interface for useSkillTraining hook\n */\ninterface UseSkillTrainingReturn {\n  /**\n   * Array of conversation messages in chronological order\n   * Includes user messages (sent via sendMessage), assistant messages (from Training Agent),\n   * and system messages (status updates)\n   */\n  messages: Message[];\n\n  /**\n   * Current training status including phase and scores\n   * - `status`: Current training phase (idle, starting, analyzing, training, evaluating, updating, completed, error)\n   * - `currentScore`: Current skill experience score\n   * - `newScore`: New score after training (only set when completed)\n   * - `issuesFound`: Issues detected during analysis (optional)\n   */\n  trainingStatus: TrainingStatus;\n\n  /**\n   * True when waiting for assistant response or processing stream\n   * Use to disable input, show loading indicators, or prevent duplicate sends\n   */\n  isProcessing: boolean;\n\n  /**\n   * Error object if any operation failed, or null if no errors\n   * Set when network requests fail, stream parsing fails, or API returns error\n   * Triggers onError callback when set\n   */\n  error: Error | null;\n\n  /**\n   * Start a new training session\n   * Resets state and sends auto-start message \"__START_TRAINING__\" to begin workflow\n   *\n   * @returns Promise that resolves when initial message is sent and stream processed\n   *\n   * @example\n   * <button onClick={startTraining} disabled={isProcessing}>\n   *   Start Training\n   * </button>\n   */\n  startTraining: () => Promise<void>;\n\n  /**\n   * Send a user message in the ongoing training conversation\n   * Appends message to conversation history and streams Training Agent's response\n   *\n   * @param content - User message text content\n   * @returns Promise that resolves when message is sent and stream processed\n   *\n   * @example\n   * await sendMessage('Focus on improving error handling');\n   *\n   * @example\n   * // With form submission\n   * const handleSubmit = async (e) => {\n   *   e.preventDefault();\n   *   await sendMessage(userInput);\n   *   setUserInput('');\n   * };\n   */\n  sendMessage: (content: string) => Promise<void>;\n\n  /**\n   * Reset all training state and cancel any active streams\n   * Clears messages, errors, training status, and cancels ongoing SSE stream\n   * Use when starting over or when component unmounts\n   *\n   * @example\n   * // Reset after training completes\n   * if (trainingStatus.status === 'completed') {\n   *   setTimeout(() => reset(), 2000);\n   * }\n   *\n   * @example\n   * // Cleanup on unmount\n   * useEffect(() => {\n   *   return () => reset();\n   * }, [reset]);\n   */\n  reset: () => void;\n}\n\n/**\n * Get auth token from cookie\n *\n * Extracts the authentication token from the browser's cookies by looking for\n * the `cui-auth-token` cookie. This token is used for authenticating API requests.\n *\n * @returns The decoded auth token string, or null if not found\n *\n * @internal\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Create fetch options with auth header\n *\n * Enhances standard fetch options by automatically adding the Authorization header\n * with the bearer token from cookies. Merges with any existing headers provided.\n *\n * @param options - Standard fetch RequestInit options (method, headers, body, etc.)\n * @returns Enhanced RequestInit with Authorization header if token is available\n *\n * @internal\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\nexport function useSkillTraining(options: UseSkillTrainingOptions): UseSkillTrainingReturn {\n  const { skillId, directory, onTrainingComplete, onError } = options;\n\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [trainingStatus, setTrainingStatus] = useState<TrainingStatus>({\n    status: 'idle',\n    currentScore: 0,\n  });\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Track the current stream\n  const streamReaderRef = useRef<ReadableStreamDefaultReader<Uint8Array> | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Track conversation history\n  const messagesRef = useRef<Message[]>([]);\n\n  // Keep ref in sync with state\n  useEffect(() => {\n    messagesRef.current = messages;\n  }, [messages]);\n\n  /**\n   * Handle stream events from training endpoint\n   *\n   * Processes SSE events from the skill training stream. Handles multiple event types:\n   * - **status**: Updates training status, adds system message, checks for completion\n   * - **message (assistant)**: Extracts text blocks, parses for training keywords and score updates\n   * - **message (result)**: Marks query as completed\n   * - **complete**: Marks processing as finished\n   * - **error**: Sets error state and invokes error callback\n   *\n   * Special handling for status events:\n   * - Updates trainingStatus with status, currentScore from backend\n   * - Adds system message with status text\n   * - When status is 'completed', triggers onTrainingComplete callback with scores\n   *\n   * Special handling for assistant messages:\n   * - Parses content for keywords: \"Analyzing\", \"Training\", \"Evaluating\", \"Updating\"\n   * - Updates status based on detected keywords (fallback when explicit status not sent)\n   * - Extracts score updates with pattern `Experience: {old}% \u2192 {new}%`\n   * - Updates currentScore and newScore when pattern found\n   *\n   * @param data - Parsed SSE event data object\n   *\n   * @internal\n   */\n  const handleStreamEvent = useCallback((data: any) => {\n    console.log('[SkillTraining] Stream event:', data);\n\n    if (data.type === 'status') {\n      // Update training status\n      setTrainingStatus((prev) => ({\n        ...prev,\n        status: data.status,\n        currentScore: data.currentScore !== undefined ? data.currentScore : prev.currentScore,\n      }));\n\n      // Add status message\n      const statusMessage: Message = {\n        id: `msg-${Date.now()}-status`,\n        role: 'system',\n        content: data.message || `Status: ${data.status}`,\n        timestamp: new Date(),\n        type: 'info',\n      };\n      setMessages((prev) => [...prev, statusMessage]);\n\n      // Check if completed\n      if (data.status === 'completed') {\n        setIsProcessing(false);\n        if (onTrainingComplete && data.newScore !== undefined) {\n          onTrainingComplete(data.currentScore || 0, data.newScore);\n        }\n      }\n    } else if (data.type === 'message' && data.messageType === 'assistant') {\n      // Assistant message from SDK\n      const content = data.content?.message?.content;\n\n      if (content && Array.isArray(content)) {\n        const textBlocks = content.filter((block: any) => block.type === 'text');\n        if (textBlocks.length > 0) {\n          const textContent = textBlocks.map((block: any) => block.text).join('\\n');\n\n          const assistantMessage: Message = {\n            id: `msg-${Date.now()}-assistant`,\n            role: 'assistant',\n            content: textContent,\n            timestamp: new Date(),\n          };\n          setMessages((prev) => [...prev, assistantMessage]);\n\n          // Parse content for training progress indicators\n          if (textContent.includes('Analyzing') || textContent.includes('Analysis')) {\n            setTrainingStatus((prev) => ({ ...prev, status: 'analyzing' }));\n          } else if (textContent.includes('Executing') || textContent.includes('Training')) {\n            setTrainingStatus((prev) => ({ ...prev, status: 'training' }));\n          } else if (textContent.includes('Evaluating') || textContent.includes('Evaluation')) {\n            setTrainingStatus((prev) => ({ ...prev, status: 'evaluating' }));\n          } else if (textContent.includes('Updating') || textContent.includes('Update')) {\n            setTrainingStatus((prev) => ({ ...prev, status: 'updating' }));\n          }\n\n          // Extract score updates from content\n          const scoreMatch = textContent.match(/Experience:\\s*(\\d+)%\\s*\u2192\\s*(\\d+)%/);\n          if (scoreMatch) {\n            const oldScore = parseInt(scoreMatch[1], 10);\n            const newScore = parseInt(scoreMatch[2], 10);\n            setTrainingStatus((prev) => ({\n              ...prev,\n              currentScore: oldScore,\n              newScore: newScore,\n            }));\n          }\n        }\n      }\n    } else if (data.type === 'message' && data.messageType === 'result') {\n      // Final result message\n      console.log('[SkillTraining] Query completed');\n      setIsProcessing(false);\n    } else if (data.type === 'complete') {\n      setIsProcessing(false);\n    } else if (data.type === 'error') {\n      // Error message\n      const err = new Error(data.message || 'Training failed');\n      setError(err);\n      setTrainingStatus((prev) => ({ ...prev, status: 'error' }));\n      setIsProcessing(false);\n\n      const errorMessage: Message = {\n        id: `msg-${Date.now()}-error`,\n        role: 'system',\n        content: data.message || 'Training failed',\n        timestamp: new Date(),\n        type: 'error',\n      };\n      setMessages((prev) => [...prev, errorMessage]);\n\n      if (onError) {\n        onError(err);\n      }\n    }\n  }, [onTrainingComplete, onError]);\n\n  /**\n   * Send a message in the training conversation\n   *\n   * Internal implementation that handles the full message send workflow including\n   * adding user message to state, building conversation history, sending POST request,\n   * and processing the SSE response stream.\n   *\n   * Workflow:\n   * 1. Sets isProcessing to true and clears any previous errors\n   * 2. Creates user message object and adds to messages state\n   * 3. Builds conversation history from current + new message\n   * 4. POSTs to `/api/manager/skills/{skillId}/train/message` with history\n   * 5. Reads SSE stream and processes events via handleStreamEvent\n   * 6. Cleans up reader when stream completes\n   * 7. Sets isProcessing to false\n   *\n   * @param content - User message text content\n   * @param currentMessages - Current message array (passed to avoid closure issues)\n   * @returns Promise that resolves when stream completes\n   *\n   * @internal\n   */\n  const sendMessageInternal = useCallback(async (content: string, currentMessages: Message[]) => {\n    try {\n      setIsProcessing(true);\n      setError(null);\n\n      // Add user message immediately\n      const userMessage: Message = {\n        id: `msg-${Date.now()}-user`,\n        role: 'user',\n        content,\n        timestamp: new Date(),\n      };\n\n      // Build conversation history (current messages + new user message)\n      const conversationHistory = [...currentMessages, userMessage].map(m => ({\n        role: m.role,\n        content: m.content\n      }));\n\n      setMessages((prev) => [...prev, userMessage]);\n\n      // NEW ENDPOINT: /train/message\n      const url = new URL(`${API_BASE}/skills/${skillId}/train/message`, window.location.origin);\n\n      const response = await fetch(url.toString(), createFetchOptions({\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          directory,\n          conversationHistory\n        }),\n      }));\n\n      if (!response.ok) {\n        throw new Error('Failed to send training message');\n      }\n\n      if (!response.body) {\n        throw new Error('No response body');\n      }\n\n      // Read SSE stream\n      const reader = response.body.getReader();\n      streamReaderRef.current = reader;\n      const decoder = new TextDecoder();\n\n      let buffer = '';\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) break;\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              try {\n                const data = JSON.parse(line.substring(6));\n                handleStreamEvent(data);\n              } catch (e) {\n                console.error('[SkillTraining] Failed to parse SSE data:', e);\n              }\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n        streamReaderRef.current = null;\n      }\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      setError(error);\n      setIsProcessing(false);\n      if (onError) {\n        onError(error);\n      }\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [skillId, directory, handleStreamEvent, onError]);\n\n  /**\n   * Public API: Send a message in the training conversation\n   *\n   * Uses messagesRef to get current messages without closure issues, then\n   * delegates to sendMessageInternal for the actual send operation.\n   *\n   * @param content - User message text content\n   * @returns Promise that resolves when message is sent and stream processed\n   */\n  const sendMessage = useCallback(async (content: string) => {\n    // Use messagesRef to get current messages without closure issues\n    const currentMessages = messagesRef.current;\n    await sendMessageInternal(content, currentMessages);\n  }, [sendMessageInternal]);\n\n  /**\n   * Start training session (sends initial message)\n   *\n   * Initiates the skill training workflow by:\n   * 1. Clearing any previous messages\n   * 2. Setting trainingStatus to 'starting' with currentScore 0\n   * 3. Sending the auto-start message \"__START_TRAINING__\" to begin the workflow\n   *\n   * The Training Agent recognizes this special message and begins the training process\n   * without requiring user input. The agent will analyze the skill, run tests, identify\n   * improvements, and update skill files automatically.\n   *\n   * @returns Promise that resolves when initial message is sent and stream processed\n   */\n  const startTraining = useCallback(async () => {\n    // Reset state\n    setMessages([]);\n    setTrainingStatus({\n      status: 'starting',\n      currentScore: 0,\n    });\n\n    // Send auto-start message\n    await sendMessageInternal('__START_TRAINING__', []);\n  }, [sendMessageInternal]);\n\n  /**\n   * Reset training state\n   *\n   * Cancels any ongoing SSE stream, clears all conversation state including messages,\n   * processing flags, training status, and errors. Also aborts any pending fetch requests.\n   * Safe to call at any time, even if no training session is active.\n   *\n   * @returns void\n   */\n  const reset = useCallback(() => {\n    // Cancel ongoing stream\n    if (streamReaderRef.current) {\n      streamReaderRef.current.cancel();\n      streamReaderRef.current = null;\n    }\n\n    // Abort fetch request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n\n    setMessages([]);\n    setTrainingStatus({\n      status: 'idle',\n      currentScore: 0,\n    });\n    setIsProcessing(false);\n    setError(null);\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (streamReaderRef.current) {\n        streamReaderRef.current.cancel();\n      }\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  return {\n    messages,\n    trainingStatus,\n    isProcessing,\n    error,\n    startTraining,\n    sendMessage,\n    reset,\n  };\n}\n",
        "last_modified": "2026-01-02T14:22:15.593700"
      },
      "task_intent": {
        "title": "Document Frontend React Components and Hooks",
        "description": "Add comprehensive JSDoc documentation to all React components and custom hooks in the frontend, including prop types, usage examples, component purposes, state management, and side effects.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:01:12.165366",
  "last_updated": "2026-01-02T14:22:15.447983"
}