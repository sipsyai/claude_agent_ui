{
  "file_path": "src/services/flow-nodes/input-node-handler.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "/**\n * Claude Agent UI - Input Node Handler\n *\n * Handles input nodes in flow execution.\n * Responsibilities:\n * - Validate input data against field definitions\n * - Apply validation rules and constraints\n * - Transform input data for downstream nodes\n * - Set up context variables from input\n *\n * @see src/types/flow-types.ts for InputNode type definition\n */\n\nimport { createLogger, type Logger } from '../logger.js';\nimport type { NodeHandler } from '../flow-execution-service.js';\nimport type {\n  FlowNode,\n  FlowExecutionContext,\n  NodeExecutionResult,\n  InputNode,\n  FlowInputField,\n} from '../../types/flow-types.js';\nimport { isInputNode } from '../../types/flow-types.js';\n\n/**\n * InputNodeHandler - Validates and processes flow input data\n *\n * This handler is the entry point for flow execution.\n * It validates user-provided input against the input field definitions\n * and sets up the execution context with validated data.\n */\nexport class InputNodeHandler implements NodeHandler {\n  private logger: Logger;\n\n  constructor() {\n    this.logger = createLogger('InputNodeHandler');\n  }\n\n  /**\n   * Execute the input node\n   * @param node - The input node to execute\n   * @param context - The flow execution context\n   * @returns Node execution result with validated input data\n   */\n  async execute(node: FlowNode, context: FlowExecutionContext): Promise<NodeExecutionResult> {\n    // Type guard to ensure we have an InputNode\n    if (!isInputNode(node)) {\n      return {\n        success: false,\n        error: `Expected input node, got ${node.type}`,\n      };\n    }\n\n    const inputNode = node as InputNode;\n    const { input } = context;\n\n    this.logger.info('Processing input node', {\n      nodeId: inputNode.nodeId,\n      nodeName: inputNode.name,\n      fieldCount: inputNode.inputFields?.length || 0,\n    });\n\n    try {\n      // Validate input against field definitions\n      const validationResult = this.validateInput(inputNode, input);\n\n      if (!validationResult.valid) {\n        context.log('error', `Input validation failed: ${validationResult.errors.join(', ')}`, node.nodeId);\n        return {\n          success: false,\n          error: `Input validation failed: ${validationResult.errors.join(', ')}`,\n          errorDetails: { validationErrors: validationResult.errors },\n        };\n      }\n\n      // Process and transform input data\n      const processedData = this.processInput(inputNode, input);\n\n      // Set up context variables for template interpolation\n      const outputData = {\n        ...processedData,\n        _inputNode: {\n          nodeId: inputNode.nodeId,\n          name: inputNode.name,\n          processedAt: new Date().toISOString(),\n        },\n      };\n\n      context.log('info', 'Input validation passed', node.nodeId, {\n        fieldCount: Object.keys(processedData).length,\n      });\n\n      return {\n        success: true,\n        output: outputData,\n        data: processedData,\n        continueExecution: true,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Input node execution failed', error as Error, {\n        nodeId: inputNode.nodeId,\n      });\n\n      return {\n        success: false,\n        error: errorMessage,\n        errorDetails: error instanceof Error ? { stack: error.stack } : undefined,\n      };\n    }\n  }\n\n  /**\n   * Validate input against field definitions\n   */\n  private validateInput(\n    node: InputNode,\n    input: Record<string, any>\n  ): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const fields = node.inputFields || [];\n\n    for (const field of fields) {\n      const value = input[field.name];\n\n      // Check required fields\n      if (field.required && (value === undefined || value === null || value === '')) {\n        errors.push(`Required field '${field.label || field.name}' is missing`);\n        continue;\n      }\n\n      // Skip validation for empty optional fields\n      if (value === undefined || value === null || value === '') {\n        continue;\n      }\n\n      // Validate by field type\n      const typeError = this.validateFieldType(field, value);\n      if (typeError) {\n        errors.push(typeError);\n      }\n\n      // Validate pattern (regex)\n      if (field.pattern) {\n        try {\n          const regex = new RegExp(field.pattern);\n          if (typeof value === 'string' && !regex.test(value)) {\n            errors.push(`Field '${field.label || field.name}' does not match the required pattern`);\n          }\n        } catch {\n          this.logger.warn('Invalid regex pattern in field definition', {\n            fieldName: field.name,\n            pattern: field.pattern,\n          });\n        }\n      }\n\n      // Validate min/max for numbers\n      if (field.type === 'number' && typeof value === 'number') {\n        if (field.min !== undefined && value < field.min) {\n          errors.push(`Field '${field.label || field.name}' must be at least ${field.min}`);\n        }\n        if (field.max !== undefined && value > field.max) {\n          errors.push(`Field '${field.label || field.name}' must be at most ${field.max}`);\n        }\n      }\n\n      // Validate min/max length for strings\n      if ((field.type === 'text' || field.type === 'textarea') && typeof value === 'string') {\n        if (field.min !== undefined && value.length < field.min) {\n          errors.push(`Field '${field.label || field.name}' must be at least ${field.min} characters`);\n        }\n        if (field.max !== undefined && value.length > field.max) {\n          errors.push(`Field '${field.label || field.name}' must be at most ${field.max} characters`);\n        }\n      }\n\n      // Validate select options\n      if ((field.type === 'select' || field.type === 'multiselect') && field.options) {\n        const values = field.type === 'multiselect' ? (Array.isArray(value) ? value : [value]) : [value];\n        for (const v of values) {\n          if (!field.options.includes(v)) {\n            errors.push(`Field '${field.label || field.name}' has invalid option: ${v}`);\n          }\n        }\n      }\n    }\n\n    // Apply custom validation rules if defined\n    if (node.validationRules) {\n      const customErrors = this.applyValidationRules(node.validationRules, input);\n      errors.push(...customErrors);\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Validate field type\n   */\n  private validateFieldType(field: FlowInputField, value: any): string | null {\n    const fieldLabel = field.label || field.name;\n\n    switch (field.type) {\n      case 'text':\n      case 'textarea':\n        if (typeof value !== 'string') {\n          return `Field '${fieldLabel}' must be a text value`;\n        }\n        break;\n\n      case 'number':\n        if (typeof value !== 'number' && isNaN(Number(value))) {\n          return `Field '${fieldLabel}' must be a number`;\n        }\n        break;\n\n      case 'url':\n        if (typeof value !== 'string') {\n          return `Field '${fieldLabel}' must be a URL string`;\n        }\n        try {\n          new URL(value);\n        } catch {\n          return `Field '${fieldLabel}' must be a valid URL`;\n        }\n        break;\n\n      case 'email':\n        if (typeof value !== 'string') {\n          return `Field '${fieldLabel}' must be an email string`;\n        }\n        // Basic email validation\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(value)) {\n          return `Field '${fieldLabel}' must be a valid email address`;\n        }\n        break;\n\n      case 'checkbox':\n        if (typeof value !== 'boolean') {\n          return `Field '${fieldLabel}' must be a boolean value`;\n        }\n        break;\n\n      case 'date':\n      case 'datetime':\n        if (typeof value !== 'string' && !(value instanceof Date)) {\n          return `Field '${fieldLabel}' must be a date value`;\n        }\n        if (typeof value === 'string') {\n          const date = new Date(value);\n          if (isNaN(date.getTime())) {\n            return `Field '${fieldLabel}' must be a valid date`;\n          }\n        }\n        break;\n\n      case 'select':\n        if (typeof value !== 'string') {\n          return `Field '${fieldLabel}' must be a string value`;\n        }\n        break;\n\n      case 'multiselect':\n        if (!Array.isArray(value)) {\n          return `Field '${fieldLabel}' must be an array of values`;\n        }\n        break;\n\n      case 'file':\n        // File validation would depend on the actual file handling mechanism\n        // For now, just check if it's an object with expected properties\n        if (typeof value !== 'object' || !value.name) {\n          return `Field '${fieldLabel}' must be a valid file reference`;\n        }\n        break;\n\n      default:\n        // Unknown field type, skip validation\n        break;\n    }\n\n    return null;\n  }\n\n  /**\n   * Apply custom validation rules\n   */\n  private applyValidationRules(\n    rules: Record<string, any>,\n    input: Record<string, any>\n  ): string[] {\n    const errors: string[] = [];\n\n    // Support for various rule types\n    // Example rules structure:\n    // {\n    //   \"conditionalRequired\": { \"fieldA\": { \"when\": \"fieldB\", \"equals\": \"value\" } },\n    //   \"comparison\": { \"startDate\": { \"lessThan\": \"endDate\" } }\n    // }\n\n    if (rules.conditionalRequired) {\n      for (const [field, condition] of Object.entries(rules.conditionalRequired as Record<string, any>)) {\n        const { when, equals } = condition;\n        if (input[when] === equals && !input[field]) {\n          errors.push(`Field '${field}' is required when '${when}' is '${equals}'`);\n        }\n      }\n    }\n\n    if (rules.comparison) {\n      for (const [field, comparison] of Object.entries(rules.comparison as Record<string, any>)) {\n        if (comparison.lessThan) {\n          const fieldValue = input[field];\n          const compareValue = input[comparison.lessThan];\n          if (fieldValue !== undefined && compareValue !== undefined && fieldValue >= compareValue) {\n            errors.push(`Field '${field}' must be less than '${comparison.lessThan}'`);\n          }\n        }\n        if (comparison.greaterThan) {\n          const fieldValue = input[field];\n          const compareValue = input[comparison.greaterThan];\n          if (fieldValue !== undefined && compareValue !== undefined && fieldValue <= compareValue) {\n            errors.push(`Field '${field}' must be greater than '${comparison.greaterThan}'`);\n          }\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Process and transform input data\n   */\n  private processInput(\n    node: InputNode,\n    input: Record<string, any>\n  ): Record<string, any> {\n    const processed: Record<string, any> = {};\n    const fields = node.inputFields || [];\n\n    for (const field of fields) {\n      let value = input[field.name];\n\n      // Apply default value if not provided\n      if ((value === undefined || value === null || value === '') && field.defaultValue !== undefined) {\n        value = field.defaultValue;\n      }\n\n      // Type coercion based on field type\n      if (value !== undefined && value !== null) {\n        switch (field.type) {\n          case 'number':\n            value = typeof value === 'number' ? value : Number(value);\n            break;\n          case 'checkbox':\n            value = Boolean(value);\n            break;\n          case 'date':\n          case 'datetime':\n            value = typeof value === 'string' ? new Date(value).toISOString() : value;\n            break;\n          case 'multiselect':\n            value = Array.isArray(value) ? value : [value];\n            break;\n        }\n      }\n\n      processed[field.name] = value;\n    }\n\n    // Also include any extra input fields not defined in the schema\n    // (for flexibility in development/testing)\n    for (const [key, value] of Object.entries(input)) {\n      if (!(key in processed)) {\n        processed[key] = value;\n      }\n    }\n\n    return processed;\n  }\n}\n\n/**\n * Singleton instance for registration\n */\nexport const inputNodeHandler = new InputNodeHandler();\n",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:46.955119",
  "last_updated": "2026-01-02T15:21:46.966812"
}