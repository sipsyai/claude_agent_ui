{
  "file_path": "src/services/conversation-status-manager.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import { EventEmitter } from 'events';\nimport { createLogger, type Logger } from './logger.js';\nimport { ConversationSummary, ConversationMessage, ConversationDetailsResponse } from '@/types/index.js';\n\n/**\n * Context data stored for active conversations that have not yet been written to local directories\n */\nexport interface ConversationStatusContext {\n  initialPrompt: string;\n  workingDirectory: string;\n  model: string;\n  timestamp: string;\n  inheritedMessages?: ConversationMessage[]; // Messages from previous session when resuming\n}\n\n/**\n * Unified service for managing conversation status and tracking active session status.\n * This service combines the functionality of ConversationStatusTracker and optimistic conversation handling.\n * \n * Responsibilities:\n * - Track active streaming sessions and their Claude session IDs\n * - Store conversation status contexts for active sessions\n * - Generate optimistic conversation summaries and details for UI feedback\n * - Emit events for session lifecycle (started/ended)\n */\nexport class ConversationStatusManager extends EventEmitter {\n  // Maps Claude session ID -> CUI streaming ID\n  private sessionToStreaming: Map<string, string> = new Map();\n  // Maps CUI streaming ID -> Claude session ID (reverse lookup)\n  private streamingToSession: Map<string, string> = new Map();\n  // Maps Claude session ID -> conversation context for active sessions\n  private sessionContext: Map<string, ConversationStatusContext> = new Map();\n  private logger: Logger;\n\n  constructor() {\n    super();\n    this.logger = createLogger('ConversationStatusManager');\n  }\n\n  /**\n   * Register a new active streaming session with optional conversation context\n   * This is called when we extract the session_id from the first stream message\n   */\n  registerActiveSession(streamingId: string, claudeSessionId: string, conversationContext?: { initialPrompt: string; workingDirectory: string; model?: string; inheritedMessages?: ConversationMessage[] }): void {\n    this.logger.debug('Registering active session', { \n      streamingId, \n      claudeSessionId,\n      hasConversationContext: !!conversationContext\n    });\n\n    // Remove any existing mapping for this Claude session\n    const existingStreamingId = this.sessionToStreaming.get(claudeSessionId);\n    if (existingStreamingId && existingStreamingId !== streamingId) {\n      this.logger.debug('Removing existing mapping for Claude session', { \n        claudeSessionId, \n        oldStreamingId: existingStreamingId,\n        newStreamingId: streamingId\n      });\n      this.streamingToSession.delete(existingStreamingId);\n    }\n\n    // Remove any existing mapping for this streaming ID\n    const existingClaudeSessionId = this.streamingToSession.get(streamingId);\n    if (existingClaudeSessionId && existingClaudeSessionId !== claudeSessionId) {\n      this.logger.debug('Removing existing mapping for streaming ID', { \n        streamingId, \n        oldClaudeSessionId: existingClaudeSessionId,\n        newClaudeSessionId: claudeSessionId\n      });\n      this.sessionToStreaming.delete(existingClaudeSessionId);\n      this.sessionContext.delete(existingClaudeSessionId);\n    }\n\n    // Set the new mapping\n    this.sessionToStreaming.set(claudeSessionId, streamingId);\n    this.streamingToSession.set(streamingId, claudeSessionId);\n\n    // If conversation context is provided, store it immediately\n    if (conversationContext) {\n      const context: ConversationStatusContext = {\n        initialPrompt: conversationContext.initialPrompt,\n        workingDirectory: conversationContext.workingDirectory,\n        model: conversationContext.model || 'default',\n        timestamp: new Date().toISOString(),\n        inheritedMessages: conversationContext.inheritedMessages\n      };\n      this.sessionContext.set(claudeSessionId, context);\n      \n      this.logger.debug('Stored conversation status context', {\n        claudeSessionId,\n        hasInitialPrompt: !!context.initialPrompt,\n        workingDirectory: context.workingDirectory,\n        model: context.model,\n        inheritedMessageCount: context.inheritedMessages?.length || 0\n      });\n    }\n\n    this.logger.debug('Active session registered', { \n      streamingId, \n      claudeSessionId,\n      totalActiveSessions: this.sessionToStreaming.size,\n      hasConversationContext: !!conversationContext\n    });\n\n    this.emit('session-started', { streamingId, claudeSessionId });\n  }\n\n  /**\n   * Unregister an active streaming session when it ends\n   */\n  unregisterActiveSession(streamingId: string): void {\n    const claudeSessionId = this.streamingToSession.get(streamingId);\n    \n    if (claudeSessionId) {\n      this.logger.debug('Unregistering active session', { \n        streamingId, \n        claudeSessionId \n      });\n\n      this.sessionToStreaming.delete(claudeSessionId);\n      this.streamingToSession.delete(streamingId);\n      this.sessionContext.delete(claudeSessionId);\n\n      this.logger.info('Active session unregistered', { \n        streamingId, \n        claudeSessionId,\n        totalActiveSessions: this.sessionToStreaming.size\n      });\n\n      this.emit('session-ended', { streamingId, claudeSessionId });\n    } else {\n      this.logger.debug('Attempted to unregister unknown streaming session', { streamingId });\n    }\n  }\n\n  /**\n   * Get conversation context for an active session\n   */\n  getConversationContext(claudeSessionId: string): ConversationStatusContext | undefined {\n    const context = this.sessionContext.get(claudeSessionId);\n    this.logger.debug('Getting conversation context', {\n      claudeSessionId,\n      hasContext: !!context\n    });\n    return context;\n  }\n\n  /**\n   * Check if a Claude session ID is currently active (has ongoing stream)\n   */\n  isSessionActive(claudeSessionId: string): boolean {\n    const isActive = this.sessionToStreaming.has(claudeSessionId);\n    return isActive;\n  }\n\n  /**\n   * Get the streaming ID for an active Claude session\n   */\n  getStreamingId(claudeSessionId: string): string | undefined {\n    const streamingId = this.sessionToStreaming.get(claudeSessionId);\n    this.logger.debug('Getting streaming ID for Claude session', { \n      claudeSessionId, \n      streamingId: streamingId || 'not found' \n    });\n    return streamingId;\n  }\n\n  /**\n   * Get the Claude session ID for an active streaming session\n   */\n  getSessionId(streamingId: string): string | undefined {\n    const claudeSessionId = this.streamingToSession.get(streamingId);\n    this.logger.debug('Getting Claude session ID for streaming ID', { \n      streamingId, \n      claudeSessionId: claudeSessionId || 'not found' \n    });\n    return claudeSessionId;\n  }\n\n  /**\n   * Get all active Claude session IDs\n   */\n  getActiveSessionIds(): string[] {\n    const sessions = Array.from(this.sessionToStreaming.keys());\n    this.logger.debug('Getting all active session IDs', { \n      count: sessions.length,\n      sessions \n    });\n    return sessions;\n  }\n\n  /**\n   * Get all active streaming IDs\n   */\n  getActiveStreamingIds(): string[] {\n    const streamingIds = Array.from(this.streamingToSession.keys());\n    this.logger.debug('Getting all active streaming IDs', { \n      count: streamingIds.length,\n      streamingIds \n    });\n    return streamingIds;\n  }\n\n  /**\n   * Get conversation status for a Claude session ID\n   */\n  getConversationStatus(claudeSessionId: string): 'completed' | 'ongoing' | 'pending' {\n    const isActive = this.isSessionActive(claudeSessionId);\n    const status = isActive ? 'ongoing' : 'completed';\n    return status;\n  }\n\n  /**\n   * Get conversations that haven't appeared in history yet\n   * Used by the conversation list endpoint\n   */\n  getConversationsNotInHistory(existingSessionIds: Set<string>): ConversationSummary[] {\n    const activeSessionIds = this.getActiveSessionIds();\n    \n    const conversationsNotInHistory = activeSessionIds\n      .filter(sessionId => !existingSessionIds.has(sessionId))\n      .map(sessionId => {\n        const context = this.getConversationContext(sessionId);\n        const streamingId = this.getStreamingId(sessionId);\n        \n        if (context && streamingId) {\n          // Create conversation entry for active session\n          const conversationSummary: ConversationSummary = {\n            sessionId,\n            projectPath: context.workingDirectory,\n            summary: '', // No summary for active conversation\n            sessionInfo: {\n              custom_name: '', // No custom name yet\n              created_at: context.timestamp,\n              updated_at: context.timestamp,\n              version: 4,\n              pinned: false,\n              archived: false,\n              continuation_session_id: '',\n              initial_commit_head: '',\n              permission_mode: 'default'\n            },\n            createdAt: context.timestamp,\n            updatedAt: context.timestamp,\n            messageCount: 1, // At least the initial user message\n            totalDuration: 0, // No duration yet\n            model: context.model || 'unknown',\n            status: 'ongoing' as const,\n            streamingId\n          };\n          \n          this.logger.debug('Created conversation summary for active session', {\n            sessionId,\n            streamingId,\n            workingDirectory: context.workingDirectory,\n            model: context.model\n          });\n          \n          return conversationSummary;\n        }\n        \n        return null;\n      })\n      .filter((conversation): conversation is ConversationSummary => conversation !== null);\n\n    this.logger.debug('Generated conversations not in history', {\n      activeSessionCount: activeSessionIds.length,\n      existingSessionCount: existingSessionIds.size,\n      conversationsNotInHistoryCount: conversationsNotInHistory.length\n    });\n\n    return conversationsNotInHistory;\n  }\n\n  /**\n   * Get conversation details if session is active but not in history\n   * Used by the conversation details endpoint\n   */\n  getActiveConversationDetails(sessionId: string): ConversationDetailsResponse | null {\n    const isActive = this.isSessionActive(sessionId);\n    const context = this.getConversationContext(sessionId);\n    \n    this.logger.debug('Checking for active conversation details', {\n      sessionId,\n      isActive,\n      hasContext: !!context\n    });\n    \n    if (!isActive || !context) {\n      return null;\n    }\n\n    // Create messages array\n    const messages: ConversationMessage[] = [];\n    \n    // Add inherited messages first (if any)\n    if (context.inheritedMessages) {\n      messages.push(...context.inheritedMessages);\n    }\n    \n    // Add the current initial prompt message\n    const activeMessage: ConversationMessage = {\n      uuid: `active-${sessionId}-user`,\n      type: 'user',\n      message: {\n        role: 'user',\n        content: context.initialPrompt\n      },\n      timestamp: context.timestamp,\n      sessionId: sessionId,\n      cwd: context.workingDirectory\n    };\n    messages.push(activeMessage);\n    \n    const response: ConversationDetailsResponse = {\n      messages,\n      summary: '', // No summary for active conversation\n      projectPath: context.workingDirectory,\n      metadata: {\n        totalDuration: 0,\n        model: context.model || 'unknown'\n      }\n    };\n    \n    this.logger.debug('Created active conversation details', {\n      sessionId,\n      workingDirectory: context.workingDirectory,\n      model: context.model,\n      totalMessageCount: messages.length,\n      inheritedMessageCount: context.inheritedMessages?.length || 0\n    });\n    \n    return response;\n  }\n\n  /**\n   * Clear all mappings (useful for testing)\n   */\n  clear(): void {\n    this.logger.debug('Clearing all session mappings');\n    this.sessionToStreaming.clear();\n    this.streamingToSession.clear();\n    this.sessionContext.clear();\n  }\n\n  /**\n   * Get statistics about tracked sessions\n   */\n  getStats(): {\n    activeSessionsCount: number;\n    activeStreamingIdsCount: number;\n    activeContextsCount: number;\n    activeSessions: Array<{ claudeSessionId: string; streamingId: string }>;\n  } {\n    const activeSessions = Array.from(this.sessionToStreaming.entries()).map(\n      ([claudeSessionId, streamingId]) => ({ claudeSessionId, streamingId })\n    );\n\n    return {\n      activeSessionsCount: this.sessionToStreaming.size,\n      activeStreamingIdsCount: this.streamingToSession.size,\n      activeContextsCount: this.sessionContext.size,\n      activeSessions\n    };\n  }\n}",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import { EventEmitter } from 'events';\nimport { createLogger, type Logger } from './logger.js';\nimport { ConversationSummary, ConversationMessage, ConversationDetailsResponse } from '@/types/index.js';\n\n/**\n * Context data stored for active conversations that have not yet been written to local directories\n *\n * @description\n * This interface defines the conversation context stored in-memory for active streaming sessions\n * that haven't been persisted to the Claude history directory yet. It enables optimistic UI updates\n * by providing conversation metadata immediately after a session starts, before SDK writes history files.\n *\n * @property {string} initialPrompt - The first user message that started this conversation\n * @property {string} workingDirectory - Absolute path to the project working directory\n * @property {string} model - Claude model used for this conversation (e.g., 'claude-sonnet-4')\n * @property {string} timestamp - ISO 8601 timestamp when the conversation was created\n * @property {ConversationMessage[]} [inheritedMessages] - Messages from previous session when resuming a conversation\n *\n * @example\n * ```typescript\n * // Basic context for new conversation\n * const context: ConversationStatusContext = {\n *   initialPrompt: 'Help me refactor this authentication code',\n *   workingDirectory: '/Users/dev/my-project',\n *   model: 'claude-sonnet-4',\n *   timestamp: '2024-01-15T10:30:00.000Z'\n * };\n * ```\n *\n * @example\n * ```typescript\n * // Context for resumed conversation with inherited messages\n * const context: ConversationStatusContext = {\n *   initialPrompt: 'Continue working on the database migration',\n *   workingDirectory: '/Users/dev/my-project',\n *   model: 'claude-sonnet-4',\n *   timestamp: '2024-01-15T14:30:00.000Z',\n *   inheritedMessages: [\n *     {\n *       uuid: 'msg-1',\n *       type: 'user',\n *       message: { role: 'user', content: 'Create a database migration' },\n *       timestamp: '2024-01-15T10:00:00.000Z',\n *       sessionId: 'previous-session-id',\n *       cwd: '/Users/dev/my-project'\n *     },\n *     {\n *       uuid: 'msg-2',\n *       type: 'assistant',\n *       message: { role: 'assistant', content: 'I created the migration...' },\n *       timestamp: '2024-01-15T10:01:00.000Z',\n *       sessionId: 'previous-session-id',\n *       cwd: '/Users/dev/my-project'\n *     }\n *   ]\n * };\n * ```\n */\nexport interface ConversationStatusContext {\n  initialPrompt: string;\n  workingDirectory: string;\n  model: string;\n  timestamp: string;\n  inheritedMessages?: ConversationMessage[]; // Messages from previous session when resuming\n}\n\n/**\n * ConversationStatusManager - Unified service for managing conversation status and active session tracking\n *\n * @description\n * The ConversationStatusManager is a critical service that bridges the gap between streaming conversations\n * and persisted conversation history. It tracks active streaming sessions in-memory and provides optimistic\n * UI updates before Claude SDK writes conversation files to disk. This enables immediate UI feedback and\n * seamless conversation list updates without polling the filesystem.\n *\n * **Key Responsibilities:**\n * - Track active streaming sessions with bidirectional Claude session ID \u2194 streaming ID mapping\n * - Store conversation context (initial prompt, model, working directory) for active sessions\n * - Generate optimistic conversation summaries for sessions not yet in history files\n * - Provide conversation details for active sessions to support real-time UI updates\n * - Emit lifecycle events ('session-started', 'session-ended') for UI synchronization\n * - Manage session cleanup when conversations complete or are cancelled\n *\n * **Architecture:**\n * - **EventEmitter Pattern**: Extends Node.js EventEmitter to broadcast session lifecycle events\n * - **Bidirectional Mapping**: Maintains two synchronized Maps for Claude session ID \u2194 streaming ID lookup\n * - **In-Memory Context Store**: Stores conversation metadata for active sessions not yet persisted to disk\n * - **Optimistic UI Support**: Generates conversation summaries/details before history files exist\n * - **Automatic Cleanup**: Removes mappings and context when sessions end or are cancelled\n *\n * **Session Lifecycle:**\n * The service manages a complete session lifecycle from start to finish:\n *\n * 1. **Session Started**: Client initiates conversation via ChatService.sendMessage()\n * 2. **Register Session**: ChatService calls registerActiveSession() when SDK emits session_id\n * 3. **Store Context**: Service stores initial prompt, model, working directory, timestamp\n * 4. **Emit Event**: Emits 'session-started' event with streamingId and claudeSessionId\n * 5. **Optimistic Updates**: UI immediately shows conversation in list (before history file exists)\n * 6. **Stream Messages**: Conversation proceeds with real-time message streaming\n * 7. **Session Ended**: Stream completes successfully, errors, or is cancelled\n * 8. **Unregister Session**: ChatService calls unregisterActiveSession() to cleanup\n * 9. **Emit Event**: Emits 'session-ended' event for UI to refresh from history files\n * 10. **Cleanup**: Removes all mappings and context from in-memory stores\n *\n * **Bidirectional Mapping Strategy:**\n * The service maintains two synchronized Maps to enable fast lookups in both directions:\n * - `sessionToStreaming`: Map<claudeSessionId, streamingId> - Lookup streaming ID by Claude session ID\n * - `streamingToSession`: Map<streamingId, claudeSessionId> - Lookup Claude session ID by streaming ID\n * - Both maps are updated atomically during registration/unregistration\n * - Old mappings are automatically cleaned up when sessions are re-registered\n *\n * **Optimistic UI Patterns:**\n * The service enables several optimistic UI patterns to improve perceived performance:\n *\n * 1. **Instant Conversation List**: Show new conversation in list immediately after user sends message\n * 2. **Real-Time Status**: Display 'ongoing' status badge for active streaming conversations\n * 3. **Inherited Message Preview**: Show previous conversation messages when resuming\n * 4. **Graceful Transition**: Auto-refresh from history files when session completes\n * 5. **Streaming Indicator**: Link conversation to active stream for real-time status updates\n *\n * **EventEmitter Events:**\n * The service emits two lifecycle events for UI synchronization:\n *\n * - **session-started**: Emitted when registerActiveSession() is called\n *   - Payload: { streamingId: string, claudeSessionId: string }\n *   - Use case: UI adds conversation to list with 'ongoing' status\n *\n * - **session-ended**: Emitted when unregisterActiveSession() is called\n *   - Payload: { streamingId: string, claudeSessionId: string }\n *   - Use case: UI refreshes conversation list from history files\n *\n * **Integration with ChatService:**\n * ChatService uses ConversationStatusManager to provide optimistic UI updates:\n * 1. ChatService.sendMessage() calls registerActiveSession() when SDK emits session_id\n * 2. Service stores conversation context (prompt, model, working directory)\n * 3. Conversation list endpoint queries getConversationsNotInHistory() for active sessions\n * 4. Conversation details endpoint queries getActiveConversationDetails() for ongoing chats\n * 5. ChatService calls unregisterActiveSession() in finally block when stream ends\n *\n * @example\n * ```typescript\n * // Basic usage - register and unregister session\n * import { ConversationStatusManager } from './conversation-status-manager';\n *\n * const statusManager = new ConversationStatusManager();\n *\n * // Listen for lifecycle events\n * statusManager.on('session-started', ({ streamingId, claudeSessionId }) => {\n *   console.log(`Session started: ${claudeSessionId} (stream: ${streamingId})`);\n *   // Update UI to show new conversation with 'ongoing' status\n * });\n *\n * statusManager.on('session-ended', ({ streamingId, claudeSessionId }) => {\n *   console.log(`Session ended: ${claudeSessionId} (stream: ${streamingId})`);\n *   // Refresh UI from history files\n * });\n *\n * // Register session when stream starts\n * const streamingId = 'stream-uuid-123';\n * const claudeSessionId = 'session-abc-456';\n * const context = {\n *   initialPrompt: 'Help me debug this code',\n *   workingDirectory: '/Users/dev/my-project',\n *   model: 'claude-sonnet-4'\n * };\n *\n * statusManager.registerActiveSession(streamingId, claudeSessionId, context);\n *\n * // Later, when stream completes...\n * statusManager.unregisterActiveSession(streamingId);\n * ```\n *\n * @example\n * ```typescript\n * // Optimistic UI pattern - conversation list with active sessions\n * import { ConversationStatusManager } from './conversation-status-manager';\n * import { claudeHistoryReader } from './claude-history-reader';\n *\n * const statusManager = new ConversationStatusManager();\n *\n * // Get conversation list (combines history files + active sessions)\n * async function getConversationList(): Promise<ConversationSummary[]> {\n *   // 1. Read persisted conversations from history files\n *   const historySummaries = await claudeHistoryReader.getConversationList('/Users/dev/my-project');\n *   const existingSessionIds = new Set(historySummaries.map(s => s.sessionId));\n *\n *   // 2. Get active sessions not yet in history\n *   const activeSummaries = statusManager.getConversationsNotInHistory(existingSessionIds);\n *\n *   // 3. Combine and sort by newest first\n *   const allSummaries = [...activeSummaries, ...historySummaries];\n *   allSummaries.sort((a, b) =>\n *     new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n *   );\n *\n *   return allSummaries;\n *   // Active sessions show status='ongoing', streamingId populated\n *   // Completed sessions show status='completed', streamingId=undefined\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Optimistic UI pattern - conversation details with active session\n * import { ConversationStatusManager } from './conversation-status-manager';\n * import { claudeHistoryReader } from './claude-history-reader';\n *\n * const statusManager = new ConversationStatusManager();\n *\n * // Get conversation details (try active session first, fallback to history)\n * async function getConversationDetails(sessionId: string): Promise<ConversationDetailsResponse> {\n *   // 1. Check if session is active (optimistic path)\n *   const activeDetails = statusManager.getActiveConversationDetails(sessionId);\n *   if (activeDetails) {\n *     return activeDetails;\n *     // Returns initial user message + any inherited messages\n *     // Assistant response will stream in real-time via separate endpoint\n *   }\n *\n *   // 2. Fallback to reading from history files\n *   const historyDetails = await claudeHistoryReader.getConversationDetails(sessionId);\n *   return historyDetails;\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Session lifecycle with inherited messages (resume conversation)\n * import { ConversationStatusManager } from './conversation-status-manager';\n *\n * const statusManager = new ConversationStatusManager();\n *\n * // User resumes a previous conversation\n * const previousMessages: ConversationMessage[] = [\n *   {\n *     uuid: 'msg-1',\n *     type: 'user',\n *     message: { role: 'user', content: 'Create an API endpoint for users' },\n *     timestamp: '2024-01-15T10:00:00.000Z',\n *     sessionId: 'old-session-id',\n *     cwd: '/Users/dev/my-project'\n *   },\n *   {\n *     uuid: 'msg-2',\n *     type: 'assistant',\n *     message: { role: 'assistant', content: 'I created the endpoint...' },\n *     timestamp: '2024-01-15T10:01:00.000Z',\n *     sessionId: 'old-session-id',\n *     cwd: '/Users/dev/my-project'\n *   }\n * ];\n *\n * // Register new session with inherited messages\n * statusManager.registerActiveSession(\n *   'stream-uuid-new',\n *   'session-new-id',\n *   {\n *     initialPrompt: 'Now add authentication to the endpoint',\n *     workingDirectory: '/Users/dev/my-project',\n *     model: 'claude-sonnet-4',\n *     inheritedMessages: previousMessages\n *   }\n * );\n *\n * // Get conversation details - includes both old and new messages\n * const details = statusManager.getActiveConversationDetails('session-new-id');\n * console.log(details?.messages.length); // 3 (2 inherited + 1 new user message)\n * ```\n *\n * @example\n * ```typescript\n * // Real-time UI synchronization with lifecycle events\n * import { ConversationStatusManager } from './conversation-status-manager';\n *\n * const statusManager = new ConversationStatusManager();\n *\n * // WebSocket handler for real-time UI updates\n * class ConversationListWebSocket {\n *   private clients: Set<WebSocket> = new Set();\n *\n *   constructor(statusManager: ConversationStatusManager) {\n *     // When session starts, notify all clients to add conversation\n *     statusManager.on('session-started', async ({ claudeSessionId }) => {\n *       const summary = statusManager.getConversationsNotInHistory(new Set())[0];\n *       this.broadcast({ type: 'conversation:added', summary });\n *     });\n *\n *     // When session ends, notify all clients to refresh from history\n *     statusManager.on('session-ended', async ({ claudeSessionId }) => {\n *       this.broadcast({ type: 'conversation:completed', sessionId: claudeSessionId });\n *     });\n *   }\n *\n *   broadcast(data: any) {\n *     this.clients.forEach(client => client.send(JSON.stringify(data)));\n *   }\n * }\n * ```\n *\n * @see {@link ConversationStatusContext} - Context data stored for active conversations\n * @see ChatService - Uses ConversationStatusManager for optimistic UI updates\n * @see ClaudeHistoryReader - Reads persisted conversations from history files\n */\nexport class ConversationStatusManager extends EventEmitter {\n  // Maps Claude session ID -> CUI streaming ID\n  private sessionToStreaming: Map<string, string> = new Map();\n  // Maps CUI streaming ID -> Claude session ID (reverse lookup)\n  private streamingToSession: Map<string, string> = new Map();\n  // Maps Claude session ID -> conversation context for active sessions\n  private sessionContext: Map<string, ConversationStatusContext> = new Map();\n  private logger: Logger;\n\n  constructor() {\n    super();\n    this.logger = createLogger('ConversationStatusManager');\n  }\n\n  /**\n   * Register a new active streaming session with optional conversation context\n   *\n   * @description\n   * This method is called when ChatService receives the session_id from Claude SDK during message streaming.\n   * It establishes bidirectional mapping between the internal streaming ID and Claude's session ID, stores\n   * conversation context for optimistic UI updates, and emits a 'session-started' event for UI synchronization.\n   *\n   * **Workflow:**\n   * 1. Clean up any existing mappings for the provided Claude session ID or streaming ID\n   * 2. Create bidirectional mapping: claudeSessionId \u2194 streamingId\n   * 3. If conversation context provided, store it with auto-generated timestamp\n   * 4. Emit 'session-started' event with { streamingId, claudeSessionId }\n   * 5. Log registration details for debugging\n   *\n   * **When to Call:**\n   * - ChatService.sendMessage() calls this when SDK emits the first 'session_id' event\n   * - Should be called exactly once per conversation (re-registration overwrites existing mappings)\n   * - Must be called before getConversationsNotInHistory() or getActiveConversationDetails()\n   *\n   * **Context Storage:**\n   * The conversationContext parameter is optional but recommended for optimistic UI support:\n   * - **Without context**: Only bidirectional mapping is stored (session tracking only)\n   * - **With context**: Full conversation metadata stored (enables optimistic summaries/details)\n   *\n   * **Cleanup Strategy:**\n   * If either the claudeSessionId or streamingId is already registered to a different ID,\n   * the old mapping is automatically removed to prevent orphaned entries.\n   *\n   * @param {string} streamingId - Internal UUID for the streaming session (generated by ChatService)\n   * @param {string} claudeSessionId - Claude SDK session ID (extracted from SDK stream)\n   * @param {object} [conversationContext] - Optional conversation metadata for optimistic UI\n   * @param {string} conversationContext.initialPrompt - First user message that started the conversation\n   * @param {string} conversationContext.workingDirectory - Project working directory path\n   * @param {string} [conversationContext.model] - Claude model name (defaults to 'default')\n   * @param {ConversationMessage[]} [conversationContext.inheritedMessages] - Messages from previous session when resuming\n   *\n   * @returns {void}\n   *\n   * @example\n   * ```typescript\n   * // Basic registration - session tracking only (no optimistic UI)\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * const streamingId = 'stream-uuid-123';\n   * const claudeSessionId = 'session-abc-456';\n   *\n   * conversationStatusManager.registerActiveSession(streamingId, claudeSessionId);\n   * // Result: Bidirectional mapping created, no context stored\n   * // Use case: Tracking active sessions without showing in conversation list\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Full registration with context - enables optimistic UI\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * const streamingId = 'stream-uuid-123';\n   * const claudeSessionId = 'session-abc-456';\n   * const context = {\n   *   initialPrompt: 'Help me refactor this authentication code',\n   *   workingDirectory: '/Users/dev/my-project',\n   *   model: 'claude-sonnet-4'\n   * };\n   *\n   * conversationStatusManager.registerActiveSession(streamingId, claudeSessionId, context);\n   * // Result: Mapping + context stored, conversation appears in list immediately\n   * // Use case: Standard workflow for optimistic UI updates\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // ChatService integration - typical usage pattern\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * class ChatService {\n   *   async *sendMessage(sessionDocId: string, message: string, ...) {\n   *     const streamingId = uuidv4();\n   *     let claudeSessionId: string | undefined;\n   *\n   *     try {\n   *       // Save user message\n   *       yield { type: 'user_message_saved', ... };\n   *\n   *       // Start SDK stream\n   *       for await (const event of sdkQuery.stream()) {\n   *         if (event.type === 'session_id') {\n   *           claudeSessionId = event.sessionId;\n   *\n   *           // Register session with context for optimistic UI\n   *           conversationStatusManager.registerActiveSession(\n   *             streamingId,\n   *             claudeSessionId,\n   *             {\n   *               initialPrompt: message,\n   *               workingDirectory: chatSession.workingDirectory,\n   *               model: chatSession.agent?.modelConfig?.model || 'claude-sonnet-4'\n   *             }\n   *           );\n   *\n   *           yield { type: 'stream_id', streamId: streamingId };\n   *         }\n   *         // ... handle other events\n   *       }\n   *     } finally {\n   *       // Cleanup in unregisterActiveSession()\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Resume conversation with inherited messages\n   * import { conversationStatusManager } from './conversation-status-manager';\n   * import { claudeHistoryReader } from './claude-history-reader';\n   *\n   * async function resumeConversation(previousSessionId: string, newMessage: string) {\n   *   // 1. Load previous conversation messages\n   *   const previousDetails = await claudeHistoryReader.getConversationDetails(previousSessionId);\n   *\n   *   // 2. Start new streaming session\n   *   const streamingId = 'stream-uuid-new';\n   *   const claudeSessionId = 'session-new-id'; // From SDK\n   *\n   *   // 3. Register with inherited messages for context continuity\n   *   conversationStatusManager.registerActiveSession(\n   *     streamingId,\n   *     claudeSessionId,\n   *     {\n   *       initialPrompt: newMessage,\n   *       workingDirectory: previousDetails.projectPath,\n   *       model: previousDetails.metadata.model,\n   *       inheritedMessages: previousDetails.messages // Include previous conversation\n   *     }\n   *   );\n   *\n   *   // UI now shows all messages: [...previousDetails.messages, newUserMessage]\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Automatic cleanup of old mappings\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * // First registration\n   * conversationStatusManager.registerActiveSession('stream-1', 'session-abc');\n   *\n   * // Re-register same Claude session with different stream ID\n   * conversationStatusManager.registerActiveSession('stream-2', 'session-abc', context);\n   * // Old mapping 'stream-1' -> 'session-abc' is automatically removed\n   * // New mapping 'stream-2' -> 'session-abc' is created\n   * // Prevents orphaned entries when sessions are reused\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Listen for session-started events\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * conversationStatusManager.on('session-started', ({ streamingId, claudeSessionId }) => {\n   *   console.log(`New conversation started: ${claudeSessionId}`);\n   *   console.log(`Stream ID: ${streamingId}`);\n   *\n   *   // Update UI: Add conversation to list with 'ongoing' status\n   *   addConversationToUI({\n   *     sessionId: claudeSessionId,\n   *     streamId: streamingId,\n   *     status: 'ongoing'\n   *   });\n   * });\n   *\n   * conversationStatusManager.registerActiveSession('stream-123', 'session-abc', context);\n   * // Triggers 'session-started' event\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - registration without context\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * conversationStatusManager.registerActiveSession('stream-123', 'session-abc');\n   * // Only mapping is stored, no context\n   *\n   * const context = conversationStatusManager.getConversationContext('session-abc');\n   * console.log(context); // undefined\n   *\n   * const summaries = conversationStatusManager.getConversationsNotInHistory(new Set());\n   * console.log(summaries); // [] (empty - no context means no summary)\n   *\n   * // Best practice: Always provide context for optimistic UI support\n   * ```\n   *\n   * @see {@link unregisterActiveSession} - Cleanup method called when session ends\n   * @see {@link getConversationContext} - Retrieve stored context for a session\n   * @see {@link getConversationsNotInHistory} - Get optimistic conversation summaries\n   * @see {@link getActiveConversationDetails} - Get optimistic conversation details\n   */\n  registerActiveSession(streamingId: string, claudeSessionId: string, conversationContext?: { initialPrompt: string; workingDirectory: string; model?: string; inheritedMessages?: ConversationMessage[] }): void {\n    this.logger.debug('Registering active session', { \n      streamingId, \n      claudeSessionId,\n      hasConversationContext: !!conversationContext\n    });\n\n    // Remove any existing mapping for this Claude session\n    const existingStreamingId = this.sessionToStreaming.get(claudeSessionId);\n    if (existingStreamingId && existingStreamingId !== streamingId) {\n      this.logger.debug('Removing existing mapping for Claude session', { \n        claudeSessionId, \n        oldStreamingId: existingStreamingId,\n        newStreamingId: streamingId\n      });\n      this.streamingToSession.delete(existingStreamingId);\n    }\n\n    // Remove any existing mapping for this streaming ID\n    const existingClaudeSessionId = this.streamingToSession.get(streamingId);\n    if (existingClaudeSessionId && existingClaudeSessionId !== claudeSessionId) {\n      this.logger.debug('Removing existing mapping for streaming ID', { \n        streamingId, \n        oldClaudeSessionId: existingClaudeSessionId,\n        newClaudeSessionId: claudeSessionId\n      });\n      this.sessionToStreaming.delete(existingClaudeSessionId);\n      this.sessionContext.delete(existingClaudeSessionId);\n    }\n\n    // Set the new mapping\n    this.sessionToStreaming.set(claudeSessionId, streamingId);\n    this.streamingToSession.set(streamingId, claudeSessionId);\n\n    // If conversation context is provided, store it immediately\n    if (conversationContext) {\n      const context: ConversationStatusContext = {\n        initialPrompt: conversationContext.initialPrompt,\n        workingDirectory: conversationContext.workingDirectory,\n        model: conversationContext.model || 'default',\n        timestamp: new Date().toISOString(),\n        inheritedMessages: conversationContext.inheritedMessages\n      };\n      this.sessionContext.set(claudeSessionId, context);\n      \n      this.logger.debug('Stored conversation status context', {\n        claudeSessionId,\n        hasInitialPrompt: !!context.initialPrompt,\n        workingDirectory: context.workingDirectory,\n        model: context.model,\n        inheritedMessageCount: context.inheritedMessages?.length || 0\n      });\n    }\n\n    this.logger.debug('Active session registered', { \n      streamingId, \n      claudeSessionId,\n      totalActiveSessions: this.sessionToStreaming.size,\n      hasConversationContext: !!conversationContext\n    });\n\n    this.emit('session-started', { streamingId, claudeSessionId });\n  }\n\n  /**\n   * Unregister an active streaming session when it ends\n   *\n   * @description\n   * This method is called when a streaming conversation completes, errors, or is cancelled.\n   * It removes all in-memory state for the session (bidirectional mappings and context),\n   * emits a 'session-ended' event for UI synchronization, and cleans up resources.\n   *\n   * **Workflow:**\n   * 1. Look up claudeSessionId from streamingId (reverse mapping)\n   * 2. If found, remove both bidirectional mappings (sessionToStreaming, streamingToSession)\n   * 3. Remove conversation context from sessionContext map\n   * 4. Emit 'session-ended' event with { streamingId, claudeSessionId }\n   * 5. Log unregistration details for debugging\n   * 6. If streamingId not found, log warning (idempotent - safe to call multiple times)\n   *\n   * **When to Call:**\n   * - ChatService.sendMessage() calls this in the finally block when stream ends\n   * - Should be called exactly once per conversation (but safe to call multiple times)\n   * - Must be called after stream completes/errors/is cancelled to prevent memory leaks\n   *\n   * **UI Synchronization:**\n   * After unregistration, the UI should:\n   * 1. Listen for 'session-ended' event\n   * 2. Refresh conversation list from history files (conversation now persisted to disk)\n   * 3. Update conversation status from 'ongoing' to 'completed'\n   * 4. Remove streaming indicator from UI\n   *\n   * **Memory Safety:**\n   * This method is critical for preventing memory leaks. If not called, sessions remain\n   * in memory indefinitely. Always call in a finally block to ensure cleanup happens\n   * even if stream errors or is cancelled.\n   *\n   * **Idempotent Behavior:**\n   * Safe to call multiple times with the same streamingId. If already unregistered,\n   * logs a debug message and returns without error.\n   *\n   * @param {string} streamingId - Internal UUID for the streaming session (same as used in registerActiveSession)\n   *\n   * @returns {void}\n   *\n   * @example\n   * ```typescript\n   * // Basic usage - unregister when stream completes\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * const streamingId = 'stream-uuid-123';\n   *\n   * // When stream completes...\n   * conversationStatusManager.unregisterActiveSession(streamingId);\n   * // Result: All mappings and context removed, 'session-ended' event emitted\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // ChatService integration - typical usage pattern\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * class ChatService {\n   *   async *sendMessage(sessionDocId: string, message: string, ...) {\n   *     const streamingId = uuidv4();\n   *     let claudeSessionId: string | undefined;\n   *\n   *     try {\n   *       // Start SDK stream\n   *       for await (const event of sdkQuery.stream()) {\n   *         if (event.type === 'session_id') {\n   *           claudeSessionId = event.sessionId;\n   *           conversationStatusManager.registerActiveSession(\n   *             streamingId,\n   *             claudeSessionId,\n   *             context\n   *           );\n   *         }\n   *         // ... handle other events\n   *       }\n   *     } catch (error) {\n   *       // Error handling...\n   *       throw error;\n   *     } finally {\n   *       // CRITICAL: Always cleanup in finally block\n   *       // Ensures cleanup happens even if stream errors or is cancelled\n   *       conversationStatusManager.unregisterActiveSession(streamingId);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Listen for session-ended events\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * conversationStatusManager.on('session-ended', async ({ streamingId, claudeSessionId }) => {\n   *   console.log(`Conversation ended: ${claudeSessionId}`);\n   *   console.log(`Stream ID: ${streamingId}`);\n   *\n   *   // Update UI: Refresh conversation from history files\n   *   const historyDetails = await claudeHistoryReader.getConversationDetails(claudeSessionId);\n   *   updateConversationInUI({\n   *     sessionId: claudeSessionId,\n   *     status: 'completed',\n   *     messages: historyDetails.messages\n   *   });\n   * });\n   *\n   * conversationStatusManager.unregisterActiveSession('stream-123');\n   * // Triggers 'session-ended' event\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Graceful transition from optimistic to persisted state\n   * import { conversationStatusManager } from './conversation-status-manager';\n   * import { claudeHistoryReader } from './claude-history-reader';\n   *\n   * async function handleSessionEnded(streamingId: string) {\n   *   const claudeSessionId = conversationStatusManager.getSessionId(streamingId);\n   *   if (!claudeSessionId) return;\n   *\n   *   // Before unregister: conversation shown via optimistic context\n   *   const optimisticDetails = conversationStatusManager.getActiveConversationDetails(claudeSessionId);\n   *   console.log('Optimistic messages:', optimisticDetails?.messages.length);\n   *\n   *   // Unregister session (cleanup in-memory state)\n   *   conversationStatusManager.unregisterActiveSession(streamingId);\n   *\n   *   // After unregister: conversation shown via history files\n   *   const persistedDetails = await claudeHistoryReader.getConversationDetails(claudeSessionId);\n   *   console.log('Persisted messages:', persistedDetails.messages.length);\n   *\n   *   // UI seamlessly transitions from optimistic to persisted state\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Memory leak prevention - always cleanup\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * // \u274c BAD: No cleanup if error occurs\n   * async function sendMessageBad(message: string) {\n   *   const streamingId = uuidv4();\n   *   conversationStatusManager.registerActiveSession(streamingId, sessionId, context);\n   *   await streamMessages(); // Throws error\n   *   conversationStatusManager.unregisterActiveSession(streamingId); // Never called!\n   *   // Memory leak: session remains in memory indefinitely\n   * }\n   *\n   * // \u2705 GOOD: Cleanup in finally block\n   * async function sendMessageGood(message: string) {\n   *   const streamingId = uuidv4();\n   *   try {\n   *     conversationStatusManager.registerActiveSession(streamingId, sessionId, context);\n   *     await streamMessages();\n   *   } finally {\n   *     conversationStatusManager.unregisterActiveSession(streamingId);\n   *     // Always called, even if error occurs\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Idempotent behavior - safe to call multiple times\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * const streamingId = 'stream-uuid-123';\n   *\n   * conversationStatusManager.registerActiveSession(streamingId, 'session-abc', context);\n   * console.log(conversationStatusManager.isSessionActive('session-abc')); // true\n   *\n   * // First unregister - removes session\n   * conversationStatusManager.unregisterActiveSession(streamingId);\n   * console.log(conversationStatusManager.isSessionActive('session-abc')); // false\n   *\n   * // Second unregister - safe, logs debug message\n   * conversationStatusManager.unregisterActiveSession(streamingId);\n   * // Logs: 'Attempted to unregister unknown streaming session'\n   * // No error thrown - idempotent behavior\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Stream cancellation workflow\n   * import { conversationStatusManager } from './conversation-status-manager';\n   * import { chatService } from './chat-service';\n   *\n   * let currentStreamId: string | null = null;\n   *\n   * // Listen for session-ended after cancellation\n   * conversationStatusManager.on('session-ended', ({ streamingId, claudeSessionId }) => {\n   *   if (streamingId === currentStreamId) {\n   *     console.log('Cancelled stream cleaned up');\n   *     updateUI({ status: 'cancelled', sessionId: claudeSessionId });\n   *   }\n   * });\n   *\n   * // Start streaming\n   * (async () => {\n   *   for await (const event of chatService.sendMessage(...)) {\n   *     if (event.type === 'stream_id') {\n   *       currentStreamId = event.streamId;\n   *     }\n   *     if (event.type === 'cancelled') {\n   *       console.log('Stream was cancelled');\n   *       // ChatService calls unregisterActiveSession in finally block\n   *     }\n   *   }\n   * })();\n   *\n   * // Cancel after 5 seconds\n   * setTimeout(() => {\n   *   if (currentStreamId) {\n   *     chatService.cancelMessage(currentStreamId);\n   *     // Triggers unregisterActiveSession via ChatService finally block\n   *   }\n   * }, 5000);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Monitoring active session count\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * // Before cleanup\n   * conversationStatusManager.registerActiveSession('stream-1', 'session-1', context1);\n   * conversationStatusManager.registerActiveSession('stream-2', 'session-2', context2);\n   * conversationStatusManager.registerActiveSession('stream-3', 'session-3', context3);\n   * console.log(conversationStatusManager.getActiveSessionIds().length); // 3\n   *\n   * // Cleanup first session\n   * conversationStatusManager.unregisterActiveSession('stream-1');\n   * console.log(conversationStatusManager.getActiveSessionIds().length); // 2\n   *\n   * // Cleanup remaining sessions\n   * conversationStatusManager.unregisterActiveSession('stream-2');\n   * conversationStatusManager.unregisterActiveSession('stream-3');\n   * console.log(conversationStatusManager.getActiveSessionIds().length); // 0\n   *\n   * // Use case: Monitor active conversation load, implement rate limiting\n   * ```\n   *\n   * @see {@link registerActiveSession} - Registration method called when session starts\n   * @see {@link getSessionId} - Look up Claude session ID by streaming ID\n   * @see {@link isSessionActive} - Check if session is still active\n   * @see {@link getActiveSessionIds} - Get all active session IDs\n   */\n  unregisterActiveSession(streamingId: string): void {\n    const claudeSessionId = this.streamingToSession.get(streamingId);\n    \n    if (claudeSessionId) {\n      this.logger.debug('Unregistering active session', { \n        streamingId, \n        claudeSessionId \n      });\n\n      this.sessionToStreaming.delete(claudeSessionId);\n      this.streamingToSession.delete(streamingId);\n      this.sessionContext.delete(claudeSessionId);\n\n      this.logger.info('Active session unregistered', { \n        streamingId, \n        claudeSessionId,\n        totalActiveSessions: this.sessionToStreaming.size\n      });\n\n      this.emit('session-ended', { streamingId, claudeSessionId });\n    } else {\n      this.logger.debug('Attempted to unregister unknown streaming session', { streamingId });\n    }\n  }\n\n  /**\n   * Get conversation context for an active session\n   */\n  getConversationContext(claudeSessionId: string): ConversationStatusContext | undefined {\n    const context = this.sessionContext.get(claudeSessionId);\n    this.logger.debug('Getting conversation context', {\n      claudeSessionId,\n      hasContext: !!context\n    });\n    return context;\n  }\n\n  /**\n   * Check if a Claude session ID is currently active (has ongoing stream)\n   */\n  isSessionActive(claudeSessionId: string): boolean {\n    const isActive = this.sessionToStreaming.has(claudeSessionId);\n    return isActive;\n  }\n\n  /**\n   * Get the streaming ID for an active Claude session\n   */\n  getStreamingId(claudeSessionId: string): string | undefined {\n    const streamingId = this.sessionToStreaming.get(claudeSessionId);\n    this.logger.debug('Getting streaming ID for Claude session', { \n      claudeSessionId, \n      streamingId: streamingId || 'not found' \n    });\n    return streamingId;\n  }\n\n  /**\n   * Get the Claude session ID for an active streaming session\n   */\n  getSessionId(streamingId: string): string | undefined {\n    const claudeSessionId = this.streamingToSession.get(streamingId);\n    this.logger.debug('Getting Claude session ID for streaming ID', { \n      streamingId, \n      claudeSessionId: claudeSessionId || 'not found' \n    });\n    return claudeSessionId;\n  }\n\n  /**\n   * Get all active Claude session IDs\n   */\n  getActiveSessionIds(): string[] {\n    const sessions = Array.from(this.sessionToStreaming.keys());\n    this.logger.debug('Getting all active session IDs', { \n      count: sessions.length,\n      sessions \n    });\n    return sessions;\n  }\n\n  /**\n   * Get all active streaming IDs\n   */\n  getActiveStreamingIds(): string[] {\n    const streamingIds = Array.from(this.streamingToSession.keys());\n    this.logger.debug('Getting all active streaming IDs', { \n      count: streamingIds.length,\n      streamingIds \n    });\n    return streamingIds;\n  }\n\n  /**\n   * Get conversation status for a Claude session ID\n   */\n  getConversationStatus(claudeSessionId: string): 'completed' | 'ongoing' | 'pending' {\n    const isActive = this.isSessionActive(claudeSessionId);\n    const status = isActive ? 'ongoing' : 'completed';\n    return status;\n  }\n\n  /**\n   * Get conversations that haven't appeared in history yet\n   *\n   * @description\n   * This method generates optimistic conversation summaries for active streaming sessions\n   * that haven't been persisted to Claude's history files yet. It enables immediate UI\n   * feedback by showing new conversations in the conversation list before the SDK writes\n   * history files to disk.\n   *\n   * **Optimistic UI Pattern:**\n   * 1. User sends a message via ChatService.sendMessage()\n   * 2. ChatService registers session with registerActiveSession()\n   * 3. UI calls getConversationList() which queries this method\n   * 4. This method returns conversation summary with status='ongoing'\n   * 5. UI immediately shows conversation in list (before history file exists)\n   * 6. When stream completes, unregisterActiveSession() is called\n   * 7. UI refreshes from history files (conversation now persisted)\n   *\n   * **How It Works:**\n   * 1. Get all active Claude session IDs from sessionToStreaming map\n   * 2. Filter out sessions that already exist in history files (via existingSessionIds set)\n   * 3. For each remaining session, check if context is stored\n   * 4. Generate ConversationSummary with status='ongoing' and streamingId populated\n   * 5. Return array of summaries for conversations not yet in history\n   *\n   * **Use Cases:**\n   * - Conversation list endpoint: Combine with history reader for complete list\n   * - Real-time UI updates: Show active conversations immediately\n   * - Status monitoring: Track which conversations are still streaming\n   * - Admin dashboard: Monitor active conversation load\n   *\n   * @param {Set<string>} existingSessionIds - Set of session IDs already in history files (to avoid duplicates)\n   *\n   * @returns {ConversationSummary[]} Array of conversation summaries for active sessions not in history\n   *\n   * @example\n   * ```typescript\n   * // Conversation list endpoint - combine history + active sessions\n   * import { conversationStatusManager } from './conversation-status-manager';\n   * import { claudeHistoryReader } from './claude-history-reader';\n   *\n   * async function getConversationList(workingDirectory: string): Promise<ConversationSummary[]> {\n   *   // 1. Read persisted conversations from history files\n   *   const historySummaries = await claudeHistoryReader.getConversationList(workingDirectory);\n   *   const existingSessionIds = new Set(historySummaries.map(s => s.sessionId));\n   *\n   *   // 2. Get active sessions not yet in history\n   *   const activeSummaries = conversationStatusManager.getConversationsNotInHistory(existingSessionIds);\n   *\n   *   // 3. Combine and sort by newest first\n   *   const allSummaries = [...activeSummaries, ...historySummaries];\n   *   allSummaries.sort((a, b) =>\n   *     new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n   *   );\n   *\n   *   return allSummaries;\n   *   // Active sessions: status='ongoing', streamingId populated\n   *   // Completed sessions: status='completed', streamingId=undefined\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Real-time UI update - show conversation immediately\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * conversationStatusManager.on('session-started', ({ claudeSessionId }) => {\n   *   // New conversation just started\n   *   const activeSummaries = conversationStatusManager.getConversationsNotInHistory(new Set());\n   *   const newConversation = activeSummaries.find(s => s.sessionId === claudeSessionId);\n   *\n   *   if (newConversation) {\n   *     // Add to UI immediately (before history file exists)\n   *     addConversationToList({\n   *       sessionId: newConversation.sessionId,\n   *       status: 'ongoing',\n   *       streamingId: newConversation.streamingId,\n   *       model: newConversation.model,\n   *       createdAt: newConversation.createdAt\n   *     });\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Filter active vs persisted conversations\n   * import { conversationStatusManager } from './conversation-status-manager';\n   * import { claudeHistoryReader } from './claude-history-reader';\n   *\n   * async function getConversationsByStatus(workingDirectory: string) {\n   *   const historySummaries = await claudeHistoryReader.getConversationList(workingDirectory);\n   *   const existingSessionIds = new Set(historySummaries.map(s => s.sessionId));\n   *\n   *   // Active conversations (still streaming)\n   *   const activeConversations = conversationStatusManager.getConversationsNotInHistory(existingSessionIds);\n   *   console.log('Active:', activeConversations.map(c => c.sessionId));\n   *\n   *   // Persisted conversations (completed)\n   *   const persistedConversations = historySummaries;\n   *   console.log('Persisted:', persistedConversations.map(c => c.sessionId));\n   *\n   *   return { active: activeConversations, persisted: persistedConversations };\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Edge case - session registered without context\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * // Register session without context\n   * conversationStatusManager.registerActiveSession('stream-1', 'session-1');\n   *\n   * // Query for conversations not in history\n   * const summaries = conversationStatusManager.getConversationsNotInHistory(new Set());\n   * console.log(summaries); // [] (empty - no context means no summary)\n   *\n   * // Register session with context\n   * conversationStatusManager.registerActiveSession('stream-2', 'session-2', {\n   *   initialPrompt: 'Help me debug this code',\n   *   workingDirectory: '/Users/dev/my-project',\n   *   model: 'claude-sonnet-4'\n   * });\n   *\n   * const summaries2 = conversationStatusManager.getConversationsNotInHistory(new Set());\n   * console.log(summaries2.length); // 1 (session-2 included)\n   * ```\n   *\n   * @see {@link registerActiveSession} - Register session with context for optimistic UI\n   * @see {@link getActiveConversationDetails} - Get conversation details for active session\n   * @see {@link ConversationSummary} - Return type interface\n   */\n  getConversationsNotInHistory(existingSessionIds: Set<string>): ConversationSummary[] {\n    const activeSessionIds = this.getActiveSessionIds();\n    \n    const conversationsNotInHistory = activeSessionIds\n      .filter(sessionId => !existingSessionIds.has(sessionId))\n      .map(sessionId => {\n        const context = this.getConversationContext(sessionId);\n        const streamingId = this.getStreamingId(sessionId);\n        \n        if (context && streamingId) {\n          // Create conversation entry for active session\n          const conversationSummary: ConversationSummary = {\n            sessionId,\n            projectPath: context.workingDirectory,\n            summary: '', // No summary for active conversation\n            sessionInfo: {\n              custom_name: '', // No custom name yet\n              created_at: context.timestamp,\n              updated_at: context.timestamp,\n              version: 4,\n              pinned: false,\n              archived: false,\n              continuation_session_id: '',\n              initial_commit_head: '',\n              permission_mode: 'default'\n            },\n            createdAt: context.timestamp,\n            updatedAt: context.timestamp,\n            messageCount: 1, // At least the initial user message\n            totalDuration: 0, // No duration yet\n            model: context.model || 'unknown',\n            status: 'ongoing' as const,\n            streamingId\n          };\n          \n          this.logger.debug('Created conversation summary for active session', {\n            sessionId,\n            streamingId,\n            workingDirectory: context.workingDirectory,\n            model: context.model\n          });\n          \n          return conversationSummary;\n        }\n        \n        return null;\n      })\n      .filter((conversation): conversation is ConversationSummary => conversation !== null);\n\n    this.logger.debug('Generated conversations not in history', {\n      activeSessionCount: activeSessionIds.length,\n      existingSessionCount: existingSessionIds.size,\n      conversationsNotInHistoryCount: conversationsNotInHistory.length\n    });\n\n    return conversationsNotInHistory;\n  }\n\n  /**\n   * Get conversation details if session is active but not in history\n   *\n   * @description\n   * This method generates optimistic conversation details for an active streaming session\n   * that hasn't been persisted to Claude's history files yet. It enables immediate UI\n   * feedback by showing the initial user message and any inherited messages before the\n   * SDK writes the conversation to disk.\n   *\n   * **Optimistic UI Pattern:**\n   * 1. User sends a message via ChatService.sendMessage()\n   * 2. ChatService registers session with registerActiveSession() including context\n   * 3. UI calls getConversationDetails(sessionId) which queries this method first\n   * 4. This method returns conversation with initial user message (+ inherited messages if resuming)\n   * 5. UI immediately shows conversation details (before history file exists)\n   * 6. Assistant response streams in real-time via separate WebSocket/SSE endpoint\n   * 7. When stream completes, unregisterActiveSession() is called\n   * 8. UI refreshes from history files (conversation now persisted with complete messages)\n   *\n   * **How It Works:**\n   * 1. Check if session is active via isSessionActive()\n   * 2. Get conversation context via getConversationContext()\n   * 3. If not active or no context, return null (fallback to history reader)\n   * 4. Build messages array: inherited messages (if any) + initial user message\n   * 5. Return ConversationDetailsResponse with status='ongoing' and partial messages\n   *\n   * **Use Cases:**\n   * - Conversation details endpoint: Try optimistic path first, fallback to history\n   * - Real-time UI updates: Show conversation immediately after user sends message\n   * - Resume conversation: Show previous messages + new user message\n   * - Status monitoring: Check if conversation is still streaming\n   *\n   * @param {string} sessionId - Claude session ID to get details for\n   *\n   * @returns {ConversationDetailsResponse | null} Conversation details if active, null if not active or no context stored\n   *\n   * @example\n   * ```typescript\n   * // Conversation details endpoint - optimistic path first, fallback to history\n   * import { conversationStatusManager } from './conversation-status-manager';\n   * import { claudeHistoryReader } from './claude-history-reader';\n   *\n   * async function getConversationDetails(sessionId: string): Promise<ConversationDetailsResponse> {\n   *   // 1. Try optimistic path (active session)\n   *   const activeDetails = conversationStatusManager.getActiveConversationDetails(sessionId);\n   *   if (activeDetails) {\n   *     return activeDetails;\n   *     // Returns initial user message + inherited messages\n   *     // Assistant response will stream in real-time via separate endpoint\n   *   }\n   *\n   *   // 2. Fallback to history files (completed session)\n   *   const historyDetails = await claudeHistoryReader.getConversationDetails(sessionId);\n   *   return historyDetails;\n   *   // Returns complete conversation with all messages\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Real-time UI update - show conversation immediately\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * conversationStatusManager.on('session-started', ({ claudeSessionId }) => {\n   *   // New conversation just started\n   *   const details = conversationStatusManager.getActiveConversationDetails(claudeSessionId);\n   *\n   *   if (details) {\n   *     // Display initial user message immediately\n   *     displayConversation({\n   *       sessionId: claudeSessionId,\n   *       messages: details.messages, // [{ type: 'user', message: { content: '...' } }]\n   *       status: 'ongoing',\n   *       projectPath: details.projectPath\n   *     });\n   *\n   *     // Assistant response will stream in via WebSocket\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Resume conversation - show previous messages + new user message\n   * import { conversationStatusManager } from './conversation-status-manager';\n   * import { claudeHistoryReader } from './claude-history-reader';\n   *\n   * async function resumeConversation(previousSessionId: string, newMessage: string) {\n   *   // 1. Load previous conversation messages\n   *   const previousDetails = await claudeHistoryReader.getConversationDetails(previousSessionId);\n   *\n   *   // 2. Register new session with inherited messages\n   *   conversationStatusManager.registerActiveSession(\n   *     'stream-uuid-new',\n   *     'session-new-id',\n   *     {\n   *       initialPrompt: newMessage,\n   *       workingDirectory: previousDetails.projectPath,\n   *       model: previousDetails.metadata.model,\n   *       inheritedMessages: previousDetails.messages // Include previous conversation\n   *     }\n   *   );\n   *\n   *   // 3. Get active conversation details\n   *   const activeDetails = conversationStatusManager.getActiveConversationDetails('session-new-id');\n   *   console.log(activeDetails?.messages.length);\n   *   // Includes: [...previousDetails.messages, newUserMessage]\n   *   // UI shows complete conversation history + new user message\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Check if conversation is active vs completed\n   * import { conversationStatusManager } from './conversation-status-manager';\n   * import { claudeHistoryReader } from './claude-history-reader';\n   *\n   * async function getConversationWithStatus(sessionId: string) {\n   *   const activeDetails = conversationStatusManager.getActiveConversationDetails(sessionId);\n   *\n   *   if (activeDetails) {\n   *     // Conversation is still streaming\n   *     return {\n   *       ...activeDetails,\n   *       status: 'ongoing',\n   *       isStreaming: true,\n   *       messages: activeDetails.messages // Partial (user message only)\n   *     };\n   *   }\n   *\n   *   // Conversation is completed\n   *   const historyDetails = await claudeHistoryReader.getConversationDetails(sessionId);\n   *   return {\n   *     ...historyDetails,\n   *     status: 'completed',\n   *     isStreaming: false,\n   *     messages: historyDetails.messages // Complete (all messages)\n   *   };\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Edge case - session registered without context\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * // Register session without context\n   * conversationStatusManager.registerActiveSession('stream-1', 'session-1');\n   *\n   * // Query for conversation details\n   * const details = conversationStatusManager.getActiveConversationDetails('session-1');\n   * console.log(details); // null (no context means no details)\n   *\n   * // Register session with context\n   * conversationStatusManager.registerActiveSession('stream-2', 'session-2', {\n   *   initialPrompt: 'Help me debug this code',\n   *   workingDirectory: '/Users/dev/my-project',\n   *   model: 'claude-sonnet-4'\n   * });\n   *\n   * const details2 = conversationStatusManager.getActiveConversationDetails('session-2');\n   * console.log(details2?.messages.length); // 1 (initial user message)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Message structure for active conversation\n   * import { conversationStatusManager } from './conversation-status-manager';\n   *\n   * conversationStatusManager.registerActiveSession('stream-1', 'session-1', {\n   *   initialPrompt: 'Help me refactor this code',\n   *   workingDirectory: '/Users/dev/my-project',\n   *   model: 'claude-sonnet-4'\n   * });\n   *\n   * const details = conversationStatusManager.getActiveConversationDetails('session-1');\n   * console.log(details);\n   * // {\n   * //   messages: [\n   * //     {\n   * //       uuid: 'active-session-1-user',\n   * //       type: 'user',\n   * //       message: { role: 'user', content: 'Help me refactor this code' },\n   * //       timestamp: '2024-01-15T10:30:00.000Z',\n   * //       sessionId: 'session-1',\n   * //       cwd: '/Users/dev/my-project'\n   * //     }\n   * //   ],\n   * //   summary: '', // No summary for active conversation\n   * //   projectPath: '/Users/dev/my-project',\n   * //   metadata: {\n   * //     totalDuration: 0, // No duration yet\n   * //     model: 'claude-sonnet-4'\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link registerActiveSession} - Register session with context for optimistic UI\n   * @see {@link getConversationsNotInHistory} - Get optimistic conversation summaries\n   * @see {@link ConversationDetailsResponse} - Return type interface\n   */\n  getActiveConversationDetails(sessionId: string): ConversationDetailsResponse | null {\n    const isActive = this.isSessionActive(sessionId);\n    const context = this.getConversationContext(sessionId);\n    \n    this.logger.debug('Checking for active conversation details', {\n      sessionId,\n      isActive,\n      hasContext: !!context\n    });\n    \n    if (!isActive || !context) {\n      return null;\n    }\n\n    // Create messages array\n    const messages: ConversationMessage[] = [];\n    \n    // Add inherited messages first (if any)\n    if (context.inheritedMessages) {\n      messages.push(...context.inheritedMessages);\n    }\n    \n    // Add the current initial prompt message\n    const activeMessage: ConversationMessage = {\n      uuid: `active-${sessionId}-user`,\n      type: 'user',\n      message: {\n        role: 'user',\n        content: context.initialPrompt\n      },\n      timestamp: context.timestamp,\n      sessionId: sessionId,\n      cwd: context.workingDirectory\n    };\n    messages.push(activeMessage);\n    \n    const response: ConversationDetailsResponse = {\n      messages,\n      summary: '', // No summary for active conversation\n      projectPath: context.workingDirectory,\n      metadata: {\n        totalDuration: 0,\n        model: context.model || 'unknown'\n      }\n    };\n    \n    this.logger.debug('Created active conversation details', {\n      sessionId,\n      workingDirectory: context.workingDirectory,\n      model: context.model,\n      totalMessageCount: messages.length,\n      inheritedMessageCount: context.inheritedMessages?.length || 0\n    });\n    \n    return response;\n  }\n\n  /**\n   * Clear all mappings (useful for testing)\n   */\n  clear(): void {\n    this.logger.debug('Clearing all session mappings');\n    this.sessionToStreaming.clear();\n    this.streamingToSession.clear();\n    this.sessionContext.clear();\n  }\n\n  /**\n   * Get statistics about tracked sessions\n   */\n  getStats(): {\n    activeSessionsCount: number;\n    activeStreamingIdsCount: number;\n    activeContextsCount: number;\n    activeSessions: Array<{ claudeSessionId: string; streamingId: string }>;\n  } {\n    const activeSessions = Array.from(this.sessionToStreaming.entries()).map(\n      ([claudeSessionId, streamingId]) => ({ claudeSessionId, streamingId })\n    );\n\n    return {\n      activeSessionsCount: this.sessionToStreaming.size,\n      activeStreamingIdsCount: this.streamingToSession.size,\n      activeContextsCount: this.sessionContext.size,\n      activeSessions\n    };\n  }\n}",
        "last_modified": "2026-01-02T15:10:07.668679"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.539313",
  "last_updated": "2026-01-02T14:06:15.550827"
}