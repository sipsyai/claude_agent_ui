{
  "file_path": "backend/src/api/flow-execution/services/flow-execution.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "/**\n * Flow Execution service\n *\n * Service layer for FlowExecution operations with helper methods for\n * execution lifecycle management, tracking, and reporting.\n */\n\nimport { factories } from '@strapi/strapi';\n\nexport default factories.createCoreService('api::flow-execution.flow-execution', ({ strapi }) => ({\n  /**\n   * Find execution with flow relation populated\n   */\n  async findWithFlow(id: number) {\n    return await strapi.entityService.findOne('api::flow-execution.flow-execution', id, {\n      populate: ['flow'],\n    });\n  },\n\n  /**\n   * Find all executions for a specific flow\n   */\n  async findByFlowId(flowId: number, limit = 10) {\n    return await strapi.entityService.findMany('api::flow-execution.flow-execution', {\n      filters: {\n        flow: { id: { $eq: flowId } },\n      },\n      sort: { createdAt: 'desc' },\n      limit,\n      populate: ['flow'],\n    });\n  },\n\n  /**\n   * Find running executions\n   */\n  async findRunning() {\n    return await strapi.entityService.findMany('api::flow-execution.flow-execution', {\n      filters: {\n        status: 'running',\n      },\n      populate: ['flow'],\n    });\n  },\n\n  /**\n   * Find recent executions across all flows\n   */\n  async findRecent(limit = 20) {\n    return await strapi.entityService.findMany('api::flow-execution.flow-execution', {\n      sort: { createdAt: 'desc' },\n      limit,\n      populate: ['flow'],\n    });\n  },\n\n  /**\n   * Find executions by status\n   */\n  async findByStatus(status: string, limit = 20) {\n    return await strapi.entityService.findMany('api::flow-execution.flow-execution', {\n      filters: {\n        status: { $eq: status },\n      },\n      sort: { createdAt: 'desc' },\n      limit,\n      populate: ['flow'],\n    });\n  },\n\n  /**\n   * Start a new execution\n   */\n  async startExecution(flowId: number, input: any, triggeredBy: string = 'manual', triggerData?: any) {\n    const now = new Date().toISOString();\n\n    return await strapi.entityService.create('api::flow-execution.flow-execution', {\n      data: {\n        flow: flowId,\n        status: 'running',\n        input,\n        startedAt: now,\n        triggeredBy,\n        triggerData,\n        logs: [{\n          timestamp: now,\n          level: 'info',\n          message: 'Flow execution started',\n        }],\n      },\n    });\n  },\n\n  /**\n   * Add a log entry to the execution\n   */\n  async addLog(id: number, level: string, message: string, nodeId?: string) {\n    const execution: any = await strapi.entityService.findOne('api::flow-execution.flow-execution', id);\n\n    if (!execution) {\n      throw new Error(`Execution with ID ${id} not found`);\n    }\n\n    const logs = execution.logs || [];\n    logs.push({\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      nodeId,\n    });\n\n    return await strapi.entityService.update('api::flow-execution.flow-execution', id, {\n      data: { logs },\n    });\n  },\n\n  /**\n   * Update node execution state\n   */\n  async updateNodeExecution(id: number, nodeId: string, nodeState: any) {\n    const execution: any = await strapi.entityService.findOne('api::flow-execution.flow-execution', id);\n\n    if (!execution) {\n      throw new Error(`Execution with ID ${id} not found`);\n    }\n\n    const nodeExecutions = execution.nodeExecutions || [];\n    const existingIndex = nodeExecutions.findIndex((n: any) => n.nodeId === nodeId);\n\n    if (existingIndex >= 0) {\n      nodeExecutions[existingIndex] = { ...nodeExecutions[existingIndex], ...nodeState };\n    } else {\n      nodeExecutions.push({ nodeId, ...nodeState });\n    }\n\n    return await strapi.entityService.update('api::flow-execution.flow-execution', id, {\n      data: {\n        nodeExecutions,\n        currentNodeId: nodeState.status === 'running' ? nodeId : execution.currentNodeId,\n      },\n    });\n  },\n\n  /**\n   * Complete an execution successfully\n   */\n  async completeExecution(id: number, output: any, tokensUsed: number = 0, cost: number = 0) {\n    const execution: any = await strapi.entityService.findOne('api::flow-execution.flow-execution', id);\n\n    if (!execution) {\n      throw new Error(`Execution with ID ${id} not found`);\n    }\n\n    const now = new Date();\n    const startedAt = new Date(execution.startedAt);\n    const executionTime = now.getTime() - startedAt.getTime();\n\n    const logs = execution.logs || [];\n    logs.push({\n      timestamp: now.toISOString(),\n      level: 'info',\n      message: 'Flow execution completed successfully',\n    });\n\n    return await strapi.entityService.update('api::flow-execution.flow-execution', id, {\n      data: {\n        status: 'completed',\n        output,\n        completedAt: now.toISOString(),\n        executionTime,\n        tokensUsed: (execution.tokensUsed || 0) + tokensUsed,\n        cost: (execution.cost || 0) + cost,\n        currentNodeId: null,\n        logs,\n      },\n    });\n  },\n\n  /**\n   * Fail an execution\n   */\n  async failExecution(id: number, error: string, errorDetails?: any) {\n    const execution: any = await strapi.entityService.findOne('api::flow-execution.flow-execution', id);\n\n    if (!execution) {\n      throw new Error(`Execution with ID ${id} not found`);\n    }\n\n    const now = new Date();\n    const startedAt = new Date(execution.startedAt);\n    const executionTime = now.getTime() - startedAt.getTime();\n\n    const logs = execution.logs || [];\n    logs.push({\n      timestamp: now.toISOString(),\n      level: 'error',\n      message: `Flow execution failed: ${error}`,\n    });\n\n    return await strapi.entityService.update('api::flow-execution.flow-execution', id, {\n      data: {\n        status: 'failed',\n        error,\n        errorDetails,\n        completedAt: now.toISOString(),\n        executionTime,\n        currentNodeId: null,\n        logs,\n      },\n    });\n  },\n\n  /**\n   * Cancel an execution\n   */\n  async cancelExecution(id: number) {\n    const execution: any = await strapi.entityService.findOne('api::flow-execution.flow-execution', id);\n\n    if (!execution) {\n      throw new Error(`Execution with ID ${id} not found`);\n    }\n\n    if (execution.status !== 'running' && execution.status !== 'pending') {\n      throw new Error('Can only cancel running or pending executions');\n    }\n\n    const now = new Date();\n    const startedAt = new Date(execution.startedAt);\n    const executionTime = now.getTime() - startedAt.getTime();\n\n    const logs = execution.logs || [];\n    logs.push({\n      timestamp: now.toISOString(),\n      level: 'warn',\n      message: 'Flow execution cancelled by user',\n    });\n\n    return await strapi.entityService.update('api::flow-execution.flow-execution', id, {\n      data: {\n        status: 'cancelled',\n        completedAt: now.toISOString(),\n        executionTime,\n        currentNodeId: null,\n        logs,\n      },\n    });\n  },\n\n  /**\n   * Retry a failed execution\n   */\n  async retryExecution(id: number) {\n    const execution: any = await strapi.entityService.findOne('api::flow-execution.flow-execution', id, {\n      populate: ['flow'],\n    });\n\n    if (!execution) {\n      throw new Error(`Execution with ID ${id} not found`);\n    }\n\n    if (execution.status !== 'failed' && execution.status !== 'cancelled') {\n      throw new Error('Can only retry failed or cancelled executions');\n    }\n\n    if (!execution.flow) {\n      throw new Error('Cannot retry execution: Flow not found');\n    }\n\n    const now = new Date().toISOString();\n    const newRetryCount = (execution.retryCount || 0) + 1;\n\n    // Create a new execution as a retry\n    return await strapi.entityService.create('api::flow-execution.flow-execution', {\n      data: {\n        flow: execution.flow.id,\n        status: 'running',\n        input: execution.input,\n        startedAt: now,\n        triggeredBy: 'api',\n        triggerData: {\n          isRetry: true,\n          originalExecutionId: id,\n          retryNumber: newRetryCount,\n        },\n        retryCount: newRetryCount,\n        parentExecutionId: id,\n        logs: [{\n          timestamp: now,\n          level: 'info',\n          message: `Retry #${newRetryCount} started (original execution: ${id})`,\n        }],\n        metadata: {\n          ...(execution.metadata || {}),\n          retryOf: id,\n        },\n      },\n    });\n  },\n\n  /**\n   * Get execution statistics for a flow\n   */\n  async getFlowStats(flowId: number) {\n    const executions = await strapi.entityService.findMany('api::flow-execution.flow-execution', {\n      filters: {\n        flow: { id: { $eq: flowId } },\n      },\n      sort: { createdAt: 'desc' },\n    }) as any[];\n\n    const total = executions.length;\n    const completed = executions.filter(e => e.status === 'completed').length;\n    const failed = executions.filter(e => e.status === 'failed').length;\n    const running = executions.filter(e => e.status === 'running').length;\n    const cancelled = executions.filter(e => e.status === 'cancelled').length;\n    const pending = executions.filter(e => e.status === 'pending').length;\n\n    const completedExecutions = executions.filter(e => e.status === 'completed' && e.executionTime);\n    const avgExecutionTime = completedExecutions.length > 0\n      ? completedExecutions.reduce((sum, e) => sum + (e.executionTime || 0), 0) / completedExecutions.length\n      : 0;\n\n    const totalTokensUsed = executions.reduce((sum, e) => sum + (e.tokensUsed || 0), 0);\n    const totalCost = executions.reduce((sum, e) => sum + parseFloat(e.cost || 0), 0);\n\n    return {\n      total,\n      completed,\n      failed,\n      running,\n      cancelled,\n      pending,\n      successRate: total > 0 ? (completed / total * 100).toFixed(1) : '0',\n      failureRate: total > 0 ? (failed / total * 100).toFixed(1) : '0',\n      avgExecutionTime: Math.round(avgExecutionTime),\n      totalTokensUsed,\n      totalCost: totalCost.toFixed(4),\n      lastExecution: executions[0] || null,\n    };\n  },\n\n  /**\n   * Get global execution statistics across all flows\n   */\n  async getGlobalStats() {\n    const executions = await strapi.entityService.findMany('api::flow-execution.flow-execution', {\n      sort: { createdAt: 'desc' },\n    }) as any[];\n\n    const total = executions.length;\n    const completed = executions.filter(e => e.status === 'completed').length;\n    const failed = executions.filter(e => e.status === 'failed').length;\n    const running = executions.filter(e => e.status === 'running').length;\n    const cancelled = executions.filter(e => e.status === 'cancelled').length;\n    const pending = executions.filter(e => e.status === 'pending').length;\n\n    const completedExecutions = executions.filter(e => e.status === 'completed' && e.executionTime);\n    const avgExecutionTime = completedExecutions.length > 0\n      ? completedExecutions.reduce((sum, e) => sum + (e.executionTime || 0), 0) / completedExecutions.length\n      : 0;\n\n    const totalTokensUsed = executions.reduce((sum, e) => sum + (e.tokensUsed || 0), 0);\n    const totalCost = executions.reduce((sum, e) => sum + parseFloat(e.cost || 0), 0);\n\n    // Count executions by trigger type\n    const byTrigger = {\n      manual: executions.filter(e => e.triggeredBy === 'manual').length,\n      schedule: executions.filter(e => e.triggeredBy === 'schedule').length,\n      webhook: executions.filter(e => e.triggeredBy === 'webhook').length,\n      api: executions.filter(e => e.triggeredBy === 'api').length,\n    };\n\n    // Get unique flow count\n    const uniqueFlowIds = new Set(executions.map(e => e.flow?.id).filter(Boolean));\n\n    // Get today's executions\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const todayExecutions = executions.filter(e => new Date(e.createdAt) >= today);\n\n    return {\n      total,\n      completed,\n      failed,\n      running,\n      cancelled,\n      pending,\n      successRate: total > 0 ? (completed / total * 100).toFixed(1) : '0',\n      failureRate: total > 0 ? (failed / total * 100).toFixed(1) : '0',\n      avgExecutionTime: Math.round(avgExecutionTime),\n      totalTokensUsed,\n      totalCost: totalCost.toFixed(4),\n      uniqueFlows: uniqueFlowIds.size,\n      byTrigger,\n      todayCount: todayExecutions.length,\n      lastExecution: executions[0] || null,\n    };\n  },\n\n  /**\n   * Clean up old executions\n   */\n  async cleanupOld(olderThanDays: number = 30, status?: string) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n\n    const filters: any = {\n      createdAt: { $lt: cutoffDate.toISOString() },\n    };\n\n    // Only clean up finished executions (not running or pending)\n    if (status) {\n      filters.status = { $eq: status };\n    } else {\n      filters.status = { $in: ['completed', 'failed', 'cancelled'] };\n    }\n\n    const executions = await strapi.entityService.findMany('api::flow-execution.flow-execution', {\n      filters,\n    }) as any[];\n\n    // Delete each execution\n    let deletedCount = 0;\n    for (const execution of executions) {\n      await strapi.entityService.delete('api::flow-execution.flow-execution', execution.id);\n      deletedCount++;\n    }\n\n    return deletedCount;\n  },\n\n  /**\n   * Get execution timeline (for visualization)\n   */\n  async getExecutionTimeline(id: number) {\n    const execution: any = await strapi.entityService.findOne('api::flow-execution.flow-execution', id);\n\n    if (!execution) {\n      throw new Error(`Execution with ID ${id} not found`);\n    }\n\n    const timeline = [];\n    const logs = execution.logs || [];\n    const nodeExecutions = execution.nodeExecutions || [];\n\n    // Add start event\n    if (execution.startedAt) {\n      timeline.push({\n        type: 'start',\n        timestamp: execution.startedAt,\n        message: 'Execution started',\n      });\n    }\n\n    // Add log entries\n    for (const log of logs) {\n      timeline.push({\n        type: 'log',\n        timestamp: log.timestamp,\n        level: log.level,\n        message: log.message,\n        nodeId: log.nodeId,\n      });\n    }\n\n    // Add node execution events\n    for (const node of nodeExecutions) {\n      if (node.startedAt) {\n        timeline.push({\n          type: 'node_start',\n          timestamp: node.startedAt,\n          nodeId: node.nodeId,\n          message: `Node ${node.nodeId} started`,\n        });\n      }\n      if (node.completedAt) {\n        timeline.push({\n          type: 'node_complete',\n          timestamp: node.completedAt,\n          nodeId: node.nodeId,\n          status: node.status,\n          message: `Node ${node.nodeId} ${node.status}`,\n        });\n      }\n    }\n\n    // Add completion event\n    if (execution.completedAt) {\n      timeline.push({\n        type: 'complete',\n        timestamp: execution.completedAt,\n        status: execution.status,\n        message: `Execution ${execution.status}`,\n      });\n    }\n\n    // Sort by timestamp\n    timeline.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n\n    return timeline;\n  },\n\n  /**\n   * Get execution summary\n   */\n  async getExecutionSummary(id: number) {\n    const execution: any = await strapi.entityService.findOne('api::flow-execution.flow-execution', id, {\n      populate: ['flow'],\n    });\n\n    if (!execution) {\n      throw new Error(`Execution with ID ${id} not found`);\n    }\n\n    const nodeExecutions = execution.nodeExecutions || [];\n    const nodesCompleted = nodeExecutions.filter((n: any) => n.status === 'completed').length;\n    const nodesFailed = nodeExecutions.filter((n: any) => n.status === 'failed').length;\n    const totalNodes = nodeExecutions.length;\n\n    return {\n      id: execution.id,\n      flowId: execution.flow?.id,\n      flowName: execution.flow?.name,\n      status: execution.status,\n      triggeredBy: execution.triggeredBy,\n      startedAt: execution.startedAt,\n      completedAt: execution.completedAt,\n      executionTime: execution.executionTime,\n      tokensUsed: execution.tokensUsed,\n      cost: execution.cost,\n      progress: {\n        totalNodes,\n        nodesCompleted,\n        nodesFailed,\n        percentage: totalNodes > 0 ? Math.round((nodesCompleted / totalNodes) * 100) : 0,\n      },\n      hasError: !!execution.error,\n      error: execution.error,\n      retryCount: execution.retryCount,\n      isRetry: !!execution.parentExecutionId,\n    };\n  },\n}));\n",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:47.252449",
  "last_updated": "2026-01-02T15:21:47.263369"
}