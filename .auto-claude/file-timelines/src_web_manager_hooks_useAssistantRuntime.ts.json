{
  "file_path": "src/web/manager/hooks/useAssistantRuntime.ts",
  "main_branch_history": [],
  "task_views": {
    "004-document-frontend-react-components-and-hooks": {
      "task_id": "004-document-frontend-react-components-and-hooks",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "/**\n * Custom assistant-ui runtime adapter for Claude Agent SDK\n * Uses ExternalStoreAdapter to connect assistant-ui to our existing SSE streaming API\n * WITHOUT changing the backend Claude Agent SDK implementation\n */\n\nimport { useEffect, useState, useCallback, useMemo } from 'react';\nimport {\n  useExternalStoreRuntime,\n  type ThreadMessage,\n  type AppendMessage,\n} from '@assistant-ui/react';\nimport * as chatApi from '../services/chat-api';\nimport { SDKEventParser, type ToolUseData, type SystemMessageData } from '../utils/sdk-event-parser';\n\ninterface UseAssistantRuntimeProps {\n  sessionId: string | null;\n  initialMessages: chatApi.ChatMessage[];\n  onMessagesUpdate: (messages: chatApi.ChatMessage[]) => void;\n  permissionMode: 'default' | 'bypass' | 'auto' | 'plan';\n  agentId?: string;\n  skillIds?: string[];\n  // SDK event handlers\n  onToolUseUpdate?: (toolUses: Map<string, ToolUseData>) => void;\n  onSystemMessage?: (message: SystemMessageData) => void;\n}\n\n/**\n * Custom hook to create an assistant-ui runtime that works with our existing API\n */\nexport function useAssistantRuntime({\n  sessionId,\n  initialMessages,\n  onMessagesUpdate,\n  permissionMode,\n  agentId,\n  skillIds,\n  onToolUseUpdate,\n  onSystemMessage,\n}: UseAssistantRuntimeProps) {\n  const [messages, setMessages] = useState<ThreadMessage[]>([]);\n  const [isRunning, setIsRunning] = useState(false);\n\n  // SDK event tracking\n  const [toolUses, setToolUses] = useState<Map<string, ToolUseData>>(new Map());\n  const [currentMessageId, setCurrentMessageId] = useState<string | null>(null);\n\n  // Stream cancellation tracking\n  const [currentStreamId, setCurrentStreamId] = useState<string | null>(null);\n\n  // Convert our ChatMessage to assistant-ui ThreadMessage format\n  const convertToThreadMessage = useCallback((msg: chatApi.ChatMessage): ThreadMessage => {\n    const baseMessage = {\n      id: msg.documentId,\n      createdAt: new Date(msg.timestamp),\n      status: { type: 'complete' as const, reason: 'stop' as const },\n      content: [\n        {\n          type: 'text' as const,\n          text: msg.content,\n        },\n      ],\n      metadata: {\n        custom: msg.metadata || {},\n      },\n    };\n\n    if (msg.role === 'user') {\n      return {\n        ...baseMessage,\n        role: 'user' as const,\n        attachments: [],\n      } as unknown as ThreadMessage;\n    } else if (msg.role === 'assistant') {\n      return {\n        ...baseMessage,\n        role: 'assistant' as const,\n      } as unknown as ThreadMessage;\n    } else {\n      return {\n        ...baseMessage,\n        role: 'system' as const,\n        content: [{ type: 'text' as const, text: msg.content }],\n      } as unknown as ThreadMessage;\n    }\n  }, []);\n\n  // Sync initial messages from props\n  useEffect(() => {\n    if (initialMessages.length > 0) {\n      setMessages(initialMessages.map(convertToThreadMessage));\n    } else {\n      setMessages([]);\n    }\n  }, [initialMessages, convertToThreadMessage]);\n\n  // Get directory from cookies\n  const getDirectory = useCallback(() => {\n    const cookies = document.cookie.split(';');\n    for (const cookie of cookies) {\n      const [name, value] = cookie.trim().split('=');\n      if (name === 'selectedDirectory') {\n        return decodeURIComponent(value);\n      }\n    }\n    return undefined;\n  }, []);\n\n  // Throttling for delta updates (50ms)\n  // Accumulates rapid deltas and updates UI in batches for better performance\n  const throttledUpdate = useMemo(() => {\n    let timeout: NodeJS.Timeout | null = null;\n    let pendingUpdate: (() => void) | null = null;\n\n    return (updateFn: () => void) => {\n      pendingUpdate = updateFn;\n\n      if (!timeout) {\n        timeout = setTimeout(() => {\n          if (pendingUpdate) {\n            pendingUpdate();\n          }\n          timeout = null;\n          pendingUpdate = null;\n        }, 50); // 50ms throttle - balances responsiveness with performance\n      }\n    };\n  }, []);\n\n  // Handle new message sending\n  const handleNewMessage = useCallback(\n    async (message: AppendMessage) => {\n      if (!sessionId) return;\n\n      setIsRunning(true);\n\n      try {\n        const directory = getDirectory();\n        const textContent = message.content.find((c) => c.type === 'text');\n        if (!textContent || textContent.type !== 'text') return;\n\n        const messageText = textContent.text;\n\n        // Create optimistic user message\n        const optimisticUserMessage: ThreadMessage = {\n          id: `temp-${Date.now()}`,\n          role: 'user' as const,\n          content: [{ type: 'text' as const, text: messageText }],\n          attachments: [],\n          createdAt: new Date(),\n          status: { type: 'complete' as const, reason: 'stop' as const },\n          metadata: {\n            custom: {},\n          },\n        } as unknown as ThreadMessage;\n\n        setMessages((prev) => [...prev, optimisticUserMessage]);\n\n        // Send message via SSE\n        const eventSource = chatApi.sendChatMessage(\n          sessionId,\n          messageText,\n          [], // attachments - to be implemented later\n          directory,\n          permissionMode,\n          agentId,\n          skillIds\n        );\n\n        let assistantMessageContent = '';\n        let assistantMessageId = '';\n\n        eventSource.addEventListener('message', async (event: MessageEvent) => {\n          try {\n            const data = JSON.parse(event.data);\n\n            if (data.type === 'stream_id') {\n              // Capture stream ID for cancellation\n              setCurrentStreamId(data.streamId);\n              console.log('Stream started with ID:', data.streamId);\n            } else if (data.type === 'user_message_saved') {\n              // Replace optimistic user message with real one\n              const realUserMessage = convertToThreadMessage(data.message);\n              setMessages((prev) =>\n                prev.map((msg) =>\n                  msg.id === optimisticUserMessage.id ? realUserMessage : msg\n                )\n              );\n            } else if (data.type === 'assistant_message_start') {\n              // Start assistant message\n              assistantMessageId = `temp-assistant-${Date.now()}`;\n              assistantMessageContent = '';\n            } else if (data.type === 'assistant_message_delta') {\n              // Stream assistant message content\n              assistantMessageContent += data.delta || '';\n\n              // Use throttling to batch rapid updates for better performance\n              throttledUpdate(() => {\n                const streamingMessage: ThreadMessage = {\n                  id: assistantMessageId,\n                  role: 'assistant' as const,\n                  content: [{ type: 'text' as const, text: assistantMessageContent }],\n                  createdAt: new Date(),\n                  status: { type: 'running' as const },\n                  metadata: {\n                    custom: {},\n                  },\n                } as unknown as ThreadMessage;\n\n                setMessages((prev) => {\n                  const withoutStreaming = prev.filter((m) => m.id !== assistantMessageId);\n                  return [...withoutStreaming, streamingMessage];\n                });\n              });\n            } else if (data.type === 'assistant_message_saved') {\n              // Replace streaming message with final saved message\n              const realAssistantMessage = convertToThreadMessage(data.message);\n              setMessages((prev) =>\n                prev.map((msg) =>\n                  msg.id === assistantMessageId ? realAssistantMessage : msg\n                )\n              );\n              // Get current messages from Strapi to ensure sync\n              const currentMessages = await chatApi.getChatMessages(sessionId);\n              onMessagesUpdate(currentMessages);\n            } else if (data.type === 'sdk_message') {\n              // Handle SDK messages (tool uses, tool results, system messages)\n              const sdkMsg = data.data;\n\n              // Set current message ID for tracking\n              if (assistantMessageId) {\n                setCurrentMessageId(assistantMessageId);\n              }\n\n              // Process assistant messages for tool_use blocks\n              if (sdkMsg.type === 'assistant' && SDKEventParser.hasToolUses(sdkMsg)) {\n                const newToolUses = SDKEventParser.extractToolUses(sdkMsg, assistantMessageId);\n\n                setToolUses((prev) => {\n                  const updated = new Map(prev);\n                  newToolUses.forEach((toolUse) => {\n                    updated.set(toolUse.id, toolUse);\n                  });\n                  return updated;\n                });\n\n                // Notify parent component\n                if (onToolUseUpdate) {\n                  setToolUses((currentToolUses) => {\n                    onToolUseUpdate(currentToolUses);\n                    return currentToolUses;\n                  });\n                }\n              }\n\n              // Process user messages for tool_result blocks\n              else if (sdkMsg.type === 'user' && SDKEventParser.hasToolResults(sdkMsg)) {\n                const results = SDKEventParser.extractToolResults(sdkMsg);\n\n                setToolUses((prev) => {\n                  const updated = new Map(prev);\n                  results.forEach((result, toolUseId) => {\n                    const toolUse = updated.get(toolUseId);\n                    if (toolUse) {\n                      updated.set(\n                        toolUseId,\n                        SDKEventParser.updateToolUseWithResult(toolUse, result)\n                      );\n                    }\n                  });\n                  return updated;\n                });\n\n                // Notify parent component\n                if (onToolUseUpdate) {\n                  setToolUses((currentToolUses) => {\n                    onToolUseUpdate(currentToolUses);\n                    return currentToolUses;\n                  });\n                }\n              }\n\n              // Process system messages\n              else if (sdkMsg.type === 'system') {\n                const systemMsg = SDKEventParser.parseSystemMessage(sdkMsg, assistantMessageId);\n\n                // Notify parent component\n                if (onSystemMessage) {\n                  onSystemMessage(systemMsg);\n                }\n              }\n            } else if (data.type === 'cancelled') {\n              console.log('Stream cancelled:', data.streamId);\n              setIsRunning(false);\n              setCurrentStreamId(null);\n              // Reload all messages to ensure sync\n              const currentMessages = await chatApi.getChatMessages(sessionId);\n              onMessagesUpdate(currentMessages);\n            } else if (data.type === 'done') {\n              console.log('Streaming complete');\n              setIsRunning(false);\n              setCurrentStreamId(null);\n              // Reload all messages to ensure sync\n              const currentMessages = await chatApi.getChatMessages(sessionId);\n              onMessagesUpdate(currentMessages);\n            } else if (data.type === 'error') {\n              console.error('Chat error:', data.error);\n              // Only show alert for real errors, not for cancellations\n              if (!data.error?.includes('abort')) {\n                alert(`Chat error: ${data.error}`);\n              }\n              setIsRunning(false);\n              setCurrentStreamId(null);\n            }\n          } catch (e) {\n            console.error('Failed to parse SSE message:', e);\n          }\n        });\n\n        eventSource.addEventListener('error', (event: Event) => {\n          console.error('SSE error:', event);\n          setIsRunning(false);\n        });\n      } catch (error) {\n        console.error('Failed to send message:', error);\n        alert('Failed to send message');\n        setIsRunning(false);\n      }\n    },\n    [sessionId, getDirectory, convertToThreadMessage, initialMessages, onMessagesUpdate, permissionMode, agentId, skillIds, onToolUseUpdate, onSystemMessage]\n  );\n\n  // Handle cancel\n  const handleCancel = useCallback(async () => {\n    if (!sessionId || !currentStreamId) {\n      // Silently ignore if no active stream (already cancelled or completed)\n      return;\n    }\n\n    try {\n      console.log('Cancelling stream:', currentStreamId);\n      await chatApi.cancelMessage(sessionId, currentStreamId);\n      // The 'cancelled' event handler will clean up state\n    } catch (error) {\n      console.error('Failed to cancel message:', error);\n      // Fallback: clean up state manually\n      setIsRunning(false);\n      setCurrentStreamId(null);\n    }\n  }, [sessionId, currentStreamId]);\n\n  // Wrapper for setMessages to match ExternalStoreAdapter signature\n  const handleSetMessages = useCallback((newMessages: readonly ThreadMessage[]) => {\n    setMessages([...newMessages]);\n  }, []);\n\n  // Create external store adapter\n  const adapter = useMemo(\n    () => ({\n      isRunning,\n      messages,\n      setMessages: handleSetMessages,\n      onNew: handleNewMessage,\n      onCancel: handleCancel,\n    }),\n    [isRunning, messages, handleSetMessages, handleNewMessage, handleCancel]\n  );\n\n  // Create runtime using useExternalStoreRuntime\n  const runtime = useExternalStoreRuntime(adapter);\n\n  return runtime;\n}\n",
        "timestamp": "2026-01-02T14:22:14.293924"
      },
      "worktree_state": {
        "content": "/**\n * useAssistantRuntime Hook\n *\n * A custom React hook that creates an assistant-ui runtime adapter for Claude Agent SDK.\n * This hook bridges assistant-ui's ExternalStoreAdapter with the existing SSE streaming API,\n * enabling rich chat UI features without modifying the backend Claude Agent SDK implementation.\n *\n * ## Features\n * - **Assistant-UI Integration**: Seamless connection between assistant-ui and Claude Agent SDK\n * - **SSE Streaming**: Real-time message streaming with Server-Sent Events\n * - **Message Format Conversion**: Automatic bidirectional conversion between ChatMessage and ThreadMessage\n * - **SDK Event Tracking**: Comprehensive tracking of tool uses, tool results, and system messages\n * - **Performance Optimization**: Throttled updates (50ms) for rapid message deltas\n * - **Stream Cancellation**: User-initiated cancellation with proper cleanup\n * - **Directory Integration**: Automatic directory selection from cookies\n * - **Permission Modes**: Support for default, bypass, auto, and plan permission modes\n * - **Agent & Skill Binding**: Optional agent and skill association for messages\n *\n * ## Runtime State\n * The hook manages the following runtime state:\n *\n * ### Message State\n * - `messages`: Array of ThreadMessage objects compatible with assistant-ui\n * - Synchronized with initialMessages prop from parent component\n * - Automatically converted from ChatMessage to ThreadMessage format\n * - Updated in real-time as SSE events stream in\n * - Includes optimistic updates for user messages\n *\n * ### Running State\n * - `isRunning`: True when actively processing a message (sending or streaming response)\n * - Set to true when user sends message\n * - Set to false when stream completes, is cancelled, or encounters error\n * - Used by assistant-ui to show loading indicators and disable input\n *\n * ### SDK Event State\n * - `toolUses`: Map of tool use ID to ToolUseData (tool invocations and their results)\n * - `currentMessageId`: ID of message currently being processed\n * - Updated as SDK events arrive via SSE stream\n * - Propagated to parent via onToolUseUpdate and onSystemMessage callbacks\n *\n * ### Stream Control State\n * - `currentStreamId`: ID of active SSE stream for cancellation\n * - Set when stream_id event received\n * - Cleared when stream completes or is cancelled\n * - Used by handleCancel to abort active streams\n *\n * ## Message Handling\n * The hook implements comprehensive message handling:\n *\n * ### Message Flow\n * 1. **User Input**: User types message in assistant-ui composer\n * 2. **Optimistic Update**: Add temporary user message to UI immediately\n * 3. **API Request**: Send message via SSE to backend\n * 4. **Stream ID**: Receive stream_id for cancellation support\n * 5. **User Saved**: Replace optimistic message with real persisted message\n * 6. **Assistant Start**: Begin streaming assistant response\n * 7. **Assistant Delta**: Stream response content in chunks (throttled updates)\n * 8. **SDK Events**: Process tool_use, tool_result, and system messages\n * 9. **Assistant Saved**: Replace streaming message with final persisted message\n * 10. **Done**: Mark stream complete, sync messages from backend\n *\n * ### Message Format Conversion\n * Converts ChatMessage (backend format) to ThreadMessage (assistant-ui format):\n * - Maps role (user/assistant/system) to assistant-ui types\n * - Converts content to content array with type-tagged blocks\n * - Adds status (complete/running) based on streaming state\n * - Preserves metadata in custom field\n * - Generates proper timestamps and IDs\n *\n * ### Optimistic Updates\n * - User messages shown immediately before backend confirmation\n * - Temporary IDs (`temp-{timestamp}`) replaced with real document IDs\n * - Streaming assistant messages shown with \"running\" status\n * - Final messages replace streaming versions when persisted\n *\n * ### Throttled Updates\n * Performance optimization for rapid message deltas:\n * - Accumulates rapid delta events (50ms window)\n * - Batches UI updates to prevent excessive re-renders\n * - Balances responsiveness (feels real-time) with performance\n * - Only applies to delta events, not final saved messages\n *\n * ## Integration with Assistant UI\n * The hook creates an ExternalStoreAdapter for assistant-ui:\n *\n * ### Adapter Interface\n * - `messages`: Current thread messages (readonly)\n * - `setMessages`: Update messages (not typically used with SSE streaming)\n * - `isRunning`: Processing state flag\n * - `onNew`: Handler for new user messages\n * - `onCancel`: Handler for stream cancellation\n *\n * ### Assistant-UI Components\n * Compatible with all assistant-ui components:\n * - `<Thread>`: Main conversation view\n * - `<ThreadMessages>`: Message list rendering\n * - `<Composer>`: Message input with send button\n * - `<AssistantMessage>`: Assistant message display\n * - `<UserMessage>`: User message display\n * - Custom components via assistant-ui primitives\n *\n * ### Event Propagation\n * SDK events are extracted and propagated to parent:\n * - Tool uses: Passed to onToolUseUpdate callback\n * - System messages: Passed to onSystemMessage callback\n * - Parent can display these in custom UI (e.g., ToolUseDisplay component)\n *\n * ## SSE Event Handling\n * The hook processes multiple SSE event types:\n *\n * ### Event Types\n * - **stream_id**: Capture stream ID for cancellation\n * - **user_message_saved**: Replace optimistic user message with persisted version\n * - **assistant_message_start**: Begin streaming assistant response\n * - **assistant_message_delta**: Append content chunks to streaming message\n * - **assistant_message_saved**: Replace streaming message with persisted version\n * - **sdk_message**: Process SDK events (tool_use, tool_result, system)\n * - **cancelled**: Handle stream cancellation, reload messages\n * - **done**: Mark completion, reload messages from backend\n * - **error**: Handle errors, show alert (except for expected abort errors)\n *\n * ### SDK Message Processing\n * - **assistant messages**: Extract tool_use blocks, create ToolUseData entries\n * - **user messages**: Extract tool_result blocks, update ToolUseData with results\n * - **system messages**: Parse and propagate to onSystemMessage callback\n *\n * ### Stream Cancellation\n * User can cancel active streams:\n * - Click stop button in assistant-ui composer\n * - Calls handleCancel which invokes chatApi.cancelMessage\n * - Backend aborts SSE stream and Claude Agent SDK request\n * - Cancelled event triggers message reload for consistency\n * - Silently ignores if no active stream (already complete/cancelled)\n *\n * ## Directory Integration\n * The hook integrates with directory selection:\n * - Reads `selectedDirectory` cookie from browser\n * - Passes directory to chatApi.sendChatMessage\n * - Backend uses directory for file operations (Read, Write, Bash, etc.)\n * - Cookie updated by Layout component's directory selector\n *\n * ## Permission Modes\n * Supports four permission modes for tool execution:\n * - **default**: Prompt user for permission before each tool use\n * - **bypass**: Skip permission prompts, execute all tools automatically\n * - **auto**: Auto-approve safe tools, prompt for dangerous tools\n * - **plan**: Agent plans before execution, user approves plan\n *\n * ## Lifecycle\n * The typical usage flow:\n *\n * 1. **Initialize**: Parent component creates chat session, loads initial messages\n * 2. **Mount**: useAssistantRuntime called with sessionId and initialMessages\n * 3. **Sync**: Hook converts initialMessages to ThreadMessage format\n * 4. **Render**: assistant-ui components render thread with messages\n * 5. **User Input**: User types message, clicks send\n * 6. **Send**: handleNewMessage sends message via SSE\n * 7. **Stream**: Hook processes SSE events, updates messages state\n * 8. **SDK Events**: Tool uses and system messages extracted and propagated\n * 9. **Complete**: Stream finishes, messages synced from backend\n * 10. **Repeat**: User sends more messages, cycle continues\n * 11. **Cancel** (optional): User clicks stop, stream cancelled\n * 12. **Unmount**: Component cleanup (event listeners removed automatically)\n *\n * @example\n * // Basic usage with chat session\n * function ChatInterface({ sessionId }: { sessionId: string }) {\n *   const [messages, setMessages] = useState<ChatMessage[]>([]);\n *\n *   // Load messages on mount\n *   useEffect(() => {\n *     if (sessionId) {\n *       chatApi.getChatMessages(sessionId).then(setMessages);\n *     }\n *   }, [sessionId]);\n *\n *   // Create runtime\n *   const runtime = useAssistantRuntime({\n *     sessionId,\n *     initialMessages: messages,\n *     onMessagesUpdate: setMessages,\n *     permissionMode: 'default',\n *   });\n *\n *   return (\n *     <AssistantRuntimeProvider runtime={runtime}>\n *       <Thread />\n *     </AssistantRuntimeProvider>\n *   );\n * }\n *\n * @example\n * // With agent and skill binding\n * const runtime = useAssistantRuntime({\n *   sessionId: 'session-123',\n *   initialMessages: messages,\n *   onMessagesUpdate: setMessages,\n *   permissionMode: 'auto',\n *   agentId: 'agent-456',\n *   skillIds: ['skill-1', 'skill-2'],\n * });\n *\n * @example\n * // With SDK event tracking for tool use display\n * function ChatWithToolDisplay({ sessionId }: { sessionId: string }) {\n *   const [messages, setMessages] = useState<ChatMessage[]>([]);\n *   const [toolUses, setToolUses] = useState<Map<string, ToolUseData>>(new Map());\n *\n *   const runtime = useAssistantRuntime({\n *     sessionId,\n *     initialMessages: messages,\n *     onMessagesUpdate: setMessages,\n *     permissionMode: 'default',\n *     onToolUseUpdate: (updates) => {\n *       setToolUses(new Map(updates));\n *     },\n *     onSystemMessage: (msg) => {\n *       console.log('System message:', msg.text);\n *     },\n *   });\n *\n *   return (\n *     <div>\n *       <AssistantRuntimeProvider runtime={runtime}>\n *         <Thread />\n *       </AssistantRuntimeProvider>\n *       <ToolUseDisplay toolUses={toolUses} />\n *     </div>\n *   );\n * }\n *\n * @example\n * // With permission mode switching\n * function ChatWithModes({ sessionId }: { sessionId: string }) {\n *   const [messages, setMessages] = useState<ChatMessage[]>([]);\n *   const [mode, setMode] = useState<'default' | 'bypass' | 'auto' | 'plan'>('default');\n *\n *   const runtime = useAssistantRuntime({\n *     sessionId,\n *     initialMessages: messages,\n *     onMessagesUpdate: setMessages,\n *     permissionMode: mode,\n *   });\n *\n *   return (\n *     <div>\n *       <select value={mode} onChange={(e) => setMode(e.target.value as any)}>\n *         <option value=\"default\">Default</option>\n *         <option value=\"bypass\">Bypass</option>\n *         <option value=\"auto\">Auto</option>\n *         <option value=\"plan\">Plan</option>\n *       </select>\n *       <AssistantRuntimeProvider runtime={runtime}>\n *         <Thread />\n *       </AssistantRuntimeProvider>\n *     </div>\n *   );\n * }\n */\n\nimport { useEffect, useState, useCallback, useMemo } from 'react';\nimport {\n  useExternalStoreRuntime,\n  type ThreadMessage,\n  type AppendMessage,\n} from '@assistant-ui/react';\nimport * as chatApi from '../services/chat-api';\nimport { SDKEventParser, type ToolUseData, type SystemMessageData } from '../utils/sdk-event-parser';\n\n/**\n * Configuration props for useAssistantRuntime hook\n */\ninterface UseAssistantRuntimeProps {\n  /**\n   * Chat session ID for the conversation\n   * Used to associate messages with specific session in backend\n   * Set to null when no session is active (disables message sending)\n   *\n   * @example 'session-abc123'\n   */\n  sessionId: string | null;\n\n  /**\n   * Initial messages to populate the conversation thread\n   * Array of ChatMessage objects from backend\n   * Automatically converted to ThreadMessage format for assistant-ui\n   * Updated via onMessagesUpdate when new messages arrive\n   *\n   * @example\n   * const [messages, setMessages] = useState<ChatMessage[]>([]);\n   * useEffect(() => {\n   *   chatApi.getChatMessages(sessionId).then(setMessages);\n   * }, [sessionId]);\n   */\n  initialMessages: chatApi.ChatMessage[];\n\n  /**\n   * Callback invoked when messages are updated\n   * Called after assistant message is saved or stream completes\n   * Should update parent component's message state to keep in sync\n   *\n   * @param messages - Updated array of ChatMessage objects from backend\n   *\n   * @example\n   * onMessagesUpdate: (messages) => {\n   *   setMessages(messages);\n   *   localStorage.setItem('lastMessages', JSON.stringify(messages));\n   * }\n   */\n  onMessagesUpdate: (messages: chatApi.ChatMessage[]) => void;\n\n  /**\n   * Permission mode for tool execution\n   * Controls how tool use permissions are handled:\n   * - **default**: Prompt user for permission before each tool use\n   * - **bypass**: Skip permission prompts, execute all tools automatically\n   * - **auto**: Auto-approve safe tools, prompt for dangerous tools\n   * - **plan**: Agent plans before execution, user approves plan\n   *\n   * @default 'default'\n   */\n  permissionMode: 'default' | 'bypass' | 'auto' | 'plan';\n\n  /**\n   * Optional agent ID to associate with messages\n   * Links conversation to specific agent for tracking and configuration\n   * Agent's system prompt and settings applied to conversation\n   *\n   * @example 'agent-coding-assistant'\n   */\n  agentId?: string;\n\n  /**\n   * Optional array of skill IDs to enable for the agent\n   * Skills provide additional capabilities (e.g., web search, code execution)\n   * Only skills listed here are available during conversation\n   *\n   * @example ['skill-web-search', 'skill-code-runner']\n   */\n  skillIds?: string[];\n\n  /**\n   * Callback invoked when tool uses are detected or updated\n   * Receives Map of tool use ID to ToolUseData with invocation and result\n   * Updated in real-time as SDK events arrive\n   * Use to display tool use information in custom UI components\n   *\n   * @param toolUses - Map of tool use ID to ToolUseData\n   *\n   * @example\n   * onToolUseUpdate: (toolUses) => {\n   *   console.log(`${toolUses.size} tools used in this conversation`);\n   *   setToolUseDisplay(Array.from(toolUses.values()));\n   * }\n   */\n  onToolUseUpdate?: (toolUses: Map<string, ToolUseData>) => void;\n\n  /**\n   * Callback invoked when system messages are received\n   * System messages provide status updates, warnings, and system-level information\n   * Use to display system messages in custom UI or log for debugging\n   *\n   * @param message - SystemMessageData with text and associated message ID\n   *\n   * @example\n   * onSystemMessage: (msg) => {\n   *   console.log(`[SYSTEM] ${msg.text}`);\n   *   toast.info(msg.text);\n   * }\n   */\n  onSystemMessage?: (message: SystemMessageData) => void;\n}\n\n/**\n * Create an assistant-ui runtime adapter for Claude Agent SDK\n *\n * This hook bridges the gap between assistant-ui (UI framework) and Claude Agent SDK (backend API),\n * enabling rich chat experiences with minimal code. It handles all the complexity of message\n * conversion, SSE streaming, SDK event parsing, and state synchronization.\n *\n * @param props - Configuration object with session, messages, callbacks, and settings\n * @returns AssistantRuntime compatible with assistant-ui components\n */\nexport function useAssistantRuntime({\n  sessionId,\n  initialMessages,\n  onMessagesUpdate,\n  permissionMode,\n  agentId,\n  skillIds,\n  onToolUseUpdate,\n  onSystemMessage,\n}: UseAssistantRuntimeProps) {\n  const [messages, setMessages] = useState<ThreadMessage[]>([]);\n  const [isRunning, setIsRunning] = useState(false);\n\n  // SDK event tracking\n  const [toolUses, setToolUses] = useState<Map<string, ToolUseData>>(new Map());\n  const [currentMessageId, setCurrentMessageId] = useState<string | null>(null);\n\n  // Stream cancellation tracking\n  const [currentStreamId, setCurrentStreamId] = useState<string | null>(null);\n\n  /**\n   * Convert ChatMessage (backend format) to ThreadMessage (assistant-ui format)\n   *\n   * Transforms messages from the backend's ChatMessage format to assistant-ui's\n   * ThreadMessage format. Handles role mapping, content array conversion, and\n   * metadata preservation.\n   *\n   * @param msg - ChatMessage from backend\n   * @returns ThreadMessage compatible with assistant-ui\n   *\n   * @internal\n   */\n  const convertToThreadMessage = useCallback((msg: chatApi.ChatMessage): ThreadMessage => {\n    const baseMessage = {\n      id: msg.documentId,\n      createdAt: new Date(msg.timestamp),\n      status: { type: 'complete' as const, reason: 'stop' as const },\n      content: [\n        {\n          type: 'text' as const,\n          text: msg.content,\n        },\n      ],\n      metadata: {\n        custom: msg.metadata || {},\n      },\n    };\n\n    if (msg.role === 'user') {\n      return {\n        ...baseMessage,\n        role: 'user' as const,\n        attachments: [],\n      } as unknown as ThreadMessage;\n    } else if (msg.role === 'assistant') {\n      return {\n        ...baseMessage,\n        role: 'assistant' as const,\n      } as unknown as ThreadMessage;\n    } else {\n      return {\n        ...baseMessage,\n        role: 'system' as const,\n        content: [{ type: 'text' as const, text: msg.content }],\n      } as unknown as ThreadMessage;\n    }\n  }, []);\n\n  // Sync initial messages from props\n  useEffect(() => {\n    if (initialMessages.length > 0) {\n      setMessages(initialMessages.map(convertToThreadMessage));\n    } else {\n      setMessages([]);\n    }\n  }, [initialMessages, convertToThreadMessage]);\n\n  /**\n   * Get selected directory from browser cookies\n   *\n   * Reads the `selectedDirectory` cookie set by Layout component's directory selector.\n   * This directory is passed to the backend for file operations (Read, Write, Bash, etc.).\n   *\n   * @returns Directory path string, or undefined if cookie not found\n   *\n   * @internal\n   */\n  const getDirectory = useCallback(() => {\n    const cookies = document.cookie.split(';');\n    for (const cookie of cookies) {\n      const [name, value] = cookie.trim().split('=');\n      if (name === 'selectedDirectory') {\n        return decodeURIComponent(value);\n      }\n    }\n    return undefined;\n  }, []);\n\n  /**\n   * Throttle rapid updates for better performance\n   *\n   * Creates a throttled update function that accumulates rapid delta events (50ms window)\n   * and batches UI updates to prevent excessive re-renders. This balances responsiveness\n   * (feels real-time to user) with performance (reduces React render cycles).\n   *\n   * When assistant_message_delta events arrive rapidly (e.g., 10-20 times per second),\n   * this mechanism ensures we only update the UI every 50ms rather than on every delta.\n   *\n   * @returns Throttled update function that accepts update callback\n   *\n   * @internal\n   */\n  const throttledUpdate = useMemo(() => {\n    let timeout: NodeJS.Timeout | null = null;\n    let pendingUpdate: (() => void) | null = null;\n\n    return (updateFn: () => void) => {\n      pendingUpdate = updateFn;\n\n      if (!timeout) {\n        timeout = setTimeout(() => {\n          if (pendingUpdate) {\n            pendingUpdate();\n          }\n          timeout = null;\n          pendingUpdate = null;\n        }, 50); // 50ms throttle - balances responsiveness with performance\n      }\n    };\n  }, []);\n\n  /**\n   * Handle new message submission from user\n   *\n   * Called by assistant-ui when user sends a message. Implements the full message\n   * send workflow including optimistic updates, SSE streaming, and event processing.\n   *\n   * Workflow:\n   * 1. Create optimistic user message with temp ID\n   * 2. Send message to backend via SSE\n   * 3. Process SSE events (stream_id, user_message_saved, assistant messages, SDK events)\n   * 4. Update UI in real-time as events arrive\n   * 5. Sync final messages from backend when complete\n   *\n   * @param message - AppendMessage from assistant-ui composer\n   * @returns Promise that resolves when stream completes\n   *\n   * @internal\n   */\n  const handleNewMessage = useCallback(\n    async (message: AppendMessage) => {\n      if (!sessionId) return;\n\n      setIsRunning(true);\n\n      try {\n        const directory = getDirectory();\n        const textContent = message.content.find((c) => c.type === 'text');\n        if (!textContent || textContent.type !== 'text') return;\n\n        const messageText = textContent.text;\n\n        // Create optimistic user message\n        const optimisticUserMessage: ThreadMessage = {\n          id: `temp-${Date.now()}`,\n          role: 'user' as const,\n          content: [{ type: 'text' as const, text: messageText }],\n          attachments: [],\n          createdAt: new Date(),\n          status: { type: 'complete' as const, reason: 'stop' as const },\n          metadata: {\n            custom: {},\n          },\n        } as unknown as ThreadMessage;\n\n        setMessages((prev) => [...prev, optimisticUserMessage]);\n\n        // Send message via SSE\n        const eventSource = chatApi.sendChatMessage(\n          sessionId,\n          messageText,\n          [], // attachments - to be implemented later\n          directory,\n          permissionMode,\n          agentId,\n          skillIds\n        );\n\n        let assistantMessageContent = '';\n        let assistantMessageId = '';\n\n        eventSource.addEventListener('message', async (event: MessageEvent) => {\n          try {\n            const data = JSON.parse(event.data);\n\n            if (data.type === 'stream_id') {\n              // Capture stream ID for cancellation\n              setCurrentStreamId(data.streamId);\n              console.log('Stream started with ID:', data.streamId);\n            } else if (data.type === 'user_message_saved') {\n              // Replace optimistic user message with real one\n              const realUserMessage = convertToThreadMessage(data.message);\n              setMessages((prev) =>\n                prev.map((msg) =>\n                  msg.id === optimisticUserMessage.id ? realUserMessage : msg\n                )\n              );\n            } else if (data.type === 'assistant_message_start') {\n              // Start assistant message\n              assistantMessageId = `temp-assistant-${Date.now()}`;\n              assistantMessageContent = '';\n            } else if (data.type === 'assistant_message_delta') {\n              // Stream assistant message content\n              assistantMessageContent += data.delta || '';\n\n              // Use throttling to batch rapid updates for better performance\n              throttledUpdate(() => {\n                const streamingMessage: ThreadMessage = {\n                  id: assistantMessageId,\n                  role: 'assistant' as const,\n                  content: [{ type: 'text' as const, text: assistantMessageContent }],\n                  createdAt: new Date(),\n                  status: { type: 'running' as const },\n                  metadata: {\n                    custom: {},\n                  },\n                } as unknown as ThreadMessage;\n\n                setMessages((prev) => {\n                  const withoutStreaming = prev.filter((m) => m.id !== assistantMessageId);\n                  return [...withoutStreaming, streamingMessage];\n                });\n              });\n            } else if (data.type === 'assistant_message_saved') {\n              // Replace streaming message with final saved message\n              const realAssistantMessage = convertToThreadMessage(data.message);\n              setMessages((prev) =>\n                prev.map((msg) =>\n                  msg.id === assistantMessageId ? realAssistantMessage : msg\n                )\n              );\n              // Get current messages from Strapi to ensure sync\n              const currentMessages = await chatApi.getChatMessages(sessionId);\n              onMessagesUpdate(currentMessages);\n            } else if (data.type === 'sdk_message') {\n              // Handle SDK messages (tool uses, tool results, system messages)\n              const sdkMsg = data.data;\n\n              // Set current message ID for tracking\n              if (assistantMessageId) {\n                setCurrentMessageId(assistantMessageId);\n              }\n\n              // Process assistant messages for tool_use blocks\n              if (sdkMsg.type === 'assistant' && SDKEventParser.hasToolUses(sdkMsg)) {\n                const newToolUses = SDKEventParser.extractToolUses(sdkMsg, assistantMessageId);\n\n                setToolUses((prev) => {\n                  const updated = new Map(prev);\n                  newToolUses.forEach((toolUse) => {\n                    updated.set(toolUse.id, toolUse);\n                  });\n                  return updated;\n                });\n\n                // Notify parent component\n                if (onToolUseUpdate) {\n                  setToolUses((currentToolUses) => {\n                    onToolUseUpdate(currentToolUses);\n                    return currentToolUses;\n                  });\n                }\n              }\n\n              // Process user messages for tool_result blocks\n              else if (sdkMsg.type === 'user' && SDKEventParser.hasToolResults(sdkMsg)) {\n                const results = SDKEventParser.extractToolResults(sdkMsg);\n\n                setToolUses((prev) => {\n                  const updated = new Map(prev);\n                  results.forEach((result, toolUseId) => {\n                    const toolUse = updated.get(toolUseId);\n                    if (toolUse) {\n                      updated.set(\n                        toolUseId,\n                        SDKEventParser.updateToolUseWithResult(toolUse, result)\n                      );\n                    }\n                  });\n                  return updated;\n                });\n\n                // Notify parent component\n                if (onToolUseUpdate) {\n                  setToolUses((currentToolUses) => {\n                    onToolUseUpdate(currentToolUses);\n                    return currentToolUses;\n                  });\n                }\n              }\n\n              // Process system messages\n              else if (sdkMsg.type === 'system') {\n                const systemMsg = SDKEventParser.parseSystemMessage(sdkMsg, assistantMessageId);\n\n                // Notify parent component\n                if (onSystemMessage) {\n                  onSystemMessage(systemMsg);\n                }\n              }\n            } else if (data.type === 'cancelled') {\n              console.log('Stream cancelled:', data.streamId);\n              setIsRunning(false);\n              setCurrentStreamId(null);\n              // Reload all messages to ensure sync\n              const currentMessages = await chatApi.getChatMessages(sessionId);\n              onMessagesUpdate(currentMessages);\n            } else if (data.type === 'done') {\n              console.log('Streaming complete');\n              setIsRunning(false);\n              setCurrentStreamId(null);\n              // Reload all messages to ensure sync\n              const currentMessages = await chatApi.getChatMessages(sessionId);\n              onMessagesUpdate(currentMessages);\n            } else if (data.type === 'error') {\n              console.error('Chat error:', data.error);\n              // Only show alert for real errors, not for cancellations\n              if (!data.error?.includes('abort')) {\n                alert(`Chat error: ${data.error}`);\n              }\n              setIsRunning(false);\n              setCurrentStreamId(null);\n            }\n          } catch (e) {\n            console.error('Failed to parse SSE message:', e);\n          }\n        });\n\n        eventSource.addEventListener('error', (event: Event) => {\n          console.error('SSE error:', event);\n          setIsRunning(false);\n        });\n      } catch (error) {\n        console.error('Failed to send message:', error);\n        alert('Failed to send message');\n        setIsRunning(false);\n      }\n    },\n    [sessionId, getDirectory, convertToThreadMessage, initialMessages, onMessagesUpdate, permissionMode, agentId, skillIds, onToolUseUpdate, onSystemMessage]\n  );\n\n  /**\n   * Handle stream cancellation request\n   *\n   * Called by assistant-ui when user clicks stop button. Sends cancellation request\n   * to backend which aborts the SSE stream and Claude Agent SDK request. The 'cancelled'\n   * event handler will clean up state and reload messages.\n   *\n   * Silently ignores if no active stream (already cancelled or completed).\n   *\n   * @returns Promise that resolves when cancellation is complete\n   *\n   * @internal\n   */\n  const handleCancel = useCallback(async () => {\n    if (!sessionId || !currentStreamId) {\n      // Silently ignore if no active stream (already cancelled or completed)\n      return;\n    }\n\n    try {\n      console.log('Cancelling stream:', currentStreamId);\n      await chatApi.cancelMessage(sessionId, currentStreamId);\n      // The 'cancelled' event handler will clean up state\n    } catch (error) {\n      console.error('Failed to cancel message:', error);\n      // Fallback: clean up state manually\n      setIsRunning(false);\n      setCurrentStreamId(null);\n    }\n  }, [sessionId, currentStreamId]);\n\n  /**\n   * Wrapper for setMessages to match ExternalStoreAdapter signature\n   *\n   * Converts readonly array to mutable array for state update. Required by\n   * useExternalStoreRuntime's adapter interface.\n   *\n   * @param newMessages - Readonly array of ThreadMessage objects\n   * @returns void\n   *\n   * @internal\n   */\n  const handleSetMessages = useCallback((newMessages: readonly ThreadMessage[]) => {\n    setMessages([...newMessages]);\n  }, []);\n\n  // Create external store adapter\n  const adapter = useMemo(\n    () => ({\n      isRunning,\n      messages,\n      setMessages: handleSetMessages,\n      onNew: handleNewMessage,\n      onCancel: handleCancel,\n    }),\n    [isRunning, messages, handleSetMessages, handleNewMessage, handleCancel]\n  );\n\n  // Create runtime using useExternalStoreRuntime\n  const runtime = useExternalStoreRuntime(adapter);\n\n  return runtime;\n}\n",
        "last_modified": "2026-01-02T14:22:15.588798"
      },
      "task_intent": {
        "title": "Document Frontend React Components and Hooks",
        "description": "Add comprehensive JSDoc documentation to all React components and custom hooks in the frontend, including prop types, usage examples, component purposes, state management, and side effects.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:01:12.098994",
  "last_updated": "2026-01-02T14:22:15.407578"
}