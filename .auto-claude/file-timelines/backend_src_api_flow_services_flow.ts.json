{
  "file_path": "backend/src/api/flow/services/flow.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "/**\n * Flow service\n *\n * Service layer for Flow operations with helper methods for\n * common operations and business logic.\n */\n\nimport { factories } from '@strapi/strapi';\n\nexport default factories.createCoreService('api::flow.flow', ({ strapi }) => ({\n  /**\n   * Find flow with all relations populated\n   */\n  async findWithFullRelations(id: number) {\n    return await strapi.entityService.findOne('api::flow.flow', id, {\n      populate: '*',\n    });\n  },\n\n  /**\n   * Find flow by slug\n   */\n  async findBySlug(slug: string) {\n    const flows = await strapi.entityService.findMany('api::flow.flow', {\n      filters: {\n        slug: { $eq: slug },\n      },\n    });\n\n    return flows[0] || null;\n  },\n\n  /**\n   * Get active flows only\n   */\n  async findActive(filters = {}) {\n    return await strapi.entityService.findMany('api::flow.flow', {\n      filters: {\n        isActive: true,\n        status: 'active',\n        ...filters,\n      },\n      sort: { name: 'asc' },\n    });\n  },\n\n  /**\n   * Update flow status\n   */\n  async updateStatus(id: number, status: string) {\n    return await strapi.entityService.update('api::flow.flow', id, {\n      data: { status },\n    });\n  },\n\n  /**\n   * Toggle flow active state\n   */\n  async toggleActive(id: number) {\n    const flow: any = await strapi.entityService.findOne('api::flow.flow', id);\n\n    if (!flow) {\n      throw new Error(`Flow with ID ${id} not found`);\n    }\n\n    return await strapi.entityService.update('api::flow.flow', id, {\n      data: { isActive: !flow.isActive },\n    });\n  },\n\n  /**\n   * Validate flow nodes structure\n   */\n  validateNodes(nodes: any[]) {\n    if (!Array.isArray(nodes)) {\n      return { valid: false, error: 'Nodes must be an array' };\n    }\n\n    if (nodes.length === 0) {\n      return { valid: true, warning: 'Flow has no nodes defined' };\n    }\n\n    const nodeIds = new Set<string>();\n    const errors: string[] = [];\n\n    for (const node of nodes) {\n      // Check required fields\n      if (!node.id || !node.type) {\n        errors.push('Each node must have an id and type');\n        continue;\n      }\n\n      // Check for duplicate IDs\n      if (nodeIds.has(node.id)) {\n        errors.push(`Duplicate node ID: ${node.id}`);\n      }\n      nodeIds.add(node.id);\n\n      // Validate node type\n      const validTypes = ['input', 'agent', 'output', 'condition', 'transform'];\n      if (!validTypes.includes(node.type)) {\n        errors.push(\n          `Invalid node type: ${node.type}. Must be one of: ${validTypes.join(', ')}`\n        );\n      }\n\n      // Type-specific validation\n      switch (node.type) {\n        case 'input':\n          if (!node.config?.inputFields || !Array.isArray(node.config.inputFields)) {\n            errors.push(`Input node ${node.id} should have inputFields array`);\n          }\n          break;\n        case 'agent':\n          if (!node.config?.agentId) {\n            errors.push(`Agent node ${node.id} must reference an agent`);\n          }\n          break;\n        case 'output':\n          if (!node.config?.outputType) {\n            errors.push(`Output node ${node.id} should specify outputType`);\n          }\n          break;\n      }\n    }\n\n    if (errors.length > 0) {\n      return { valid: false, errors };\n    }\n\n    // Validate flow structure\n    const hasInput = nodes.some((n) => n.type === 'input');\n    const hasOutput = nodes.some((n) => n.type === 'output');\n\n    const warnings: string[] = [];\n    if (!hasInput) {\n      warnings.push('Flow should have at least one input node');\n    }\n    if (!hasOutput) {\n      warnings.push('Flow should have at least one output node');\n    }\n\n    return {\n      valid: true,\n      warnings: warnings.length > 0 ? warnings : undefined,\n    };\n  },\n\n  /**\n   * Duplicate a flow with a new name\n   */\n  async duplicateFlow(id: number, newName?: string) {\n    const originalFlow: any = await strapi.entityService.findOne('api::flow.flow', id);\n\n    if (!originalFlow) {\n      throw new Error(`Flow with ID ${id} not found`);\n    }\n\n    // Generate new name and slug\n    const timestamp = Date.now();\n    const name = newName || `${originalFlow.name} (Copy)`;\n    const slug = this.generateSlug(name, timestamp);\n\n    // Create duplicate with reset fields\n    const duplicateData = {\n      name,\n      slug,\n      description: originalFlow.description,\n      nodes: originalFlow.nodes || [],\n      status: 'draft' as const,\n      inputSchema: originalFlow.inputSchema || {},\n      outputSchema: originalFlow.outputSchema || {},\n      isActive: false,\n      version: '1.0.0',\n      category: originalFlow.category,\n      metadata: {\n        ...(originalFlow.metadata || {}),\n        duplicatedFrom: id,\n        duplicatedAt: new Date().toISOString(),\n      },\n    };\n\n    return await strapi.entityService.create('api::flow.flow', {\n      data: duplicateData,\n    });\n  },\n\n  /**\n   * Generate a unique slug from a name\n   */\n  generateSlug(name: string, uniqueSuffix?: number): string {\n    let slug = name\n      .toLowerCase()\n      .replace(/[^a-z0-9\\s-]/g, '')\n      .replace(/\\s+/g, '-')\n      .replace(/-+/g, '-')\n      .trim();\n\n    if (uniqueSuffix) {\n      slug = `${slug}-${uniqueSuffix}`;\n    }\n\n    return slug;\n  },\n\n  /**\n   * Get flow summary for listing\n   */\n  async getFlowSummaries() {\n    const flows = await strapi.entityService.findMany('api::flow.flow', {\n      sort: { updatedAt: 'desc' },\n    }) as any[];\n\n    return flows.map((flow) => ({\n      id: flow.id,\n      name: flow.name,\n      slug: flow.slug,\n      description: flow.description,\n      status: flow.status,\n      isActive: flow.isActive,\n      category: flow.category,\n      version: flow.version,\n      nodeCount: (flow.nodes || []).length,\n      createdAt: flow.createdAt,\n      updatedAt: flow.updatedAt,\n    }));\n  },\n\n  /**\n   * Update flow version\n   */\n  async bumpVersion(id: number, versionType: 'major' | 'minor' | 'patch' = 'patch') {\n    const flow: any = await strapi.entityService.findOne('api::flow.flow', id);\n\n    if (!flow) {\n      throw new Error(`Flow with ID ${id} not found`);\n    }\n\n    const currentVersion = flow.version || '1.0.0';\n    const [major, minor, patch] = currentVersion.split('.').map(Number);\n\n    let newVersion: string;\n    switch (versionType) {\n      case 'major':\n        newVersion = `${major + 1}.0.0`;\n        break;\n      case 'minor':\n        newVersion = `${major}.${minor + 1}.0`;\n        break;\n      case 'patch':\n      default:\n        newVersion = `${major}.${minor}.${patch + 1}`;\n        break;\n    }\n\n    return await strapi.entityService.update('api::flow.flow', id, {\n      data: { version: newVersion },\n    });\n  },\n\n  /**\n   * Search flows by name or description\n   */\n  async search(query: string) {\n    return await strapi.entityService.findMany('api::flow.flow', {\n      filters: {\n        $or: [\n          { name: { $containsi: query } },\n          { description: { $containsi: query } },\n        ],\n      },\n      sort: { name: 'asc' },\n    });\n  },\n\n  /**\n   * Get flows that can be executed (active and has nodes)\n   */\n  async getExecutableFlows() {\n    const flows = await strapi.entityService.findMany('api::flow.flow', {\n      filters: {\n        isActive: true,\n        status: 'active',\n      },\n    }) as any[];\n\n    return flows.filter((flow) => {\n      const nodes = flow.nodes || [];\n      return nodes.length > 0;\n    });\n  },\n\n  /**\n   * Export flow to JSON format\n   */\n  async exportFlow(id: number) {\n    const flow: any = await strapi.entityService.findOne('api::flow.flow', id);\n\n    if (!flow) {\n      throw new Error(`Flow with ID ${id} not found`);\n    }\n\n    return {\n      name: flow.name,\n      description: flow.description,\n      nodes: flow.nodes,\n      inputSchema: flow.inputSchema,\n      outputSchema: flow.outputSchema,\n      version: flow.version,\n      category: flow.category,\n      metadata: flow.metadata,\n      exportedAt: new Date().toISOString(),\n    };\n  },\n\n  /**\n   * Import flow from JSON format\n   */\n  async importFlow(data: any) {\n    // Validate required fields\n    if (!data.name) {\n      throw new Error('Flow name is required');\n    }\n\n    // Generate unique slug\n    const slug = this.generateSlug(data.name, Date.now());\n\n    return await strapi.entityService.create('api::flow.flow', {\n      data: {\n        name: data.name,\n        slug,\n        description: data.description || '',\n        nodes: data.nodes || [],\n        status: 'draft',\n        inputSchema: data.inputSchema || {},\n        outputSchema: data.outputSchema || {},\n        isActive: false,\n        version: data.version || '1.0.0',\n        category: data.category || 'custom',\n        metadata: {\n          ...(data.metadata || {}),\n          importedAt: new Date().toISOString(),\n        },\n      },\n    });\n  },\n}));\n",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:46.876841",
  "last_updated": "2026-01-02T15:21:46.896705"
}