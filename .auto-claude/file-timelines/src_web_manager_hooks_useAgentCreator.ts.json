{
  "file_path": "src/web/manager/hooks/useAgentCreator.ts",
  "main_branch_history": [],
  "task_views": {
    "004-document-frontend-react-components-and-hooks": {
      "task_id": "004-document-frontend-react-components-and-hooks",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "/**\n * Hook for managing interactive agent creation with Claude Manager\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\nconst API_BASE = '/api/manager';\n\ninterface Message {\n  id: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  timestamp: Date;\n}\n\ninterface UseAgentCreatorOptions {\n  directory?: string;\n  onAgentCreated?: (agentName: string, filePath: string) => void;\n  onError?: (error: Error) => void;\n}\n\ninterface UseAgentCreatorReturn {\n  messages: Message[];\n  isProcessing: boolean;\n  isCreating: boolean;\n  createdAgentName: string | null;\n  error: Error | null;\n  startConversation: () => Promise<void>;\n  sendMessage: (content: string) => Promise<void>;\n  reset: () => void;\n}\n\n/**\n * Get auth token from cookie\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Create fetch options with auth header\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\nexport function useAgentCreator(options: UseAgentCreatorOptions = {}): UseAgentCreatorReturn {\n  const { directory, onAgentCreated, onError } = options;\n\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [isCreating, setIsCreating] = useState(false);\n  const [createdAgentName, setCreatedAgentName] = useState<string | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Track the current conversation stream\n  const streamReaderRef = useRef<ReadableStreamDefaultReader<Uint8Array> | null>(null);\n  const conversationIdRef = useRef<string | null>(null);\n  const messagesRef = useRef<Message[]>([]);\n\n  // Keep ref in sync with state\n  useEffect(() => {\n    messagesRef.current = messages;\n  }, [messages]);\n\n  /**\n   * Send a message in the ongoing conversation\n   */\n  const sendMessageInternal = useCallback(async (content: string, currentMessages: Message[]) => {\n    try {\n      setIsProcessing(true);\n      setError(null);\n\n      // Add user message immediately\n      const userMessage: Message = {\n        id: `msg-${Date.now()}-user`,\n        role: 'user',\n        content,\n        timestamp: new Date(),\n      };\n\n      // Build conversation history (current messages + new user message)\n      const conversationHistory = [...currentMessages, userMessage].map(m => ({\n        role: m.role,\n        content: m.content\n      }));\n\n      setMessages((prev) => [...prev, userMessage]);\n\n      const url = new URL(`${API_BASE}/agents/create-with-claude/message`, window.location.origin);\n\n      const response = await fetch(url.toString(), createFetchOptions({\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          directory,\n          conversationHistory\n        }),\n      }));\n\n      if (!response.ok) {\n        throw new Error('Failed to send message');\n      }\n\n      if (!response.body) {\n        throw new Error('No response body');\n      }\n\n      // Read SSE stream\n      const reader = response.body.getReader();\n      streamReaderRef.current = reader;\n      const decoder = new TextDecoder();\n\n      let buffer = '';\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) break;\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              try {\n                const data = JSON.parse(line.substring(6));\n                handleStreamEvent(data);\n              } catch (e) {\n                console.error('Failed to parse SSE data:', e);\n              }\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n        streamReaderRef.current = null;\n      }\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      setError(error);\n      if (onError) {\n        onError(error);\n      }\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [directory, onError]);\n\n  /**\n   * Start a new conversation with the agent creator\n   */\n  const startConversation = useCallback(async () => {\n    // Send initial message to start conversation\n    await sendMessageInternal(\"Let's create a new agent.\", []);\n  }, [sendMessageInternal]);\n\n  /**\n   * Public API: Send a message in the ongoing conversation\n   */\n  const sendMessage = useCallback(async (content: string) => {\n    // Use messagesRef to get current messages without closure issues\n    const currentMessages = messagesRef.current;\n    await sendMessageInternal(content, currentMessages);\n  }, [sendMessageInternal]);\n\n  /**\n   * Handle stream events\n   */\n  const handleStreamEvent = useCallback((data: any) => {\n    // Debug logging\n    console.log('[AgentCreator] Stream event:', data.type, data.messageType);\n\n    if (data.type === 'message' && data.messageType === 'assistant') {\n      // Extract text content from assistant message\n      // SDK structure: message.message.content (not message.content)\n      const content = data.content?.message?.content;\n      console.log('[AgentCreator] Assistant message content:', content);\n\n      if (content && Array.isArray(content)) {\n        const textBlocks = content.filter((block: any) => block.type === 'text');\n        if (textBlocks.length > 0) {\n          const textContent = textBlocks.map((block: any) => block.text).join('\\n');\n          console.log('[AgentCreator] Extracted text:', textContent);\n\n          const assistantMessage: Message = {\n            id: `msg-${Date.now()}-assistant`,\n            role: 'assistant',\n            content: textContent,\n            timestamp: new Date(),\n          };\n          setMessages((prev) => [...prev, assistantMessage]);\n        }\n\n        // Check for Write tool usage in assistant message\n        const toolUseBlocks = content.filter((block: any) => block.type === 'tool_use');\n        for (const block of toolUseBlocks) {\n          if (block.name === 'Write') {\n            const filePath = block.input?.file_path || '';\n            console.log('[AgentCreator] Write tool detected:', filePath);\n\n            // Check if writing to .claude/agents/\n            const match = filePath.match(/\\.claude[\\/\\\\]agents[\\/\\\\]([^\\/\\\\]+)\\.md/);\n            if (match) {\n              const agentName = match[1];\n              console.log('[AgentCreator] Agent file created:', agentName);\n              setCreatedAgentName(agentName);\n              setIsCreating(false);\n\n              if (onAgentCreated) {\n                onAgentCreated(agentName, filePath);\n              }\n            }\n          }\n        }\n      }\n    } else if (data.type === 'message' && data.messageType === 'result') {\n      // Final result message - query completed\n      console.log('[AgentCreator] Query completed');\n    } else if (data.type === 'status') {\n      // Check if Claude is creating the agent\n      if (data.status?.includes('Creating') || data.status?.includes('Writing')) {\n        setIsCreating(true);\n      }\n    } else if (data.type === 'complete') {\n      setIsProcessing(false);\n    } else if (data.type === 'error') {\n      const error = new Error(data.error || 'Agent creation failed');\n      setError(error);\n      if (onError) {\n        onError(error);\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [onAgentCreated, onError]);\n\n  /**\n   * Reset the conversation state\n   */\n  const reset = useCallback(() => {\n    // Cancel any ongoing stream\n    if (streamReaderRef.current) {\n      streamReaderRef.current.cancel();\n      streamReaderRef.current = null;\n    }\n\n    conversationIdRef.current = null;\n    setMessages([]);\n    setIsProcessing(false);\n    setIsCreating(false);\n    setCreatedAgentName(null);\n    setError(null);\n  }, []);\n\n  return {\n    messages,\n    isProcessing,\n    isCreating,\n    createdAgentName,\n    error,\n    startConversation,\n    sendMessage,\n    reset,\n  };\n}\n",
        "timestamp": "2026-01-02T14:22:14.293924"
      },
      "worktree_state": {
        "content": "/**\n * useAgentCreator Hook\n *\n * A custom React hook for managing interactive agent creation with Claude Manager through\n * a conversational interface. This hook orchestrates the complete agent creation workflow\n * including SSE streaming, message handling, and state management.\n *\n * ## Features\n * - **Conversational Agent Creation**: Interactive chat-based workflow for creating new agents\n * - **SSE Streaming**: Real-time message streaming from Claude API using Server-Sent Events\n * - **State Management**: Comprehensive tracking of conversation, processing, creation, and error states\n * - **Tool Use Detection**: Automatically detects when Claude writes agent files via Write tool\n * - **Authentication**: Automatic token-based authentication with cookie management\n * - **Error Handling**: Robust error handling with optional error callbacks\n * - **Session Management**: Complete conversation lifecycle with reset functionality\n * - **Ref-based Updates**: Uses refs to avoid closure issues with async streaming\n *\n * ## State Management\n * The hook manages the following state:\n *\n * ### Message State\n * - `messages`: Array of conversation messages (user, assistant, system)\n * - Each message includes id, role, content, and timestamp\n * - Messages are updated in real-time as SSE events arrive\n *\n * ### Processing State\n * - `isProcessing`: True when waiting for/receiving assistant response\n * - Indicates active network request and stream reading\n * - Automatically set to false when stream completes or errors\n *\n * ### Creation State\n * - `isCreating`: True when Claude is actively writing the agent file\n * - Set when status events indicate \"Creating\" or \"Writing\"\n * - Set to false when Write tool completes\n *\n * ### Result State\n * - `createdAgentName`: Name of successfully created agent (extracted from file path)\n * - Extracted from Write tool's file_path matching pattern `.claude/agents/{name}.md`\n * - Used to trigger onAgentCreated callback\n *\n * ### Error State\n * - `error`: Error object if any operation fails\n * - Triggers onError callback when set\n * - Can be cleared with reset()\n *\n * ## SSE Streaming Handling\n * The hook implements a robust SSE streaming mechanism:\n *\n * ### Stream Lifecycle\n * 1. **Initiate**: POST to `/api/manager/agents/create-with-claude/message`\n * 2. **Read**: Obtain ReadableStream reader and decode chunks\n * 3. **Parse**: Split by newlines, extract `data: ` prefixed JSON\n * 4. **Handle**: Process each event type (message, status, complete, error)\n * 5. **Cleanup**: Release reader lock when stream completes or errors\n *\n * ### Event Types\n * - **message (assistant)**: Extract text blocks and tool uses from content array\n * - **message (result)**: Final query completion indicator\n * - **status**: Check for \"Creating\"/\"Writing\" keywords to update isCreating\n * - **complete**: Mark processing as finished\n * - **error**: Set error state and invoke error callback\n *\n * ### Tool Use Detection\n * When an assistant message contains tool_use blocks:\n * - Filters content array for `type: 'tool_use'` blocks\n * - Checks if `name === 'Write'` (file write operation)\n * - Extracts `file_path` from tool input\n * - Matches against `.claude/agents/{name}.md` pattern\n * - Extracts agent name and triggers onAgentCreated callback\n *\n * ### Stream Cancellation\n * - Reader reference stored in `streamReaderRef` for cleanup\n * - Automatically cancelled on component unmount or reset()\n * - Prevents memory leaks and dangling streams\n *\n * ## Lifecycle\n * The typical usage flow:\n *\n * 1. **Initialize**: Call useAgentCreator() with options\n * 2. **Start**: Call startConversation() to begin with initial message\n * 3. **Converse**: User calls sendMessage() with responses to Claude's questions\n * 4. **Stream**: Hook processes SSE events, updates messages state\n * 5. **Detect**: Hook detects Write tool usage, sets createdAgentName\n * 6. **Callback**: onAgentCreated() invoked with agent name and file path\n * 7. **Reset** (optional): Call reset() to clear state and start over\n *\n * ## Authentication\n * The hook automatically handles authentication:\n * - Reads `cui-auth-token` cookie from document.cookie\n * - Adds `Authorization: Bearer {token}` header to all requests\n * - Token extraction and header injection via helper functions\n *\n * @example\n * // Basic usage with agent creation detection\n * function AgentCreatorPanel() {\n *   const {\n *     messages,\n *     isProcessing,\n *     isCreating,\n *     createdAgentName,\n *     error,\n *     startConversation,\n *     sendMessage,\n *     reset\n *   } = useAgentCreator({\n *     directory: '/path/to/project',\n *     onAgentCreated: (name, path) => {\n *       console.log(`Agent \"${name}\" created at ${path}`);\n *       // Navigate to agent details page or refresh agent list\n *     },\n *     onError: (err) => {\n *       console.error('Agent creation failed:', err);\n *     }\n *   });\n *\n *   return (\n *     <div>\n *       {!messages.length && (\n *         <button onClick={startConversation} disabled={isProcessing}>\n *           Start Creating Agent\n *         </button>\n *       )}\n *       {messages.map(msg => (\n *         <div key={msg.id}>{msg.role}: {msg.content}</div>\n *       ))}\n *       {isCreating && <p>Claude is writing your agent file...</p>}\n *       {createdAgentName && <p>Successfully created agent: {createdAgentName}</p>}\n *       {error && <p className=\"error\">{error.message}</p>}\n *     </div>\n *   );\n * }\n *\n * @example\n * // With custom directory and callbacks\n * const { startConversation, sendMessage } = useAgentCreator({\n *   directory: process.env.PROJECT_ROOT,\n *   onAgentCreated: (agentName, filePath) => {\n *     toast.success(`Created ${agentName}`);\n *     router.push(`/agents/${agentName}`);\n *   },\n *   onError: (error) => {\n *     toast.error(`Failed: ${error.message}`);\n *   }\n * });\n *\n * @example\n * // Handling user input and sending messages\n * function ChatInterface() {\n *   const [input, setInput] = useState('');\n *   const { messages, isProcessing, sendMessage } = useAgentCreator();\n *\n *   const handleSubmit = async (e) => {\n *     e.preventDefault();\n *     if (!input.trim() || isProcessing) return;\n *\n *     await sendMessage(input);\n *     setInput('');\n *   };\n *\n *   return (\n *     <form onSubmit={handleSubmit}>\n *       {messages.map(msg => <MessageBubble key={msg.id} message={msg} />)}\n *       <input\n *         value={input}\n *         onChange={(e) => setInput(e.target.value)}\n *         disabled={isProcessing}\n *         placeholder={isProcessing ? 'Waiting for response...' : 'Type your message...'}\n *       />\n *       <button type=\"submit\" disabled={isProcessing || !input.trim()}>Send</button>\n *     </form>\n *   );\n * }\n *\n * @example\n * // Reset conversation after agent creation\n * function AgentCreator() {\n *   const { createdAgentName, reset, startConversation } = useAgentCreator({\n *     onAgentCreated: (name) => {\n *       setTimeout(() => {\n *         if (confirm(`Agent \"${name}\" created! Create another?`)) {\n *           reset();\n *           startConversation();\n *         }\n *       }, 1000);\n *     }\n *   });\n *\n *   // ... render UI\n * }\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\nconst API_BASE = '/api/manager';\n\n/**\n * Message object representing a single message in the conversation\n */\ninterface Message {\n  /** Unique message identifier (format: `msg-{timestamp}-{role}`) */\n  id: string;\n  /** Message author role */\n  role: 'user' | 'assistant' | 'system';\n  /** Message text content */\n  content: string;\n  /** Message creation timestamp */\n  timestamp: Date;\n}\n\n/**\n * Configuration options for useAgentCreator hook\n */\ninterface UseAgentCreatorOptions {\n  /**\n   * Project directory path where agent should be created\n   * Passed to the API to determine where to write `.claude/agents/{name}.md`\n   *\n   * @example '/path/to/my/project'\n   */\n  directory?: string;\n\n  /**\n   * Callback invoked when agent file is successfully created\n   *\n   * @param agentName - Name of created agent (extracted from filename)\n   * @param filePath - Full path to created agent file\n   *\n   * @example\n   * onAgentCreated: (name, path) => {\n   *   console.log(`Agent ${name} created at ${path}`);\n   *   refreshAgentList();\n   * }\n   */\n  onAgentCreated?: (agentName: string, filePath: string) => void;\n\n  /**\n   * Callback invoked when any error occurs during agent creation\n   *\n   * @param error - Error object with message and stack trace\n   *\n   * @example\n   * onError: (err) => {\n   *   toast.error(`Failed to create agent: ${err.message}`);\n   * }\n   */\n  onError?: (error: Error) => void;\n}\n\n/**\n * Return value interface for useAgentCreator hook\n */\ninterface UseAgentCreatorReturn {\n  /**\n   * Array of conversation messages in chronological order\n   * Includes user messages (sent via sendMessage), assistant messages (from Claude),\n   * and system messages (from API)\n   */\n  messages: Message[];\n\n  /**\n   * True when waiting for assistant response or processing stream\n   * Use to disable input, show loading indicators, or prevent duplicate sends\n   */\n  isProcessing: boolean;\n\n  /**\n   * True when Claude is actively writing the agent file\n   * Set when status events contain \"Creating\" or \"Writing\" keywords\n   * Useful for showing specific \"Creating agent...\" UI feedback\n   */\n  isCreating: boolean;\n\n  /**\n   * Name of successfully created agent, or null if not yet created\n   * Extracted from Write tool's file_path (.claude/agents/{name}.md)\n   * Set when agent file is written, triggers onAgentCreated callback\n   */\n  createdAgentName: string | null;\n\n  /**\n   * Error object if any operation failed, or null if no errors\n   * Set when network requests fail, stream parsing fails, or API returns error\n   * Triggers onError callback when set\n   */\n  error: Error | null;\n\n  /**\n   * Start a new conversation with the agent creator\n   * Sends initial message \"Let's create a new agent.\" to begin workflow\n   *\n   * @returns Promise that resolves when initial message is sent and stream processed\n   *\n   * @example\n   * <button onClick={startConversation} disabled={isProcessing}>\n   *   Start Creating Agent\n   * </button>\n   */\n  startConversation: () => Promise<void>;\n\n  /**\n   * Send a user message in the ongoing conversation\n   * Appends message to conversation history and streams Claude's response\n   *\n   * @param content - User message text content\n   * @returns Promise that resolves when message is sent and stream processed\n   *\n   * @example\n   * await sendMessage('Create an agent for web scraping');\n   *\n   * @example\n   * // With form submission\n   * const handleSubmit = async (e) => {\n   *   e.preventDefault();\n   *   await sendMessage(userInput);\n   *   setUserInput('');\n   * };\n   */\n  sendMessage: (content: string) => Promise<void>;\n\n  /**\n   * Reset all conversation state and cancel any active streams\n   * Clears messages, errors, creation status, and cancels ongoing SSE stream\n   * Use when starting over or when component unmounts\n   *\n   * @example\n   * // Reset after successful creation\n   * if (createdAgentName) {\n   *   setTimeout(() => reset(), 2000);\n   * }\n   *\n   * @example\n   * // Cleanup on unmount\n   * useEffect(() => {\n   *   return () => reset();\n   * }, [reset]);\n   */\n  reset: () => void;\n}\n\n/**\n * Get auth token from cookie\n *\n * Extracts the authentication token from the browser's cookies by looking for\n * the `cui-auth-token` cookie. This token is used for authenticating API requests.\n *\n * @returns The decoded auth token string, or null if not found\n *\n * @internal\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Create fetch options with auth header\n *\n * Enhances standard fetch options by automatically adding the Authorization header\n * with the bearer token from cookies. Merges with any existing headers provided.\n *\n * @param options - Standard fetch RequestInit options (method, headers, body, etc.)\n * @returns Enhanced RequestInit with Authorization header if token is available\n *\n * @internal\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\nexport function useAgentCreator(options: UseAgentCreatorOptions = {}): UseAgentCreatorReturn {\n  const { directory, onAgentCreated, onError } = options;\n\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [isCreating, setIsCreating] = useState(false);\n  const [createdAgentName, setCreatedAgentName] = useState<string | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Track the current conversation stream\n  const streamReaderRef = useRef<ReadableStreamDefaultReader<Uint8Array> | null>(null);\n  const conversationIdRef = useRef<string | null>(null);\n  const messagesRef = useRef<Message[]>([]);\n\n  // Keep ref in sync with state\n  useEffect(() => {\n    messagesRef.current = messages;\n  }, [messages]);\n\n  /**\n   * Send a message in the ongoing conversation\n   *\n   * Internal implementation that handles the full message send workflow including\n   * adding user message to state, building conversation history, sending POST request,\n   * and processing the SSE response stream.\n   *\n   * @param content - User message text content\n   * @param currentMessages - Current message array (passed to avoid closure issues)\n   * @returns Promise that resolves when stream completes\n   *\n   * @internal\n   */\n  const sendMessageInternal = useCallback(async (content: string, currentMessages: Message[]) => {\n    try {\n      setIsProcessing(true);\n      setError(null);\n\n      // Add user message immediately\n      const userMessage: Message = {\n        id: `msg-${Date.now()}-user`,\n        role: 'user',\n        content,\n        timestamp: new Date(),\n      };\n\n      // Build conversation history (current messages + new user message)\n      const conversationHistory = [...currentMessages, userMessage].map(m => ({\n        role: m.role,\n        content: m.content\n      }));\n\n      setMessages((prev) => [...prev, userMessage]);\n\n      const url = new URL(`${API_BASE}/agents/create-with-claude/message`, window.location.origin);\n\n      const response = await fetch(url.toString(), createFetchOptions({\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          directory,\n          conversationHistory\n        }),\n      }));\n\n      if (!response.ok) {\n        throw new Error('Failed to send message');\n      }\n\n      if (!response.body) {\n        throw new Error('No response body');\n      }\n\n      // Read SSE stream\n      const reader = response.body.getReader();\n      streamReaderRef.current = reader;\n      const decoder = new TextDecoder();\n\n      let buffer = '';\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) break;\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              try {\n                const data = JSON.parse(line.substring(6));\n                handleStreamEvent(data);\n              } catch (e) {\n                console.error('Failed to parse SSE data:', e);\n              }\n            }\n          }\n        }\n      } finally {\n        reader.releaseLock();\n        streamReaderRef.current = null;\n      }\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      setError(error);\n      if (onError) {\n        onError(error);\n      }\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [directory, onError]);\n\n  /**\n   * Start a new conversation with the agent creator\n   *\n   * Initiates the agent creation workflow by sending the initial message\n   * \"Let's create a new agent.\" with an empty conversation history.\n   *\n   * @returns Promise that resolves when initial message is sent and stream processed\n   */\n  const startConversation = useCallback(async () => {\n    // Send initial message to start conversation\n    await sendMessageInternal(\"Let's create a new agent.\", []);\n  }, [sendMessageInternal]);\n\n  /**\n   * Public API: Send a message in the ongoing conversation\n   *\n   * Uses messagesRef to get current messages without closure issues, then\n   * delegates to sendMessageInternal for the actual send operation.\n   *\n   * @param content - User message text content\n   * @returns Promise that resolves when message is sent and stream processed\n   */\n  const sendMessage = useCallback(async (content: string) => {\n    // Use messagesRef to get current messages without closure issues\n    const currentMessages = messagesRef.current;\n    await sendMessageInternal(content, currentMessages);\n  }, [sendMessageInternal]);\n\n  /**\n   * Handle stream events\n   *\n   * Processes SSE events from the agent creation stream. Handles multiple event types:\n   * - **message (assistant)**: Extracts text blocks and detects Write tool usage\n   * - **message (result)**: Marks query as completed\n   * - **status**: Updates isCreating flag when \"Creating\" or \"Writing\" detected\n   * - **complete**: Marks processing as finished\n   * - **error**: Sets error state and invokes error callback\n   *\n   * When Write tool is detected for `.claude/agents/{name}.md`, extracts agent name\n   * and invokes onAgentCreated callback.\n   *\n   * @param data - Parsed SSE event data object\n   *\n   * @internal\n   */\n  const handleStreamEvent = useCallback((data: any) => {\n    // Debug logging\n    console.log('[AgentCreator] Stream event:', data.type, data.messageType);\n\n    if (data.type === 'message' && data.messageType === 'assistant') {\n      // Extract text content from assistant message\n      // SDK structure: message.message.content (not message.content)\n      const content = data.content?.message?.content;\n      console.log('[AgentCreator] Assistant message content:', content);\n\n      if (content && Array.isArray(content)) {\n        const textBlocks = content.filter((block: any) => block.type === 'text');\n        if (textBlocks.length > 0) {\n          const textContent = textBlocks.map((block: any) => block.text).join('\\n');\n          console.log('[AgentCreator] Extracted text:', textContent);\n\n          const assistantMessage: Message = {\n            id: `msg-${Date.now()}-assistant`,\n            role: 'assistant',\n            content: textContent,\n            timestamp: new Date(),\n          };\n          setMessages((prev) => [...prev, assistantMessage]);\n        }\n\n        // Check for Write tool usage in assistant message\n        const toolUseBlocks = content.filter((block: any) => block.type === 'tool_use');\n        for (const block of toolUseBlocks) {\n          if (block.name === 'Write') {\n            const filePath = block.input?.file_path || '';\n            console.log('[AgentCreator] Write tool detected:', filePath);\n\n            // Check if writing to .claude/agents/\n            const match = filePath.match(/\\.claude[\\/\\\\]agents[\\/\\\\]([^\\/\\\\]+)\\.md/);\n            if (match) {\n              const agentName = match[1];\n              console.log('[AgentCreator] Agent file created:', agentName);\n              setCreatedAgentName(agentName);\n              setIsCreating(false);\n\n              if (onAgentCreated) {\n                onAgentCreated(agentName, filePath);\n              }\n            }\n          }\n        }\n      }\n    } else if (data.type === 'message' && data.messageType === 'result') {\n      // Final result message - query completed\n      console.log('[AgentCreator] Query completed');\n    } else if (data.type === 'status') {\n      // Check if Claude is creating the agent\n      if (data.status?.includes('Creating') || data.status?.includes('Writing')) {\n        setIsCreating(true);\n      }\n    } else if (data.type === 'complete') {\n      setIsProcessing(false);\n    } else if (data.type === 'error') {\n      const error = new Error(data.error || 'Agent creation failed');\n      setError(error);\n      if (onError) {\n        onError(error);\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [onAgentCreated, onError]);\n\n  /**\n   * Reset the conversation state\n   *\n   * Cancels any ongoing SSE stream, clears all conversation state including messages,\n   * processing flags, creation status, created agent name, and errors. Safe to call\n   * at any time, even if no conversation is active.\n   *\n   * @returns void\n   */\n  const reset = useCallback(() => {\n    // Cancel any ongoing stream\n    if (streamReaderRef.current) {\n      streamReaderRef.current.cancel();\n      streamReaderRef.current = null;\n    }\n\n    conversationIdRef.current = null;\n    setMessages([]);\n    setIsProcessing(false);\n    setIsCreating(false);\n    setCreatedAgentName(null);\n    setError(null);\n  }, []);\n\n  return {\n    messages,\n    isProcessing,\n    isCreating,\n    createdAgentName,\n    error,\n    startConversation,\n    sendMessage,\n    reset,\n  };\n}\n",
        "last_modified": "2026-01-02T14:22:15.587359"
      },
      "task_intent": {
        "title": "Document Frontend React Components and Hooks",
        "description": "Add comprehensive JSDoc documentation to all React components and custom hooks in the frontend, including prop types, usage examples, component purposes, state management, and side effects.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:01:12.074192",
  "last_updated": "2026-01-02T14:22:15.391187"
}