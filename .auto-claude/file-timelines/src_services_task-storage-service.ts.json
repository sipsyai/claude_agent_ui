{
  "file_path": "src/services/task-storage-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { randomUUID } from 'crypto';\nimport { createLogger, type Logger } from './logger.js';\nimport type { Task, CreateTaskRequest, TaskFilter, TaskStatus } from '../types/task-types.js';\n\n/**\n * Service for managing task storage\n * Each task is stored as a separate JSON file in logs/{task-id}.json\n * Also maintains an index file for fast listing\n */\nexport class TaskStorageService {\n  private logger: Logger;\n  private logsDir: string;\n  private indexFilePath: string;\n  private initialized = false;\n\n  constructor(logsDir?: string) {\n    this.logger = createLogger('TaskStorageService');\n\n    // Use logs directory in project root\n    this.logsDir = logsDir || path.join(process.cwd(), 'logs');\n    this.indexFilePath = path.join(this.logsDir, '_index.json');\n  }\n\n  /**\n   * Initialize storage (create logs directory if needed)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Ensure logs directory exists\n      await fs.mkdir(this.logsDir, { recursive: true });\n\n      // Try to load index file, create if doesn't exist\n      try {\n        await fs.access(this.indexFilePath);\n        this.logger.info('Logs directory initialized', { path: this.logsDir });\n      } catch (error: any) {\n        if (error.code === 'ENOENT') {\n          // Create empty index file\n          await this.saveIndex([]);\n          this.logger.info('Created new index file', { path: this.indexFilePath });\n        } else {\n          throw error;\n        }\n      }\n\n      this.initialized = true;\n    } catch (error) {\n      this.logger.error('Failed to initialize task storage', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get task file path\n   */\n  private getTaskFilePath(taskId: string): string {\n    return path.join(this.logsDir, `${taskId}.json`);\n  }\n\n  /**\n   * Save task to individual file\n   */\n  private async saveTask(task: Task): Promise<void> {\n    try {\n      const filePath = this.getTaskFilePath(task.id);\n      await fs.writeFile(filePath, JSON.stringify(task, null, 2), 'utf-8');\n      this.logger.debug('Task file saved', { taskId: task.id, path: filePath });\n    } catch (error) {\n      this.logger.error('Failed to save task file', error, { taskId: task.id });\n      throw error;\n    }\n  }\n\n  /**\n   * Load task from individual file\n   */\n  private async loadTask(taskId: string): Promise<Task | null> {\n    try {\n      const filePath = this.getTaskFilePath(taskId);\n      const data = await fs.readFile(filePath, 'utf-8');\n      return JSON.parse(data);\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return null;\n      }\n      this.logger.error('Failed to load task file', error, { taskId });\n      throw error;\n    }\n  }\n\n  /**\n   * Load index file (lightweight task summaries)\n   */\n  private async loadIndex(): Promise<Array<{\n    id: string;\n    name: string;\n    status: TaskStatus;\n    taskType: string;\n    agentName: string;\n    createdAt: string;\n    completedAt?: string;\n  }>> {\n    try {\n      const data = await fs.readFile(this.indexFilePath, 'utf-8');\n      return JSON.parse(data);\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Save index file\n   */\n  private async saveIndex(index: Array<any>): Promise<void> {\n    try {\n      await fs.writeFile(this.indexFilePath, JSON.stringify(index, null, 2), 'utf-8');\n    } catch (error) {\n      this.logger.error('Failed to save index file', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update index with task summary\n   */\n  private async updateIndex(task: Task): Promise<void> {\n    const index = await this.loadIndex();\n\n    // Remove existing entry if present\n    const existingIndex = index.findIndex(t => t.id === task.id);\n    if (existingIndex !== -1) {\n      index.splice(existingIndex, 1);\n    }\n\n    // Add updated entry at the beginning\n    index.unshift({\n      id: task.id,\n      name: task.name,\n      status: task.status,\n      taskType: task.taskType,\n      agentName: task.agentName,\n      createdAt: task.createdAt,\n      completedAt: task.completedAt,\n    });\n\n    await this.saveIndex(index);\n  }\n\n  /**\n   * Create a new task\n   */\n  async createTask(request: CreateTaskRequest, agentName: string): Promise<Task> {\n    await this.initialize();\n\n    const task: Task = {\n      id: randomUUID(),\n      name: request.name,\n      description: request.description,\n      agentId: request.agentId,\n      agentName,\n      taskType: request.taskType || 'agent',\n      status: 'pending',\n      userPrompt: request.userPrompt,\n      inputValues: request.inputValues,\n      permissionMode: request.permissionMode || 'default',\n      createdAt: new Date().toISOString(),\n      directory: request.directory,\n    };\n\n    // Save task to individual file\n    await this.saveTask(task);\n\n    // Update index\n    await this.updateIndex(task);\n\n    this.logger.info('Task created', {\n      taskId: task.id,\n      taskName: task.name,\n      taskType: task.taskType,\n      logFile: this.getTaskFilePath(task.id)\n    });\n\n    return task;\n  }\n\n  /**\n   * Get all tasks with optional filtering\n   */\n  async getTasks(filter?: TaskFilter): Promise<Task[]> {\n    await this.initialize();\n\n    // Load index for fast filtering\n    const index = await this.loadIndex();\n\n    // Apply filters to index\n    let filtered = [...index];\n\n    if (filter?.status) {\n      filtered = filtered.filter(t => t.status === filter.status);\n    }\n    // Apply pagination to index\n    const offset = filter?.offset || 0;\n    const limit = filter?.limit || 100;\n    const paginatedIndex = filtered.slice(offset, offset + limit);\n\n    // Load full task data for paginated results\n    const tasks = await Promise.all(\n      paginatedIndex.map(t => this.loadTask(t.id))\n    );\n\n    const validTasks = tasks.filter((t): t is Task => t !== null);\n\n    // Apply agentId filter if needed (requires full task data)\n    if (filter?.agentId) {\n      return validTasks.filter(t => t.agentId === filter.agentId);\n    }\n\n    return validTasks;\n  }\n\n  /**\n   * Get task by ID\n   */\n  async getTask(taskId: string): Promise<Task | null> {\n    await this.initialize();\n    return await this.loadTask(taskId);\n  }\n\n  /**\n   * Update task status\n   */\n  async updateTaskStatus(taskId: string, status: TaskStatus, data?: Partial<Task>): Promise<Task | null> {\n    await this.initialize();\n\n    const task = await this.loadTask(taskId);\n    if (!task) return null;\n\n    task.status = status;\n\n    // Update timestamps\n    if (status === 'running' && !task.startedAt) {\n      task.startedAt = new Date().toISOString();\n    }\n    if ((status === 'completed' || status === 'failed') && !task.completedAt) {\n      task.completedAt = new Date().toISOString();\n      if (task.startedAt) {\n        task.duration = new Date(task.completedAt).getTime() - new Date(task.startedAt).getTime();\n      }\n    }\n\n    // Apply additional data\n    if (data) {\n      Object.assign(task, data);\n    }\n\n    // Save updated task to file\n    await this.saveTask(task);\n\n    // Update index\n    await this.updateIndex(task);\n\n    this.logger.info('Task status updated', {\n      taskId,\n      status,\n      logFile: this.getTaskFilePath(taskId)\n    });\n\n    return task;\n  }\n\n  /**\n   * Delete task\n   */\n  async deleteTask(taskId: string): Promise<boolean> {\n    await this.initialize();\n\n    const task = await this.loadTask(taskId);\n    if (!task) return false;\n\n    // Delete task file\n    try {\n      const filePath = this.getTaskFilePath(taskId);\n      await fs.unlink(filePath);\n    } catch (error: any) {\n      if (error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n\n    // Update index\n    const index = await this.loadIndex();\n    const filteredIndex = index.filter(t => t.id !== taskId);\n    await this.saveIndex(filteredIndex);\n\n    this.logger.info('Task deleted', { taskId });\n    return true;\n  }\n\n  /**\n   * Get task statistics\n   */\n  async getStats(): Promise<{\n    total: number;\n    pending: number;\n    running: number;\n    completed: number;\n    failed: number;\n  }> {\n    await this.initialize();\n\n    const index = await this.loadIndex();\n\n    return {\n      total: index.length,\n      pending: index.filter(t => t.status === 'pending').length,\n      running: index.filter(t => t.status === 'running').length,\n      completed: index.filter(t => t.status === 'completed').length,\n      failed: index.filter(t => t.status === 'failed').length,\n    };\n  }\n\n  /**\n   * Rebuild index from all task files\n   * Useful for recovery or migration\n   */\n  async rebuildIndex(): Promise<void> {\n    await this.initialize();\n\n    this.logger.info('Rebuilding index from task files...');\n\n    // Get all .json files except _index.json\n    const files = await fs.readdir(this.logsDir);\n    const taskFiles = files.filter(f => f.endsWith('.json') && f !== '_index.json');\n\n    // Load all tasks\n    const tasks: Task[] = [];\n    for (const file of taskFiles) {\n      const taskId = file.replace('.json', '');\n      const task = await this.loadTask(taskId);\n      if (task) {\n        tasks.push(task);\n      }\n    }\n\n    // Sort by creation date (newest first)\n    tasks.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Build new index\n    const newIndex = tasks.map(t => ({\n      id: t.id,\n      name: t.name,\n      status: t.status,\n      taskType: t.taskType,\n      agentName: t.agentName,\n      createdAt: t.createdAt,\n      completedAt: t.completedAt,\n    }));\n\n    await this.saveIndex(newIndex);\n\n    this.logger.info('Index rebuilt successfully', { taskCount: newIndex.length });\n  }\n}\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { randomUUID } from 'crypto';\nimport { createLogger, type Logger } from './logger.js';\nimport type { Task, CreateTaskRequest, TaskFilter, TaskStatus } from '../types/task-types.js';\n\n/**\n * Service for managing persistent task storage using file-based JSON storage.\n *\n * @description\n * TaskStorageService provides a file-based storage system for agent task execution records.\n * Each task is stored as an individual JSON file in the logs directory, with a lightweight\n * index file for fast querying and filtering.\n *\n * ## Architecture\n *\n * **Storage Strategy:**\n * - Individual task files: `logs/{task-id}.json` - Contains full task data\n * - Index file: `logs/_index.json` - Contains lightweight task summaries for fast filtering\n * - Directory location: `logs/` in project root (configurable via constructor)\n *\n * **Index-Based Optimization:**\n * The service maintains a dual-layer storage approach:\n * 1. **Index layer** (`_index.json`): Lightweight summaries with essential fields (id, name, status, taskType, agentName, timestamps)\n * 2. **Task file layer** (`{task-id}.json`): Full task data with results, errors, execution logs, metadata\n *\n * This allows fast filtering/sorting without loading all task files into memory.\n *\n * **Task Lifecycle:**\n * 1. **Creation** (pending): Task created via createTask() with auto-generated UUID\n * 2. **Execution** (running): Status updated to 'running' via updateTaskStatus(), startedAt timestamp set\n * 3. **Completion** (completed/failed): Status updated, completedAt timestamp set, duration calculated\n * 4. **Deletion**: Task file and index entry removed via deleteTask()\n *\n * **File Structure:**\n * ```\n * logs/\n * \u251c\u2500\u2500 _index.json                    # Index file (lightweight summaries)\n * \u251c\u2500\u2500 123e4567-e89b-12d3-a456-426614174000.json  # Task file\n * \u251c\u2500\u2500 234e5678-e89b-12d3-a456-426614174001.json\n * \u2514\u2500\u2500 ...\n * ```\n *\n * **Index File Format:**\n * ```json\n * [\n *   {\n *     \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n *     \"name\": \"Implement user authentication\",\n *     \"status\": \"completed\",\n *     \"taskType\": \"agent\",\n *     \"agentName\": \"Backend Developer\",\n *     \"createdAt\": \"2026-01-02T08:00:00.000Z\",\n *     \"completedAt\": \"2026-01-02T08:05:30.000Z\"\n *   }\n * ]\n * ```\n *\n * **Task File Format:**\n * Full Task object with all fields (result, error, executionLog, metadata, etc.)\n *\n * @example\n * // Basic usage - Create and track task lifecycle\n * const taskStorage = new TaskStorageService();\n * await taskStorage.initialize();\n *\n * // Create new task\n * const task = await taskStorage.createTask({\n *   name: 'Implement user authentication',\n *   description: 'Add JWT-based authentication to the API',\n *   agentId: 'agent_123',\n *   taskType: 'agent',\n *   userPrompt: 'Implement JWT authentication with refresh tokens',\n *   permissionMode: 'default',\n *   directory: '/home/user/projects/my-app'\n * }, 'Backend Developer');\n *\n * // Update task status to running\n * await taskStorage.updateTaskStatus(task.id, 'running');\n *\n * // Complete task with result\n * await taskStorage.updateTaskStatus(task.id, 'completed', {\n *   result: 'Successfully implemented JWT authentication with refresh token support',\n *   executionLog: [...]\n * });\n *\n * @example\n * // List tasks with filtering and pagination\n * const taskStorage = new TaskStorageService();\n *\n * // Get all pending tasks\n * const pendingTasks = await taskStorage.getTasks({ status: 'pending' });\n *\n * // Get all tasks for a specific agent with pagination\n * const agentTasks = await taskStorage.getTasks({\n *   agentId: 'agent_123',\n *   limit: 20,\n *   offset: 0\n * });\n *\n * // Get task statistics\n * const stats = await taskStorage.getStats();\n * console.log(`Total: ${stats.total}, Pending: ${stats.pending}, Running: ${stats.running}`);\n *\n * @example\n * // Retrieve and display task details\n * const taskStorage = new TaskStorageService();\n *\n * const task = await taskStorage.getTask('123e4567-e89b-12d3-a456-426614174000');\n * if (task) {\n *   console.log(`Task: ${task.name}`);\n *   console.log(`Status: ${task.status}`);\n *   console.log(`Duration: ${task.duration}ms`);\n *   if (task.result) console.log(`Result: ${task.result}`);\n *   if (task.error) console.error(`Error: ${task.error}`);\n * }\n *\n * @example\n * // Custom logs directory for testing\n * const taskStorage = new TaskStorageService('/tmp/test-tasks');\n * await taskStorage.initialize();\n * // Tasks stored in /tmp/test-tasks/*.json\n *\n * @example\n * // Index recovery after corruption or migration\n * const taskStorage = new TaskStorageService();\n * await taskStorage.initialize();\n *\n * // Rebuild index from all task files\n * await taskStorage.rebuildIndex();\n * // Index file regenerated from all .json task files\n *\n * @see {@link Task} for full task data structure\n * @see {@link CreateTaskRequest} for task creation parameters\n * @see {@link TaskFilter} for filtering options\n */\nexport class TaskStorageService {\n  /** Logger instance for task storage operations */\n  private logger: Logger;\n\n  /** Directory path for task JSON files (default: logs/ in project root) */\n  private logsDir: string;\n\n  /** Path to index file for fast task querying */\n  private indexFilePath: string;\n\n  /** Initialization flag to ensure directory/index setup runs once */\n  private initialized = false;\n\n  constructor(logsDir?: string) {\n    this.logger = createLogger('TaskStorageService');\n\n    // Use logs directory in project root\n    this.logsDir = logsDir || path.join(process.cwd(), 'logs');\n    this.indexFilePath = path.join(this.logsDir, '_index.json');\n  }\n\n  /**\n   * Initialize task storage by creating logs directory and index file if needed.\n   *\n   * @description\n   * Prepares the task storage system for use by ensuring the logs directory exists\n   * and creating an empty index file if one doesn't exist. This method is idempotent\n   * and safe to call multiple times.\n   *\n   * **Initialization Workflow:**\n   * 1. Check if already initialized (skip if true)\n   * 2. Create logs directory if it doesn't exist (recursive creation)\n   * 3. Check for existing index file\n   * 4. Create empty index file if it doesn't exist\n   * 5. Mark as initialized\n   *\n   * **Automatic Initialization:**\n   * All public methods automatically call initialize() before executing, so manual\n   * initialization is typically not required. However, it can be useful for:\n   * - Pre-warming storage during application startup\n   * - Testing directory permissions before use\n   * - Explicit setup in initialization scripts\n   *\n   * **File Creation:**\n   * - Directory: `logs/` (or custom path from constructor)\n   * - Index file: `logs/_index.json` (empty array `[]`)\n   *\n   * **Idempotent Behavior:**\n   * - Safe to call multiple times (no-op if already initialized)\n   * - Does not overwrite existing index file\n   * - Creates directory with `{ recursive: true }` (safe if already exists)\n   *\n   * @returns Promise that resolves when initialization is complete\n   * @throws Error if directory creation fails (permissions, disk full, etc.)\n   *\n   * @example\n   * // Manual initialization during application startup\n   * const taskStorage = new TaskStorageService();\n   * await taskStorage.initialize();\n   * console.log('Task storage initialized');\n   *\n   * @example\n   * // Test directory permissions before use\n   * const taskStorage = new TaskStorageService();\n   *\n   * try {\n   *   await taskStorage.initialize();\n   *   console.log('Storage is ready');\n   * } catch (error) {\n   *   console.error('Failed to initialize storage:', error.message);\n   *   // Handle permission errors, disk full, etc.\n   * }\n   *\n   * @example\n   * // Automatic initialization (typical usage)\n   * const taskStorage = new TaskStorageService();\n   * // No need to call initialize() - it's called automatically\n   * const task = await taskStorage.createTask({...}, 'Agent Name');\n   *\n   * @example\n   * // Custom logs directory\n   * const taskStorage = new TaskStorageService('/var/app/task-logs');\n   * await taskStorage.initialize();\n   * // Creates /var/app/task-logs/ and /var/app/task-logs/_index.json\n   *\n   * @example\n   * // Idempotent behavior\n   * const taskStorage = new TaskStorageService();\n   * await taskStorage.initialize(); // Creates directory and index\n   * await taskStorage.initialize(); // No-op (already initialized)\n   * await taskStorage.initialize(); // No-op (already initialized)\n   *\n   * @see {@link createTask} for creating tasks (auto-initializes)\n   * @see {@link getTasks} for retrieving tasks (auto-initializes)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Ensure logs directory exists\n      await fs.mkdir(this.logsDir, { recursive: true });\n\n      // Try to load index file, create if doesn't exist\n      try {\n        await fs.access(this.indexFilePath);\n        this.logger.info('Logs directory initialized', { path: this.logsDir });\n      } catch (error: any) {\n        if (error.code === 'ENOENT') {\n          // Create empty index file\n          await this.saveIndex([]);\n          this.logger.info('Created new index file', { path: this.indexFilePath });\n        } else {\n          throw error;\n        }\n      }\n\n      this.initialized = true;\n    } catch (error) {\n      this.logger.error('Failed to initialize task storage', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get task file path\n   */\n  private getTaskFilePath(taskId: string): string {\n    return path.join(this.logsDir, `${taskId}.json`);\n  }\n\n  /**\n   * Save task to individual file\n   */\n  private async saveTask(task: Task): Promise<void> {\n    try {\n      const filePath = this.getTaskFilePath(task.id);\n      await fs.writeFile(filePath, JSON.stringify(task, null, 2), 'utf-8');\n      this.logger.debug('Task file saved', { taskId: task.id, path: filePath });\n    } catch (error) {\n      this.logger.error('Failed to save task file', error, { taskId: task.id });\n      throw error;\n    }\n  }\n\n  /**\n   * Load task from individual file\n   */\n  private async loadTask(taskId: string): Promise<Task | null> {\n    try {\n      const filePath = this.getTaskFilePath(taskId);\n      const data = await fs.readFile(filePath, 'utf-8');\n      return JSON.parse(data);\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return null;\n      }\n      this.logger.error('Failed to load task file', error, { taskId });\n      throw error;\n    }\n  }\n\n  /**\n   * Load index file (lightweight task summaries)\n   */\n  private async loadIndex(): Promise<Array<{\n    id: string;\n    name: string;\n    status: TaskStatus;\n    taskType: string;\n    agentName: string;\n    createdAt: string;\n    completedAt?: string;\n  }>> {\n    try {\n      const data = await fs.readFile(this.indexFilePath, 'utf-8');\n      return JSON.parse(data);\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Save index file\n   */\n  private async saveIndex(index: Array<any>): Promise<void> {\n    try {\n      await fs.writeFile(this.indexFilePath, JSON.stringify(index, null, 2), 'utf-8');\n    } catch (error) {\n      this.logger.error('Failed to save index file', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update index with task summary\n   */\n  private async updateIndex(task: Task): Promise<void> {\n    const index = await this.loadIndex();\n\n    // Remove existing entry if present\n    const existingIndex = index.findIndex(t => t.id === task.id);\n    if (existingIndex !== -1) {\n      index.splice(existingIndex, 1);\n    }\n\n    // Add updated entry at the beginning\n    index.unshift({\n      id: task.id,\n      name: task.name,\n      status: task.status,\n      taskType: task.taskType,\n      agentName: task.agentName,\n      createdAt: task.createdAt,\n      completedAt: task.completedAt,\n    });\n\n    await this.saveIndex(index);\n  }\n\n  /**\n   * Create a new task and persist to storage.\n   *\n   * @description\n   * Creates a new task record with auto-generated UUID, initializes task lifecycle fields,\n   * saves task to individual JSON file, and updates index for fast querying.\n   *\n   * **Task Initialization:**\n   * - Auto-generates UUID for task.id\n   * - Sets status to 'pending'\n   * - Sets createdAt timestamp (ISO 8601 format)\n   * - Defaults taskType to 'agent' if not provided\n   * - Defaults permissionMode to 'default' if not provided\n   *\n   * **Storage Operations:**\n   * 1. Initialize storage if not already initialized\n   * 2. Create Task object with auto-generated fields\n   * 3. Save task to `logs/{task-id}.json`\n   * 4. Update index file with task summary\n   * 5. Log task creation with metadata\n   *\n   * **File Creation:**\n   * - Task file: `logs/{uuid}.json` - Full task data\n   * - Index entry: Added to `logs/_index.json` - Lightweight summary\n   *\n   * @param request - Task creation parameters (name, description, agentId, userPrompt, etc.)\n   * @param agentName - Human-readable agent/skill name for display and filtering\n   * @returns Promise resolving to created Task object with auto-generated id and timestamps\n   *\n   * @example\n   * // Create agent task\n   * const taskStorage = new TaskStorageService();\n   *\n   * const task = await taskStorage.createTask({\n   *   name: 'Implement user authentication',\n   *   description: 'Add JWT-based authentication to the API',\n   *   agentId: 'agent_123',\n   *   taskType: 'agent',\n   *   userPrompt: 'Implement JWT authentication with refresh tokens and role-based access control',\n   *   permissionMode: 'default',\n   *   directory: '/home/user/projects/my-app'\n   * }, 'Backend Developer');\n   *\n   * console.log(task.id); // '123e4567-e89b-12d3-a456-426614174000' (auto-generated UUID)\n   * console.log(task.status); // 'pending'\n   * console.log(task.createdAt); // '2026-01-02T08:00:00.000Z'\n   *\n   * @example\n   * // Create skill task with input values\n   * const taskStorage = new TaskStorageService();\n   *\n   * const task = await taskStorage.createTask({\n   *   name: 'Generate API documentation',\n   *   description: 'Generate OpenAPI documentation for REST API',\n   *   agentId: 'skill_api-docs',\n   *   taskType: 'skill',\n   *   userPrompt: 'Generate complete OpenAPI 3.0 documentation',\n   *   inputValues: {\n   *     apiPath: '/home/user/projects/my-app/src/api',\n   *     outputFormat: 'yaml',\n   *     includeExamples: true\n   *   },\n   *   permissionMode: 'default'\n   * }, 'API Documentation Generator');\n   *\n   * console.log(task.inputValues); // { apiPath: '...', outputFormat: 'yaml', ... }\n   *\n   * @example\n   * // Create task with bypass permission mode\n   * const task = await taskStorage.createTask({\n   *   name: 'Deploy to production',\n   *   agentId: 'agent_devops',\n   *   taskType: 'agent',\n   *   userPrompt: 'Deploy latest build to production environment',\n   *   permissionMode: 'bypass', // Auto-approve all tool use\n   *   directory: '/home/user/projects/my-app'\n   * }, 'DevOps Engineer');\n   *\n   * @example\n   * // Create task with metadata for skill execution\n   * const task = await taskStorage.createTask({\n   *   name: 'Run code linter',\n   *   agentId: 'skill_linter',\n   *   taskType: 'skill',\n   *   userPrompt: 'Lint all TypeScript files',\n   *   directory: '/home/user/projects/my-app'\n   * }, 'Code Linter');\n   * // Metadata can be added later via updateTaskStatus\n   *\n   * @example\n   * // Verify task file creation\n   * const taskStorage = new TaskStorageService();\n   * const task = await taskStorage.createTask({\n   *   name: 'Test task',\n   *   agentId: 'agent_test',\n   *   userPrompt: 'Test prompt',\n   *   permissionMode: 'default'\n   * }, 'Test Agent');\n   *\n   * const fs = require('fs/promises');\n   * const taskFile = `logs/${task.id}.json`;\n   * const fileContent = await fs.readFile(taskFile, 'utf-8');\n   * const savedTask = JSON.parse(fileContent);\n   * console.log(savedTask.id === task.id); // true\n   *\n   * @see {@link CreateTaskRequest} for request parameters\n   * @see {@link Task} for full task data structure\n   * @see {@link updateTaskStatus} for updating task status and adding results\n   */\n  async createTask(request: CreateTaskRequest, agentName: string): Promise<Task> {\n    await this.initialize();\n\n    const task: Task = {\n      id: randomUUID(),\n      name: request.name,\n      description: request.description,\n      agentId: request.agentId,\n      agentName,\n      taskType: request.taskType || 'agent',\n      status: 'pending',\n      userPrompt: request.userPrompt,\n      inputValues: request.inputValues,\n      permissionMode: request.permissionMode || 'default',\n      createdAt: new Date().toISOString(),\n      directory: request.directory,\n    };\n\n    // Save task to individual file\n    await this.saveTask(task);\n\n    // Update index\n    await this.updateIndex(task);\n\n    this.logger.info('Task created', {\n      taskId: task.id,\n      taskName: task.name,\n      taskType: task.taskType,\n      logFile: this.getTaskFilePath(task.id)\n    });\n\n    return task;\n  }\n\n  /**\n   * Retrieve all tasks with optional filtering, sorting, and pagination.\n   *\n   * @description\n   * Retrieves tasks from storage using the index file for fast filtering, then loads\n   * full task data only for the filtered results. Supports filtering by status and agentId,\n   * with built-in pagination support.\n   *\n   * **Query Strategy:**\n   * 1. Load lightweight index file (`_index.json`)\n   * 2. Apply status filter to index (if provided)\n   * 3. Apply pagination to filtered index (limit/offset)\n   * 4. Load full task data only for paginated results\n   * 5. Apply agentId filter to full task data (requires full task object)\n   *\n   * This two-phase approach minimizes file I/O by filtering at the index level first.\n   *\n   * **Default Behavior:**\n   * - Returns all tasks if no filter provided\n   * - Default limit: 100 tasks\n   * - Default offset: 0\n   * - Sorted by creation date (newest first) via index ordering\n   *\n   * **Performance:**\n   * - Fast for status filtering (uses index)\n   * - Slower for agentId filtering (requires loading full task files)\n   * - Pagination reduces memory usage for large task lists\n   *\n   * @param filter - Optional filter criteria (status, agentId, limit, offset)\n   * @returns Promise resolving to array of Task objects matching filter criteria\n   *\n   * @example\n   * // Get all tasks (up to default limit of 100)\n   * const taskStorage = new TaskStorageService();\n   * const allTasks = await taskStorage.getTasks();\n   * console.log(`Total tasks: ${allTasks.length}`);\n   *\n   * @example\n   * // Get all pending tasks\n   * const taskStorage = new TaskStorageService();\n   * const pendingTasks = await taskStorage.getTasks({ status: 'pending' });\n   * console.log(`Pending tasks: ${pendingTasks.length}`);\n   * pendingTasks.forEach(task => {\n   *   console.log(`- ${task.name} (${task.agentName})`);\n   * });\n   *\n   * @example\n   * // Get all running tasks\n   * const runningTasks = await taskStorage.getTasks({ status: 'running' });\n   * runningTasks.forEach(task => {\n   *   const elapsed = Date.now() - new Date(task.startedAt!).getTime();\n   *   console.log(`${task.name}: Running for ${elapsed}ms`);\n   * });\n   *\n   * @example\n   * // Get all completed tasks\n   * const completedTasks = await taskStorage.getTasks({ status: 'completed' });\n   * const avgDuration = completedTasks.reduce((sum, t) => sum + (t.duration || 0), 0) / completedTasks.length;\n   * console.log(`Average completion time: ${avgDuration}ms`);\n   *\n   * @example\n   * // Get all tasks for a specific agent\n   * const agentTasks = await taskStorage.getTasks({ agentId: 'agent_123' });\n   * console.log(`Agent 'agent_123' has ${agentTasks.length} tasks`);\n   *\n   * @example\n   * // Pagination for task list UI\n   * const taskStorage = new TaskStorageService();\n   * const page = 2;\n   * const pageSize = 20;\n   *\n   * const tasks = await taskStorage.getTasks({\n   *   limit: pageSize,\n   *   offset: (page - 1) * pageSize\n   * });\n   *\n   * console.log(`Page ${page}: Showing ${tasks.length} tasks`);\n   * tasks.forEach(task => {\n   *   console.log(`${task.name} - ${task.status}`);\n   * });\n   *\n   * @example\n   * // Combined filtering - Pending tasks for specific agent\n   * const agentPendingTasks = await taskStorage.getTasks({\n   *   status: 'pending',\n   *   agentId: 'agent_backend',\n   *   limit: 10\n   * });\n   * console.log(`Agent has ${agentPendingTasks.length} pending tasks`);\n   *\n   * @example\n   * // Task queue management\n   * const taskStorage = new TaskStorageService();\n   *\n   * // Get next pending task to execute\n   * const pendingTasks = await taskStorage.getTasks({\n   *   status: 'pending',\n   *   limit: 1\n   * });\n   *\n   * if (pendingTasks.length > 0) {\n   *   const nextTask = pendingTasks[0];\n   *   console.log(`Next task: ${nextTask.name}`);\n   *   await taskStorage.updateTaskStatus(nextTask.id, 'running');\n   * }\n   *\n   * @example\n   * // Empty result handling\n   * const failedTasks = await taskStorage.getTasks({ status: 'failed' });\n   * if (failedTasks.length === 0) {\n   *   console.log('No failed tasks found');\n   * } else {\n   *   console.log(`Found ${failedTasks.length} failed tasks`);\n   *   failedTasks.forEach(task => {\n   *     console.error(`${task.name}: ${task.error}`);\n   *   });\n   * }\n   *\n   * @see {@link TaskFilter} for available filter options\n   * @see {@link Task} for task data structure\n   * @see {@link getStats} for task statistics without loading full data\n   */\n  async getTasks(filter?: TaskFilter): Promise<Task[]> {\n    await this.initialize();\n\n    // Load index for fast filtering\n    const index = await this.loadIndex();\n\n    // Apply filters to index\n    let filtered = [...index];\n\n    if (filter?.status) {\n      filtered = filtered.filter(t => t.status === filter.status);\n    }\n    // Apply pagination to index\n    const offset = filter?.offset || 0;\n    const limit = filter?.limit || 100;\n    const paginatedIndex = filtered.slice(offset, offset + limit);\n\n    // Load full task data for paginated results\n    const tasks = await Promise.all(\n      paginatedIndex.map(t => this.loadTask(t.id))\n    );\n\n    const validTasks = tasks.filter((t): t is Task => t !== null);\n\n    // Apply agentId filter if needed (requires full task data)\n    if (filter?.agentId) {\n      return validTasks.filter(t => t.agentId === filter.agentId);\n    }\n\n    return validTasks;\n  }\n\n  /**\n   * Retrieve a single task by its unique identifier.\n   *\n   * @description\n   * Loads full task data from individual task file. Returns null if task file\n   * does not exist (task not found or deleted).\n   *\n   * **File Lookup:**\n   * - Reads task file: `logs/{taskId}.json`\n   * - Returns null if file not found (ENOENT error)\n   * - Throws error for other read failures (permissions, corrupted file, etc.)\n   *\n   * **Use Cases:**\n   * - Retrieve task details for display\n   * - Check task status before updating\n   * - Load task data for execution\n   * - Verify task existence\n   *\n   * @param taskId - Unique task identifier (UUID)\n   * @returns Promise resolving to Task object if found, null if not found\n   *\n   * @example\n   * // Basic task retrieval\n   * const taskStorage = new TaskStorageService();\n   * const task = await taskStorage.getTask('123e4567-e89b-12d3-a456-426614174000');\n   *\n   * if (task) {\n   *   console.log(`Task: ${task.name}`);\n   *   console.log(`Status: ${task.status}`);\n   *   console.log(`Agent: ${task.agentName}`);\n   * } else {\n   *   console.log('Task not found');\n   * }\n   *\n   * @example\n   * // Display task details\n   * const task = await taskStorage.getTask(taskId);\n   * if (task) {\n   *   console.log(`Name: ${task.name}`);\n   *   console.log(`Description: ${task.description}`);\n   *   console.log(`Status: ${task.status}`);\n   *   console.log(`Created: ${new Date(task.createdAt).toLocaleString()}`);\n   *\n   *   if (task.startedAt) {\n   *     console.log(`Started: ${new Date(task.startedAt).toLocaleString()}`);\n   *   }\n   *\n   *   if (task.completedAt) {\n   *     console.log(`Completed: ${new Date(task.completedAt).toLocaleString()}`);\n   *     console.log(`Duration: ${task.duration}ms`);\n   *   }\n   *\n   *   if (task.result) {\n   *     console.log(`Result: ${task.result}`);\n   *   }\n   *\n   *   if (task.error) {\n   *     console.error(`Error: ${task.error}`);\n   *   }\n   * }\n   *\n   * @example\n   * // Check task status before execution\n   * const task = await taskStorage.getTask(taskId);\n   * if (!task) {\n   *   throw new Error('Task not found');\n   * }\n   *\n   * if (task.status !== 'pending') {\n   *   throw new Error(`Task is already ${task.status}`);\n   * }\n   *\n   * // Proceed with execution\n   * await taskStorage.updateTaskStatus(taskId, 'running');\n   *\n   * @example\n   * // Load task for result display\n   * const task = await taskStorage.getTask(taskId);\n   * if (task && task.status === 'completed') {\n   *   console.log('=== Task Results ===');\n   *   console.log(`Task: ${task.name}`);\n   *   console.log(`Duration: ${task.duration}ms`);\n   *   console.log(`Result:\\n${task.result}`);\n   *\n   *   if (task.executionLog) {\n   *     console.log('\\n=== Execution Log ===');\n   *     task.executionLog.forEach(entry => console.log(entry));\n   *   }\n   * }\n   *\n   * @example\n   * // Verify task existence\n   * const taskExists = await taskStorage.getTask(taskId) !== null;\n   * if (taskExists) {\n   *   console.log('Task exists');\n   * } else {\n   *   console.log('Task does not exist or was deleted');\n   * }\n   *\n   * @example\n   * // Load task with metadata\n   * const task = await taskStorage.getTask(taskId);\n   * if (task && task.metadata?.skillExecution) {\n   *   const skillMeta = task.metadata.skillExecution;\n   *   console.log(`Skill: ${skillMeta.selectedSkillName}`);\n   *   console.log(`Isolation: ${skillMeta.isolationLevel}`);\n   *   console.log(`System Prompt Source: ${skillMeta.systemPromptSource}`);\n   * }\n   *\n   * @see {@link Task} for task data structure\n   * @see {@link getTasks} for retrieving multiple tasks with filtering\n   * @see {@link updateTaskStatus} for updating task status\n   */\n  async getTask(taskId: string): Promise<Task | null> {\n    await this.initialize();\n    return await this.loadTask(taskId);\n  }\n\n  /**\n   * Update task status and optionally merge additional task data.\n   *\n   * @description\n   * Updates task status with automatic timestamp management and lifecycle tracking.\n   * Also supports merging additional task data (result, error, executionLog, metadata).\n   *\n   * **Automatic Timestamp Management:**\n   * - **Running**: Sets `startedAt` timestamp on first transition to 'running' status\n   * - **Completed/Failed**: Sets `completedAt` timestamp and calculates `duration` (ms)\n   *\n   * **Duration Calculation:**\n   * - `duration = completedAt - startedAt` (in milliseconds)\n   * - Only calculated if both timestamps exist\n   *\n   * **Task Lifecycle Workflow:**\n   * 1. Load existing task from file\n   * 2. Update status\n   * 3. Set automatic timestamps based on new status\n   * 4. Merge additional data (if provided)\n   * 5. Save updated task to file\n   * 6. Update index with new status and timestamps\n   * 7. Log status change\n   *\n   * **Data Merge Behavior:**\n   * - Uses Object.assign() for shallow merge\n   * - Additional data overwrites existing fields\n   * - Useful for adding result, error, executionLog, metadata\n   *\n   * @param taskId - Unique task identifier (UUID)\n   * @param status - New task status ('pending' | 'running' | 'completed' | 'failed')\n   * @param data - Optional additional task data to merge (result, error, executionLog, metadata, etc.)\n   * @returns Promise resolving to updated Task object, or null if task not found\n   *\n   * @example\n   * // Start task execution (pending \u2192 running)\n   * const taskStorage = new TaskStorageService();\n   *\n   * const task = await taskStorage.updateTaskStatus(taskId, 'running');\n   * console.log(task.status); // 'running'\n   * console.log(task.startedAt); // '2026-01-02T08:00:00.000Z' (auto-set)\n   *\n   * @example\n   * // Complete task with result (running \u2192 completed)\n   * const taskStorage = new TaskStorageService();\n   *\n   * const task = await taskStorage.updateTaskStatus(taskId, 'completed', {\n   *   result: 'Successfully implemented user authentication with JWT tokens and role-based access control',\n   *   executionLog: [\n   *     { timestamp: '2026-01-02T08:00:00.000Z', message: 'Started task execution' },\n   *     { timestamp: '2026-01-02T08:02:30.000Z', message: 'Generated JWT secret key' },\n   *     { timestamp: '2026-01-02T08:05:00.000Z', message: 'Implemented token refresh logic' },\n   *     { timestamp: '2026-01-02T08:05:30.000Z', message: 'Task completed successfully' }\n   *   ]\n   * });\n   *\n   * console.log(task.status); // 'completed'\n   * console.log(task.completedAt); // '2026-01-02T08:05:30.000Z' (auto-set)\n   * console.log(task.duration); // 330000 (5 minutes 30 seconds in ms)\n   * console.log(task.result); // 'Successfully implemented...'\n   *\n   * @example\n   * // Fail task with error (running \u2192 failed)\n   * const task = await taskStorage.updateTaskStatus(taskId, 'failed', {\n   *   error: 'Failed to connect to database: ECONNREFUSED',\n   *   executionLog: [\n   *     { timestamp: '2026-01-02T08:00:00.000Z', message: 'Started task execution' },\n   *     { timestamp: '2026-01-02T08:01:00.000Z', message: 'Attempting database connection' },\n   *     { timestamp: '2026-01-02T08:01:30.000Z', message: 'Connection failed: ECONNREFUSED' }\n   *   ]\n   * });\n   *\n   * console.log(task.status); // 'failed'\n   * console.log(task.error); // 'Failed to connect to database: ECONNREFUSED'\n   * console.log(task.duration); // 90000 (1 minute 30 seconds in ms)\n   *\n   * @example\n   * // Update task with metadata\n   * const task = await taskStorage.updateTaskStatus(taskId, 'running', {\n   *   metadata: {\n   *     skillExecution: {\n   *       selectedSkillId: 'skill_123',\n   *       selectedSkillName: 'Code Linter',\n   *       source: 'strapi',\n   *       isolationLevel: 'full',\n   *       systemPromptSource: 'skill.content',\n   *       otherSkillsAccessible: false\n   *     }\n   *   }\n   * });\n   *\n   * @example\n   * // Update task with input values result\n   * const task = await taskStorage.updateTaskStatus(taskId, 'completed', {\n   *   result: 'Generated API documentation successfully',\n   *   metadata: {\n   *     outputFile: '/home/user/projects/my-app/docs/api.yaml',\n   *     linesGenerated: 1200,\n   *     endpointsDocumented: 45\n   *   }\n   * });\n   *\n   * @example\n   * // Handle task not found\n   * const task = await taskStorage.updateTaskStatus('invalid-task-id', 'completed');\n   * if (!task) {\n   *   console.error('Task not found');\n   * }\n   *\n   * @example\n   * // Task execution wrapper\n   * async function executeTask(taskId: string, executeFn: () => Promise<string>) {\n   *   const taskStorage = new TaskStorageService();\n   *\n   *   try {\n   *     // Start execution\n   *     await taskStorage.updateTaskStatus(taskId, 'running');\n   *\n   *     // Execute task\n   *     const result = await executeFn();\n   *\n   *     // Mark as completed\n   *     await taskStorage.updateTaskStatus(taskId, 'completed', { result });\n   *   } catch (error) {\n   *     // Mark as failed\n   *     await taskStorage.updateTaskStatus(taskId, 'failed', {\n   *       error: error.message\n   *     });\n   *   }\n   * }\n   *\n   * @example\n   * // Incremental status updates\n   * const taskStorage = new TaskStorageService();\n   *\n   * // Start execution\n   * await taskStorage.updateTaskStatus(taskId, 'running');\n   *\n   * // Add execution log entry during execution\n   * await taskStorage.updateTaskStatus(taskId, 'running', {\n   *   executionLog: [\n   *     { timestamp: new Date().toISOString(), message: 'Checkpoint: 50% complete' }\n   *   ]\n   * });\n   *\n   * // Complete with final result\n   * await taskStorage.updateTaskStatus(taskId, 'completed', {\n   *   result: 'Task completed successfully',\n   *   executionLog: [\n   *     { timestamp: new Date().toISOString(), message: 'Checkpoint: 100% complete' }\n   *   ]\n   * });\n   *\n   * @see {@link Task} for task data structure\n   * @see {@link TaskStatus} for available status values\n   * @see {@link getTask} for retrieving task details\n   */\n  async updateTaskStatus(taskId: string, status: TaskStatus, data?: Partial<Task>): Promise<Task | null> {\n    await this.initialize();\n\n    const task = await this.loadTask(taskId);\n    if (!task) return null;\n\n    task.status = status;\n\n    // Update timestamps\n    if (status === 'running' && !task.startedAt) {\n      task.startedAt = new Date().toISOString();\n    }\n    if ((status === 'completed' || status === 'failed') && !task.completedAt) {\n      task.completedAt = new Date().toISOString();\n      if (task.startedAt) {\n        task.duration = new Date(task.completedAt).getTime() - new Date(task.startedAt).getTime();\n      }\n    }\n\n    // Apply additional data\n    if (data) {\n      Object.assign(task, data);\n    }\n\n    // Save updated task to file\n    await this.saveTask(task);\n\n    // Update index\n    await this.updateIndex(task);\n\n    this.logger.info('Task status updated', {\n      taskId,\n      status,\n      logFile: this.getTaskFilePath(taskId)\n    });\n\n    return task;\n  }\n\n  /**\n   * Permanently delete task from storage.\n   *\n   * @description\n   * Removes task file and index entry. This operation is irreversible - once deleted,\n   * the task cannot be recovered.\n   *\n   * **Deletion Workflow:**\n   * 1. Initialize storage if not already initialized\n   * 2. Load task to verify existence\n   * 3. Delete task file from `logs/{taskId}.json`\n   * 4. Remove task entry from index file\n   * 5. Save updated index\n   * 6. Log deletion\n   *\n   * **File Operations:**\n   * - Deletes: `logs/{taskId}.json`\n   * - Updates: `logs/_index.json` (removes entry)\n   *\n   * **Error Handling:**\n   * - Returns false if task not found (no task file exists)\n   * - Gracefully handles ENOENT errors (file already deleted)\n   * - Throws error for other file system failures (permissions, etc.)\n   *\n   * **Important Notes:**\n   * - **IRREVERSIBLE**: Deleted tasks cannot be recovered\n   * - Consider archiving instead of deleting for audit trail\n   * - Use with caution in production environments\n   *\n   * @param taskId - Unique task identifier (UUID) of task to delete\n   * @returns Promise resolving to true if task was deleted, false if task not found\n   *\n   * @example\n   * // Basic task deletion\n   * const taskStorage = new TaskStorageService();\n   *\n   * const deleted = await taskStorage.deleteTask('123e4567-e89b-12d3-a456-426614174000');\n   * if (deleted) {\n   *   console.log('Task deleted successfully');\n   * } else {\n   *   console.log('Task not found');\n   * }\n   *\n   * @example\n   * // Safe deletion with confirmation\n   * const taskStorage = new TaskStorageService();\n   *\n   * // Load task first to show details\n   * const task = await taskStorage.getTask(taskId);\n   * if (!task) {\n   *   console.error('Task not found');\n   *   return;\n   * }\n   *\n   * // Confirm deletion\n   * console.log(`About to delete task: ${task.name}`);\n   * const confirmed = await getUserConfirmation('Are you sure? This cannot be undone.');\n   *\n   * if (confirmed) {\n   *   await taskStorage.deleteTask(taskId);\n   *   console.log('Task deleted successfully');\n   * }\n   *\n   * @example\n   * // Clean up completed tasks older than 30 days\n   * const taskStorage = new TaskStorageService();\n   *\n   * const completedTasks = await taskStorage.getTasks({ status: 'completed' });\n   * const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\n   *\n   * for (const task of completedTasks) {\n   *   const completedDate = new Date(task.completedAt!).getTime();\n   *   if (completedDate < thirtyDaysAgo) {\n   *     await taskStorage.deleteTask(task.id);\n   *     console.log(`Deleted old task: ${task.name}`);\n   *   }\n   * }\n   *\n   * @example\n   * // Delete failed tasks with cleanup logging\n   * const taskStorage = new TaskStorageService();\n   *\n   * const failedTasks = await taskStorage.getTasks({ status: 'failed' });\n   * console.log(`Found ${failedTasks.length} failed tasks to delete`);\n   *\n   * for (const task of failedTasks) {\n   *   const deleted = await taskStorage.deleteTask(task.id);\n   *   if (deleted) {\n   *     console.log(`Deleted: ${task.name} (Error: ${task.error})`);\n   *   }\n   * }\n   *\n   * @example\n   * // Bulk delete with error handling\n   * async function bulkDeleteTasks(taskIds: string[]) {\n   *   const taskStorage = new TaskStorageService();\n   *   const results = { deleted: 0, notFound: 0, errors: 0 };\n   *\n   *   for (const taskId of taskIds) {\n   *     try {\n   *       const deleted = await taskStorage.deleteTask(taskId);\n   *       if (deleted) {\n   *         results.deleted++;\n   *       } else {\n   *         results.notFound++;\n   *       }\n   *     } catch (error) {\n   *       results.errors++;\n   *       console.error(`Error deleting task ${taskId}:`, error);\n   *     }\n   *   }\n   *\n   *   return results;\n   * }\n   *\n   * @example\n   * // Alternative: Archive instead of delete (preserves audit trail)\n   * // Note: TaskStorageService doesn't have archive functionality,\n   * // but you could implement it by adding an 'archived' field\n   * const task = await taskStorage.getTask(taskId);\n   * if (task) {\n   *   // Instead of deleting, mark as archived\n   *   await taskStorage.updateTaskStatus(taskId, task.status, {\n   *     metadata: {\n   *       ...task.metadata,\n   *       archived: true,\n   *       archivedAt: new Date().toISOString()\n   *     }\n   *   });\n   * }\n   * // Then filter out archived tasks in getTasks() results\n   *\n   * @example\n   * // Handle deletion errors\n   * const taskStorage = new TaskStorageService();\n   *\n   * try {\n   *   const deleted = await taskStorage.deleteTask(taskId);\n   *   if (deleted) {\n   *     console.log('Task deleted successfully');\n   *   } else {\n   *     console.log('Task not found or already deleted');\n   *   }\n   * } catch (error) {\n   *   console.error('Failed to delete task:', error.message);\n   *   // Handle permission errors, disk full, etc.\n   * }\n   *\n   * @see {@link Task} for task data structure\n   * @see {@link getTask} for retrieving task before deletion\n   * @see {@link getTasks} for bulk operations\n   */\n  async deleteTask(taskId: string): Promise<boolean> {\n    await this.initialize();\n\n    const task = await this.loadTask(taskId);\n    if (!task) return false;\n\n    // Delete task file\n    try {\n      const filePath = this.getTaskFilePath(taskId);\n      await fs.unlink(filePath);\n    } catch (error: any) {\n      if (error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n\n    // Update index\n    const index = await this.loadIndex();\n    const filteredIndex = index.filter(t => t.id !== taskId);\n    await this.saveIndex(filteredIndex);\n\n    this.logger.info('Task deleted', { taskId });\n    return true;\n  }\n\n  /**\n   * Retrieve task statistics without loading full task data.\n   *\n   * @description\n   * Returns task counts by status using the lightweight index file for fast aggregation.\n   * Does not load full task files, making it efficient for large task lists.\n   *\n   * **Performance:**\n   * - Fast: Only reads index file (lightweight summaries)\n   * - No full task file loading\n   * - O(n) where n = number of tasks in index\n   *\n   * **Use Cases:**\n   * - Dashboard statistics display\n   * - Task queue monitoring\n   * - System health checks\n   * - Task management UI badges\n   *\n   * @returns Promise resolving to statistics object with counts by status\n   *\n   * @example\n   * // Basic statistics\n   * const taskStorage = new TaskStorageService();\n   * const stats = await taskStorage.getStats();\n   *\n   * console.log(`Total: ${stats.total}`);\n   * console.log(`Pending: ${stats.pending}`);\n   * console.log(`Running: ${stats.running}`);\n   * console.log(`Completed: ${stats.completed}`);\n   * console.log(`Failed: ${stats.failed}`);\n   *\n   * @example\n   * // Dashboard statistics display\n   * const taskStorage = new TaskStorageService();\n   * const stats = await taskStorage.getStats();\n   *\n   * console.log('=== Task Statistics ===');\n   * console.log(`Total Tasks: ${stats.total}`);\n   * console.log(`Pending: ${stats.pending} (${(stats.pending / stats.total * 100).toFixed(1)}%)`);\n   * console.log(`Running: ${stats.running} (${(stats.running / stats.total * 100).toFixed(1)}%)`);\n   * console.log(`Completed: ${stats.completed} (${(stats.completed / stats.total * 100).toFixed(1)}%)`);\n   * console.log(`Failed: ${stats.failed} (${(stats.failed / stats.total * 100).toFixed(1)}%)`);\n   *\n   * @example\n   * // Task queue monitoring\n   * const taskStorage = new TaskStorageService();\n   *\n   * setInterval(async () => {\n   *   const stats = await taskStorage.getStats();\n   *   console.log(`Queue: ${stats.pending} pending, ${stats.running} running`);\n   *\n   *   if (stats.running > 10) {\n   *     console.warn('High number of running tasks detected');\n   *   }\n   * }, 5000); // Check every 5 seconds\n   *\n   * @example\n   * // System health check\n   * async function checkTaskHealth() {\n   *   const taskStorage = new TaskStorageService();\n   *   const stats = await taskStorage.getStats();\n   *\n   *   const healthStatus = {\n   *     healthy: true,\n   *     warnings: [] as string[]\n   *   };\n   *\n   *   if (stats.failed > stats.completed * 0.1) {\n   *     healthStatus.healthy = false;\n   *     healthStatus.warnings.push('High failure rate (>10%)');\n   *   }\n   *\n   *   if (stats.pending > 100) {\n   *     healthStatus.warnings.push('Large pending queue (>100 tasks)');\n   *   }\n   *\n   *   return healthStatus;\n   * }\n   *\n   * @example\n   * // Task management UI badges\n   * const stats = await taskStorage.getStats();\n   *\n   * // Display badges in UI\n   * const badges = [\n   *   { label: 'Pending', count: stats.pending, color: 'blue' },\n   *   { label: 'Running', count: stats.running, color: 'yellow' },\n   *   { label: 'Completed', count: stats.completed, color: 'green' },\n   *   { label: 'Failed', count: stats.failed, color: 'red' }\n   * ];\n   *\n   * @example\n   * // Empty storage handling\n   * const stats = await taskStorage.getStats();\n   * if (stats.total === 0) {\n   *   console.log('No tasks in storage');\n   * }\n   *\n   * @see {@link getTasks} for retrieving full task data with filtering\n   */\n  async getStats(): Promise<{\n    total: number;\n    pending: number;\n    running: number;\n    completed: number;\n    failed: number;\n  }> {\n    await this.initialize();\n\n    const index = await this.loadIndex();\n\n    return {\n      total: index.length,\n      pending: index.filter(t => t.status === 'pending').length,\n      running: index.filter(t => t.status === 'running').length,\n      completed: index.filter(t => t.status === 'completed').length,\n      failed: index.filter(t => t.status === 'failed').length,\n    };\n  }\n\n  /**\n   * Rebuild index file from all task files in storage directory.\n   *\n   * @description\n   * Scans logs directory for all task JSON files, loads them, and regenerates the index file.\n   * Useful for recovering from index corruption, migrating data, or fixing inconsistencies\n   * between task files and index.\n   *\n   * **Rebuild Workflow:**\n   * 1. Initialize storage if not already initialized\n   * 2. Read all .json files from logs directory (excluding _index.json)\n   * 3. Load full task data from each task file\n   * 4. Sort tasks by creation date (newest first)\n   * 5. Build new index with task summaries\n   * 6. Save new index file (overwrites existing index)\n   * 7. Log rebuild completion with task count\n   *\n   * **When to Use:**\n   * - Index file corrupted or deleted\n   * - Inconsistency between task files and index\n   * - After manual file operations (copying, restoring from backup)\n   * - Data migration from another system\n   * - Development/testing cleanup\n   *\n   * **Performance:**\n   * - Reads all task files in directory (can be slow for large task lists)\n   * - Time complexity: O(n log n) where n = number of task files (due to sorting)\n   * - Safe operation: Only rebuilds index, does not modify task files\n   *\n   * **Important Notes:**\n   * - **Overwrites existing index**: Current index file is replaced\n   * - **Safe operation**: Does not modify task files, only regenerates index\n   * - **Idempotent**: Can be run multiple times safely\n   * - Automatically filters out invalid/corrupted task files\n   *\n   * @returns Promise that resolves when index rebuild is complete\n   *\n   * @example\n   * // Basic index rebuild\n   * const taskStorage = new TaskStorageService();\n   * await taskStorage.rebuildIndex();\n   * console.log('Index rebuilt successfully');\n   *\n   * @example\n   * // Recover from corrupted index\n   * const taskStorage = new TaskStorageService();\n   *\n   * try {\n   *   // Try to load tasks (might fail if index is corrupted)\n   *   await taskStorage.getTasks();\n   * } catch (error) {\n   *   console.error('Index corrupted, rebuilding...');\n   *   await taskStorage.rebuildIndex();\n   *   console.log('Index rebuilt successfully');\n   *\n   *   // Retry loading tasks\n   *   const tasks = await taskStorage.getTasks();\n   *   console.log(`Loaded ${tasks.length} tasks`);\n   * }\n   *\n   * @example\n   * // Migration workflow\n   * const taskStorage = new TaskStorageService();\n   *\n   * console.log('Starting data migration...');\n   *\n   * // 1. Copy task files from old location\n   * // (external script copies files to logs/)\n   *\n   * // 2. Rebuild index from copied files\n   * await taskStorage.rebuildIndex();\n   *\n   * // 3. Verify migration\n   * const stats = await taskStorage.getStats();\n   * console.log(`Migration complete: ${stats.total} tasks imported`);\n   *\n   * @example\n   * // Fix inconsistency between task files and index\n   * const taskStorage = new TaskStorageService();\n   *\n   * // Rebuild index to match actual task files\n   * console.log('Checking for inconsistencies...');\n   * await taskStorage.rebuildIndex();\n   *\n   * // Verify consistency\n   * const stats = await taskStorage.getStats();\n   * const tasks = await taskStorage.getTasks();\n   * console.log(`Index: ${stats.total} tasks, Files: ${tasks.length} tasks`);\n   *\n   * @example\n   * // Development/testing cleanup\n   * const taskStorage = new TaskStorageService();\n   *\n   * // After manual file manipulation in logs/ directory\n   * await taskStorage.rebuildIndex();\n   * console.log('Index synchronized with task files');\n   *\n   * @example\n   * // Scheduled maintenance job\n   * async function scheduledIndexMaintenance() {\n   *   const taskStorage = new TaskStorageService();\n   *\n   *   console.log('Running scheduled index rebuild...');\n   *   const startTime = Date.now();\n   *\n   *   await taskStorage.rebuildIndex();\n   *\n   *   const duration = Date.now() - startTime;\n   *   const stats = await taskStorage.getStats();\n   *   console.log(`Index rebuilt in ${duration}ms (${stats.total} tasks)`);\n   * }\n   *\n   * // Run daily at 3 AM\n   * cron.schedule('0 3 * * *', scheduledIndexMaintenance);\n   *\n   * @example\n   * // Backup restoration workflow\n   * const taskStorage = new TaskStorageService();\n   *\n   * // 1. Restore task files from backup\n   * console.log('Restoring task files from backup...');\n   * // (external script restores files)\n   *\n   * // 2. Rebuild index from restored files\n   * console.log('Rebuilding index from restored files...');\n   * await taskStorage.rebuildIndex();\n   *\n   * // 3. Verify restoration\n   * const stats = await taskStorage.getStats();\n   * console.log(`Restoration complete: ${stats.total} tasks restored`);\n   *\n   * @see {@link initialize} for initial index creation\n   * @see {@link getStats} for verifying index consistency\n   */\n  async rebuildIndex(): Promise<void> {\n    await this.initialize();\n\n    this.logger.info('Rebuilding index from task files...');\n\n    // Get all .json files except _index.json\n    const files = await fs.readdir(this.logsDir);\n    const taskFiles = files.filter(f => f.endsWith('.json') && f !== '_index.json');\n\n    // Load all tasks\n    const tasks: Task[] = [];\n    for (const file of taskFiles) {\n      const taskId = file.replace('.json', '');\n      const task = await this.loadTask(taskId);\n      if (task) {\n        tasks.push(task);\n      }\n    }\n\n    // Sort by creation date (newest first)\n    tasks.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Build new index\n    const newIndex = tasks.map(t => ({\n      id: t.id,\n      name: t.name,\n      status: t.status,\n      taskType: t.taskType,\n      agentName: t.agentName,\n      createdAt: t.createdAt,\n      completedAt: t.completedAt,\n    }));\n\n    await this.saveIndex(newIndex);\n\n    this.logger.info('Index rebuilt successfully', { taskCount: newIndex.length });\n  }\n}\n",
        "last_modified": "2026-01-02T15:10:07.679828"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.688125",
  "last_updated": "2026-01-02T14:06:15.699943"
}