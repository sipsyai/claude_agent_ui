{
  "file_path": "src/services/notification-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import { PermissionRequest } from '@/types/index.js';\nimport { createLogger, type Logger } from './logger.js';\nimport { ConfigService } from './config-service.js';\nimport { WebPushService } from './web-push-service.js';\n\nexport interface Notification {\n  title: string;\n  message: string;\n  priority: 'min' | 'low' | 'default' | 'high' | 'urgent';\n  tags: string[];\n  sessionId: string;\n  streamingId: string;\n  permissionRequestId?: string;\n}\n\n/**\n * Service for sending push notifications via ntfy.sh\n */\nexport class NotificationService {\n  private logger: Logger;\n  private configService: ConfigService;\n  private machineId: string | null = null;\n  private webPushService: WebPushService;\n\n  constructor() {\n    this.logger = createLogger('NotificationService');\n    this.configService = ConfigService.getInstance();\n    this.webPushService = WebPushService.getInstance();\n  }\n\n  /**\n   * Get machine ID from config\n   */\n  private getMachineId(): string {\n    if (!this.machineId) {\n      try {\n        const config = this.configService.getConfig();\n        this.machineId = config.machine_id;\n      } catch (error) {\n        this.logger.error('Failed to get machine ID from config', error);\n        this.machineId = 'unknown';\n      }\n    }\n    return this.machineId;\n  }\n\n  /**\n   * Check if notifications are enabled\n   */\n  private async isEnabled(): Promise<boolean> {\n    const config = this.configService.getConfig();\n    return config.interface.notifications?.enabled ?? false;\n  }\n\n  /**\n   * Get the ntfy URL from preferences\n   */\n  private async getNtfyUrl(): Promise<string> {\n    const config = this.configService.getConfig();\n    return config.interface.notifications?.ntfyUrl || 'https://ntfy.sh';\n  }\n\n  /**\n   * Send a notification for a permission request\n   */\n  async sendPermissionNotification(\n    request: PermissionRequest,\n    sessionId?: string,\n    summary?: string\n  ): Promise<void> {\n    if (!(await this.isEnabled())) {\n      this.logger.debug('Notifications disabled, skipping permission notification');\n      return;\n    }\n\n    try {\n      const machineId = this.getMachineId();\n      const topic = `cui-${machineId}`;\n      const ntfyUrl = await this.getNtfyUrl();\n\n      const notification: Notification = {\n        title: 'CUI Permission Request',\n        message: summary \n          ? `${summary} - ${request.toolName}`\n          : `${request.toolName} tool: ${JSON.stringify(request.toolInput).substring(0, 100)}...`,\n        priority: 'default',\n        tags: ['cui-permission'],\n        sessionId: sessionId || 'unknown',\n        streamingId: request.streamingId,\n        permissionRequestId: request.id\n      };\n\n      // Send via ntfy\n      await this.sendNotification(ntfyUrl, topic, notification);\n\n      // Also broadcast via native web push (best-effort)\n      try {\n        await this.webPushService.initialize();\n        if (this.webPushService.getEnabled()) {\n          await this.webPushService.broadcast({\n            title: notification.title,\n            message: notification.message,\n            tag: notification.tags[0],\n            data: {\n              sessionId: notification.sessionId,\n              streamingId: notification.streamingId,\n              permissionRequestId: notification.permissionRequestId,\n              type: 'permission',\n            },\n          });\n        }\n      } catch (err) {\n        this.logger.debug('Web push broadcast failed (non-fatal)', { error: (err as Error)?.message });\n      }\n      \n      this.logger.info('Permission notification sent', {\n        requestId: request.id,\n        toolName: request.toolName,\n        topic\n      });\n    } catch (error) {\n      this.logger.error('Failed to send permission notification', error, {\n        requestId: request.id\n      });\n    }\n  }\n\n  /**\n   * Send a notification when a conversation ends\n   */\n  async sendConversationEndNotification(\n    streamingId: string,\n    sessionId: string,\n    summary?: string\n  ): Promise<void> {\n    if (!(await this.isEnabled())) {\n      this.logger.debug('Notifications disabled, skipping conversation end notification');\n      return;\n    }\n\n    try {\n      const machineId = this.getMachineId();\n      const topic = `cui-${machineId}`;\n      const ntfyUrl = await this.getNtfyUrl();\n\n      const notification: Notification = {\n        title: 'Task Finished',\n        message: summary || 'Task completed',\n        priority: 'default',\n        tags: ['cui-complete'],\n        sessionId,\n        streamingId\n      };\n\n      // Send via ntfy\n      await this.sendNotification(ntfyUrl, topic, notification);\n\n      // Also broadcast via native web push (best-effort)\n      try {\n        await this.webPushService.initialize();\n        if (this.webPushService.getEnabled()) {\n          await this.webPushService.broadcast({\n            title: notification.title,\n            message: notification.message,\n            tag: notification.tags[0],\n            data: {\n              sessionId: notification.sessionId,\n              streamingId: notification.streamingId,\n              type: 'conversation-end',\n            },\n          });\n        }\n      } catch (err) {\n        this.logger.debug('Web push broadcast failed (non-fatal)', { error: (err as Error)?.message });\n      }\n      \n      this.logger.info('Conversation end notification sent', {\n        sessionId,\n        streamingId,\n        topic\n      });\n    } catch (error) {\n      this.logger.error('Failed to send conversation end notification', error, {\n        sessionId,\n        streamingId\n      });\n    }\n  }\n\n  /**\n   * Send a notification to ntfy\n   */\n  private async sendNotification(\n    ntfyUrl: string,\n    topic: string,\n    notification: Notification\n  ): Promise<void> {\n    const url = `${ntfyUrl}/${topic}`;\n    \n    const headers: Record<string, string> = {\n      'Title': notification.title,\n      'Priority': notification.priority,\n      'Tags': notification.tags.join(',')\n    };\n\n    // Add custom headers for CUI metadata\n    headers['X-CUI-SessionId'] = notification.sessionId;\n    headers['X-CUI-StreamingId'] = notification.streamingId;\n    if (notification.permissionRequestId) {\n      headers['X-CUI-PermissionRequestId'] = notification.permissionRequestId;\n    }\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers,\n      body: notification.message\n    });\n\n    if (!response.ok) {\n      throw new Error(`Ntfy returned ${response.status}: ${await response.text()}`);\n    }\n  }\n}",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import { PermissionRequest } from '@/types/index.js';\nimport { createLogger, type Logger } from './logger.js';\nimport { ConfigService } from './config-service.js';\nimport { WebPushService } from './web-push-service.js';\n\n/**\n * Notification payload for ntfy.sh push notifications\n *\n * @description\n * Represents a structured notification payload for the ntfy.sh push notification service.\n * Notifications are sent via HTTP POST to ntfy.sh topics with custom headers for metadata.\n *\n * @example\n * ```typescript\n * // Permission request notification\n * const notification: Notification = {\n *   title: 'CUI Permission Request',\n *   message: 'EnterPlanMode tool requires approval',\n *   priority: 'default',\n *   tags: ['cui-permission'],\n *   sessionId: 'sess-abc123',\n *   streamingId: 'stream-xyz789',\n *   permissionRequestId: 'perm-123'\n * };\n * ```\n *\n * @example\n * ```typescript\n * // Task completion notification\n * const notification: Notification = {\n *   title: 'Task Finished',\n *   message: 'Created 5 new unit tests for UserService',\n *   priority: 'default',\n *   tags: ['cui-complete'],\n *   sessionId: 'sess-abc123',\n *   streamingId: 'stream-xyz789'\n * };\n * ```\n */\nexport interface Notification {\n  /** Notification title displayed prominently in push notification UI */\n  title: string;\n  /** Notification message body with task details or summary */\n  message: string;\n  /** Priority level affecting notification delivery and display (min=silent, urgent=bypass DND) */\n  priority: 'min' | 'low' | 'default' | 'high' | 'urgent';\n  /** Tags for categorizing and filtering notifications (e.g., ['cui-permission'], ['cui-complete']) */\n  tags: string[];\n  /** Session ID for tracking which chat session triggered the notification */\n  sessionId: string;\n  /** Streaming ID for tracking the specific message stream that triggered the notification */\n  streamingId: string;\n  /** Optional permission request ID for linking notification to specific approval workflow */\n  permissionRequestId?: string;\n}\n\n/**\n * NotificationService - Push notification delivery via ntfy.sh and native Web Push\n *\n * @description\n * The NotificationService handles push notification delivery for CUI application events such as\n * permission requests and task completions. It supports dual delivery channels: ntfy.sh HTTP\n * push notifications (for mobile/desktop apps) and native browser Web Push API (for web clients).\n *\n * **Key Responsibilities:**\n * - Send permission request notifications when tools require user approval\n * - Send task completion notifications when conversations end\n * - Dual-channel delivery: ntfy.sh (primary) + Web Push (best-effort)\n * - Configuration-based enable/disable via ConfigService\n * - Machine ID-based topic routing for privacy and multi-instance support\n * - Custom metadata headers (X-CUI-SessionId, X-CUI-StreamingId, X-CUI-PermissionRequestId)\n *\n * **Architecture:**\n * - **ntfy.sh Integration**: HTTP POST to `${ntfyUrl}/${topic}` with custom headers\n * - **Web Push Integration**: Best-effort native browser push via WebPushService\n * - **Topic Naming**: `cui-${machineId}` ensures notifications route to correct machine\n * - **Configuration**: Controlled by `config.interface.notifications.enabled` and `ntfyUrl`\n * - **Graceful Degradation**: Web Push failures are logged but don't block ntfy.sh delivery\n * - **Machine ID**: Retrieved from ConfigService, ensures privacy across machines\n *\n * **Notification Types:**\n * 1. **Permission Requests** (`sendPermissionNotification`)\n *    - Triggered when tools require user approval (e.g., EnterPlanMode, file writes)\n *    - Priority: 'default'\n *    - Tags: ['cui-permission']\n *    - Includes: tool name, request summary, permission request ID\n *    - Use case: Mobile notification for approval when away from computer\n *\n * 2. **Task Completions** (`sendConversationEndNotification`)\n *    - Triggered when AI conversation/task completes\n *    - Priority: 'default'\n *    - Tags: ['cui-complete']\n *    - Includes: task summary, session ID, streaming ID\n *    - Use case: Know when long-running tasks finish\n *\n * **Configuration:**\n * Notifications are controlled via `~/.cui/config.json`:\n * ```json\n * {\n *   \"interface\": {\n *     \"notifications\": {\n *       \"enabled\": false,           // Enable notifications\n *       \"ntfyUrl\": \"https://ntfy.sh\" // ntfy.sh server URL\n *     }\n *   }\n * }\n * ```\n *\n * **ntfy.sh Protocol:**\n * - **HTTP POST**: Send message body as plain text\n * - **Custom Headers**:\n *   - `Title`: Notification title\n *   - `Priority`: min | low | default | high | urgent\n *   - `Tags`: Comma-separated tags for filtering\n *   - `X-CUI-SessionId`: Session ID for tracking\n *   - `X-CUI-StreamingId`: Streaming ID for message correlation\n *   - `X-CUI-PermissionRequestId`: Permission request ID (if applicable)\n * - **Topic Subscription**: Users subscribe to `cui-${machineId}` on mobile/desktop apps\n *\n * **Use Cases:**\n * - Permission approval: Get notified on phone when AI needs approval\n * - Task monitoring: Know when long-running tasks complete\n * - Multi-instance: Different machines use different topics (cui-machine1, cui-machine2)\n * - Remote work: Work from anywhere, get notified when tasks need attention\n *\n * @example\n * ```typescript\n * // Basic usage - send permission notification\n * import { NotificationService } from './notification-service';\n * import { PermissionRequest } from '@/types';\n *\n * const notificationService = new NotificationService();\n *\n * const request: PermissionRequest = {\n *   id: 'perm-123',\n *   toolName: 'EnterPlanMode',\n *   toolInput: { task: 'Implement user authentication' },\n *   streamingId: 'stream-xyz789'\n * };\n *\n * await notificationService.sendPermissionNotification(\n *   request,\n *   'sess-abc123',\n *   'Planning implementation for user authentication'\n * );\n * // Sends notification to ntfy.sh topic: cui-a1b2c3d4e5f6g7h8\n * // Title: CUI Permission Request\n * // Message: Planning implementation for user authentication - EnterPlanMode\n * ```\n *\n * @example\n * ```typescript\n * // Task completion notification\n * import { NotificationService } from './notification-service';\n *\n * const notificationService = new NotificationService();\n *\n * await notificationService.sendConversationEndNotification(\n *   'stream-xyz789',\n *   'sess-abc123',\n *   'Created 5 unit tests for UserService with 100% coverage'\n * );\n * // Sends notification to ntfy.sh topic: cui-a1b2c3d4e5f6g7h8\n * // Title: Task Finished\n * // Message: Created 5 unit tests for UserService with 100% coverage\n * ```\n *\n * @example\n * ```typescript\n * // Mobile app subscription workflow\n * // 1. User installs ntfy.sh mobile app on phone\n * // 2. Subscribe to topic: cui-a1b2c3d4e5f6g7h8 (machine ID from ~/.cui/config.json)\n * // 3. Enable notifications in CUI config:\n * import { ConfigService } from './config-service';\n *\n * const configService = ConfigService.getInstance();\n * await configService.updateConfig({\n *   interface: {\n *     notifications: {\n *       enabled: true,\n *       ntfyUrl: 'https://ntfy.sh' // or self-hosted ntfy.sh server\n *     }\n *   }\n * });\n *\n * // 4. Start working - notifications now arrive on phone automatically\n * ```\n *\n * @example\n * ```typescript\n * // Disabled notifications (default behavior)\n * import { NotificationService } from './notification-service';\n *\n * // When notifications disabled in config, methods return early (no-op)\n * const notificationService = new NotificationService();\n *\n * await notificationService.sendPermissionNotification(request);\n * // No notification sent (logged as debug: \"Notifications disabled, skipping\")\n * ```\n *\n * @example\n * ```typescript\n * // Self-hosted ntfy.sh server for privacy\n * import { ConfigService } from './config-service';\n *\n * const configService = ConfigService.getInstance();\n * await configService.updateConfig({\n *   interface: {\n *     notifications: {\n *       enabled: true,\n *       ntfyUrl: 'https://ntfy.example.com' // Private server\n *     }\n *   }\n * });\n *\n * // Notifications now route to self-hosted server\n * // Subscribe in mobile app: https://ntfy.example.com/cui-a1b2c3d4e5f6g7h8\n * ```\n *\n * @see {@link ConfigService} for notification configuration\n * @see {@link WebPushService} for native browser push notifications\n * @see https://docs.ntfy.sh/ for ntfy.sh documentation\n */\nexport class NotificationService {\n  /** Logger instance for NotificationService component */\n  private logger: Logger;\n  /** ConfigService singleton for reading notification configuration */\n  private configService: ConfigService;\n  /** Cached machine ID from config (null until first access) */\n  private machineId: string | null = null;\n  /** WebPushService singleton for native browser push notifications */\n  private webPushService: WebPushService;\n\n  constructor() {\n    this.logger = createLogger('NotificationService');\n    this.configService = ConfigService.getInstance();\n    this.webPushService = WebPushService.getInstance();\n  }\n\n  /**\n   * Get machine ID from config with caching\n   *\n   * @description\n   * Retrieves the unique machine ID from ConfigService with single-access caching.\n   * The machine ID is used to construct the ntfy.sh topic name (`cui-${machineId}`),\n   * ensuring notifications route to the correct machine in multi-instance setups.\n   *\n   * **Caching Strategy:**\n   * - First call: Fetch from ConfigService, cache in memory\n   * - Subsequent calls: Return cached value (avoids config reads)\n   * - Error fallback: Returns 'unknown' if config read fails\n   *\n   * @private\n   * @returns {string} Machine ID (e.g., 'a1b2c3d4e5f6g7h8') or 'unknown' on error\n   *\n   * @example\n   * ```typescript\n   * // Internal usage - construct ntfy.sh topic\n   * const machineId = this.getMachineId(); // 'a1b2c3d4e5f6g7h8'\n   * const topic = `cui-${machineId}`; // 'cui-a1b2c3d4e5f6g7h8'\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Caching behavior\n   * const id1 = this.getMachineId(); // Fetches from config\n   * const id2 = this.getMachineId(); // Returns cached value\n   * // id1 === id2 (same instance)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - config read failure\n   * // If config.machine_id throws error, returns 'unknown'\n   * const machineId = this.getMachineId(); // 'unknown'\n   * // Error logged but notification still attempts delivery\n   * ```\n   */\n  private getMachineId(): string {\n    if (!this.machineId) {\n      try {\n        const config = this.configService.getConfig();\n        this.machineId = config.machine_id;\n      } catch (error) {\n        this.logger.error('Failed to get machine ID from config', error);\n        this.machineId = 'unknown';\n      }\n    }\n    return this.machineId;\n  }\n\n  /**\n   * Check if notifications are enabled in configuration\n   *\n   * @description\n   * Reads the notification enable flag from ConfigService. When disabled, notification\n   * methods return early (no-op) to avoid unnecessary processing and API calls.\n   *\n   * **Configuration Path:**\n   * `config.interface.notifications.enabled` (default: false)\n   *\n   * @private\n   * @returns {Promise<boolean>} True if notifications enabled, false otherwise (default: false)\n   *\n   * @example\n   * ```typescript\n   * // Internal usage - early return when disabled\n   * if (!(await this.isEnabled())) {\n   *   this.logger.debug('Notifications disabled, skipping');\n   *   return;\n   * }\n   * // Continue with notification delivery...\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Configuration check\n   * const enabled = await this.isEnabled(); // false (default)\n   *\n   * // Enable notifications in config\n   * await configService.updateConfig({\n   *   interface: {\n   *     notifications: { enabled: true }\n   *   }\n   * });\n   *\n   * const enabledNow = await this.isEnabled(); // true\n   * ```\n   */\n  private async isEnabled(): Promise<boolean> {\n    const config = this.configService.getConfig();\n    return config.interface.notifications?.enabled ?? false;\n  }\n\n  /**\n   * Get the ntfy.sh server URL from configuration\n   *\n   * @description\n   * Retrieves the ntfy.sh server URL from ConfigService with fallback to public ntfy.sh.\n   * Supports self-hosted ntfy.sh servers for privacy and control.\n   *\n   * **Configuration Path:**\n   * `config.interface.notifications.ntfyUrl` (default: 'https://ntfy.sh')\n   *\n   * **Use Cases:**\n   * - Public server: Use default 'https://ntfy.sh' for quick setup\n   * - Self-hosted: Use custom URL like 'https://ntfy.example.com' for privacy\n   * - Corporate: Use internal server behind firewall\n   *\n   * @private\n   * @returns {Promise<string>} ntfy.sh server URL (default: 'https://ntfy.sh')\n   *\n   * @example\n   * ```typescript\n   * // Internal usage - construct notification URL\n   * const ntfyUrl = await this.getNtfyUrl(); // 'https://ntfy.sh'\n   * const topic = `cui-${machineId}`; // 'cui-a1b2c3d4e5f6g7h8'\n   * const url = `${ntfyUrl}/${topic}`; // 'https://ntfy.sh/cui-a1b2c3d4e5f6g7h8'\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Default public server\n   * const url = await this.getNtfyUrl(); // 'https://ntfy.sh'\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Self-hosted server configuration\n   * await configService.updateConfig({\n   *   interface: {\n   *     notifications: {\n   *       enabled: true,\n   *       ntfyUrl: 'https://ntfy.example.com'\n   *     }\n   *   }\n   * });\n   *\n   * const url = await this.getNtfyUrl(); // 'https://ntfy.example.com'\n   * ```\n   */\n  private async getNtfyUrl(): Promise<string> {\n    const config = this.configService.getConfig();\n    return config.interface.notifications?.ntfyUrl || 'https://ntfy.sh';\n  }\n\n  /**\n   * Send notification for tool permission requests\n   *\n   * @description\n   * Sends push notifications via ntfy.sh and native Web Push when tools require user approval.\n   * This enables mobile/remote approval workflows where users can approve tool usage from their\n   * phone while away from their computer.\n   *\n   * **Dual-Channel Delivery:**\n   * 1. **ntfy.sh** (primary): HTTP POST with custom headers for metadata\n   * 2. **Web Push** (best-effort): Native browser push via WebPushService\n   *\n   * **Notification Workflow:**\n   * 1. Check if notifications enabled via `isEnabled()` (early return if disabled)\n   * 2. Get machine ID and construct topic: `cui-${machineId}`\n   * 3. Get ntfy.sh URL from config (default: 'https://ntfy.sh')\n   * 4. Build notification payload with metadata\n   * 5. Send to ntfy.sh via HTTP POST with custom headers\n   * 6. Attempt Web Push broadcast (errors logged but non-blocking)\n   * 7. Log success with request details\n   *\n   * **Notification Payload:**\n   * - Title: 'CUI Permission Request'\n   * - Message: `${summary} - ${toolName}` or truncated tool input\n   * - Priority: 'default'\n   * - Tags: ['cui-permission']\n   * - Custom headers: X-CUI-SessionId, X-CUI-StreamingId, X-CUI-PermissionRequestId\n   *\n   * **Use Cases:**\n   * - EnterPlanMode approval: Notify user that AI wants to plan implementation\n   * - File write approval: Notify user about pending file modifications\n   * - Dangerous tool approval: Alert about high-risk operations\n   * - Remote work: Approve tools from phone while away from desk\n   *\n   * @param {PermissionRequest} request - Permission request object with tool details\n   * @param {string} [sessionId] - Optional session ID for tracking (default: 'unknown')\n   * @param {string} [summary] - Optional human-friendly summary of the request\n   * @returns {Promise<void>} Resolves when notification sent (or disabled/failed)\n   *\n   * @example\n   * ```typescript\n   * // Basic permission notification with summary\n   * import { NotificationService } from './notification-service';\n   * import { PermissionRequest } from '@/types';\n   *\n   * const notificationService = new NotificationService();\n   *\n   * const request: PermissionRequest = {\n   *   id: 'perm-123',\n   *   toolName: 'EnterPlanMode',\n   *   toolInput: { task: 'Implement authentication' },\n   *   streamingId: 'stream-xyz789'\n   * };\n   *\n   * await notificationService.sendPermissionNotification(\n   *   request,\n   *   'sess-abc123',\n   *   'Planning implementation for user authentication feature'\n   * );\n   * // Sends notification:\n   * // Title: CUI Permission Request\n   * // Message: Planning implementation for user authentication feature - EnterPlanMode\n   * // Topic: cui-a1b2c3d4e5f6g7h8\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Permission notification without summary (uses truncated tool input)\n   * const request: PermissionRequest = {\n   *   id: 'perm-456',\n   *   toolName: 'Write',\n   *   toolInput: {\n   *     file_path: '/src/auth/login.ts',\n   *     content: 'export function login() { ... }'\n   *   },\n   *   streamingId: 'stream-abc123'\n   * };\n   *\n   * await notificationService.sendPermissionNotification(request, 'sess-def456');\n   * // Message: Write tool: {\"file_path\":\"/src/auth/login.ts\",\"content\":\"export function login() {...\n   * // (truncated to 100 chars)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Notification includes custom metadata headers for client correlation\n   * // HTTP POST to https://ntfy.sh/cui-a1b2c3d4e5f6g7h8\n   * // Headers:\n   * //   Title: CUI Permission Request\n   * //   Priority: default\n   * //   Tags: cui-permission\n   * //   X-CUI-SessionId: sess-abc123\n   * //   X-CUI-StreamingId: stream-xyz789\n   * //   X-CUI-PermissionRequestId: perm-123\n   * // Body: Planning implementation for user authentication feature - EnterPlanMode\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Graceful handling when notifications disabled\n   * // Config: { interface: { notifications: { enabled: false } } }\n   *\n   * await notificationService.sendPermissionNotification(request);\n   * // Logs: \"Notifications disabled, skipping permission notification\"\n   * // No API calls made, returns immediately\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - notification failure doesn't block execution\n   * // If ntfy.sh is unreachable or returns 500, error is logged but promise resolves\n   * await notificationService.sendPermissionNotification(request, 'sess-abc123');\n   * // Logs: \"Failed to send permission notification\" with error details\n   * // Execution continues normally (non-blocking)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Mobile app integration workflow\n   * // 1. User receives notification on phone via ntfy.sh mobile app\n   * // 2. Notification displays:\n   * //    - Title: \"CUI Permission Request\"\n   * //    - Message: \"Planning implementation for user authentication - EnterPlanMode\"\n   * //    - Metadata: Session ID, Streaming ID, Permission Request ID\n   * // 3. User taps notification, opens CUI web UI (deep link to permission approval)\n   * // 4. User approves/denies request\n   * // 5. AI continues execution based on approval\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Web Push broadcast (best-effort, non-blocking)\n   * // After ntfy.sh delivery, also broadcasts via native Web Push API\n   * // If Web Push fails (no subscriptions, service worker offline, etc.):\n   * //   - Error logged as debug (non-fatal)\n   * //   - ntfy.sh notification still delivered successfully\n   * //   - Promise resolves normally\n   * ```\n   *\n   * @see {@link sendConversationEndNotification} for task completion notifications\n   * @see {@link Notification} for notification payload structure\n   */\n  async sendPermissionNotification(\n    request: PermissionRequest,\n    sessionId?: string,\n    summary?: string\n  ): Promise<void> {\n    if (!(await this.isEnabled())) {\n      this.logger.debug('Notifications disabled, skipping permission notification');\n      return;\n    }\n\n    try {\n      const machineId = this.getMachineId();\n      const topic = `cui-${machineId}`;\n      const ntfyUrl = await this.getNtfyUrl();\n\n      const notification: Notification = {\n        title: 'CUI Permission Request',\n        message: summary \n          ? `${summary} - ${request.toolName}`\n          : `${request.toolName} tool: ${JSON.stringify(request.toolInput).substring(0, 100)}...`,\n        priority: 'default',\n        tags: ['cui-permission'],\n        sessionId: sessionId || 'unknown',\n        streamingId: request.streamingId,\n        permissionRequestId: request.id\n      };\n\n      // Send via ntfy\n      await this.sendNotification(ntfyUrl, topic, notification);\n\n      // Also broadcast via native web push (best-effort)\n      try {\n        await this.webPushService.initialize();\n        if (this.webPushService.getEnabled()) {\n          await this.webPushService.broadcast({\n            title: notification.title,\n            message: notification.message,\n            tag: notification.tags[0],\n            data: {\n              sessionId: notification.sessionId,\n              streamingId: notification.streamingId,\n              permissionRequestId: notification.permissionRequestId,\n              type: 'permission',\n            },\n          });\n        }\n      } catch (err) {\n        this.logger.debug('Web push broadcast failed (non-fatal)', { error: (err as Error)?.message });\n      }\n      \n      this.logger.info('Permission notification sent', {\n        requestId: request.id,\n        toolName: request.toolName,\n        topic\n      });\n    } catch (error) {\n      this.logger.error('Failed to send permission notification', error, {\n        requestId: request.id\n      });\n    }\n  }\n\n  /**\n   * Send notification when AI conversation/task completes\n   *\n   * @description\n   * Sends push notifications via ntfy.sh and native Web Push when AI conversations finish.\n   * This enables users to monitor long-running tasks and know when they can review results,\n   * especially useful for tasks that take minutes or hours to complete.\n   *\n   * **Dual-Channel Delivery:**\n   * 1. **ntfy.sh** (primary): HTTP POST with custom headers for metadata\n   * 2. **Web Push** (best-effort): Native browser push via WebPushService\n   *\n   * **Notification Workflow:**\n   * 1. Check if notifications enabled via `isEnabled()` (early return if disabled)\n   * 2. Get machine ID and construct topic: `cui-${machineId}`\n   * 3. Get ntfy.sh URL from config (default: 'https://ntfy.sh')\n   * 4. Build notification payload with task summary\n   * 5. Send to ntfy.sh via HTTP POST with custom headers\n   * 6. Attempt Web Push broadcast (errors logged but non-blocking)\n   * 7. Log success with session details\n   *\n   * **Notification Payload:**\n   * - Title: 'Task Finished'\n   * - Message: `${summary}` or 'Task completed' (default)\n   * - Priority: 'default'\n   * - Tags: ['cui-complete']\n   * - Custom headers: X-CUI-SessionId, X-CUI-StreamingId\n   *\n   * **Use Cases:**\n   * - Long-running tasks: Know when multi-hour refactoring completes\n   * - Background work: Monitor tasks while working on other things\n   * - Remote work: Get notified on phone when away from desk\n   * - Batch operations: Track completion of large file processing jobs\n   *\n   * @param {string} streamingId - Streaming ID of the completed conversation\n   * @param {string} sessionId - Session ID for tracking which chat session completed\n   * @param {string} [summary] - Optional task summary describing what was accomplished (default: 'Task completed')\n   * @returns {Promise<void>} Resolves when notification sent (or disabled/failed)\n   *\n   * @example\n   * ```typescript\n   * // Basic task completion notification with summary\n   * import { NotificationService } from './notification-service';\n   *\n   * const notificationService = new NotificationService();\n   *\n   * await notificationService.sendConversationEndNotification(\n   *   'stream-xyz789',\n   *   'sess-abc123',\n   *   'Created 5 unit tests for UserService with 100% coverage'\n   * );\n   * // Sends notification:\n   * // Title: Task Finished\n   * // Message: Created 5 unit tests for UserService with 100% coverage\n   * // Topic: cui-a1b2c3d4e5f6g7h8\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Task completion without summary (uses default message)\n   * await notificationService.sendConversationEndNotification(\n   *   'stream-abc123',\n   *   'sess-def456'\n   * );\n   * // Message: Task completed\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Long-running refactoring task notification\n   * await notificationService.sendConversationEndNotification(\n   *   'stream-refactor-001',\n   *   'sess-refactor-session',\n   *   'Refactored 47 files, moved 23 components to new architecture, all tests passing'\n   * );\n   * // Useful for monitoring tasks that take 30+ minutes\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Notification includes custom metadata headers for client correlation\n   * // HTTP POST to https://ntfy.sh/cui-a1b2c3d4e5f6g7h8\n   * // Headers:\n   * //   Title: Task Finished\n   * //   Priority: default\n   * //   Tags: cui-complete\n   * //   X-CUI-SessionId: sess-abc123\n   * //   X-CUI-StreamingId: stream-xyz789\n   * // Body: Created 5 unit tests for UserService with 100% coverage\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Graceful handling when notifications disabled\n   * // Config: { interface: { notifications: { enabled: false } } }\n   *\n   * await notificationService.sendConversationEndNotification(\n   *   'stream-xyz789',\n   *   'sess-abc123',\n   *   'Task completed'\n   * );\n   * // Logs: \"Notifications disabled, skipping conversation end notification\"\n   * // No API calls made, returns immediately\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - notification failure doesn't block execution\n   * // If ntfy.sh is unreachable or returns 500, error is logged but promise resolves\n   * await notificationService.sendConversationEndNotification(\n   *   'stream-xyz789',\n   *   'sess-abc123'\n   * );\n   * // Logs: \"Failed to send conversation end notification\" with error details\n   * // Execution continues normally (non-blocking)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Integration with ChatService - called when conversation completes\n   * // ChatService.sendMessage() async generator workflow:\n   * async function* sendMessage() {\n   *   // ... AI conversation processing ...\n   *\n   *   // When done, send completion notification\n   *   const summary = extractSummary(assistantMessage);\n   *   await notificationService.sendConversationEndNotification(\n   *     streamingId,\n   *     sessionId,\n   *     summary\n   *   );\n   *\n   *   yield { type: 'done', cost, usage };\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Mobile app integration - user experience\n   * // 1. User starts long-running task (e.g., \"Refactor entire codebase\")\n   * // 2. User closes laptop, goes to lunch\n   * // 3. 45 minutes later, task completes\n   * // 4. User receives notification on phone:\n   * //    - Title: \"Task Finished\"\n   * //    - Message: \"Refactored 47 files, moved 23 components to new architecture\"\n   * // 5. User returns to desk, reviews completed work\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Web Push broadcast (best-effort, non-blocking)\n   * // After ntfy.sh delivery, also broadcasts via native Web Push API\n   * // If Web Push fails (no subscriptions, service worker offline, etc.):\n   * //   - Error logged as debug (non-fatal)\n   * //   - ntfy.sh notification still delivered successfully\n   * //   - Promise resolves normally\n   * ```\n   *\n   * @see {@link sendPermissionNotification} for permission request notifications\n   * @see {@link Notification} for notification payload structure\n   */\n  async sendConversationEndNotification(\n    streamingId: string,\n    sessionId: string,\n    summary?: string\n  ): Promise<void> {\n    if (!(await this.isEnabled())) {\n      this.logger.debug('Notifications disabled, skipping conversation end notification');\n      return;\n    }\n\n    try {\n      const machineId = this.getMachineId();\n      const topic = `cui-${machineId}`;\n      const ntfyUrl = await this.getNtfyUrl();\n\n      const notification: Notification = {\n        title: 'Task Finished',\n        message: summary || 'Task completed',\n        priority: 'default',\n        tags: ['cui-complete'],\n        sessionId,\n        streamingId\n      };\n\n      // Send via ntfy\n      await this.sendNotification(ntfyUrl, topic, notification);\n\n      // Also broadcast via native web push (best-effort)\n      try {\n        await this.webPushService.initialize();\n        if (this.webPushService.getEnabled()) {\n          await this.webPushService.broadcast({\n            title: notification.title,\n            message: notification.message,\n            tag: notification.tags[0],\n            data: {\n              sessionId: notification.sessionId,\n              streamingId: notification.streamingId,\n              type: 'conversation-end',\n            },\n          });\n        }\n      } catch (err) {\n        this.logger.debug('Web push broadcast failed (non-fatal)', { error: (err as Error)?.message });\n      }\n      \n      this.logger.info('Conversation end notification sent', {\n        sessionId,\n        streamingId,\n        topic\n      });\n    } catch (error) {\n      this.logger.error('Failed to send conversation end notification', error, {\n        sessionId,\n        streamingId\n      });\n    }\n  }\n\n  /**\n   * Send notification to ntfy.sh via HTTP POST\n   *\n   * @description\n   * Core method that sends HTTP POST request to ntfy.sh server with notification payload\n   * and custom headers. This method implements the ntfy.sh HTTP protocol for push notifications.\n   *\n   * **ntfy.sh HTTP Protocol:**\n   * - **Method**: POST\n   * - **URL**: `${ntfyUrl}/${topic}` (e.g., 'https://ntfy.sh/cui-a1b2c3d4e5f6g7h8')\n   * - **Headers**:\n   *   - `Title`: Notification title\n   *   - `Priority`: min | low | default | high | urgent\n   *   - `Tags`: Comma-separated tags (e.g., 'cui-permission,urgent')\n   *   - `X-CUI-SessionId`: Session ID for tracking\n   *   - `X-CUI-StreamingId`: Streaming ID for message correlation\n   *   - `X-CUI-PermissionRequestId`: Permission request ID (optional)\n   * - **Body**: Plain text message content\n   *\n   * **Priority Levels:**\n   * - `min`: No sound/vibration, background delivery only\n   * - `low`: No sound/vibration, but visible notification\n   * - `default`: Default notification sound and vibration\n   * - `high`: Higher priority sound and vibration\n   * - `urgent`: Bypass Do Not Disturb mode, maximum urgency\n   *\n   * **Custom Headers:**\n   * Custom `X-CUI-*` headers enable client-side correlation and routing:\n   * - X-CUI-SessionId: Link notification to specific chat session\n   * - X-CUI-StreamingId: Link notification to specific message stream\n   * - X-CUI-PermissionRequestId: Link notification to approval workflow\n   *\n   * **Error Handling:**\n   * Throws error if:\n   * - HTTP response status is not 2xx\n   * - Network request fails (timeout, DNS error, etc.)\n   *\n   * @private\n   * @param {string} ntfyUrl - ntfy.sh server URL (e.g., 'https://ntfy.sh')\n   * @param {string} topic - Topic name for routing (e.g., 'cui-a1b2c3d4e5f6g7h8')\n   * @param {Notification} notification - Notification payload with title, message, metadata\n   * @returns {Promise<void>} Resolves when notification sent successfully\n   * @throws {Error} If ntfy.sh returns non-2xx status or network request fails\n   *\n   * @example\n   * ```typescript\n   * // Internal usage - send permission notification\n   * const notification: Notification = {\n   *   title: 'CUI Permission Request',\n   *   message: 'EnterPlanMode tool requires approval',\n   *   priority: 'default',\n   *   tags: ['cui-permission'],\n   *   sessionId: 'sess-abc123',\n   *   streamingId: 'stream-xyz789',\n   *   permissionRequestId: 'perm-123'\n   * };\n   *\n   * await this.sendNotification(\n   *   'https://ntfy.sh',\n   *   'cui-a1b2c3d4e5f6g7h8',\n   *   notification\n   * );\n   * // HTTP POST to https://ntfy.sh/cui-a1b2c3d4e5f6g7h8\n   * // Headers:\n   * //   Title: CUI Permission Request\n   * //   Priority: default\n   * //   Tags: cui-permission\n   * //   X-CUI-SessionId: sess-abc123\n   * //   X-CUI-StreamingId: stream-xyz789\n   * //   X-CUI-PermissionRequestId: perm-123\n   * // Body: EnterPlanMode tool requires approval\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Task completion notification (no permissionRequestId)\n   * const notification: Notification = {\n   *   title: 'Task Finished',\n   *   message: 'Created 5 unit tests with 100% coverage',\n   *   priority: 'default',\n   *   tags: ['cui-complete'],\n   *   sessionId: 'sess-def456',\n   *   streamingId: 'stream-abc123'\n   * };\n   *\n   * await this.sendNotification(\n   *   'https://ntfy.sh',\n   *   'cui-a1b2c3d4e5f6g7h8',\n   *   notification\n   * );\n   * // No X-CUI-PermissionRequestId header (omitted when undefined)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Self-hosted ntfy.sh server\n   * await this.sendNotification(\n   *   'https://ntfy.example.com',\n   *   'cui-a1b2c3d4e5f6g7h8',\n   *   notification\n   * );\n   * // HTTP POST to https://ntfy.example.com/cui-a1b2c3d4e5f6g7h8\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Error handling - ntfy.sh server error\n   * try {\n   *   await this.sendNotification(\n   *     'https://ntfy.sh',\n   *     'cui-a1b2c3d4e5f6g7h8',\n   *     notification\n   *   );\n   * } catch (error) {\n   *   // Throws: \"Ntfy returned 500: Internal Server Error\"\n   *   console.error('Notification delivery failed:', error);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Priority levels - urgent notification\n   * const urgentNotification: Notification = {\n   *   title: 'CRITICAL: Production Down',\n   *   message: 'Production database connection lost',\n   *   priority: 'urgent', // Bypass Do Not Disturb mode\n   *   tags: ['cui-alert', 'production'],\n   *   sessionId: 'sess-monitoring',\n   *   streamingId: 'stream-alert-001'\n   * };\n   *\n   * await this.sendNotification(\n   *   'https://ntfy.sh',\n   *   'cui-alerts',\n   *   urgentNotification\n   * );\n   * // Notification bypasses DND, delivered immediately with maximum urgency\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Multiple tags for filtering\n   * const notification: Notification = {\n   *   title: 'Build Failed',\n   *   message: 'CI/CD pipeline failed on main branch',\n   *   priority: 'high',\n   *   tags: ['cui-ci', 'build-failure', 'main-branch'], // Multiple tags\n   *   sessionId: 'sess-ci-001',\n   *   streamingId: 'stream-build-123'\n   * };\n   *\n   * await this.sendNotification(\n   *   'https://ntfy.sh',\n   *   'cui-ci-alerts',\n   *   notification\n   * );\n   * // Headers: Tags: cui-ci,build-failure,main-branch\n   * // Users can filter by specific tags in ntfy.sh mobile app\n   * ```\n   *\n   * @see {@link Notification} for notification payload structure\n   * @see https://docs.ntfy.sh/publish/ for ntfy.sh HTTP API documentation\n   */\n  private async sendNotification(\n    ntfyUrl: string,\n    topic: string,\n    notification: Notification\n  ): Promise<void> {\n    const url = `${ntfyUrl}/${topic}`;\n    \n    const headers: Record<string, string> = {\n      'Title': notification.title,\n      'Priority': notification.priority,\n      'Tags': notification.tags.join(',')\n    };\n\n    // Add custom headers for CUI metadata\n    headers['X-CUI-SessionId'] = notification.sessionId;\n    headers['X-CUI-StreamingId'] = notification.streamingId;\n    if (notification.permissionRequestId) {\n      headers['X-CUI-PermissionRequestId'] = notification.permissionRequestId;\n    }\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers,\n      body: notification.message\n    });\n\n    if (!response.ok) {\n      throw new Error(`Ntfy returned ${response.status}: ${await response.text()}`);\n    }\n  }\n}",
        "last_modified": "2026-01-02T14:06:15.769520"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.613724",
  "last_updated": "2026-01-02T14:06:15.625383"
}