{
  "file_path": "src/web/manager/services/api.ts",
  "main_branch_history": [],
  "task_views": {
    "004-document-frontend-react-components-and-hooks": {
      "task_id": "004-document-frontend-react-components-and-hooks",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "/**\n * API service for Manager frontend\n *\n * Hybrid Architecture:\n * - CRUD operations -> Strapi API (proxied through Express at /api/strapi)\n * - Execution/Streaming -> Express API (/api/execute)\n *\n * Backend provides three route groups:\n * - /api/manager - Legacy file-system based routes\n * - /api/strapi - Strapi CRUD proxy routes\n * - /api/execute - SSE streaming execution routes\n */\n\nimport type { Agent as AgentType, Skill as SkillType, Agent, Skill } from '../../../types/agent.types';\nimport type { ModelConfiguration } from '../../../types/strapi-components.types';\n\n// Express API base URL\n// @ts-ignore - Vite env variables are available at runtime\nconst EXPRESS_API = import.meta.env?.VITE_EXPRESS_URL || 'http://localhost:3001/api';\n\n// Strapi CRUD operations (proxied through Express)\nconst STRAPI_BASE = `${EXPRESS_API}/strapi`;\n\n// Execution routes (SSE streaming)\nconst EXECUTE_BASE = `${EXPRESS_API}/execute`;\n\n// Legacy manager endpoint (file-system based - deprecated)\nconst API_BASE = `${EXPRESS_API}/manager`;\n\n/**\n * Get auth token from cookie\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Create fetch options with auth header\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\nexport interface ValidationResult {\n  cli: { status: string; message: string };\n  sdk: { status: string; message: string };\n  folder: { status: string; message: string };\n  agents: { status: string; message: string; count: number };\n  commands: { status: string; message: string; count: number };\n  skills: { status: string; message: string; count: number };\n}\n\nexport interface SlashCommand {\n  id: string;\n  name: string;\n  description?: string;\n  path: string;\n  relativePath: string;\n  content: string;\n  metadata?: {\n    allowedTools?: string[];\n    argumentHint?: string;\n    model?: string;\n    disableModelInvocation?: boolean;\n  };\n  category?: string;\n}\n\nexport interface TrainingRecord {\n  date: string;\n  scoreBefore: number;\n  scoreAfter: number;\n  issuesFound: string[];\n  correctionsMade: boolean;\n  executionSuccess: boolean;\n}\n\n/**\n * Re-export Strapi-based type definitions\n * DEPRECATED: Direct imports from this file. Use imports from '../../../types/agent.types' instead.\n */\nexport type { Skill } from '../../../types/agent.types';\n\n/**\n * Input field definition for agent and skill execution\n */\nexport interface InputField {\n  name: string;\n  type: 'text' | 'textarea' | 'dropdown' | 'multiselect' | 'checkbox' | 'number' | 'filepath';\n  label: string;\n  description?: string;\n  placeholder?: string;\n  required?: boolean;\n  options?: string[]; // For dropdown and multiselect\n  default?: any;\n}\n\n/**\n * Phase 3: Skill file upload definition\n */\nexport interface SkillFileUpload {\n  fileId: string;\n  fileType: 'REFERENCE' | 'EXAMPLES' | 'TROUBLESHOOTING' | 'CHANGELOG' | 'FAQ' | 'API_DOCS' | 'TUTORIAL' | 'CUSTOM';\n  description?: string;\n  displayOrder: number;\n}\n\n/**\n * Re-export Strapi-based type definitions\n * DEPRECATED: Direct imports from this file. Use imports from '../../../types/agent.types' instead.\n */\nexport type { Agent } from '../../../types/agent.types';\n\nexport interface ProjectAnalysis {\n  commands: SlashCommand[];\n  skills: Skill[];\n  agents: Agent[];\n  hasClaudeFolder: boolean;\n}\n\n/**\n * Validate project setup\n */\nexport async function validateProject(directoryPath: string): Promise<ValidationResult> {\n  const response = await fetch(`${API_BASE}/validate`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directoryPath }),\n  }));\n\n  if (!response.ok) {\n    throw new Error('Validation failed');\n  }\n\n  return response.json();\n}\n\n/**\n * Get agents\n * Now using Strapi API for CRUD operations\n */\nexport async function getAgents(directory?: string): Promise<AgentType[]> {\n  // Use Strapi endpoint for data retrieval\n  const url = new URL(`${STRAPI_BASE}/agents`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get agents');\n  }\n\n  const data = await response.json();\n  return data.agents || data.data || data;\n}\n\n/**\n * Get slash commands\n */\nexport async function getCommands(directory?: string): Promise<SlashCommand[]> {\n  const url = new URL(`${API_BASE}/commands`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get commands');\n  }\n\n  const data = await response.json();\n  return data.commands;\n}\n\n/**\n * Get skills\n * Now using Strapi API for CRUD operations\n */\nexport async function getSkills(directory?: string, includeUsage = false): Promise<SkillType[]> {\n  // Use Strapi endpoint for data retrieval\n  const url = new URL(`${STRAPI_BASE}/skills`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n  if (includeUsage) {\n    url.searchParams.set('includeUsage', 'true');\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get skills');\n  }\n\n  const data = await response.json();\n  return data.skills || data.data || data;\n}\n\n/**\n * Get usage information for all skills\n */\nexport async function getSkillsUsage(directory?: string): Promise<Array<{\n  id: string;\n  name: string;\n  usedInAgents: string[];\n  usageCount: number;\n}>> {\n  const url = new URL(`${STRAPI_BASE}/skills-usage`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get skills usage');\n  }\n\n  const data = await response.json();\n  return data.skills;\n}\n\n/**\n * Analyze entire project\n */\nexport async function analyzeProject(directory?: string): Promise<ProjectAnalysis> {\n  // Fetch all data from Strapi endpoints in parallel\n  const [agents, commands, skills] = await Promise.all([\n    getAgents(directory),\n    getCommands(directory),  // Commands still use file-system\n    getSkills(directory)\n  ]);\n\n  return {\n    agents,\n    commands,\n    skills,\n    hasClaudeFolder: true  // Always true when using Strapi\n  };\n}\n\n/**\n * Get agent details\n * Now using Strapi API\n */\nexport async function getAgentDetails(id: string, directory?: string): Promise<AgentType> {\n  const url = new URL(`${STRAPI_BASE}/agents/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get agent details');\n  }\n\n  const data = await response.json();\n  return data.agent || data.data || data;\n}\n\n/**\n * Get command details\n */\nexport async function getCommandDetails(id: string, directory?: string): Promise<SlashCommand> {\n  const url = new URL(`${API_BASE}/commands/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get command details');\n  }\n\n  const data = await response.json();\n  return data.command;\n}\n\n/**\n * Get skill details\n * Now using Strapi API\n */\nexport async function getSkillDetails(id: string, directory?: string): Promise<SkillType> {\n  const url = new URL(`${STRAPI_BASE}/skills/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get skill details');\n  }\n\n  const data = await response.json();\n  return data.skill || data.data || data;\n}\n\n/**\n * Agent execution event types\n */\nexport interface AgentExecutionEvent {\n  type: 'status' | 'message' | 'complete' | 'error' | 'debug';\n  status?: string;\n  message?: string;\n  messageType?: string;\n  content?: any;\n  error?: string;\n}\n\n/**\n * Tool definition\n */\nexport interface Tool {\n  name: string;\n  description: string;\n}\n\n/**\n * Get available tools\n */\nexport async function getTools(): Promise<Tool[]> {\n  const response = await fetch(`${API_BASE}/tools`, createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get tools');\n  }\n\n  const data = await response.json();\n  return data.tools;\n}\n\n/**\n * Create agent request\n */\nexport interface CreateAgentRequest {\n  name: string;\n  description: string;\n  systemPrompt: string;\n  tools?: string[];\n  model?: 'sonnet' | 'opus' | 'haiku';\n  inputFields?: InputField[];\n  outputSchema?: string | object;\n  mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n  skills?: string[]; // List of skill IDs this agent can use\n}\n\n/**\n * Create skill request\n */\nexport interface CreateSkillRequest {\n  name: string;\n  displayName: string;\n  description: string;\n  allowedTools?: string[];\n  disallowedTools?: string[]; // Phase 2: Disallowed tools\n  mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n  inputFields?: InputField[]; // Input parameters for skill execution\n  skillmd: string;\n  // Phase 1: New metadata fields\n  category?: 'general-purpose' | 'code-analysis' | 'data-processing' | 'web-scraping' | 'file-manipulation' | 'api-integration' | 'browser-automation' | 'testing' | 'custom';\n  isPublic?: boolean;\n  version?: string;\n  license?: string;\n  // Phase 2: Model configuration\n  modelConfig?: ModelConfiguration;\n  // Phase 3: Additional files\n  additionalFiles?: SkillFileUpload[];\n}\n\n/**\n * Update skill request\n */\nexport interface UpdateSkillRequest {\n  description?: string;\n  allowedTools?: string[];\n  disallowedTools?: string[]; // Phase 2: Disallowed tools\n  mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n  inputFields?: InputField[]; // Input parameters for skill execution\n  skillmd?: string;\n  // Phase 1: New metadata fields\n  category?: 'general-purpose' | 'code-analysis' | 'data-processing' | 'web-scraping' | 'file-manipulation' | 'api-integration' | 'browser-automation' | 'testing' | 'custom';\n  isPublic?: boolean;\n  version?: string;\n  license?: string;\n  // Phase 2: Model configuration\n  modelConfig?: ModelConfiguration;\n  // Phase 3: Additional files\n  additionalFiles?: SkillFileUpload[];\n}\n\n/**\n * Create skill response\n */\nexport interface CreateSkillResponse {\n  success: boolean;\n  skill?: Skill;\n  path?: string;\n  error?: string;\n  message?: string;\n}\n\n/**\n * Create a new agent\n * Now using Strapi API\n */\nexport async function createAgent(\n  agent: CreateAgentRequest,\n  directory?: string\n): Promise<{ success: boolean; agentId: string; filePath: string; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/agents`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, agent }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create agent');\n  }\n\n  return response.json();\n}\n\n/**\n * Update an existing agent\n * Now using Strapi API\n */\nexport async function updateAgent(\n  id: string,\n  agent: CreateAgentRequest,\n  directory?: string\n): Promise<{ success: boolean; agentId: string; filePath: string; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/agents/${id}`, createFetchOptions({\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, agent }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to update agent');\n  }\n\n  return response.json();\n}\n\n/**\n * Create a new skill\n * Now using Strapi API\n */\nexport async function createSkill(\n  skill: CreateSkillRequest,\n  directory?: string\n): Promise<CreateSkillResponse> {\n  const response = await fetch(`${STRAPI_BASE}/skills`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, ...skill }),\n  }));\n\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.error || 'Failed to create skill');\n  }\n\n  return data;\n}\n\n/**\n * Update an existing skill\n * Now using Strapi API\n */\nexport async function updateSkill(\n  id: string,\n  skill: UpdateSkillRequest,\n  directory?: string\n): Promise<CreateSkillResponse> {\n  const response = await fetch(`${STRAPI_BASE}/skills/${id}`, createFetchOptions({\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, ...skill }),\n  }));\n\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.error || 'Failed to update skill');\n  }\n\n  return data;\n}\n\n/**\n * Execute an agent with streaming response\n * Now using dedicated execution endpoint for SSE streaming\n */\nexport async function executeAgent(\n  agentId: string,\n  userPrompt: string,\n  directory?: string,\n  permissionMode?: 'default' | 'acceptEdits' | 'bypass' | 'plan',\n  onEvent?: (event: AgentExecutionEvent) => void\n): Promise<void> {\n  // Use EXECUTE_BASE for SSE streaming operations\n  const url = new URL(`${EXECUTE_BASE}/agent/${agentId}`, window.location.origin);\n\n  const response = await fetch(url.toString(), createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, userPrompt, permissionMode }),\n  }));\n\n  if (!response.ok) {\n    throw new Error('Failed to execute agent');\n  }\n\n  if (!response.body) {\n    throw new Error('No response body');\n  }\n\n  // Read SSE stream\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) break;\n\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n');\n\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          try {\n            const data = JSON.parse(line.substring(6));\n            if (onEvent) {\n              onEvent(data);\n            }\n          } catch (e) {\n            console.error('Failed to parse SSE data:', e);\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * ========================================\n * TASK MANAGEMENT API\n * ========================================\n */\n\nconst TASK_API_BASE = EXPRESS_API; // Use /api/tasks (supports both agents and skills)\n\nexport type TaskStatus = 'pending' | 'running' | 'completed' | 'failed';\n\nexport interface Task {\n  id: string;\n  name: string;\n  description?: string;\n  agentId: string; // Can be agent ID or skill ID\n  agentName: string; // Can be agent name or skill name\n  taskType?: 'agent' | 'skill'; // Type of task\n  status: TaskStatus;\n  userPrompt: string;\n  inputValues?: Record<string, any>;\n  permissionMode: string;\n  createdAt: string;\n  startedAt?: string;\n  completedAt?: string;\n  duration?: number;\n  result?: string;\n  error?: string;\n  executionLog?: any[];\n  directory?: string;\n}\n\nexport interface CreateTaskRequest {\n  name: string;\n  description?: string;\n  agentId: string;\n  taskType?: 'agent' | 'skill'; // Type of task (defaults to 'agent' for backward compatibility)\n  userPrompt: string;\n  inputValues?: Record<string, any>;\n  permissionMode?: string;\n  directory?: string;\n}\n\n/**\n * Get all tasks with optional filtering\n */\nexport async function getTasks(params?: {\n  status?: TaskStatus;\n  agentId?: string;\n  limit?: number;\n  offset?: number;\n}): Promise<Task[]> {\n  const queryParams = new URLSearchParams();\n  if (params?.status) queryParams.append('status', params.status);\n  if (params?.agentId) queryParams.append('agentId', params.agentId);\n  if (params?.limit) queryParams.append('limit', params.limit.toString());\n  if (params?.offset) queryParams.append('offset', params.offset.toString());\n\n  const response = await fetch(`${TASK_API_BASE}/tasks?${queryParams}`, createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get tasks');\n  }\n\n  const data = await response.json();\n  return data.data || data.tasks || data;\n}\n\n/**\n * Get task by ID\n */\nexport async function getTask(taskId: string): Promise<Task> {\n  const response = await fetch(`${TASK_API_BASE}/tasks/${taskId}`, createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get task');\n  }\n\n  const data = await response.json();\n  return data.task;\n}\n\n/**\n * Create a new task\n */\nexport async function createTask(request: CreateTaskRequest): Promise<Task> {\n  const response = await fetch(`${TASK_API_BASE}/tasks`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(request),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create task');\n  }\n\n  const data = await response.json();\n  return data.task;\n}\n\n/**\n * Execute a task with streaming response\n * Uses task.routes.ts endpoint for both local and Strapi tasks\n */\nexport async function executeTask(\n  taskId: string,\n  onEvent?: (event: any) => void\n): Promise<void> {\n  const url = `${TASK_API_BASE}/tasks/${taskId}/execute`;\n\n  const response = await fetch(url, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n  }));\n\n  if (!response.ok) {\n    throw new Error('Failed to execute task');\n  }\n\n  if (!response.body) {\n    throw new Error('No response body');\n  }\n\n  // Read SSE stream\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n');\n\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          try {\n            const data = JSON.parse(line.substring(6));\n            if (onEvent) {\n              onEvent(data);\n            }\n          } catch (e) {\n            console.error('Failed to parse SSE data:', e);\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * Delete a task\n */\nexport async function deleteTask(taskId: string): Promise<void> {\n  const response = await fetch(`${TASK_API_BASE}/tasks/${taskId}`, createFetchOptions({\n    method: 'DELETE',\n  }));\n\n  if (!response.ok) {\n    throw new Error('Failed to delete task');\n  }\n}\n\n/**\n * ========================================\n * MCP SERVERS API (SDK-aligned)\n * ========================================\n */\n\n/**\n * Import MCP types from manager types\n */\nimport type {\n  MCPServer as MCPServerType,\n  MCPServerConfig,\n  MCPStdioServerConfig,\n  MCPSdkServerConfig,\n  MCPSSEServerConfig,\n  MCPHttpServerConfig,\n  MCPTool\n} from '../types';\n\n/**\n * Re-export for convenience\n */\nexport type {\n  MCPServerType as MCPServer,\n  MCPServerConfig,\n  MCPStdioServerConfig,\n  MCPSdkServerConfig,\n  MCPSSEServerConfig,\n  MCPHttpServerConfig,\n  MCPTool as MCPToolType\n};\n\n/**\n * Get all MCP servers from project config\n * Now using Strapi API\n */\nexport async function getMCPServers(directory?: string): Promise<MCPServerType[]> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get MCP servers');\n  }\n\n  const data = await response.json();\n  return data.servers || data.data || data;\n}\n\n/**\n * Get MCP server details by ID\n * Now using Strapi API\n */\nexport async function getMCPServerDetails(\n  id: string,\n  directory?: string\n): Promise<MCPServerType> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get MCP server details');\n  }\n\n  const data = await response.json();\n  return data.server || data.data || data;\n}\n\n/**\n * Create a new MCP server\n * Now using Strapi API\n */\nexport async function createMCPServer(\n  name: string,\n  config: MCPServerConfig,\n  directory?: string\n): Promise<{ success: boolean; server: MCPServerType; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ name, config, directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create MCP server');\n  }\n\n  return response.json();\n}\n\n/**\n * Update an existing MCP server\n * Now using Strapi API\n */\nexport async function updateMCPServer(\n  id: string,\n  config: MCPServerConfig,\n  directory?: string\n): Promise<{ success: boolean; server: MCPServerType; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/${id}`, createFetchOptions({\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ config, directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to update MCP server');\n  }\n\n  return response.json();\n}\n\n/**\n * Delete an MCP server\n */\nexport async function deleteMCPServer(\n  id: string,\n  directory?: string\n): Promise<void> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions({\n    method: 'DELETE',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to delete MCP server');\n  }\n}\n\n/**\n * Test an MCP server\n */\nexport async function testMCPServer(\n  id: string,\n  directory?: string\n): Promise<{ success: boolean; message: string; error?: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/${id}/test`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to test MCP server');\n  }\n\n  return response.json();\n}\n\n/**\n * Toggle MCP server enabled/disabled state\n */\nexport async function toggleMCPServer(\n  id: string,\n  directory?: string\n): Promise<{ success: boolean; disabled: boolean; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/${id}/toggle`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to toggle MCP server');\n  }\n\n  return response.json();\n}\n\n/**\n * List tools provided by an MCP server\n */\nexport async function listMCPServerTools(\n  id: string,\n  directory?: string\n): Promise<{ success: boolean; tools: MCPTool[]; error?: string }> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/${id}/tools`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions({\n    method: 'GET',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to list MCP server tools');\n  }\n\n  return response.json();\n}\n\n/**\n * Refresh and sync MCP server tools to Strapi\n * Fetches tools from MCP server and saves them as separate entities in Strapi\n */\nexport async function refreshMCPServerTools(\n  id: string,\n  directory?: string\n): Promise<{ success: boolean; toolsCount: number; tools: MCPTool[]; error?: string }> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/${id}/refresh-tools`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions({\n    method: 'POST',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to refresh MCP server tools');\n  }\n\n  return response.json();\n}\n\n/**\n * Export MCP configuration\n */\nexport async function exportMCPConfig(directory?: string): Promise<any> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/export`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to export MCP configuration');\n  }\n\n  return response.json();\n}\n\n/**\n * Import MCP configuration\n */\nexport async function importMCPConfig(\n  config: any,\n  mode: 'merge' | 'overwrite',\n  directory?: string\n): Promise<{ success: boolean; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/import`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ config, mode, directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to import MCP configuration');\n  }\n\n  return response.json();\n}\n\n/**\n * Bulk delete MCP servers\n */\nexport async function bulkDeleteMCPServers(\n  serverIds: string[],\n  directory?: string\n): Promise<{ success: boolean; successCount: number; failed: number; errors: string[]; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/bulk-delete`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ serverIds, directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to bulk delete MCP servers');\n  }\n\n  const data = await response.json();\n  return {\n    success: data.success,\n    successCount: data.successCount,\n    failed: data.failed,\n    errors: data.errors || [],\n    message: data.message,\n  };\n}\n\n/**\n * Get training history for a skill\n */\nexport async function getSkillTrainingHistory(\n  skillId: string,\n  directory?: string\n): Promise<TrainingRecord[]> {\n  const params = new URLSearchParams();\n  if (directory) {\n    params.append('directory', directory);\n  }\n\n  const url = `${STRAPI_BASE}/skills/${skillId}/training-history?${params.toString()}`;\n  const response = await fetch(url, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get training history');\n  }\n\n  const data = await response.json();\n  return data.history || [];\n}\n\n/**\n * Upload a file to Strapi Media Library\n */\nexport async function uploadFile(file: File): Promise<{\n  id: number;\n  documentId: string;\n  name: string;\n  url: string;\n  mime: string;\n  size: number;\n}> {\n  const formData = new FormData();\n  formData.append('file', file);\n\n  const response = await fetch(`${STRAPI_BASE}/upload`, {\n    method: 'POST',\n    body: formData,\n    // Don't set Content-Type header - browser will set it with boundary\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to upload file');\n  }\n\n  return response.json();\n}\n\n/**\n * Delete a file from Strapi Media Library\n */\nexport async function deleteFile(fileId: string): Promise<void> {\n  const response = await fetch(`${STRAPI_BASE}/upload/${fileId}`, {\n    method: 'DELETE',\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to delete file');\n  }\n}\n",
        "timestamp": "2026-01-02T14:22:14.293924"
      },
      "worktree_state": {
        "content": "/**\n * API service for Manager frontend\n *\n * Hybrid Architecture:\n * - CRUD operations -> Strapi API (proxied through Express at /api/strapi)\n * - Execution/Streaming -> Express API (/api/execute)\n *\n * Backend provides three route groups:\n * - /api/manager - Legacy file-system based routes\n * - /api/strapi - Strapi CRUD proxy routes\n * - /api/execute - SSE streaming execution routes\n */\n\nimport type { Agent as AgentType, Skill as SkillType, Agent, Skill } from '../../../types/agent.types';\nimport type { ModelConfiguration } from '../../../types/strapi-components.types';\n\n// Express API base URL\n// @ts-ignore - Vite env variables are available at runtime\nconst EXPRESS_API = import.meta.env?.VITE_EXPRESS_URL || 'http://localhost:3001/api';\n\n// Strapi CRUD operations (proxied through Express)\nconst STRAPI_BASE = `${EXPRESS_API}/strapi`;\n\n// Execution routes (SSE streaming)\nconst EXECUTE_BASE = `${EXPRESS_API}/execute`;\n\n// Legacy manager endpoint (file-system based - deprecated)\nconst API_BASE = `${EXPRESS_API}/manager`;\n\n/**\n * Retrieves the authentication token from browser cookies.\n *\n * Looks for the 'cui-auth-token' cookie and returns its decoded value.\n * This token is used to authenticate API requests to the backend.\n *\n * @returns The decoded auth token string if found, null otherwise\n *\n * @example\n * const token = getAuthToken();\n * if (token) {\n *   // Use token for authenticated requests\n * }\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Creates fetch options with authentication header.\n *\n * Merges provided options with an Authorization header containing the Bearer token\n * from the authentication cookie. Used internally for all authenticated API requests.\n *\n * @param options - Optional fetch configuration to merge with auth headers\n * @returns RequestInit object with auth header added\n *\n * @example\n * const options = createFetchOptions({\n *   method: 'POST',\n *   body: JSON.stringify({ data: 'value' })\n * });\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\nexport interface ValidationResult {\n  cli: { status: string; message: string };\n  sdk: { status: string; message: string };\n  folder: { status: string; message: string };\n  agents: { status: string; message: string; count: number };\n  commands: { status: string; message: string; count: number };\n  skills: { status: string; message: string; count: number };\n}\n\nexport interface SlashCommand {\n  id: string;\n  name: string;\n  description?: string;\n  path: string;\n  relativePath: string;\n  content: string;\n  metadata?: {\n    allowedTools?: string[];\n    argumentHint?: string;\n    model?: string;\n    disableModelInvocation?: boolean;\n  };\n  category?: string;\n}\n\nexport interface TrainingRecord {\n  date: string;\n  scoreBefore: number;\n  scoreAfter: number;\n  issuesFound: string[];\n  correctionsMade: boolean;\n  executionSuccess: boolean;\n}\n\n/**\n * Re-export Strapi-based type definitions\n * DEPRECATED: Direct imports from this file. Use imports from '../../../types/agent.types' instead.\n */\nexport type { Skill } from '../../../types/agent.types';\n\n/**\n * Input field definition for agent and skill execution\n */\nexport interface InputField {\n  name: string;\n  type: 'text' | 'textarea' | 'dropdown' | 'multiselect' | 'checkbox' | 'number' | 'filepath';\n  label: string;\n  description?: string;\n  placeholder?: string;\n  required?: boolean;\n  options?: string[]; // For dropdown and multiselect\n  default?: any;\n}\n\n/**\n * Phase 3: Skill file upload definition\n */\nexport interface SkillFileUpload {\n  fileId: string;\n  fileType: 'REFERENCE' | 'EXAMPLES' | 'TROUBLESHOOTING' | 'CHANGELOG' | 'FAQ' | 'API_DOCS' | 'TUTORIAL' | 'CUSTOM';\n  description?: string;\n  displayOrder: number;\n}\n\n/**\n * Re-export Strapi-based type definitions\n * DEPRECATED: Direct imports from this file. Use imports from '../../../types/agent.types' instead.\n */\nexport type { Agent } from '../../../types/agent.types';\n\nexport interface ProjectAnalysis {\n  commands: SlashCommand[];\n  skills: Skill[];\n  agents: Agent[];\n  hasClaudeFolder: boolean;\n}\n\n/**\n * Validates project setup including CLI, SDK, folder structure, and resources.\n *\n * Checks if the project has the correct setup for Claude Code agents, including:\n * - CLI installation and version\n * - SDK installation\n * - .claude folder structure\n * - Available agents, commands, and skills\n *\n * @param directoryPath - Absolute path to the project directory to validate\n * @returns Promise resolving to validation results with status for each component\n * @throws Error if validation request fails\n *\n * @example\n * const result = await validateProject('/path/to/project');\n * if (result.cli.status === 'success') {\n *   console.log('CLI is properly installed');\n * }\n */\nexport async function validateProject(directoryPath: string): Promise<ValidationResult> {\n  const response = await fetch(`${API_BASE}/validate`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directoryPath }),\n  }));\n\n  if (!response.ok) {\n    throw new Error('Validation failed');\n  }\n\n  return response.json();\n}\n\n/**\n * Retrieves all agents from the Strapi database.\n *\n * Fetches agent configurations from the Strapi API, optionally filtered by directory.\n * Each agent contains system prompts, tool configurations, and model settings.\n *\n * @param directory - Optional project directory path to filter agents\n * @returns Promise resolving to array of agent objects\n * @throws Error if the API request fails\n *\n * @example\n * const agents = await getAgents();\n * agents.forEach(agent => console.log(agent.name));\n *\n * @example\n * // Get agents for specific directory\n * const projectAgents = await getAgents('/path/to/project');\n */\nexport async function getAgents(directory?: string): Promise<AgentType[]> {\n  // Use Strapi endpoint for data retrieval\n  const url = new URL(`${STRAPI_BASE}/agents`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get agents');\n  }\n\n  const data = await response.json();\n  return data.agents || data.data || data;\n}\n\n/**\n * Retrieves all slash commands from the file system.\n *\n * Fetches command configurations from .claude/commands directory. Commands are\n * markdown files that define custom prompts and workflows for Claude Code.\n *\n * @param directory - Optional project directory path to search for commands\n * @returns Promise resolving to array of slash command objects\n * @throws Error if the API request fails\n *\n * @example\n * const commands = await getCommands('/path/to/project');\n * commands.forEach(cmd => console.log(`/${cmd.name}`));\n */\nexport async function getCommands(directory?: string): Promise<SlashCommand[]> {\n  const url = new URL(`${API_BASE}/commands`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get commands');\n  }\n\n  const data = await response.json();\n  return data.commands;\n}\n\n/**\n * Retrieves all skills from the Strapi database.\n *\n * Fetches skill configurations from the Strapi API. Skills are reusable capabilities\n * that agents can invoke. Optionally includes usage information showing which agents\n * use each skill.\n *\n * @param directory - Optional project directory path to filter skills\n * @param includeUsage - Whether to include usage statistics (which agents use this skill)\n * @returns Promise resolving to array of skill objects\n * @throws Error if the API request fails\n *\n * @example\n * const skills = await getSkills();\n * skills.forEach(skill => console.log(skill.name));\n *\n * @example\n * // Get skills with usage information\n * const skillsWithUsage = await getSkills('/path/to/project', true);\n */\nexport async function getSkills(directory?: string, includeUsage = false): Promise<SkillType[]> {\n  // Use Strapi endpoint for data retrieval\n  const url = new URL(`${STRAPI_BASE}/skills`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n  if (includeUsage) {\n    url.searchParams.set('includeUsage', 'true');\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get skills');\n  }\n\n  const data = await response.json();\n  return data.skills || data.data || data;\n}\n\n/**\n * Retrieves usage statistics for all skills.\n *\n * Returns information about which agents use each skill and how many times\n * it's referenced across the project. Useful for understanding skill adoption\n * and identifying unused skills.\n *\n * @param directory - Optional project directory path to analyze\n * @returns Promise resolving to array of usage statistics per skill\n * @throws Error if the API request fails\n *\n * @example\n * const usage = await getSkillsUsage();\n * usage.forEach(skill => {\n *   console.log(`${skill.name}: used ${skill.usageCount} times`);\n *   console.log(`Used by: ${skill.usedInAgents.join(', ')}`);\n * });\n */\nexport async function getSkillsUsage(directory?: string): Promise<Array<{\n  id: string;\n  name: string;\n  usedInAgents: string[];\n  usageCount: number;\n}>> {\n  const url = new URL(`${STRAPI_BASE}/skills-usage`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get skills usage');\n  }\n\n  const data = await response.json();\n  return data.skills;\n}\n\n/**\n * Analyzes entire project structure and resources.\n *\n * Performs a comprehensive analysis of the project by fetching all agents, commands,\n * and skills in parallel. Returns a complete snapshot of available resources.\n *\n * @param directory - Optional project directory path to analyze\n * @returns Promise resolving to project analysis with all resources\n * @throws Error if any API request fails\n *\n * @example\n * const analysis = await analyzeProject('/path/to/project');\n * console.log(`Found ${analysis.agents.length} agents`);\n * console.log(`Found ${analysis.skills.length} skills`);\n * console.log(`Found ${analysis.commands.length} commands`);\n */\nexport async function analyzeProject(directory?: string): Promise<ProjectAnalysis> {\n  // Fetch all data from Strapi endpoints in parallel\n  const [agents, commands, skills] = await Promise.all([\n    getAgents(directory),\n    getCommands(directory),  // Commands still use file-system\n    getSkills(directory)\n  ]);\n\n  return {\n    agents,\n    commands,\n    skills,\n    hasClaudeFolder: true  // Always true when using Strapi\n  };\n}\n\n/**\n * Retrieves detailed information for a specific agent.\n *\n * Fetches complete agent configuration including system prompt, tool configuration,\n * model settings, input fields, and skill associations.\n *\n * @param id - Agent document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise resolving to agent details\n * @throws Error if agent not found or request fails\n *\n * @example\n * const agent = await getAgentDetails('agent-123');\n * console.log(agent.systemPrompt);\n * console.log(agent.toolConfig);\n */\nexport async function getAgentDetails(id: string, directory?: string): Promise<AgentType> {\n  const url = new URL(`${STRAPI_BASE}/agents/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get agent details');\n  }\n\n  const data = await response.json();\n  return data.agent || data.data || data;\n}\n\n/**\n * Retrieves detailed information for a specific slash command.\n *\n * Fetches the full command configuration including metadata, content,\n * and allowed tools from the file system.\n *\n * @param id - Command identifier (filename without extension)\n * @param directory - Optional project directory path\n * @returns Promise resolving to command details\n * @throws Error if command not found or request fails\n *\n * @example\n * const command = await getCommandDetails('code-review');\n * console.log(command.content);\n */\nexport async function getCommandDetails(id: string, directory?: string): Promise<SlashCommand> {\n  const url = new URL(`${API_BASE}/commands/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get command details');\n  }\n\n  const data = await response.json();\n  return data.command;\n}\n\n/**\n * Retrieves detailed information for a specific skill.\n *\n * Fetches complete skill configuration including skill.md content, tool permissions,\n * input fields, model configuration, and additional files.\n *\n * @param id - Skill document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise resolving to skill details\n * @throws Error if skill not found or request fails\n *\n * @example\n * const skill = await getSkillDetails('skill-456');\n * console.log(skill.skillmd);\n * console.log(skill.allowedTools);\n */\nexport async function getSkillDetails(id: string, directory?: string): Promise<SkillType> {\n  const url = new URL(`${STRAPI_BASE}/skills/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get skill details');\n  }\n\n  const data = await response.json();\n  return data.skill || data.data || data;\n}\n\n/**\n * Agent execution event types\n */\nexport interface AgentExecutionEvent {\n  type: 'status' | 'message' | 'complete' | 'error' | 'debug';\n  status?: string;\n  message?: string;\n  messageType?: string;\n  content?: any;\n  error?: string;\n}\n\n/**\n * Tool definition\n */\nexport interface Tool {\n  name: string;\n  description: string;\n}\n\n/**\n * Retrieves all available Claude Code tools.\n *\n * Fetches the list of built-in tools that can be assigned to agents and skills.\n * Tools include capabilities like Bash, Read, Write, Edit, Grep, etc.\n *\n * @returns Promise resolving to array of available tools\n * @throws Error if the API request fails\n *\n * @example\n * const tools = await getTools();\n * tools.forEach(tool => console.log(`${tool.name}: ${tool.description}`));\n */\nexport async function getTools(): Promise<Tool[]> {\n  const response = await fetch(`${API_BASE}/tools`, createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get tools');\n  }\n\n  const data = await response.json();\n  return data.tools;\n}\n\n/**\n * Create agent request\n */\nexport interface CreateAgentRequest {\n  name: string;\n  description: string;\n  systemPrompt: string;\n  tools?: string[];\n  model?: 'sonnet' | 'opus' | 'haiku';\n  inputFields?: InputField[];\n  outputSchema?: string | object;\n  mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n  skills?: string[]; // List of skill IDs this agent can use\n}\n\n/**\n * Create skill request\n */\nexport interface CreateSkillRequest {\n  name: string;\n  displayName: string;\n  description: string;\n  allowedTools?: string[];\n  disallowedTools?: string[]; // Phase 2: Disallowed tools\n  mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n  inputFields?: InputField[]; // Input parameters for skill execution\n  skillmd: string;\n  // Phase 1: New metadata fields\n  category?: 'general-purpose' | 'code-analysis' | 'data-processing' | 'web-scraping' | 'file-manipulation' | 'api-integration' | 'browser-automation' | 'testing' | 'custom';\n  isPublic?: boolean;\n  version?: string;\n  license?: string;\n  // Phase 2: Model configuration\n  modelConfig?: ModelConfiguration;\n  // Phase 3: Additional files\n  additionalFiles?: SkillFileUpload[];\n}\n\n/**\n * Update skill request\n */\nexport interface UpdateSkillRequest {\n  description?: string;\n  allowedTools?: string[];\n  disallowedTools?: string[]; // Phase 2: Disallowed tools\n  mcpTools?: Record<string, string[]>; // { serverId: [toolName1, toolName2, ...] }\n  inputFields?: InputField[]; // Input parameters for skill execution\n  skillmd?: string;\n  // Phase 1: New metadata fields\n  category?: 'general-purpose' | 'code-analysis' | 'data-processing' | 'web-scraping' | 'file-manipulation' | 'api-integration' | 'browser-automation' | 'testing' | 'custom';\n  isPublic?: boolean;\n  version?: string;\n  license?: string;\n  // Phase 2: Model configuration\n  modelConfig?: ModelConfiguration;\n  // Phase 3: Additional files\n  additionalFiles?: SkillFileUpload[];\n}\n\n/**\n * Create skill response\n */\nexport interface CreateSkillResponse {\n  success: boolean;\n  skill?: Skill;\n  path?: string;\n  error?: string;\n  message?: string;\n}\n\n/**\n * Creates a new agent in Strapi and syncs to file system.\n *\n * Creates an agent with the specified configuration, saves it to Strapi database,\n * and generates the corresponding agent.json file in the .claude/agents directory.\n *\n * @param agent - Agent configuration including name, description, systemPrompt, tools, etc.\n * @param directory - Optional project directory path where agent file will be created\n * @returns Promise resolving to creation result with agent ID and file path\n * @throws Error if creation fails or validation errors occur\n *\n * @example\n * const result = await createAgent({\n *   name: 'code-reviewer',\n *   description: 'Reviews code for best practices',\n *   systemPrompt: 'You are a code review expert...',\n *   tools: ['Read', 'Grep'],\n *   model: 'sonnet'\n * });\n * console.log(`Agent created at ${result.filePath}`);\n */\nexport async function createAgent(\n  agent: CreateAgentRequest,\n  directory?: string\n): Promise<{ success: boolean; agentId: string; filePath: string; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/agents`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, agent }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create agent');\n  }\n\n  return response.json();\n}\n\n/**\n * Updates an existing agent in Strapi and syncs to file system.\n *\n * Updates the agent configuration in Strapi database and regenerates the\n * agent.json file in the .claude/agents directory with the new settings.\n *\n * @param id - Agent document ID (Strapi documentId)\n * @param agent - Updated agent configuration\n * @param directory - Optional project directory path\n * @returns Promise resolving to update result with agent ID and file path\n * @throws Error if update fails or agent not found\n *\n * @example\n * const result = await updateAgent('agent-123', {\n *   name: 'code-reviewer',\n *   description: 'Reviews code with updated guidelines',\n *   systemPrompt: 'New system prompt...',\n *   tools: ['Read', 'Grep', 'Edit']\n * });\n */\nexport async function updateAgent(\n  id: string,\n  agent: CreateAgentRequest,\n  directory?: string\n): Promise<{ success: boolean; agentId: string; filePath: string; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/agents/${id}`, createFetchOptions({\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, agent }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to update agent');\n  }\n\n  return response.json();\n}\n\n/**\n * Creates a new skill in Strapi and syncs to file system.\n *\n * Creates a skill with the specified configuration, saves it to Strapi database,\n * and generates the skill.md file in the .claude/skills directory. Skills can\n * include tool permissions, input fields, model configurations, and additional files.\n *\n * @param skill - Skill configuration including name, description, skillmd content, tools, etc.\n * @param directory - Optional project directory path where skill file will be created\n * @returns Promise resolving to creation result with skill object and file path\n * @throws Error if creation fails or validation errors occur\n *\n * @example\n * const result = await createSkill({\n *   name: 'web-scraper',\n *   displayName: 'Web Scraper',\n *   description: 'Scrapes content from websites',\n *   skillmd: '# Web Scraper\\n\\nInstructions...',\n *   allowedTools: ['WebFetch', 'Grep'],\n *   category: 'web-scraping'\n * });\n * console.log(`Skill created at ${result.path}`);\n */\nexport async function createSkill(\n  skill: CreateSkillRequest,\n  directory?: string\n): Promise<CreateSkillResponse> {\n  const response = await fetch(`${STRAPI_BASE}/skills`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, ...skill }),\n  }));\n\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.error || 'Failed to create skill');\n  }\n\n  return data;\n}\n\n/**\n * Updates an existing skill in Strapi and syncs to file system.\n *\n * Updates the skill configuration in Strapi database and regenerates the\n * skill.md file in the .claude/skills directory with the new settings.\n *\n * @param id - Skill document ID (Strapi documentId)\n * @param skill - Updated skill configuration (partial update supported)\n * @param directory - Optional project directory path\n * @returns Promise resolving to update result with skill object and file path\n * @throws Error if update fails or skill not found\n *\n * @example\n * const result = await updateSkill('skill-456', {\n *   description: 'Updated description',\n *   skillmd: '# Updated content...',\n *   allowedTools: ['WebFetch', 'Grep', 'Read']\n * });\n */\nexport async function updateSkill(\n  id: string,\n  skill: UpdateSkillRequest,\n  directory?: string\n): Promise<CreateSkillResponse> {\n  const response = await fetch(`${STRAPI_BASE}/skills/${id}`, createFetchOptions({\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, ...skill }),\n  }));\n\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.error || 'Failed to update skill');\n  }\n\n  return data;\n}\n\n/**\n * Executes an agent with streaming Server-Sent Events (SSE) response.\n *\n * Starts agent execution and streams events in real-time including status updates,\n * messages, tool usage, and completion. Uses SSE for low-latency streaming of\n * execution progress.\n *\n * @param agentId - Agent document ID (Strapi documentId)\n * @param userPrompt - User's input prompt/task for the agent\n * @param directory - Optional working directory for agent execution\n * @param permissionMode - Permission handling mode ('default', 'acceptEdits', 'bypass', 'plan')\n * @param onEvent - Callback function invoked for each SSE event\n * @returns Promise that resolves when stream completes\n * @throws Error if execution fails to start or no response body\n *\n * @example\n * await executeAgent(\n *   'agent-123',\n *   'Review the authentication code',\n *   '/path/to/project',\n *   'default',\n *   (event) => {\n *     if (event.type === 'message') {\n *       console.log(event.content);\n *     } else if (event.type === 'complete') {\n *       console.log('Execution complete');\n *     }\n *   }\n * );\n */\nexport async function executeAgent(\n  agentId: string,\n  userPrompt: string,\n  directory?: string,\n  permissionMode?: 'default' | 'acceptEdits' | 'bypass' | 'plan',\n  onEvent?: (event: AgentExecutionEvent) => void\n): Promise<void> {\n  // Use EXECUTE_BASE for SSE streaming operations\n  const url = new URL(`${EXECUTE_BASE}/agent/${agentId}`, window.location.origin);\n\n  const response = await fetch(url.toString(), createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory, userPrompt, permissionMode }),\n  }));\n\n  if (!response.ok) {\n    throw new Error('Failed to execute agent');\n  }\n\n  if (!response.body) {\n    throw new Error('No response body');\n  }\n\n  // Read SSE stream\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) break;\n\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n');\n\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          try {\n            const data = JSON.parse(line.substring(6));\n            if (onEvent) {\n              onEvent(data);\n            }\n          } catch (e) {\n            console.error('Failed to parse SSE data:', e);\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * ========================================\n * TASK MANAGEMENT API\n * ========================================\n */\n\nconst TASK_API_BASE = EXPRESS_API; // Use /api/tasks (supports both agents and skills)\n\nexport type TaskStatus = 'pending' | 'running' | 'completed' | 'failed';\n\nexport interface Task {\n  id: string;\n  name: string;\n  description?: string;\n  agentId: string; // Can be agent ID or skill ID\n  agentName: string; // Can be agent name or skill name\n  taskType?: 'agent' | 'skill'; // Type of task\n  status: TaskStatus;\n  userPrompt: string;\n  inputValues?: Record<string, any>;\n  permissionMode: string;\n  createdAt: string;\n  startedAt?: string;\n  completedAt?: string;\n  duration?: number;\n  result?: string;\n  error?: string;\n  executionLog?: any[];\n  directory?: string;\n}\n\nexport interface CreateTaskRequest {\n  name: string;\n  description?: string;\n  agentId: string;\n  taskType?: 'agent' | 'skill'; // Type of task (defaults to 'agent' for backward compatibility)\n  userPrompt: string;\n  inputValues?: Record<string, any>;\n  permissionMode?: string;\n  directory?: string;\n}\n\n/**\n * Retrieves all tasks with optional filtering.\n *\n * Fetches task history from the database with support for filtering by status,\n * agent ID, and pagination. Tasks represent agent or skill execution requests.\n *\n * @param params - Optional filtering and pagination parameters\n * @param params.status - Filter by task status ('pending', 'running', 'completed', 'failed')\n * @param params.agentId - Filter by agent or skill document ID\n * @param params.limit - Maximum number of tasks to return\n * @param params.offset - Number of tasks to skip (for pagination)\n * @returns Promise resolving to array of task objects\n * @throws Error if the API request fails\n *\n * @example\n * // Get all completed tasks\n * const completedTasks = await getTasks({ status: 'completed', limit: 10 });\n *\n * @example\n * // Get tasks for specific agent\n * const agentTasks = await getTasks({ agentId: 'agent-123' });\n */\nexport async function getTasks(params?: {\n  status?: TaskStatus;\n  agentId?: string;\n  limit?: number;\n  offset?: number;\n}): Promise<Task[]> {\n  const queryParams = new URLSearchParams();\n  if (params?.status) queryParams.append('status', params.status);\n  if (params?.agentId) queryParams.append('agentId', params.agentId);\n  if (params?.limit) queryParams.append('limit', params.limit.toString());\n  if (params?.offset) queryParams.append('offset', params.offset.toString());\n\n  const response = await fetch(`${TASK_API_BASE}/tasks?${queryParams}`, createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get tasks');\n  }\n\n  const data = await response.json();\n  return data.data || data.tasks || data;\n}\n\n/**\n * Retrieves a specific task by ID.\n *\n * Fetches complete task details including status, execution log, results,\n * and error information if applicable.\n *\n * @param taskId - Task ID (UUID)\n * @returns Promise resolving to task object with full details\n * @throws Error if task not found or request fails\n *\n * @example\n * const task = await getTask('task-uuid-123');\n * console.log(`Status: ${task.status}`);\n * if (task.error) console.error(task.error);\n */\nexport async function getTask(taskId: string): Promise<Task> {\n  const response = await fetch(`${TASK_API_BASE}/tasks/${taskId}`, createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get task');\n  }\n\n  const data = await response.json();\n  return data.task;\n}\n\n/**\n * Creates a new task for agent or skill execution.\n *\n * Creates a task record in the database with the specified configuration.\n * The task can be executed later using executeTask(). Supports both agent\n * and skill tasks with optional input values.\n *\n * @param request - Task creation request with name, description, agent/skill ID, etc.\n * @returns Promise resolving to created task object\n * @throws Error if creation fails or validation errors occur\n *\n * @example\n * const task = await createTask({\n *   name: 'Code Review Task',\n *   description: 'Review authentication module',\n *   agentId: 'agent-123',\n *   taskType: 'agent',\n *   userPrompt: 'Review the auth code for security issues',\n *   permissionMode: 'default',\n *   directory: '/path/to/project'\n * });\n */\nexport async function createTask(request: CreateTaskRequest): Promise<Task> {\n  const response = await fetch(`${TASK_API_BASE}/tasks`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(request),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create task');\n  }\n\n  const data = await response.json();\n  return data.task;\n}\n\n/**\n * Executes a task with streaming Server-Sent Events (SSE) response.\n *\n * Starts task execution and streams events in real-time. Works for both agent\n * and skill tasks. The task must already exist (created via createTask).\n *\n * @param taskId - Task ID (UUID)\n * @param onEvent - Callback function invoked for each SSE event\n * @returns Promise that resolves when stream completes\n * @throws Error if execution fails to start or task not found\n *\n * @example\n * await executeTask('task-uuid-123', (event) => {\n *   if (event.type === 'status') {\n *     console.log(`Status: ${event.status}`);\n *   } else if (event.type === 'message') {\n *     console.log(event.content);\n *   } else if (event.type === 'complete') {\n *     console.log('Task complete');\n *   }\n * });\n */\nexport async function executeTask(\n  taskId: string,\n  onEvent?: (event: any) => void\n): Promise<void> {\n  const url = `${TASK_API_BASE}/tasks/${taskId}/execute`;\n\n  const response = await fetch(url, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n  }));\n\n  if (!response.ok) {\n    throw new Error('Failed to execute task');\n  }\n\n  if (!response.body) {\n    throw new Error('No response body');\n  }\n\n  // Read SSE stream\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n');\n\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          try {\n            const data = JSON.parse(line.substring(6));\n            if (onEvent) {\n              onEvent(data);\n            }\n          } catch (e) {\n            console.error('Failed to parse SSE data:', e);\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * Deletes a task from the database.\n *\n * Permanently removes the task and all associated execution logs.\n * This action cannot be undone.\n *\n * @param taskId - Task ID (UUID) to delete\n * @returns Promise that resolves when deletion completes\n * @throws Error if deletion fails or task not found\n *\n * @example\n * await deleteTask('task-uuid-123');\n */\nexport async function deleteTask(taskId: string): Promise<void> {\n  const response = await fetch(`${TASK_API_BASE}/tasks/${taskId}`, createFetchOptions({\n    method: 'DELETE',\n  }));\n\n  if (!response.ok) {\n    throw new Error('Failed to delete task');\n  }\n}\n\n/**\n * ========================================\n * MCP SERVERS API (SDK-aligned)\n * ========================================\n */\n\n/**\n * Import MCP types from manager types\n */\nimport type {\n  MCPServer as MCPServerType,\n  MCPServerConfig,\n  MCPStdioServerConfig,\n  MCPSdkServerConfig,\n  MCPSSEServerConfig,\n  MCPHttpServerConfig,\n  MCPTool\n} from '../types';\n\n/**\n * Re-export for convenience\n */\nexport type {\n  MCPServerType as MCPServer,\n  MCPServerConfig,\n  MCPStdioServerConfig,\n  MCPSdkServerConfig,\n  MCPSSEServerConfig,\n  MCPHttpServerConfig,\n  MCPTool as MCPToolType\n};\n\n/**\n * Retrieves all MCP (Model Context Protocol) servers from Strapi.\n *\n * Fetches configured MCP servers that provide additional tools and capabilities\n * to agents and skills. Supports stdio, SSE, HTTP, and SDK-based servers.\n *\n * @param directory - Optional project directory path to filter servers\n * @returns Promise resolving to array of MCP server configurations\n * @throws Error if the API request fails\n *\n * @example\n * const servers = await getMCPServers();\n * servers.forEach(server => {\n *   console.log(`${server.name}: ${server.config.type}`);\n * });\n */\nexport async function getMCPServers(directory?: string): Promise<MCPServerType[]> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get MCP servers');\n  }\n\n  const data = await response.json();\n  return data.servers || data.data || data;\n}\n\n/**\n * Retrieves detailed information for a specific MCP server.\n *\n * Fetches complete server configuration including connection details,\n * environment variables, and associated tools.\n *\n * @param id - MCP server document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise resolving to MCP server details\n * @throws Error if server not found or request fails\n *\n * @example\n * const server = await getMCPServerDetails('server-123');\n * console.log(server.config);\n */\nexport async function getMCPServerDetails(\n  id: string,\n  directory?: string\n): Promise<MCPServerType> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to get MCP server details');\n  }\n\n  const data = await response.json();\n  return data.server || data.data || data;\n}\n\n/**\n * Creates a new MCP server in Strapi and project configuration.\n *\n * Creates an MCP server with the specified configuration, saves it to Strapi,\n * and updates the claude_desktop_config.json file in the project.\n *\n * @param name - Unique name for the MCP server\n * @param config - Server configuration (type, command, args, env, etc.)\n * @param directory - Optional project directory path\n * @returns Promise resolving to creation result with server object\n * @throws Error if creation fails or validation errors occur\n *\n * @example\n * const result = await createMCPServer('filesystem', {\n *   type: 'stdio',\n *   command: 'node',\n *   args: ['/path/to/mcp-server.js'],\n *   env: { NODE_ENV: 'production' }\n * });\n */\nexport async function createMCPServer(\n  name: string,\n  config: MCPServerConfig,\n  directory?: string\n): Promise<{ success: boolean; server: MCPServerType; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ name, config, directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create MCP server');\n  }\n\n  return response.json();\n}\n\n/**\n * Updates an existing MCP server in Strapi and project configuration.\n *\n * Updates the server configuration in Strapi and regenerates the\n * claude_desktop_config.json file with the new settings.\n *\n * @param id - MCP server document ID (Strapi documentId)\n * @param config - Updated server configuration\n * @param directory - Optional project directory path\n * @returns Promise resolving to update result with server object\n * @throws Error if update fails or server not found\n *\n * @example\n * const result = await updateMCPServer('server-123', {\n *   type: 'stdio',\n *   command: 'node',\n *   args: ['/updated/path.js']\n * });\n */\nexport async function updateMCPServer(\n  id: string,\n  config: MCPServerConfig,\n  directory?: string\n): Promise<{ success: boolean; server: MCPServerType; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/${id}`, createFetchOptions({\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ config, directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to update MCP server');\n  }\n\n  return response.json();\n}\n\n/**\n * Deletes an MCP server from Strapi and project configuration.\n *\n * Removes the server from Strapi database and updates the\n * claude_desktop_config.json file to remove the server entry.\n *\n * @param id - MCP server document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise that resolves when deletion completes\n * @throws Error if deletion fails or server not found\n *\n * @example\n * await deleteMCPServer('server-123');\n */\nexport async function deleteMCPServer(\n  id: string,\n  directory?: string\n): Promise<void> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/${id}`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions({\n    method: 'DELETE',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to delete MCP server');\n  }\n}\n\n/**\n * Tests an MCP server connection.\n *\n * Attempts to connect to the MCP server and verify it's working correctly.\n * Returns success status and any error messages if connection fails.\n *\n * @param id - MCP server document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise resolving to test result with success status and message\n * @throws Error if test request fails\n *\n * @example\n * const result = await testMCPServer('server-123');\n * if (result.success) {\n *   console.log('Server is working');\n * } else {\n *   console.error(result.error);\n * }\n */\nexport async function testMCPServer(\n  id: string,\n  directory?: string\n): Promise<{ success: boolean; message: string; error?: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/${id}/test`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to test MCP server');\n  }\n\n  return response.json();\n}\n\n/**\n * Toggles an MCP server's enabled/disabled state.\n *\n * Switches the server between enabled and disabled states. Disabled servers\n * are not available for use by agents and skills.\n *\n * @param id - MCP server document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise resolving to new disabled state and message\n * @throws Error if toggle fails or server not found\n *\n * @example\n * const result = await toggleMCPServer('server-123');\n * console.log(`Server is now ${result.disabled ? 'disabled' : 'enabled'}`);\n */\nexport async function toggleMCPServer(\n  id: string,\n  directory?: string\n): Promise<{ success: boolean; disabled: boolean; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/${id}/toggle`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to toggle MCP server');\n  }\n\n  return response.json();\n}\n\n/**\n * Lists all tools provided by an MCP server.\n *\n * Retrieves the list of tools/capabilities exposed by the MCP server.\n * Each tool includes name, description, and input schema.\n *\n * @param id - MCP server document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise resolving to tool list with success status\n * @throws Error if request fails\n *\n * @example\n * const result = await listMCPServerTools('server-123');\n * if (result.success) {\n *   result.tools.forEach(tool => console.log(tool.name));\n * }\n */\nexport async function listMCPServerTools(\n  id: string,\n  directory?: string\n): Promise<{ success: boolean; tools: MCPTool[]; error?: string }> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/${id}/tools`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions({\n    method: 'GET',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to list MCP server tools');\n  }\n\n  return response.json();\n}\n\n/**\n * Refreshes and syncs MCP server tools to Strapi.\n *\n * Fetches the latest tools from the MCP server and saves them as separate\n * entities in Strapi. This allows tools to be tracked and referenced by agents.\n *\n * @param id - MCP server document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise resolving to refresh result with tool count and list\n * @throws Error if refresh fails\n *\n * @example\n * const result = await refreshMCPServerTools('server-123');\n * console.log(`Refreshed ${result.toolsCount} tools`);\n */\nexport async function refreshMCPServerTools(\n  id: string,\n  directory?: string\n): Promise<{ success: boolean; toolsCount: number; tools: MCPTool[]; error?: string }> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/${id}/refresh-tools`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions({\n    method: 'POST',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to refresh MCP server tools');\n  }\n\n  return response.json();\n}\n\n/**\n * Exports MCP server configuration.\n *\n * Generates a JSON configuration containing all MCP servers in the format\n * compatible with claude_desktop_config.json.\n *\n * @param directory - Optional project directory path\n * @returns Promise resolving to MCP configuration object\n * @throws Error if export fails\n *\n * @example\n * const config = await exportMCPConfig();\n * console.log(JSON.stringify(config, null, 2));\n */\nexport async function exportMCPConfig(directory?: string): Promise<any> {\n  const url = new URL(`${STRAPI_BASE}/mcp-servers/export`, window.location.origin);\n  if (directory) {\n    url.searchParams.set('directory', directory);\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    throw new Error('Failed to export MCP configuration');\n  }\n\n  return response.json();\n}\n\n/**\n * Imports MCP server configuration.\n *\n * Imports MCP servers from a configuration object in claude_desktop_config.json format.\n * Supports merge mode (adds to existing servers) or overwrite mode (replaces all servers).\n *\n * @param config - MCP configuration object to import\n * @param mode - Import mode: 'merge' adds to existing, 'overwrite' replaces all\n * @param directory - Optional project directory path\n * @returns Promise resolving to import result with success status\n * @throws Error if import fails or validation errors occur\n *\n * @example\n * const result = await importMCPConfig(configObj, 'merge');\n * console.log(result.message);\n */\nexport async function importMCPConfig(\n  config: any,\n  mode: 'merge' | 'overwrite',\n  directory?: string\n): Promise<{ success: boolean; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/import`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ config, mode, directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to import MCP configuration');\n  }\n\n  return response.json();\n}\n\n/**\n * Deletes multiple MCP servers in a single operation.\n *\n * Removes multiple servers from Strapi and updates the project configuration.\n * Returns detailed results including success count and any errors.\n *\n * @param serverIds - Array of MCP server document IDs to delete\n * @param directory - Optional project directory path\n * @returns Promise resolving to bulk delete result with counts and errors\n * @throws Error if the bulk delete request fails\n *\n * @example\n * const result = await bulkDeleteMCPServers(['server-1', 'server-2']);\n * console.log(`Deleted ${result.successCount} servers`);\n * if (result.failed > 0) {\n *   console.error(`Failed to delete ${result.failed} servers`);\n *   result.errors.forEach(err => console.error(err));\n * }\n */\nexport async function bulkDeleteMCPServers(\n  serverIds: string[],\n  directory?: string\n): Promise<{ success: boolean; successCount: number; failed: number; errors: string[]; message: string }> {\n  const response = await fetch(`${STRAPI_BASE}/mcp-servers/bulk-delete`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ serverIds, directory }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to bulk delete MCP servers');\n  }\n\n  const data = await response.json();\n  return {\n    success: data.success,\n    successCount: data.successCount,\n    failed: data.failed,\n    errors: data.errors || [],\n    message: data.message,\n  };\n}\n\n/**\n * Retrieves training history for a skill.\n *\n * Fetches historical training records showing how the skill has been improved\n * over time, including scores before/after training and issues found.\n *\n * @param skillId - Skill document ID (Strapi documentId)\n * @param directory - Optional project directory path\n * @returns Promise resolving to array of training records\n * @throws Error if request fails or skill not found\n *\n * @example\n * const history = await getSkillTrainingHistory('skill-456');\n * history.forEach(record => {\n *   console.log(`${record.date}: ${record.scoreBefore} -> ${record.scoreAfter}`);\n * });\n */\nexport async function getSkillTrainingHistory(\n  skillId: string,\n  directory?: string\n): Promise<TrainingRecord[]> {\n  const params = new URLSearchParams();\n  if (directory) {\n    params.append('directory', directory);\n  }\n\n  const url = `${STRAPI_BASE}/skills/${skillId}/training-history?${params.toString()}`;\n  const response = await fetch(url, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get training history');\n  }\n\n  const data = await response.json();\n  return data.history || [];\n}\n\n/**\n * Uploads a file to Strapi Media Library.\n *\n * Uploads a file for use as a skill attachment or other media. Returns the\n * file metadata including URL for later reference.\n *\n * @param file - File object to upload\n * @returns Promise resolving to uploaded file metadata\n * @throws Error if upload fails\n *\n * @example\n * const fileInput = document.querySelector('input[type=\"file\"]');\n * const file = fileInput.files[0];\n * const uploadedFile = await uploadFile(file);\n * console.log(`File uploaded: ${uploadedFile.url}`);\n */\nexport async function uploadFile(file: File): Promise<{\n  id: number;\n  documentId: string;\n  name: string;\n  url: string;\n  mime: string;\n  size: number;\n}> {\n  const formData = new FormData();\n  formData.append('file', file);\n\n  const response = await fetch(`${STRAPI_BASE}/upload`, {\n    method: 'POST',\n    body: formData,\n    // Don't set Content-Type header - browser will set it with boundary\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to upload file');\n  }\n\n  return response.json();\n}\n\n/**\n * Deletes a file from Strapi Media Library.\n *\n * Permanently removes a file from the media library. This action cannot be undone.\n *\n * @param fileId - File document ID (Strapi documentId)\n * @returns Promise that resolves when deletion completes\n * @throws Error if deletion fails or file not found\n *\n * @example\n * await deleteFile('file-doc-id-123');\n */\nexport async function deleteFile(fileId: string): Promise<void> {\n  const response = await fetch(`${STRAPI_BASE}/upload/${fileId}`, {\n    method: 'DELETE',\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to delete file');\n  }\n}\n",
        "last_modified": "2026-01-02T15:11:36.300287"
      },
      "task_intent": {
        "title": "Document Frontend React Components and Hooks",
        "description": "Add comprehensive JSDoc documentation to all React components and custom hooks in the frontend, including prop types, usage examples, component purposes, state management, and side effects.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:22:15.449058",
  "last_updated": "2026-01-02T14:22:15.469941"
}