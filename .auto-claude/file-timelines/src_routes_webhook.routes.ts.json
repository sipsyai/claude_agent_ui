{
  "file_path": "src/routes/webhook.routes.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": {
        "content": "/**\n * Webhook Routes - REST API for Triggering Flows via HTTP Webhooks\n *\n * Provides endpoints for:\n * - Triggering flows via external HTTP requests\n * - Webhook authentication via secret token\n * - Synchronous and asynchronous execution modes\n *\n * @see src/services/flow-execution-service.ts for execution logic\n * @see src/types/flow-types.ts for type definitions\n */\n\nimport { Router, Request, Response } from 'express';\nimport { strapiClient } from '../services/strapi-client.js';\nimport { flowExecutionService } from '../services/flow-execution-service.js';\nimport { createLogger } from '../services/logger.js';\nimport { asyncHandler, AppError } from '../middleware/error-handler.js';\nimport { z } from 'zod';\nimport type { Flow, FlowExecutionResult } from '../types/flow-types.js';\n\n// ============= VALIDATION SCHEMAS =============\n\n/**\n * Webhook flow identifier parameter validation\n * Accepts either a documentId (UUID) or a slug\n */\nconst webhookIdentifierSchema = z.object({\n  identifier: z.string()\n    .min(1, 'Flow identifier is required')\n});\n\n/**\n * Webhook request body validation\n */\nconst webhookBodySchema = z.object({\n  // Input data for the flow\n  input: z.record(z.any())\n    .optional()\n    .default({}),\n\n  // Whether to wait for flow completion before responding\n  // Default: false (async mode - returns execution ID immediately)\n  waitForCompletion: z.boolean()\n    .optional()\n    .default(false),\n\n  // Optional timeout in milliseconds for waitForCompletion mode\n  // Default: 60000 (60 seconds)\n  timeout: z.number()\n    .min(1000)\n    .max(300000) // Max 5 minutes\n    .optional()\n    .default(60000),\n\n  // Additional metadata to store with the execution\n  metadata: z.record(z.any())\n    .optional()\n});\n\n// ============= HELPER FUNCTIONS =============\n\n/**\n * Find a flow by ID or slug\n */\nasync function findFlowByIdentifier(identifier: string): Promise<Flow | null> {\n  // First try to find by ID\n  try {\n    const flow = await strapiClient.getFlow(identifier);\n    if (flow) return flow;\n  } catch {\n    // Not found by ID, try slug\n  }\n\n  // Try to find by slug\n  const flow = await strapiClient.getFlowBySlug(identifier);\n  return flow;\n}\n\n/**\n * Validate webhook secret from request headers\n */\nfunction validateWebhookSecret(req: Request, flow: Flow): boolean {\n  if (!flow.webhookSecret) {\n    // No secret configured, allow all requests\n    return true;\n  }\n\n  // Check X-Webhook-Secret header\n  const secretHeader = req.header('X-Webhook-Secret');\n  if (secretHeader === flow.webhookSecret) {\n    return true;\n  }\n\n  // Check Authorization header (Bearer token format)\n  const authHeader = req.header('Authorization');\n  if (authHeader) {\n    const [type, token] = authHeader.split(' ');\n    if (type?.toLowerCase() === 'bearer' && token === flow.webhookSecret) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Get client IP address from request\n */\nfunction getClientIp(req: Request): string {\n  const forwardedFor = req.header('X-Forwarded-For');\n  if (forwardedFor) {\n    return forwardedFor.split(',')[0].trim();\n  }\n  return req.ip || req.socket.remoteAddress || 'unknown';\n}\n\n// ============= ROUTE FACTORY =============\n\nexport function createWebhookRoutes(): Router {\n  const router = Router();\n  const logger = createLogger('WebhookRoutes');\n\n  // ============= WEBHOOK TRIGGER ENDPOINT =============\n\n  /**\n   * POST /api/webhooks/flows/:identifier\n   * Trigger a flow execution via webhook\n   *\n   * The identifier can be either a flow ID or a slug\n   *\n   * Headers:\n   * - X-Webhook-Secret: Secret token for authentication (optional, depends on flow config)\n   * - Authorization: Bearer <secret> (alternative to X-Webhook-Secret)\n   *\n   * Body:\n   * - input: Object - Input data for the flow (optional)\n   * - waitForCompletion: boolean - Wait for execution to complete (default: false)\n   * - timeout: number - Timeout in ms for waitForCompletion (default: 60000)\n   * - metadata: Object - Additional metadata (optional)\n   *\n   * Response (async mode - waitForCompletion: false):\n   * {\n   *   success: true,\n   *   executionId: \"...\",\n   *   message: \"Flow execution started\",\n   *   statusUrl: \"/api/flows/executions/:id\"\n   * }\n   *\n   * Response (sync mode - waitForCompletion: true):\n   * {\n   *   success: true/false,\n   *   executionId: \"...\",\n   *   status: \"completed\" | \"failed\" | \"cancelled\",\n   *   output: { ... },\n   *   error: \"...\" (if failed),\n   *   executionTime: 1234\n   * }\n   */\n  router.post('/flows/:identifier', asyncHandler(async (req: Request, res: Response) => {\n    const { identifier } = webhookIdentifierSchema.parse(req.params);\n    const body = webhookBodySchema.parse(req.body);\n\n    const clientIp = getClientIp(req);\n    const userAgent = req.header('User-Agent') || 'unknown';\n\n    logger.info('Webhook trigger received', {\n      identifier,\n      clientIp,\n      userAgent,\n      hasInput: Object.keys(body.input).length > 0,\n      waitForCompletion: body.waitForCompletion\n    });\n\n    // 1. Find the flow\n    const flow = await findFlowByIdentifier(identifier);\n\n    if (!flow) {\n      logger.warn('Webhook: Flow not found', { identifier, clientIp });\n      throw new AppError(404, 'Flow not found');\n    }\n\n    // 2. Check if webhook is enabled for this flow\n    if (!flow.webhookEnabled) {\n      logger.warn('Webhook: Webhook not enabled for flow', {\n        flowId: flow.id,\n        flowName: flow.name,\n        clientIp\n      });\n      throw new AppError(403, 'Webhook is not enabled for this flow');\n    }\n\n    // 3. Check if flow is active\n    if (!flow.isActive) {\n      logger.warn('Webhook: Flow is not active', {\n        flowId: flow.id,\n        flowName: flow.name,\n        clientIp\n      });\n      throw new AppError(403, 'Flow is not active. Please activate it before triggering via webhook.');\n    }\n\n    // 4. Validate webhook secret\n    if (!validateWebhookSecret(req, flow)) {\n      logger.warn('Webhook: Invalid secret', {\n        flowId: flow.id,\n        flowName: flow.name,\n        clientIp,\n        hasSecretHeader: !!req.header('X-Webhook-Secret'),\n        hasAuthHeader: !!req.header('Authorization')\n      });\n      throw new AppError(401, 'Invalid webhook secret');\n    }\n\n    // 5. Prepare trigger data\n    const triggerData = {\n      source: 'webhook',\n      clientIp,\n      userAgent,\n      timestamp: new Date().toISOString(),\n      headers: {\n        'content-type': req.header('Content-Type'),\n        'x-request-id': req.header('X-Request-Id'),\n      },\n      metadata: body.metadata\n    };\n\n    logger.info('Webhook: Starting flow execution', {\n      flowId: flow.id,\n      flowName: flow.name,\n      clientIp,\n      waitForCompletion: body.waitForCompletion\n    });\n\n    // 6. Start the flow execution\n    if (body.waitForCompletion) {\n      // Synchronous mode - wait for completion\n      try {\n        const result = await Promise.race([\n          flowExecutionService.startExecution({\n            flowId: flow.id,\n            input: body.input,\n            triggeredBy: 'webhook',\n            triggerData\n          }),\n          new Promise<FlowExecutionResult>((_, reject) => {\n            setTimeout(() => reject(new Error('Webhook timeout')), body.timeout);\n          })\n        ]);\n\n        logger.info('Webhook: Flow execution completed', {\n          flowId: flow.id,\n          executionId: result.executionId,\n          success: result.success,\n          executionTime: result.executionTime,\n          clientIp\n        });\n\n        res.json({\n          success: result.success,\n          executionId: result.executionId,\n          status: result.status,\n          output: result.output,\n          error: result.error,\n          executionTime: result.executionTime,\n          tokensUsed: result.tokensUsed,\n          cost: result.cost\n        });\n\n      } catch (error) {\n        if (error instanceof Error && error.message === 'Webhook timeout') {\n          logger.warn('Webhook: Execution timeout', {\n            flowId: flow.id,\n            timeout: body.timeout,\n            clientIp\n          });\n          throw new AppError(504, `Flow execution timed out after ${body.timeout}ms`);\n        }\n        throw error;\n      }\n\n    } else {\n      // Asynchronous mode - return immediately\n      // Start execution in background\n      flowExecutionService.startExecution({\n        flowId: flow.id,\n        input: body.input,\n        triggeredBy: 'webhook',\n        triggerData\n      }).then(result => {\n        logger.info('Webhook: Background execution completed', {\n          flowId: flow.id,\n          executionId: result.executionId,\n          success: result.success,\n          clientIp\n        });\n      }).catch(error => {\n        logger.error('Webhook: Background execution failed', error as Error, {\n          flowId: flow.id,\n          clientIp\n        });\n      });\n\n      // Generate execution ID for tracking\n      // Note: The actual execution ID will be created by flowExecutionService\n      // We return a placeholder message\n      res.status(202).json({\n        success: true,\n        message: `Flow \"${flow.name}\" execution started`,\n        flowId: flow.id,\n        flowName: flow.name,\n        triggeredAt: new Date().toISOString(),\n        statusUrl: `/api/flows/${flow.id}/executions`\n      });\n    }\n  }));\n\n  // ============= WEBHOOK INFO ENDPOINT =============\n\n  /**\n   * GET /api/webhooks/flows/:identifier/info\n   * Get webhook configuration info for a flow\n   *\n   * Useful for debugging and verifying webhook setup\n   */\n  router.get('/flows/:identifier/info', asyncHandler(async (req: Request, res: Response) => {\n    const { identifier } = webhookIdentifierSchema.parse(req.params);\n\n    logger.debug('Webhook info requested', { identifier });\n\n    const flow = await findFlowByIdentifier(identifier);\n\n    if (!flow) {\n      throw new AppError(404, 'Flow not found');\n    }\n\n    // Return webhook configuration (without exposing the secret)\n    res.json({\n      flowId: flow.id,\n      flowName: flow.name,\n      flowSlug: flow.slug,\n      webhookEnabled: flow.webhookEnabled,\n      hasWebhookSecret: !!flow.webhookSecret,\n      isActive: flow.isActive,\n      status: flow.status,\n      category: flow.category,\n      webhookUrl: `/api/webhooks/flows/${flow.slug}`,\n      alternativeUrl: `/api/webhooks/flows/${flow.id}`,\n      inputSchema: flow.inputSchema,\n      usage: {\n        method: 'POST',\n        contentType: 'application/json',\n        headers: flow.webhookSecret ? {\n          'X-Webhook-Secret': '<your-secret>',\n          'OR Authorization': 'Bearer <your-secret>'\n        } : {},\n        body: {\n          input: '{ \"fieldName\": \"value\" }',\n          waitForCompletion: 'boolean (optional, default: false)',\n          timeout: 'number (optional, default: 60000ms)',\n          metadata: '{ ... } (optional)'\n        }\n      }\n    });\n  }));\n\n  // ============= WEBHOOK TEST ENDPOINT =============\n\n  /**\n   * POST /api/webhooks/flows/:identifier/test\n   * Test webhook configuration without executing the flow\n   *\n   * Returns authentication status and input validation results\n   */\n  router.post('/flows/:identifier/test', asyncHandler(async (req: Request, res: Response) => {\n    const { identifier } = webhookIdentifierSchema.parse(req.params);\n    const body = webhookBodySchema.parse(req.body);\n\n    const clientIp = getClientIp(req);\n\n    logger.info('Webhook test requested', { identifier, clientIp });\n\n    const flow = await findFlowByIdentifier(identifier);\n\n    if (!flow) {\n      throw new AppError(404, 'Flow not found');\n    }\n\n    // Test results\n    const results = {\n      flowFound: true,\n      flowId: flow.id,\n      flowName: flow.name,\n      webhookEnabled: flow.webhookEnabled,\n      flowActive: flow.isActive,\n      authenticationValid: validateWebhookSecret(req, flow),\n      secretRequired: !!flow.webhookSecret,\n      inputProvided: Object.keys(body.input).length > 0,\n      inputFields: Object.keys(body.input),\n      expectedInputFields: flow.inputSchema?.properties ? Object.keys(flow.inputSchema.properties) : [],\n      requiredInputFields: flow.inputSchema?.required || [],\n      timestamp: new Date().toISOString(),\n      clientIp\n    };\n\n    // Determine overall test status\n    const canExecute = results.webhookEnabled &&\n                       results.flowActive &&\n                       results.authenticationValid;\n\n    res.json({\n      success: canExecute,\n      message: canExecute\n        ? 'Webhook test passed! The flow can be triggered.'\n        : 'Webhook test failed. Check the results for details.',\n      results,\n      issues: [\n        !results.webhookEnabled && 'Webhook is not enabled for this flow',\n        !results.flowActive && 'Flow is not active',\n        !results.authenticationValid && results.secretRequired && 'Invalid or missing webhook secret'\n      ].filter(Boolean)\n    });\n  }));\n\n  // ============= LIST WEBHOOK-ENABLED FLOWS =============\n\n  /**\n   * GET /api/webhooks/flows\n   * List all flows that have webhooks enabled\n   */\n  router.get('/flows', asyncHandler(async (req: Request, res: Response) => {\n    logger.debug('Listing webhook-enabled flows');\n\n    // Get all active flows with webhooks enabled\n    const allFlows = await strapiClient.getAllFlows({\n      filters: {\n        webhookEnabled: true\n      }\n    });\n\n    const webhookFlows = allFlows.map(flow => ({\n      id: flow.id,\n      name: flow.name,\n      slug: flow.slug,\n      description: flow.description,\n      category: flow.category,\n      isActive: flow.isActive,\n      status: flow.status,\n      hasSecret: !!flow.webhookSecret,\n      webhookUrl: `/api/webhooks/flows/${flow.slug}`\n    }));\n\n    res.json({\n      count: webhookFlows.length,\n      flows: webhookFlows\n    });\n  }));\n\n  return router;\n}\n\n// ============= DEFAULT EXPORT =============\n\nexport default createWebhookRoutes;\n",
        "last_modified": "2026-01-02T17:55:06.516242"
      },
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:47.194632",
  "last_updated": "2026-01-02T15:21:47.206717"
}