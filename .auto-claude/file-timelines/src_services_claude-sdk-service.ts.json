{
  "file_path": "src/services/claude-sdk-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { query, type Query, type Options } from '@anthropic-ai/claude-agent-sdk';\nimport type {\n  ConversationConfig,\n  CUIError,\n  SystemInitMessage,\n  AssistantStreamMessage,\n  UserStreamMessage,\n  ResultStreamMessage,\n  StreamEvent,\n  PermissionRequest,\n  SDKMessage,\n  SDKAssistantMessage,\n  SDKUserMessage,\n  SDKResultMessage,\n  SDKPartialAssistantMessage,\n} from '@/types/index.js';\nimport { createLogger, type Logger } from './logger.js';\nimport { ClaudeHistoryReader } from './claude-history-reader.js';\nimport { ConversationStatusManager } from './conversation-status-manager.js';\nimport { ToolMetricsService } from './ToolMetricsService.js';\nimport { SessionInfoService } from './session-info-service.js';\nimport { FileSystemService } from './file-system-service.js';\nimport { NotificationService } from './notification-service.js';\nimport { ClaudeRouterService } from './claude-router-service.js';\nimport { SdkHistoryWriter } from './sdk-history-writer.js';\nimport type Anthropic from '@anthropic-ai/sdk';\nimport * as fs from 'fs/promises';\n\n/**\n * Manages Claude conversations using the Agent SDK\n * Replaces CLI-based approach with direct SDK integration\n */\nexport class ClaudeSdkService extends EventEmitter {\n  private queries: Map<string, Query> = new Map();\n  private conversationConfigs: Map<string, ConversationConfig> = new Map();\n  private sessionIds: Map<string, string> = new Map(); // streamingId -> sessionId\n  private logger: Logger;\n  private historyReader: ClaudeHistoryReader;\n  private historyWriter: SdkHistoryWriter;\n  private statusTracker: ConversationStatusManager;\n  private toolMetricsService?: ToolMetricsService;\n  private sessionInfoService?: SessionInfoService;\n  private fileSystemService?: FileSystemService;\n  private notificationService?: NotificationService;\n  private routerService?: ClaudeRouterService;\n  private mcpConfigPath?: string;\n  private pendingPermissions: Map<string, PermissionRequest> = new Map();\n\n  constructor(\n    historyReader: ClaudeHistoryReader,\n    statusTracker: ConversationStatusManager,\n    toolMetricsService?: ToolMetricsService,\n    sessionInfoService?: SessionInfoService,\n    fileSystemService?: FileSystemService\n  ) {\n    super();\n    this.historyReader = historyReader;\n    this.historyWriter = new SdkHistoryWriter();\n    this.statusTracker = statusTracker;\n    this.toolMetricsService = toolMetricsService;\n    this.sessionInfoService = sessionInfoService;\n    this.fileSystemService = fileSystemService;\n    this.logger = createLogger('ClaudeSdkService');\n\n    // Initialize history writer\n    this.historyWriter.initialize().catch((error) => {\n      this.logger.error('Failed to initialize history writer', error);\n    });\n  }\n\n  setRouterService(service?: ClaudeRouterService): void {\n    this.routerService = service;\n  }\n\n  setMcpConfigPath(configPath: string): void {\n    this.mcpConfigPath = configPath;\n  }\n\n  setNotificationService(service?: NotificationService): void {\n    this.notificationService = service;\n  }\n\n  /**\n   * Start a new conversation using the SDK\n   */\n  async startConversation(\n    config: ConversationConfig & { resumedSessionId?: string }\n  ): Promise<{ streamingId: string; systemInit: SystemInitMessage }> {\n    const isResume = !!config.resumedSessionId;\n    const streamingId = uuidv4();\n\n    this.logger.info('\ud83d\ude80 SDK MODE: Start conversation requested', {\n      streamingId,\n      hasInitialPrompt: !!config.initialPrompt,\n      promptLength: config.initialPrompt?.length,\n      workingDirectory: config.workingDirectory,\n      model: config.model,\n      isResume,\n      resumedSessionId: config.resumedSessionId,\n    });\n\n    // Store config\n    this.conversationConfigs.set(streamingId, config);\n\n    try {\n      // Generate a temporary session ID - will be replaced with SDK's actual session ID\n      const sessionId = config.resumedSessionId || `sdk-${uuidv4()}`;\n      this.sessionIds.set(streamingId, sessionId);\n\n      // Initialize session info in database\n      if (this.sessionInfoService) {\n        await this.sessionInfoService.getSessionInfo(sessionId);\n\n        // Update session info with permission mode if provided\n        if (config.permissionMode) {\n          await this.sessionInfoService.updateSessionInfo(sessionId, {\n            permission_mode: config.permissionMode,\n          });\n        }\n      }\n\n      // Build SDK options from config\n      const options = await this.buildSdkOptions(config);\n\n      // Create the query with error handling\n      let queryInstance: Query;\n      try {\n        queryInstance = query({\n          prompt: config.initialPrompt,\n          options,\n        });\n      } catch (error) {\n        this.logger.error('\u274c Failed to create SDK query', error, { streamingId, sessionId });\n        throw new Error(`Failed to create SDK query: ${error instanceof Error ? error.message : String(error)}`);\n      }\n\n      this.queries.set(streamingId, queryInstance);\n\n      // Start processing messages IMMEDIATELY (not in background)\n      // This prevents EPIPE errors from being unhandled\n      setImmediate(() => {\n        this.processQueryMessages(streamingId, queryInstance).catch((error) => {\n          this.logger.error('\u274c Error processing query messages', error, { streamingId });\n          this.emit('process-error', { streamingId, error: error instanceof Error ? error.message : String(error) });\n\n          // Clean up on error\n          this.queries.delete(streamingId);\n          this.conversationConfigs.delete(streamingId);\n          this.sessionIds.delete(streamingId);\n          this.statusTracker.unregisterActiveSession(streamingId);\n        });\n      });\n\n      // Register conversation with status tracker\n      this.statusTracker.registerActiveSession(streamingId, sessionId, {\n        initialPrompt: config.initialPrompt,\n        workingDirectory: config.workingDirectory || process.cwd(),\n        model: config.model,\n        inheritedMessages: config.previousMessages,\n      });\n\n      // Create system init message\n      const systemInit: SystemInitMessage = {\n        type: 'system',\n        subtype: 'init',\n        session_id: sessionId,\n        cwd: config.workingDirectory || process.cwd(),\n        tools: config.allowedTools || [],\n        mcp_servers: [], // Will be populated if MCP is configured\n        model: config.model || 'claude-sonnet-4-5',\n        permissionMode: config.permissionMode || 'default',\n        apiKeySource: process.env.ANTHROPIC_API_KEY ? 'environment' : 'unknown',\n      };\n\n      this.logger.info('\u2705 SDK MODE: Conversation started successfully', {\n        streamingId,\n        sessionId,\n      });\n\n      return { streamingId, systemInit };\n    } catch (error) {\n      this.logger.error('\u274c SDK MODE: Failed to start conversation', error, { streamingId });\n      throw error;\n    }\n  }\n\n  /**\n   * Stop a conversation\n   */\n  async stopConversation(streamingId: string): Promise<boolean> {\n    this.logger.debug('Stopping conversation', { streamingId });\n\n    const query = this.queries.get(streamingId);\n    if (!query) {\n      this.logger.warn('No query found for conversation', { streamingId });\n      return false;\n    }\n\n    try {\n      // Flush history before stopping\n      const sessionId = this.sessionIds.get(streamingId);\n      if (sessionId) {\n        await this.historyWriter.flush(sessionId);\n      }\n\n      // Unregister from status tracker\n      this.statusTracker.unregisterActiveSession(streamingId);\n\n      // SDK queries are async generators, we can't directly stop them\n      // but we can clean up our references\n      this.queries.delete(streamingId);\n      this.conversationConfigs.delete(streamingId);\n      this.sessionIds.delete(streamingId);\n\n      this.emit('process-closed', { streamingId, code: 0 });\n      this.logger.debug('Conversation stopped', { streamingId });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Error stopping conversation', error, { streamingId });\n      return false;\n    }\n  }\n\n  /**\n   * Build SDK options from conversation config\n   */\n  private async buildSdkOptions(config: ConversationConfig): Promise<Options> {\n    const options: Options = {\n      model: config.model || 'claude-sonnet-4-5',\n      permissionMode: (config.permissionMode as Options['permissionMode']) || 'default',\n      includePartialMessages: true, // Enable streaming for real-time updates\n\n      // \u2705 NEW: Skills filesystem settings (REQUIRED for skills to work)\n      settingSources: ['project'], // Loads .claude/skills/ directory\n\n      // \u2705 Working directory (required for settingSources)\n      cwd: config.workingDirectory || process.cwd(),\n\n      // \u2705 Extended thinking configuration (required for thinking strategies)\n      maxThinkingTokens: config.maxThinkingTokens || 10000,\n    };\n\n    // System prompt\n    if (config.systemPrompt) {\n      options.systemPrompt = config.systemPrompt;\n    }\n\n    // Allowed/disallowed tools - Add \"Skill\" tool for skill execution\n    if (config.allowedTools) {\n      // \u2705 NEW: Add \"Skill\" tool to allowedTools (use Set to prevent duplicates)\n      const toolsWithSkill = [...new Set([...config.allowedTools, 'Skill'])];\n      options.allowedTools = toolsWithSkill;\n    } else {\n      // If no allowedTools specified, only add Skill tool\n      options.allowedTools = ['Skill'];\n    }\n\n    if (config.disallowedTools) {\n      options.disallowedTools = config.disallowedTools;\n    }\n\n    // MCP servers - load from multiple sources (merge strategy: file < agent < skill)\n    try {\n      const mcpServers: Record<string, any> = {};\n\n      // Source 1: Load from .mcp.json if path is configured (lowest priority)\n      if (this.mcpConfigPath) {\n        const mcpConfig = await this.loadMcpConfig(this.mcpConfigPath);\n        if (mcpConfig) {\n          Object.assign(mcpServers, mcpConfig);\n          this.logger.info('Loaded MCP servers from .mcp.json', {\n            serverCount: Object.keys(mcpConfig).length\n          });\n        }\n      }\n\n      // Source 2: Load from Strapi agent-level servers (medium priority)\n      const strapiServers = await this.loadMcpServersFromStrapi(config.workingDirectory);\n      if (strapiServers) {\n        // Strapi servers take precedence over .mcp.json\n        Object.assign(mcpServers, strapiServers);\n        this.logger.info('Loaded MCP servers from Strapi', {\n          serverCount: Object.keys(strapiServers).length\n        });\n      }\n\n      // \u2705 NEW: Source 3: Load from Skill-specific MCP servers (highest priority)\n      if (config.skills && config.skills.length > 0) {\n        const skillMcpServers = await this.loadMcpServersFromSkills(config.skills);\n        if (skillMcpServers) {\n          // Skill MCP servers take highest precedence\n          Object.assign(mcpServers, skillMcpServers);\n          this.logger.info('Loaded MCP servers from Skills', {\n            serverCount: Object.keys(skillMcpServers).length\n          });\n        }\n      }\n\n      if (Object.keys(mcpServers).length > 0) {\n        options.mcpServers = mcpServers;\n        this.logger.info('\u2705 Total MCP servers loaded for SDK', {\n          serverCount: Object.keys(mcpServers).length,\n          servers: Object.keys(mcpServers)\n        });\n      }\n    } catch (error) {\n      this.logger.warn('Failed to load MCP servers', { error });\n    }\n\n    // Capture Claude CLI stderr to diagnose subprocess issues\n    options.stderr = (data: string) => {\n      this.logger.error('\ud83d\udea8 Claude CLI stderr', { stderr: data });\n    };\n\n    // Add permission hooks\n    // Note: SDK hooks API may differ - this is a placeholder implementation\n    // TODO: Implement proper permission handling once SDK hook types are confirmed\n    // options.hooks = {\n    //   PreToolUse: async (event: any) => {\n    //     this.logger.debug('PreToolUse hook', { tool: event.tool.name });\n    //   },\n    //   PostToolUse: async (event: any) => {\n    //     this.logger.debug('PostToolUse hook', { tool: event.tool.name });\n    //   },\n    // };\n\n    return options;\n  }\n\n  /**\n   * Load MCP configuration from file\n   */\n  private async loadMcpConfig(configPath: string): Promise<Options['mcpServers']> {\n    try {\n      const content = await fs.readFile(configPath, 'utf-8');\n      const config = JSON.parse(content);\n\n      // Transform MCP config to SDK format\n      // This is a simplified version - actual transformation depends on config structure\n      const mcpServers: Record<string, any> = {};\n\n      if (config.mcpServers) {\n        for (const [name, serverConfig] of Object.entries(config.mcpServers as Record<string, any>)) {\n          if (serverConfig.command) {\n            // stdio-based server\n            mcpServers[name] = {\n              type: 'stdio',\n              command: serverConfig.command,\n              args: serverConfig.args || [],\n              env: serverConfig.env || {},\n            };\n          }\n        }\n      }\n\n      return mcpServers as Options['mcpServers'];\n    } catch (error) {\n      this.logger.error('Failed to load MCP config', error, { configPath });\n      return undefined;\n    }\n  }\n\n  /**\n   * Load MCP servers from Strapi database\n   * Only returns enabled servers\n   */\n  private async loadMcpServersFromStrapi(workingDirectory?: string): Promise<Options['mcpServers']> {\n    try {\n      const { strapiClient } = await import('./strapi-client.js');\n\n      // Get all enabled MCP servers from Strapi\n      const servers = await strapiClient.getAllMCPServers({\n        filters: { disabled: false }\n      });\n\n      if (!servers || servers.length === 0) {\n        return undefined;\n      }\n\n      // Transform to SDK format\n      const mcpServers: Record<string, any> = {};\n\n      for (const server of servers) {\n        // Skip servers without command\n        if (!server.command) {\n          continue;\n        }\n\n        mcpServers[server.name] = {\n          type: server.transport || 'stdio',\n          command: server.command,\n          args: server.args || [],\n          env: server.env || {},\n        };\n      }\n\n      this.logger.info('Loaded MCP servers from Strapi', {\n        serverCount: Object.keys(mcpServers).length,\n        servers: Object.keys(mcpServers)\n      });\n\n      return mcpServers as Options['mcpServers'];\n    } catch (error) {\n      this.logger.warn('Failed to load MCP servers from Strapi', { error });\n      return undefined;\n    }\n  }\n\n  /**\n   * Load MCP servers from Skills' MCP configurations\n   * Skills can specify which MCP servers they need via mcpConfig\n   * @param skills - Array of skills with mcpConfig\n   * @returns MCP servers in SDK format\n   */\n  private async loadMcpServersFromSkills(skills: any[]): Promise<Options['mcpServers']> {\n    try {\n      const { strapiClient } = await import('./strapi-client.js');\n      const mcpServers: Record<string, any> = {};\n\n      for (const skill of skills) {\n        // Skip skills without MCP config\n        if (!skill.mcpConfig || !Array.isArray(skill.mcpConfig)) {\n          continue;\n        }\n\n        // Process each MCP server selection in the skill\n        for (const mcpSelection of skill.mcpConfig) {\n          // Extract MCP server ID (can be string or object with id)\n          const serverId = typeof mcpSelection.mcpServer === 'string'\n            ? mcpSelection.mcpServer\n            : mcpSelection.mcpServer?.id;\n\n          if (!serverId) {\n            continue;\n          }\n\n          try {\n            // Fetch MCP server details from Strapi\n            const server = await strapiClient.getMCPServer(serverId);\n\n            // Skip disabled servers or servers without command\n            if (server.disabled || !server.command) {\n              continue;\n            }\n\n            // Transform to SDK format\n            mcpServers[server.name] = {\n              type: server.transport || 'stdio',\n              command: server.command,\n              args: server.args || [],\n              env: server.env || {},\n            };\n\n            this.logger.info(`[ClaudeSDK] Loaded MCP server from skill: ${server.name}`, {\n              skillName: skill.name,\n              serverName: server.name\n            });\n          } catch (error) {\n            this.logger.error(`[ClaudeSDK] Failed to load MCP server ${serverId}:`, error);\n            // Continue with other servers even if one fails\n          }\n        }\n      }\n\n      return Object.keys(mcpServers).length > 0 ? (mcpServers as Options['mcpServers']) : undefined;\n    } catch (error) {\n      this.logger.warn('Failed to load MCP servers from skills', { error });\n      return undefined;\n    }\n  }\n\n  /**\n   * Process messages from SDK query\n   */\n  private async processQueryMessages(streamingId: string, queryInstance: Query): Promise<void> {\n    try {\n      let sessionId = this.sessionIds.get(streamingId);\n      if (!sessionId) {\n        throw new Error('Session ID not found');\n      }\n\n      this.logger.info('\ud83d\udd04 Starting to process SDK query messages', { streamingId, sessionId });\n\n      const config = this.conversationConfigs.get(streamingId);\n      const workingDirectory = config?.workingDirectory;\n      const isResume = config?.previousMessages && config.previousMessages.length > 0;\n\n      let messageCount = 0;\n      for await (const message of queryInstance) {\n        messageCount++;\n\n        // Extract the SDK's actual session ID from the first message (only for new conversations)\n        if (messageCount === 1 && message.session_id && !isResume) {\n          const sdkSessionId = message.session_id;\n          const oldSessionId = sessionId;\n          this.logger.info('\ud83d\udd11 Extracted SDK session ID', { streamingId, sdkSessionId, oldSessionId });\n          this.sessionIds.set(streamingId, sdkSessionId);\n          sessionId = sdkSessionId; // Update local variable\n\n          // Emit session ID update event to notify frontend\n          this.emit('claude-message', {\n            streamingId,\n            message: {\n              type: 'session_id_update',\n              oldSessionId,\n              newSessionId: sdkSessionId,\n              streamingId,\n              timestamp: new Date().toISOString()\n            }\n          });\n          this.logger.info('\ud83d\udce4 Emitted session ID update event', { streamingId, oldSessionId, newSessionId: sdkSessionId });\n        }\n\n        this.logger.info('\ud83d\udce8 Received SDK message', {\n          streamingId,\n          sessionId,\n          messageNumber: messageCount,\n          type: message.type\n        });\n\n        // Write message to history\n        try {\n          if (message.type === 'assistant') {\n            this.logger.info('\ud83d\udcdd Writing assistant message to history', { streamingId, sessionId });\n            await this.historyWriter.writeAssistantMessage(\n              message as unknown as SDKAssistantMessage,\n              workingDirectory\n            );\n            this.logger.info('\u2705 Assistant message written to history', { streamingId, sessionId });\n          } else if (message.type === 'user' && !(message as any).isReplay) {\n            this.logger.info('\ud83d\udcdd Writing user message to history', { streamingId, sessionId });\n            await this.historyWriter.writeUserMessage(\n              message as unknown as SDKUserMessage,\n              workingDirectory\n            );\n            this.logger.info('\u2705 User message written to history', { streamingId, sessionId });\n          } else if (message.type === 'result') {\n            this.logger.info('\ud83d\udcdd Writing result message to history', { streamingId, sessionId });\n            await this.historyWriter.writeResultMessage(\n              message as unknown as SDKResultMessage,\n              workingDirectory\n            );\n            this.logger.info('\u2705 Result message written to history', { streamingId, sessionId });\n          }\n        } catch (historyError) {\n          this.logger.error('\u274c Failed to write message to history', historyError, {\n            streamingId,\n            sessionId,\n            messageType: message.type\n          });\n        }\n\n        // Transform SDK message to StreamEvent\n        // Type assertion needed due to slight differences between SDK types and our types\n        const streamEvent = this.transformSdkMessage(message as unknown as SDKMessage, sessionId);\n\n        if (streamEvent) {\n          this.logger.info('\u2705 Transformed and emitting claude-message event', {\n            streamingId,\n            eventType: streamEvent.type\n          });\n          // Emit as claude-message event\n          this.emit('claude-message', { streamingId, message: streamEvent });\n          this.logger.info('\ud83d\udce1 claude-message event emitted', { streamingId, eventType: streamEvent.type });\n        } else {\n          this.logger.warn('\u23ed\ufe0f  Skipped message (no transform)', {\n            streamingId,\n            messageType: message.type\n          });\n        }\n      }\n\n      this.logger.info('\u2705 Query iteration complete', { streamingId, totalMessages: messageCount });\n\n      // Query completed - flush history before closing\n      await this.historyWriter.flush(sessionId);\n\n      // Unregister from status tracker\n      this.statusTracker.unregisterActiveSession(streamingId);\n\n      this.logger.info('\ud83c\udfc1 Query completed', { streamingId, sessionId });\n      this.emit('process-closed', { streamingId, code: 0 });\n    } catch (error) {\n      this.logger.error('\u274c Error in processQueryMessages', error, { streamingId });\n      this.emit('process-error', { streamingId, error: error instanceof Error ? error.message : String(error) });\n    }\n  }\n\n  /**\n   * Get conversation config by session ID\n   */\n  private getConfigBySessionId(sessionId: string): ConversationConfig | undefined {\n    const streamingId = Array.from(this.sessionIds.entries()).find(\n      ([_, sid]) => sid === sessionId\n    )?.[0];\n    return streamingId ? this.conversationConfigs.get(streamingId) : undefined;\n  }\n\n  /**\n   * Transform SDK message to StreamEvent format\n   * Maps SDK message structure to CUI's StreamEvent format\n   */\n  private transformSdkMessage(sdkMessage: SDKMessage, sessionId: string): StreamEvent | null {\n    try {\n      switch (sdkMessage.type) {\n        case 'assistant':\n          return this.transformAssistantMessage(sdkMessage as SDKAssistantMessage, sessionId);\n\n        case 'user':\n          return this.transformUserMessage(sdkMessage as SDKUserMessage, sessionId);\n\n        case 'result':\n          return this.transformResultMessage(sdkMessage as SDKResultMessage, sessionId);\n\n        case 'stream_event':\n          return this.transformStreamEvent(sdkMessage as SDKPartialAssistantMessage, sessionId);\n\n        default:\n          this.logger.debug('Unhandled SDK message type', { type: (sdkMessage as any).type });\n          return null;\n      }\n    } catch (error) {\n      this.logger.error('Error transforming SDK message', error, {\n        messageType: sdkMessage.type,\n        sessionId,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Transform SDK assistant message\n   */\n  private transformAssistantMessage(\n    sdkMessage: SDKAssistantMessage,\n    sessionId: string\n  ): AssistantStreamMessage {\n    // Write to history asynchronously (don't block message processing)\n    const config = this.getConfigBySessionId(sessionId);\n    this.historyWriter.writeAssistantMessage(\n      sdkMessage,\n      config?.workingDirectory,\n      'sdk-0.1.0'\n    ).catch((error) => {\n      this.logger.error('Failed to write assistant message to history', error, { sessionId });\n    });\n\n    return {\n      type: 'assistant',\n      session_id: sessionId,\n      message: sdkMessage.message,\n      parent_tool_use_id: sdkMessage.parent_tool_use_id || undefined,\n    };\n  }\n\n  /**\n   * Transform SDK user message\n   */\n  private transformUserMessage(\n    sdkMessage: SDKUserMessage,\n    sessionId: string\n  ): UserStreamMessage {\n    // Write to history asynchronously\n    const config = this.getConfigBySessionId(sessionId);\n    this.historyWriter.writeUserMessage(\n      sdkMessage,\n      config?.workingDirectory,\n      'sdk-0.1.0'\n    ).catch((error) => {\n      this.logger.error('Failed to write user message to history', error, { sessionId });\n    });\n\n    return {\n      type: 'user',\n      session_id: sessionId,\n      message: sdkMessage.message,\n      parent_tool_use_id: sdkMessage.parent_tool_use_id || undefined,\n    };\n  }\n\n  /**\n   * Transform SDK result message with proper metrics\n   */\n  private transformResultMessage(\n    sdkMessage: SDKResultMessage,\n    sessionId: string\n  ): ResultStreamMessage {\n    // Write to history asynchronously\n    const config = this.getConfigBySessionId(sessionId);\n    this.historyWriter.writeResultMessage(\n      sdkMessage,\n      config?.workingDirectory,\n      'sdk-0.1.0'\n    ).catch((error) => {\n      this.logger.error('Failed to write result message to history', error, { sessionId });\n    });\n\n    return {\n      type: 'result',\n      session_id: sessionId,\n      subtype: sdkMessage.subtype,\n      is_error: sdkMessage.is_error,\n      duration_ms: sdkMessage.duration_ms || 0,\n      duration_api_ms: sdkMessage.duration_api_ms || 0,\n      num_turns: sdkMessage.num_turns || 0,\n      result: sdkMessage.result,\n      usage: {\n        input_tokens: sdkMessage.usage?.input_tokens || 0,\n        cache_creation_input_tokens: sdkMessage.usage?.cache_creation_input_tokens || 0,\n        cache_read_input_tokens: sdkMessage.usage?.cache_read_input_tokens || 0,\n        output_tokens: sdkMessage.usage?.output_tokens || 0,\n        server_tool_use: {\n          web_search_requests: 0, // SDK doesn't provide this granularity\n        },\n      },\n    };\n  }\n\n  /**\n   * Transform SDK stream event for real-time updates\n   * Handles partial assistant messages during streaming\n   */\n  private transformStreamEvent(\n    sdkMessage: SDKPartialAssistantMessage,\n    sessionId: string\n  ): StreamEvent | null {\n    // Log streaming events for debugging\n    this.logger.debug('SDK streaming event', {\n      sessionId,\n      eventType: sdkMessage.event.type,\n      parentToolUseId: sdkMessage.parent_tool_use_id,\n    });\n\n    // Extract useful information from stream events for progress updates\n    const event = sdkMessage.event;\n    let statusMessage = '';\n\n    // Handle different stream event types\n    switch (event.type) {\n      case 'message_start':\n        statusMessage = '\ud83e\udd16 Assistant is thinking...';\n        break;\n\n      case 'content_block_start':\n        if (event.content_block?.type === 'tool_use') {\n          const toolName = (event.content_block as any).name || 'tool';\n          statusMessage = `\ud83d\udd27 Using tool: ${toolName}`;\n        } else if (event.content_block?.type === 'text') {\n          statusMessage = '\ud83d\udcac Generating response...';\n        }\n        break;\n\n      case 'content_block_delta':\n        // For text deltas, we could accumulate text, but for now just show activity\n        if (event.delta?.type === 'text_delta') {\n          // Skip individual text deltas to avoid too many messages\n          return null;\n        } else if (event.delta?.type === 'input_json_delta') {\n          // Tool input is being streamed\n          return null;\n        }\n        break;\n\n      case 'content_block_stop':\n        // Content block finished\n        return null;\n\n      case 'message_delta':\n        if (event.delta?.stop_reason) {\n          statusMessage = `\u2705 Message complete (${event.delta.stop_reason})`;\n        }\n        break;\n\n      case 'message_stop':\n        statusMessage = '\u2705 Response complete';\n        break;\n\n      default:\n        // Unknown event type, skip it\n        return null;\n    }\n\n    // If we have a status message, create a synthetic assistant message\n    if (statusMessage) {\n      // Create a minimal Anthropic.Message structure for status updates\n      const syntheticMessage: any = {\n        id: `stream_${Date.now()}_${Math.random()}`,\n        type: 'message',\n        role: 'assistant',\n        content: [{\n          type: 'text',\n          text: statusMessage\n        }],\n        model: 'claude-3-5-sonnet-20241022', // Default model\n        stop_reason: null,\n        stop_sequence: null,\n        usage: {\n          input_tokens: 0,\n          output_tokens: 0\n        }\n      };\n\n      return {\n        type: 'assistant',\n        session_id: sessionId,\n        message: syntheticMessage,\n        parent_tool_use_id: sdkMessage.parent_tool_use_id || undefined,\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Get active conversations count\n   */\n  getActiveConversationsCount(): number {\n    return this.queries.size;\n  }\n\n  /**\n   * Check if a conversation is active\n   */\n  isConversationActive(streamingId: string): boolean {\n    return this.queries.has(streamingId);\n  }\n}\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { query, type Query, type Options } from '@anthropic-ai/claude-agent-sdk';\nimport type {\n  ConversationConfig,\n  CUIError,\n  SystemInitMessage,\n  AssistantStreamMessage,\n  UserStreamMessage,\n  ResultStreamMessage,\n  StreamEvent,\n  PermissionRequest,\n  SDKMessage,\n  SDKAssistantMessage,\n  SDKUserMessage,\n  SDKResultMessage,\n  SDKPartialAssistantMessage,\n} from '@/types/index.js';\nimport { createLogger, type Logger } from './logger.js';\nimport { ClaudeHistoryReader } from './claude-history-reader.js';\nimport { ConversationStatusManager } from './conversation-status-manager.js';\nimport { ToolMetricsService } from './ToolMetricsService.js';\nimport { SessionInfoService } from './session-info-service.js';\nimport { FileSystemService } from './file-system-service.js';\nimport { NotificationService } from './notification-service.js';\nimport { ClaudeRouterService } from './claude-router-service.js';\nimport { SdkHistoryWriter } from './sdk-history-writer.js';\nimport type Anthropic from '@anthropic-ai/sdk';\nimport * as fs from 'fs/promises';\n\n/**\n * ClaudeSdkService - Core service for managing Claude conversations using the Agent SDK\n *\n * @description\n * Manages the lifecycle of Claude Agent SDK conversations, providing a high-level interface\n * for starting/stopping conversations, handling message streaming, and integrating with\n * MCP servers. This service replaces the legacy CLI-based approach with direct SDK integration,\n * enabling better control over conversation state, real-time event streaming, and seamless\n * integration with the application's architecture.\n *\n * Key responsibilities:\n * - Initialize and manage SDK query instances for active conversations\n * - Stream SDK messages and transform them to application's StreamEvent format\n * - Integrate with MCP servers from multiple sources (config files, Strapi, skills)\n * - Write conversation history to JSONL files via SdkHistoryWriter\n * - Track conversation status and emit real-time events to the frontend\n * - Handle session lifecycle, including resume functionality\n * - Manage permissions and tool access control\n *\n * Architecture:\n * - Uses EventEmitter to broadcast conversation events ('claude-message', 'process-closed', 'process-error')\n * - Maintains internal maps for queries, configs, and session IDs\n * - Integrates with ClaudeHistoryReader, ConversationStatusManager, and other services\n * - Supports multiple concurrent conversations with unique streamingId tracking\n *\n * @example\n * ```typescript\n * // Initialize the service with required dependencies\n * const historyReader = new ClaudeHistoryReader();\n * const statusTracker = new ConversationStatusManager();\n * const toolMetrics = new ToolMetricsService();\n * const sessionInfo = new SessionInfoService();\n * const fileSystem = new FileSystemService();\n *\n * const claudeSdk = new ClaudeSdkService(\n *   historyReader,\n *   statusTracker,\n *   toolMetrics,\n *   sessionInfo,\n *   fileSystem\n * );\n *\n * // Configure optional services\n * claudeSdk.setMcpConfigPath('/path/to/.mcp.json');\n * claudeSdk.setNotificationService(notificationService);\n *\n * // Start a new conversation\n * const config = {\n *   initialPrompt: 'Hello, Claude!',\n *   workingDirectory: '/path/to/project',\n *   model: 'claude-sonnet-4-5',\n *   permissionMode: 'default',\n *   allowedTools: ['Read', 'Write', 'Bash']\n * };\n *\n * const { streamingId, systemInit } = await claudeSdk.startConversation(config);\n *\n * // Listen for conversation events\n * claudeSdk.on('claude-message', ({ streamingId, message }) => {\n *   console.log('Received message:', message);\n * });\n *\n * claudeSdk.on('process-closed', ({ streamingId, code }) => {\n *   console.log('Conversation ended:', streamingId);\n * });\n *\n * // Stop conversation when done\n * await claudeSdk.stopConversation(streamingId);\n * ```\n *\n * @see {@link https://github.com/anthropics/anthropic-sdk-typescript|Anthropic SDK Documentation}\n */\nexport class ClaudeSdkService extends EventEmitter {\n  /**\n   * Active SDK query instances indexed by streaming ID\n   * Each query represents an active conversation with the Claude Agent SDK\n   */\n  private queries: Map<string, Query> = new Map();\n\n  /**\n   * Conversation configurations indexed by streaming ID\n   * Stores the initial config for each conversation (prompt, model, tools, etc.)\n   */\n  private conversationConfigs: Map<string, ConversationConfig> = new Map();\n\n  /**\n   * Maps streaming IDs to SDK session IDs\n   * The streaming ID is generated internally, while session ID comes from the SDK\n   */\n  private sessionIds: Map<string, string> = new Map();\n\n  /**\n   * Logger instance for structured logging\n   */\n  private logger: Logger;\n\n  /**\n   * Service for reading Claude's conversation history from JSONL files\n   */\n  private historyReader: ClaudeHistoryReader;\n\n  /**\n   * Service for writing SDK messages to conversation history files\n   */\n  private historyWriter: SdkHistoryWriter;\n\n  /**\n   * Tracks active conversation sessions and manages optimistic UI state\n   */\n  private statusTracker: ConversationStatusManager;\n\n  /**\n   * Optional service for tracking tool usage metrics and analytics\n   */\n  private toolMetricsService?: ToolMetricsService;\n\n  /**\n   * Optional service for persisting session metadata to database\n   */\n  private sessionInfoService?: SessionInfoService;\n\n  /**\n   * Optional service providing abstraction over Node.js filesystem operations\n   */\n  private fileSystemService?: FileSystemService;\n\n  /**\n   * Optional service for sending in-app and push notifications\n   */\n  private notificationService?: NotificationService;\n\n  /**\n   * Optional service for routing Claude API requests (load balancing, failover)\n   */\n  private routerService?: ClaudeRouterService;\n\n  /**\n   * Path to MCP configuration file (.mcp.json)\n   * When set, MCP servers are loaded from this file for SDK conversations\n   */\n  private mcpConfigPath?: string;\n\n  /**\n   * Pending permission requests awaiting user approval\n   * Maps permission request ID to PermissionRequest object\n   */\n  private pendingPermissions: Map<string, PermissionRequest> = new Map();\n\n  /**\n   * Creates a new ClaudeSdkService instance\n   *\n   * @param historyReader - Service for reading Claude's JSONL conversation history\n   * @param statusTracker - Service for tracking active conversation sessions\n   * @param toolMetricsService - Optional service for tracking tool usage analytics\n   * @param sessionInfoService - Optional service for persisting session metadata\n   * @param fileSystemService - Optional service for filesystem operations\n   *\n   * @example\n   * ```typescript\n   * const service = new ClaudeSdkService(\n   *   new ClaudeHistoryReader(),\n   *   new ConversationStatusManager(),\n   *   new ToolMetricsService(),\n   *   new SessionInfoService(),\n   *   new FileSystemService()\n   * );\n   * ```\n   */\n  constructor(\n    historyReader: ClaudeHistoryReader,\n    statusTracker: ConversationStatusManager,\n    toolMetricsService?: ToolMetricsService,\n    sessionInfoService?: SessionInfoService,\n    fileSystemService?: FileSystemService\n  ) {\n    super();\n    this.historyReader = historyReader;\n    this.historyWriter = new SdkHistoryWriter();\n    this.statusTracker = statusTracker;\n    this.toolMetricsService = toolMetricsService;\n    this.sessionInfoService = sessionInfoService;\n    this.fileSystemService = fileSystemService;\n    this.logger = createLogger('ClaudeSdkService');\n\n    // Initialize history writer\n    this.historyWriter.initialize().catch((error) => {\n      this.logger.error('Failed to initialize history writer', error);\n    });\n  }\n\n  /**\n   * Set the Claude Router Service for load balancing and failover\n   *\n   * @description\n   * Optionally configure a router service to handle request routing across multiple\n   * Claude API endpoints. The router can implement load balancing, failover, and\n   * rate limiting strategies.\n   *\n   * @param service - Optional ClaudeRouterService instance for API request routing\n   *\n   * @example\n   * ```typescript\n   * const router = new ClaudeRouterService();\n   * router.registerRoute('primary', 'https://api.anthropic.com');\n   * router.registerRoute('fallback', 'https://backup.anthropic.com');\n   *\n   * claudeSdk.setRouterService(router);\n   * ```\n   */\n  setRouterService(service?: ClaudeRouterService): void {\n    this.routerService = service;\n  }\n\n  /**\n   * Set the path to MCP configuration file\n   *\n   * @description\n   * Configure the path to a .mcp.json file containing MCP server configurations.\n   * When set, MCP servers defined in this file will be loaded and made available\n   * to SDK conversations. These servers have the lowest priority in the merge\n   * strategy (file < Strapi agent < skill-specific MCP).\n   *\n   * @param configPath - Absolute path to .mcp.json configuration file\n   *\n   * @example\n   * ```typescript\n   * import path from 'path';\n   * import os from 'os';\n   *\n   * const mcpPath = path.join(os.homedir(), '.config', 'claude', '.mcp.json');\n   * claudeSdk.setMcpConfigPath(mcpPath);\n   * ```\n   */\n  setMcpConfigPath(configPath: string): void {\n    this.mcpConfigPath = configPath;\n  }\n\n  /**\n   * Set the notification service for conversation events\n   *\n   * @description\n   * Optionally configure a notification service to send in-app and push notifications\n   * for conversation events such as new messages, errors, or conversation completion.\n   * The service will be used to notify users when conversations require attention.\n   *\n   * @param service - Optional NotificationService instance for sending notifications\n   *\n   * @example\n   * ```typescript\n   * const notifications = new NotificationService();\n   * claudeSdk.setNotificationService(notifications);\n   *\n   * // Notifications will be sent automatically for conversation events\n   * claudeSdk.on('process-error', ({ streamingId, error }) => {\n   *   // Notification service can handle this event\n   * });\n   * ```\n   */\n  setNotificationService(service?: NotificationService): void {\n    this.notificationService = service;\n  }\n\n  /**\n   * Start a new conversation using the Claude Agent SDK\n   *\n   * @description\n   * Initializes a new SDK conversation with the provided configuration. This method:\n   * - Creates a unique streaming ID for tracking the conversation\n   * - Builds SDK options including MCP servers from multiple sources\n   * - Initializes session info in the database\n   * - Registers the conversation with the status tracker\n   * - Starts processing SDK messages asynchronously\n   * - Emits 'claude-message' events for real-time updates\n   *\n   * The conversation will continue until stopped via stopConversation() or until\n   * the SDK query completes naturally.\n   *\n   * MCP Server Merge Priority (highest to lowest):\n   * 1. Skill-specific MCP servers (from config.skills[].mcpConfig)\n   * 2. Strapi agent-level MCP servers (from database)\n   * 3. File-based MCP servers (from .mcp.json config file)\n   *\n   * @param config - Conversation configuration including prompt, model, tools, and optional resume session\n   * @param config.initialPrompt - The user's initial message to start the conversation\n   * @param config.workingDirectory - Working directory for the conversation (defaults to process.cwd())\n   * @param config.model - Claude model to use (defaults to 'claude-sonnet-4-5')\n   * @param config.permissionMode - Permission mode for tool execution ('default', 'auto', 'manual')\n   * @param config.allowedTools - Array of allowed tool names (e.g., ['Read', 'Write', 'Bash'])\n   * @param config.disallowedTools - Array of disallowed tool names\n   * @param config.systemPrompt - Optional system prompt for the conversation\n   * @param config.skills - Optional array of skills to enable for the conversation\n   * @param config.previousMessages - Optional array of previous messages to resume from\n   * @param config.resumedSessionId - Optional session ID to resume an existing conversation\n   * @param config.maxThinkingTokens - Maximum tokens for extended thinking (defaults to 10000)\n   *\n   * @returns Promise resolving to an object containing:\n   *   - streamingId: Unique identifier for this conversation instance\n   *   - systemInit: System initialization message with session details\n   *\n   * @throws Error if SDK query creation fails or session initialization fails\n   *\n   * @example\n   * ```typescript\n   * // Start a basic conversation\n   * const { streamingId, systemInit } = await claudeSdk.startConversation({\n   *   initialPrompt: 'Hello, Claude! Can you help me write a function?',\n   *   workingDirectory: '/path/to/project',\n   *   model: 'claude-sonnet-4-5',\n   *   permissionMode: 'default',\n   *   allowedTools: ['Read', 'Write', 'Edit']\n   * });\n   *\n   * console.log('Conversation started:', streamingId);\n   * console.log('Session ID:', systemInit.session_id);\n   *\n   * // Listen for conversation events\n   * claudeSdk.on('claude-message', ({ streamingId, message }) => {\n   *   if (message.type === 'assistant') {\n   *     console.log('Assistant:', message.message.content);\n   *   }\n   * });\n   *\n   * // Resume an existing conversation\n   * const { streamingId: resumedId } = await claudeSdk.startConversation({\n   *   initialPrompt: 'Continue from where we left off',\n   *   resumedSessionId: previousSessionId,\n   *   previousMessages: historyMessages,\n   *   workingDirectory: '/path/to/project'\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Start conversation with skills and MCP servers\n   * const { streamingId } = await claudeSdk.startConversation({\n   *   initialPrompt: 'Help me analyze this codebase',\n   *   workingDirectory: '/path/to/project',\n   *   skills: [\n   *     {\n   *       name: 'code-analysis',\n   *       mcpConfig: [\n   *         { mcpServer: 'mcp-server-id-1' }\n   *       ]\n   *     }\n   *   ],\n   *   allowedTools: ['Read', 'Grep', 'Bash', 'Skill'],\n   *   permissionMode: 'auto'\n   * });\n   * ```\n   */\n  async startConversation(\n    config: ConversationConfig & { resumedSessionId?: string }\n  ): Promise<{ streamingId: string; systemInit: SystemInitMessage }> {\n    const isResume = !!config.resumedSessionId;\n    const streamingId = uuidv4();\n\n    this.logger.info('\ud83d\ude80 SDK MODE: Start conversation requested', {\n      streamingId,\n      hasInitialPrompt: !!config.initialPrompt,\n      promptLength: config.initialPrompt?.length,\n      workingDirectory: config.workingDirectory,\n      model: config.model,\n      isResume,\n      resumedSessionId: config.resumedSessionId,\n    });\n\n    // Store config\n    this.conversationConfigs.set(streamingId, config);\n\n    try {\n      // Generate a temporary session ID - will be replaced with SDK's actual session ID\n      const sessionId = config.resumedSessionId || `sdk-${uuidv4()}`;\n      this.sessionIds.set(streamingId, sessionId);\n\n      // Initialize session info in database\n      if (this.sessionInfoService) {\n        await this.sessionInfoService.getSessionInfo(sessionId);\n\n        // Update session info with permission mode if provided\n        if (config.permissionMode) {\n          await this.sessionInfoService.updateSessionInfo(sessionId, {\n            permission_mode: config.permissionMode,\n          });\n        }\n      }\n\n      // Build SDK options from config\n      const options = await this.buildSdkOptions(config);\n\n      // Create the query with error handling\n      let queryInstance: Query;\n      try {\n        queryInstance = query({\n          prompt: config.initialPrompt,\n          options,\n        });\n      } catch (error) {\n        this.logger.error('\u274c Failed to create SDK query', error, { streamingId, sessionId });\n        throw new Error(`Failed to create SDK query: ${error instanceof Error ? error.message : String(error)}`);\n      }\n\n      this.queries.set(streamingId, queryInstance);\n\n      // Start processing messages IMMEDIATELY (not in background)\n      // This prevents EPIPE errors from being unhandled\n      setImmediate(() => {\n        this.processQueryMessages(streamingId, queryInstance).catch((error) => {\n          this.logger.error('\u274c Error processing query messages', error, { streamingId });\n          this.emit('process-error', { streamingId, error: error instanceof Error ? error.message : String(error) });\n\n          // Clean up on error\n          this.queries.delete(streamingId);\n          this.conversationConfigs.delete(streamingId);\n          this.sessionIds.delete(streamingId);\n          this.statusTracker.unregisterActiveSession(streamingId);\n        });\n      });\n\n      // Register conversation with status tracker\n      this.statusTracker.registerActiveSession(streamingId, sessionId, {\n        initialPrompt: config.initialPrompt,\n        workingDirectory: config.workingDirectory || process.cwd(),\n        model: config.model,\n        inheritedMessages: config.previousMessages,\n      });\n\n      // Create system init message\n      const systemInit: SystemInitMessage = {\n        type: 'system',\n        subtype: 'init',\n        session_id: sessionId,\n        cwd: config.workingDirectory || process.cwd(),\n        tools: config.allowedTools || [],\n        mcp_servers: [], // Will be populated if MCP is configured\n        model: config.model || 'claude-sonnet-4-5',\n        permissionMode: config.permissionMode || 'default',\n        apiKeySource: process.env.ANTHROPIC_API_KEY ? 'environment' : 'unknown',\n      };\n\n      this.logger.info('\u2705 SDK MODE: Conversation started successfully', {\n        streamingId,\n        sessionId,\n      });\n\n      return { streamingId, systemInit };\n    } catch (error) {\n      this.logger.error('\u274c SDK MODE: Failed to start conversation', error, { streamingId });\n      throw error;\n    }\n  }\n\n  /**\n   * Stop an active conversation and clean up resources\n   *\n   * @description\n   * Gracefully stops a running SDK conversation by:\n   * - Flushing any pending history writes to disk\n   * - Unregistering the conversation from the status tracker\n   * - Cleaning up internal query and config references\n   * - Emitting a 'process-closed' event with exit code 0\n   *\n   * Note: SDK queries are async generators and cannot be forcefully terminated.\n   * This method cleans up our internal tracking and ensures history is persisted,\n   * but the SDK query may continue briefly before completing.\n   *\n   * @param streamingId - Unique identifier of the conversation to stop\n   *\n   * @returns Promise<boolean> - true if conversation was found and stopped, false if not found\n   *\n   * @example\n   * ```typescript\n   * // Start a conversation\n   * const { streamingId } = await claudeSdk.startConversation({\n   *   initialPrompt: 'Hello!',\n   *   workingDirectory: '/path/to/project'\n   * });\n   *\n   * // ... conversation runs ...\n   *\n   * // Stop the conversation when done\n   * const stopped = await claudeSdk.stopConversation(streamingId);\n   * if (stopped) {\n   *   console.log('Conversation stopped successfully');\n   * } else {\n   *   console.log('Conversation not found');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Stop conversation on user cancellation\n   * claudeSdk.on('claude-message', async ({ streamingId, message }) => {\n   *   if (message.type === 'assistant') {\n   *     // Process message...\n   *   }\n   * });\n   *\n   * // User clicks cancel button\n   * cancelButton.addEventListener('click', async () => {\n   *   await claudeSdk.stopConversation(currentStreamingId);\n   * });\n   * ```\n   */\n  async stopConversation(streamingId: string): Promise<boolean> {\n    this.logger.debug('Stopping conversation', { streamingId });\n\n    const query = this.queries.get(streamingId);\n    if (!query) {\n      this.logger.warn('No query found for conversation', { streamingId });\n      return false;\n    }\n\n    try {\n      // Flush history before stopping\n      const sessionId = this.sessionIds.get(streamingId);\n      if (sessionId) {\n        await this.historyWriter.flush(sessionId);\n      }\n\n      // Unregister from status tracker\n      this.statusTracker.unregisterActiveSession(streamingId);\n\n      // SDK queries are async generators, we can't directly stop them\n      // but we can clean up our references\n      this.queries.delete(streamingId);\n      this.conversationConfigs.delete(streamingId);\n      this.sessionIds.delete(streamingId);\n\n      this.emit('process-closed', { streamingId, code: 0 });\n      this.logger.debug('Conversation stopped', { streamingId });\n\n      return true;\n    } catch (error) {\n      this.logger.error('Error stopping conversation', error, { streamingId });\n      return false;\n    }\n  }\n\n  /**\n   * Build SDK options from conversation config\n   *\n   * @description\n   * Transforms a ConversationConfig into SDK-compatible Options object. This method:\n   * - Sets model, permission mode, and working directory\n   * - Enables partial message streaming for real-time updates\n   * - Configures skills filesystem settings by loading .claude/skills/ directory\n   * - Adds \"Skill\" tool to allowed tools for skill execution\n   * - Loads MCP servers from multiple sources with priority merge strategy:\n   *   1. File-based (.mcp.json) - lowest priority\n   *   2. Strapi agent-level servers - medium priority\n   *   3. Skill-specific servers - highest priority\n   * - Configures extended thinking tokens for reasoning\n   * - Sets up stderr capture for debugging subprocess issues\n   *\n   * The merge strategy ensures skill-specific MCP servers override agent-level\n   * servers, which override file-based servers. This allows fine-grained control\n   * over which tools are available for different conversation contexts.\n   *\n   * @param config - Conversation configuration with prompt, model, tools, and optional skills\n   * @param config.model - Claude model name (defaults to 'claude-sonnet-4-5')\n   * @param config.permissionMode - Tool execution permission mode ('default', 'auto', 'manual')\n   * @param config.workingDirectory - Working directory for the conversation\n   * @param config.systemPrompt - Optional system prompt to guide Claude's behavior\n   * @param config.allowedTools - Array of allowed tool names (e.g., ['Read', 'Write'])\n   * @param config.disallowedTools - Array of disallowed tool names\n   * @param config.skills - Array of skills to enable with optional MCP configurations\n   * @param config.maxThinkingTokens - Maximum tokens for extended thinking (defaults to 10000)\n   *\n   * @returns Promise resolving to SDK Options object with merged configuration\n   *\n   * @example\n   * ```typescript\n   * // Basic configuration\n   * const options = await this.buildSdkOptions({\n   *   initialPrompt: 'Hello',\n   *   workingDirectory: '/path/to/project',\n   *   model: 'claude-sonnet-4-5',\n   *   permissionMode: 'default',\n   *   allowedTools: ['Read', 'Write', 'Bash']\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Configuration with skills and MCP servers\n   * const options = await this.buildSdkOptions({\n   *   initialPrompt: 'Analyze codebase',\n   *   workingDirectory: '/path/to/project',\n   *   skills: [\n   *     {\n   *       name: 'code-analysis',\n   *       mcpConfig: [{ mcpServer: 'mcp-server-id-1' }]\n   *     }\n   *   ],\n   *   allowedTools: ['Read', 'Grep', 'Skill'],\n   *   maxThinkingTokens: 15000\n   * });\n   * // Result includes MCP servers from skill-specific config\n   * ```\n   *\n   * @private\n   */\n  private async buildSdkOptions(config: ConversationConfig): Promise<Options> {\n    const options: Options = {\n      model: config.model || 'claude-sonnet-4-5',\n      permissionMode: (config.permissionMode as Options['permissionMode']) || 'default',\n      includePartialMessages: true, // Enable streaming for real-time updates\n\n      // \u2705 NEW: Skills filesystem settings (REQUIRED for skills to work)\n      settingSources: ['project'], // Loads .claude/skills/ directory\n\n      // \u2705 Working directory (required for settingSources)\n      cwd: config.workingDirectory || process.cwd(),\n\n      // \u2705 Extended thinking configuration (required for thinking strategies)\n      maxThinkingTokens: config.maxThinkingTokens || 10000,\n    };\n\n    // System prompt\n    if (config.systemPrompt) {\n      options.systemPrompt = config.systemPrompt;\n    }\n\n    // Allowed/disallowed tools - Add \"Skill\" tool for skill execution\n    if (config.allowedTools) {\n      // \u2705 NEW: Add \"Skill\" tool to allowedTools (use Set to prevent duplicates)\n      const toolsWithSkill = [...new Set([...config.allowedTools, 'Skill'])];\n      options.allowedTools = toolsWithSkill;\n    } else {\n      // If no allowedTools specified, only add Skill tool\n      options.allowedTools = ['Skill'];\n    }\n\n    if (config.disallowedTools) {\n      options.disallowedTools = config.disallowedTools;\n    }\n\n    // MCP servers - load from multiple sources (merge strategy: file < agent < skill)\n    try {\n      const mcpServers: Record<string, any> = {};\n\n      // Source 1: Load from .mcp.json if path is configured (lowest priority)\n      if (this.mcpConfigPath) {\n        const mcpConfig = await this.loadMcpConfig(this.mcpConfigPath);\n        if (mcpConfig) {\n          Object.assign(mcpServers, mcpConfig);\n          this.logger.info('Loaded MCP servers from .mcp.json', {\n            serverCount: Object.keys(mcpConfig).length\n          });\n        }\n      }\n\n      // Source 2: Load from Strapi agent-level servers (medium priority)\n      const strapiServers = await this.loadMcpServersFromStrapi(config.workingDirectory);\n      if (strapiServers) {\n        // Strapi servers take precedence over .mcp.json\n        Object.assign(mcpServers, strapiServers);\n        this.logger.info('Loaded MCP servers from Strapi', {\n          serverCount: Object.keys(strapiServers).length\n        });\n      }\n\n      // \u2705 NEW: Source 3: Load from Skill-specific MCP servers (highest priority)\n      if (config.skills && config.skills.length > 0) {\n        const skillMcpServers = await this.loadMcpServersFromSkills(config.skills);\n        if (skillMcpServers) {\n          // Skill MCP servers take highest precedence\n          Object.assign(mcpServers, skillMcpServers);\n          this.logger.info('Loaded MCP servers from Skills', {\n            serverCount: Object.keys(skillMcpServers).length\n          });\n        }\n      }\n\n      if (Object.keys(mcpServers).length > 0) {\n        options.mcpServers = mcpServers;\n        this.logger.info('\u2705 Total MCP servers loaded for SDK', {\n          serverCount: Object.keys(mcpServers).length,\n          servers: Object.keys(mcpServers)\n        });\n      }\n    } catch (error) {\n      this.logger.warn('Failed to load MCP servers', { error });\n    }\n\n    // Capture Claude CLI stderr to diagnose subprocess issues\n    options.stderr = (data: string) => {\n      this.logger.error('\ud83d\udea8 Claude CLI stderr', { stderr: data });\n    };\n\n    // Add permission hooks\n    // Note: SDK hooks API may differ - this is a placeholder implementation\n    // TODO: Implement proper permission handling once SDK hook types are confirmed\n    // options.hooks = {\n    //   PreToolUse: async (event: any) => {\n    //     this.logger.debug('PreToolUse hook', { tool: event.tool.name });\n    //   },\n    //   PostToolUse: async (event: any) => {\n    //     this.logger.debug('PostToolUse hook', { tool: event.tool.name });\n    //   },\n    // };\n\n    return options;\n  }\n\n  /**\n   * Load MCP configuration from file\n   *\n   * @description\n   * Reads and parses a .mcp.json configuration file, transforming it into SDK-compatible\n   * MCP server format. The configuration file should contain an 'mcpServers' object\n   * where each key is a server name and the value includes command, args, and env.\n   *\n   * This method handles stdio-based MCP servers (servers launched as child processes).\n   * The transformation ensures compatibility with the Claude Agent SDK's expected\n   * mcpServers format.\n   *\n   * File format:\n   * ```json\n   * {\n   *   \"mcpServers\": {\n   *     \"server-name\": {\n   *       \"command\": \"node\",\n   *       \"args\": [\"path/to/server.js\"],\n   *       \"env\": { \"API_KEY\": \"value\" }\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @param configPath - Absolute path to .mcp.json configuration file\n   *\n   * @returns Promise resolving to SDK-compatible mcpServers object, or undefined if file cannot be read/parsed\n   *\n   * @example\n   * ```typescript\n   * // Load MCP config from user's home directory\n   * const mcpServers = await this.loadMcpConfig('/home/user/.config/claude/.mcp.json');\n   * if (mcpServers) {\n   *   console.log('Loaded servers:', Object.keys(mcpServers));\n   *   // Output: ['filesystem', 'database', 'api-client']\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle missing or invalid config file\n   * const mcpServers = await this.loadMcpConfig('/path/to/nonexistent.json');\n   * // Returns undefined, error logged but not thrown\n   * ```\n   *\n   * @private\n   */\n  private async loadMcpConfig(configPath: string): Promise<Options['mcpServers']> {\n    try {\n      const content = await fs.readFile(configPath, 'utf-8');\n      const config = JSON.parse(content);\n\n      // Transform MCP config to SDK format\n      // This is a simplified version - actual transformation depends on config structure\n      const mcpServers: Record<string, any> = {};\n\n      if (config.mcpServers) {\n        for (const [name, serverConfig] of Object.entries(config.mcpServers as Record<string, any>)) {\n          if (serverConfig.command) {\n            // stdio-based server\n            mcpServers[name] = {\n              type: 'stdio',\n              command: serverConfig.command,\n              args: serverConfig.args || [],\n              env: serverConfig.env || {},\n            };\n          }\n        }\n      }\n\n      return mcpServers as Options['mcpServers'];\n    } catch (error) {\n      this.logger.error('Failed to load MCP config', error, { configPath });\n      return undefined;\n    }\n  }\n\n  /**\n   * Load MCP servers from Strapi database\n   *\n   * @description\n   * Fetches all enabled MCP server configurations from the Strapi CMS database and\n   * transforms them into SDK-compatible format. This method:\n   * - Queries Strapi for MCP servers where disabled=false\n   * - Filters out servers without a command (invalid configurations)\n   * - Transforms each server to SDK format with type, command, args, and env\n   * - Supports stdio transport type for child process-based servers\n   *\n   * This provides centralized MCP server management through the CMS, allowing\n   * administrators to configure servers without modifying code or config files.\n   * These servers have medium priority in the merge strategy (higher than file-based,\n   * lower than skill-specific).\n   *\n   * @param workingDirectory - Optional working directory context (currently unused, reserved for future filtering)\n   *\n   * @returns Promise resolving to SDK-compatible mcpServers object, or undefined if no enabled servers found or on error\n   *\n   * @example\n   * ```typescript\n   * // Load agent-level MCP servers from Strapi\n   * const strapiServers = await this.loadMcpServersFromStrapi('/path/to/project');\n   * if (strapiServers) {\n   *   console.log('Loaded Strapi servers:', Object.keys(strapiServers));\n   *   // Output: ['github-api', 'slack-integration', 'database-tool']\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Gracefully handles Strapi connection failures\n   * const servers = await this.loadMcpServersFromStrapi();\n   * // Returns undefined if Strapi is unavailable, error logged as warning\n   * ```\n   *\n   * @private\n   */\n  private async loadMcpServersFromStrapi(workingDirectory?: string): Promise<Options['mcpServers']> {\n    try {\n      const { strapiClient } = await import('./strapi-client.js');\n\n      // Get all enabled MCP servers from Strapi\n      const servers = await strapiClient.getAllMCPServers({\n        filters: { disabled: false }\n      });\n\n      if (!servers || servers.length === 0) {\n        return undefined;\n      }\n\n      // Transform to SDK format\n      const mcpServers: Record<string, any> = {};\n\n      for (const server of servers) {\n        // Skip servers without command\n        if (!server.command) {\n          continue;\n        }\n\n        mcpServers[server.name] = {\n          type: server.transport || 'stdio',\n          command: server.command,\n          args: server.args || [],\n          env: server.env || {},\n        };\n      }\n\n      this.logger.info('Loaded MCP servers from Strapi', {\n        serverCount: Object.keys(mcpServers).length,\n        servers: Object.keys(mcpServers)\n      });\n\n      return mcpServers as Options['mcpServers'];\n    } catch (error) {\n      this.logger.warn('Failed to load MCP servers from Strapi', { error });\n      return undefined;\n    }\n  }\n\n  /**\n   * Load MCP servers from Skills' MCP configurations\n   *\n   * @description\n   * Extracts and loads MCP servers specified in skills' mcpConfig arrays. This method:\n   * - Iterates through each skill's mcpConfig array\n   * - Extracts MCP server IDs (handles both string and object formats)\n   * - Fetches full server details from Strapi database\n   * - Filters out disabled servers and servers without commands\n   * - Transforms servers to SDK-compatible format\n   *\n   * Skills can declare which MCP servers they require, enabling context-specific\n   * tool access. For example, a 'database-analysis' skill might require a\n   * 'postgres-mcp' server. These skill-specific servers have the highest priority\n   * in the merge strategy, ensuring skills get exactly the tools they need.\n   *\n   * The mcpConfig format supports:\n   * - Direct server ID: { mcpServer: \"server-id\" }\n   * - Server object: { mcpServer: { id: \"server-id\" } }\n   *\n   * @param skills - Array of skills with optional mcpConfig arrays\n   * @param skills[].name - Skill name for logging\n   * @param skills[].mcpConfig - Array of MCP server selections\n   * @param skills[].mcpConfig[].mcpServer - Server ID (string) or server object with id\n   *\n   * @returns Promise resolving to SDK-compatible mcpServers object, or undefined if no skill servers configured\n   *\n   * @example\n   * ```typescript\n   * // Load MCP servers from skills with mcpConfig\n   * const skills = [\n   *   {\n   *     name: 'code-analysis',\n   *     mcpConfig: [\n   *       { mcpServer: 'github-mcp-id' },\n   *       { mcpServer: { id: 'ast-parser-mcp-id' } }\n   *     ]\n   *   }\n   * ];\n   *\n   * const skillServers = await this.loadMcpServersFromSkills(skills);\n   * // Result: { 'github-api': {...}, 'ast-parser': {...} }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handles skills without mcpConfig gracefully\n   * const skills = [\n   *   { name: 'simple-skill' } // No mcpConfig\n   * ];\n   *\n   * const servers = await this.loadMcpServersFromSkills(skills);\n   * // Returns undefined (no servers to load)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Continues processing if individual server fetch fails\n   * const skills = [\n   *   {\n   *     name: 'mixed-skill',\n   *     mcpConfig: [\n   *       { mcpServer: 'valid-server-id' },\n   *       { mcpServer: 'invalid-server-id' } // Fails to fetch\n   *     ]\n   *   }\n   * ];\n   *\n   * const servers = await this.loadMcpServersFromSkills(skills);\n   * // Returns servers that were successfully loaded, logs error for failed ones\n   * ```\n   *\n   * @private\n   */\n  private async loadMcpServersFromSkills(skills: any[]): Promise<Options['mcpServers']> {\n    try {\n      const { strapiClient } = await import('./strapi-client.js');\n      const mcpServers: Record<string, any> = {};\n\n      for (const skill of skills) {\n        // Skip skills without MCP config\n        if (!skill.mcpConfig || !Array.isArray(skill.mcpConfig)) {\n          continue;\n        }\n\n        // Process each MCP server selection in the skill\n        for (const mcpSelection of skill.mcpConfig) {\n          // Extract MCP server ID (can be string or object with id)\n          const serverId = typeof mcpSelection.mcpServer === 'string'\n            ? mcpSelection.mcpServer\n            : mcpSelection.mcpServer?.id;\n\n          if (!serverId) {\n            continue;\n          }\n\n          try {\n            // Fetch MCP server details from Strapi\n            const server = await strapiClient.getMCPServer(serverId);\n\n            // Skip disabled servers or servers without command\n            if (server.disabled || !server.command) {\n              continue;\n            }\n\n            // Transform to SDK format\n            mcpServers[server.name] = {\n              type: server.transport || 'stdio',\n              command: server.command,\n              args: server.args || [],\n              env: server.env || {},\n            };\n\n            this.logger.info(`[ClaudeSDK] Loaded MCP server from skill: ${server.name}`, {\n              skillName: skill.name,\n              serverName: server.name\n            });\n          } catch (error) {\n            this.logger.error(`[ClaudeSDK] Failed to load MCP server ${serverId}:`, error);\n            // Continue with other servers even if one fails\n          }\n        }\n      }\n\n      return Object.keys(mcpServers).length > 0 ? (mcpServers as Options['mcpServers']) : undefined;\n    } catch (error) {\n      this.logger.warn('Failed to load MCP servers from skills', { error });\n      return undefined;\n    }\n  }\n\n  /**\n   * Process messages from SDK query\n   *\n   * @description\n   * Asynchronous generator that processes messages from an active SDK query instance.\n   * This is the core message processing loop that:\n   * - Iterates through SDK messages as they arrive\n   * - Extracts and updates the SDK session ID from the first message\n   * - Writes messages to conversation history files via SdkHistoryWriter\n   * - Transforms SDK messages to application's StreamEvent format\n   * - Emits 'claude-message' events for real-time frontend updates\n   * - Handles conversation completion and cleanup\n   * - Manages error recovery and resource cleanup\n   *\n   * The method runs asynchronously and should be started with setImmediate to prevent\n   * EPIPE errors from being unhandled. It continues processing until the SDK query\n   * completes or an error occurs.\n   *\n   * Session ID handling:\n   * - New conversations: Extracts SDK's session ID from first message\n   * - Resumed conversations: Uses existing session ID from config\n   * - Emits session_id_update event when SDK session ID is obtained\n   *\n   * @param streamingId - Unique identifier for this conversation instance\n   * @param queryInstance - Active SDK Query instance to process messages from\n   *\n   * @returns Promise<void> - Resolves when query completes or rejects on error\n   *\n   * @throws Error if session ID is not found or if message processing fails critically\n   *\n   * @fires claude-message - Emitted for each transformed SDK message\n   * @fires process-closed - Emitted when query completes successfully (code: 0)\n   * @fires process-error - Emitted when query fails or processing error occurs\n   *\n   * @example\n   * ```typescript\n   * // Start processing query messages asynchronously\n   * const query = query({ prompt: 'Hello', options });\n   * this.queries.set(streamingId, query);\n   *\n   * setImmediate(() => {\n   *   this.processQueryMessages(streamingId, query).catch((error) => {\n   *     this.logger.error('Query processing failed', error);\n   *     this.emit('process-error', { streamingId, error: error.message });\n   *   });\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Listen for messages during processing\n   * claudeSdk.on('claude-message', ({ streamingId, message }) => {\n   *   if (message.type === 'assistant') {\n   *     console.log('Assistant message:', message.message.content);\n   *   } else if (message.type === 'result') {\n   *     console.log('Tool result:', message.result);\n   *   } else if (message.type === 'session_id_update') {\n   *     console.log('Session ID updated:', message.newSessionId);\n   *   }\n   * });\n   * ```\n   *\n   * @private\n   */\n  private async processQueryMessages(streamingId: string, queryInstance: Query): Promise<void> {\n    try {\n      let sessionId = this.sessionIds.get(streamingId);\n      if (!sessionId) {\n        throw new Error('Session ID not found');\n      }\n\n      this.logger.info('\ud83d\udd04 Starting to process SDK query messages', { streamingId, sessionId });\n\n      const config = this.conversationConfigs.get(streamingId);\n      const workingDirectory = config?.workingDirectory;\n      const isResume = config?.previousMessages && config.previousMessages.length > 0;\n\n      let messageCount = 0;\n      for await (const message of queryInstance) {\n        messageCount++;\n\n        // Extract the SDK's actual session ID from the first message (only for new conversations)\n        if (messageCount === 1 && message.session_id && !isResume) {\n          const sdkSessionId = message.session_id;\n          const oldSessionId = sessionId;\n          this.logger.info('\ud83d\udd11 Extracted SDK session ID', { streamingId, sdkSessionId, oldSessionId });\n          this.sessionIds.set(streamingId, sdkSessionId);\n          sessionId = sdkSessionId; // Update local variable\n\n          // Emit session ID update event to notify frontend\n          this.emit('claude-message', {\n            streamingId,\n            message: {\n              type: 'session_id_update',\n              oldSessionId,\n              newSessionId: sdkSessionId,\n              streamingId,\n              timestamp: new Date().toISOString()\n            }\n          });\n          this.logger.info('\ud83d\udce4 Emitted session ID update event', { streamingId, oldSessionId, newSessionId: sdkSessionId });\n        }\n\n        this.logger.info('\ud83d\udce8 Received SDK message', {\n          streamingId,\n          sessionId,\n          messageNumber: messageCount,\n          type: message.type\n        });\n\n        // Write message to history\n        try {\n          if (message.type === 'assistant') {\n            this.logger.info('\ud83d\udcdd Writing assistant message to history', { streamingId, sessionId });\n            await this.historyWriter.writeAssistantMessage(\n              message as unknown as SDKAssistantMessage,\n              workingDirectory\n            );\n            this.logger.info('\u2705 Assistant message written to history', { streamingId, sessionId });\n          } else if (message.type === 'user' && !(message as any).isReplay) {\n            this.logger.info('\ud83d\udcdd Writing user message to history', { streamingId, sessionId });\n            await this.historyWriter.writeUserMessage(\n              message as unknown as SDKUserMessage,\n              workingDirectory\n            );\n            this.logger.info('\u2705 User message written to history', { streamingId, sessionId });\n          } else if (message.type === 'result') {\n            this.logger.info('\ud83d\udcdd Writing result message to history', { streamingId, sessionId });\n            await this.historyWriter.writeResultMessage(\n              message as unknown as SDKResultMessage,\n              workingDirectory\n            );\n            this.logger.info('\u2705 Result message written to history', { streamingId, sessionId });\n          }\n        } catch (historyError) {\n          this.logger.error('\u274c Failed to write message to history', historyError, {\n            streamingId,\n            sessionId,\n            messageType: message.type\n          });\n        }\n\n        // Transform SDK message to StreamEvent\n        // Type assertion needed due to slight differences between SDK types and our types\n        const streamEvent = this.transformSdkMessage(message as unknown as SDKMessage, sessionId);\n\n        if (streamEvent) {\n          this.logger.info('\u2705 Transformed and emitting claude-message event', {\n            streamingId,\n            eventType: streamEvent.type\n          });\n          // Emit as claude-message event\n          this.emit('claude-message', { streamingId, message: streamEvent });\n          this.logger.info('\ud83d\udce1 claude-message event emitted', { streamingId, eventType: streamEvent.type });\n        } else {\n          this.logger.warn('\u23ed\ufe0f  Skipped message (no transform)', {\n            streamingId,\n            messageType: message.type\n          });\n        }\n      }\n\n      this.logger.info('\u2705 Query iteration complete', { streamingId, totalMessages: messageCount });\n\n      // Query completed - flush history before closing\n      await this.historyWriter.flush(sessionId);\n\n      // Unregister from status tracker\n      this.statusTracker.unregisterActiveSession(streamingId);\n\n      this.logger.info('\ud83c\udfc1 Query completed', { streamingId, sessionId });\n      this.emit('process-closed', { streamingId, code: 0 });\n    } catch (error) {\n      this.logger.error('\u274c Error in processQueryMessages', error, { streamingId });\n      this.emit('process-error', { streamingId, error: error instanceof Error ? error.message : String(error) });\n    }\n  }\n\n  /**\n   * Get conversation config by session ID\n   *\n   * @description\n   * Retrieves the conversation configuration for a given SDK session ID by looking up\n   * the streaming ID associated with that session, then returning the stored config.\n   * This reverse lookup is necessary because configs are stored by streaming ID\n   * (our internal identifier) but often we only have the session ID (SDK's identifier)\n   * when processing callbacks or writing history.\n   *\n   * @param sessionId - SDK session ID to look up configuration for\n   *\n   * @returns ConversationConfig if found, undefined if no config exists for this session\n   *\n   * @example\n   * ```typescript\n   * // Get config when processing history write\n   * const config = this.getConfigBySessionId(sessionId);\n   * if (config?.workingDirectory) {\n   *   await this.historyWriter.writeMessage(message, config.workingDirectory);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Access conversation settings by session ID\n   * const config = this.getConfigBySessionId(sessionId);\n   * console.log('Model:', config?.model);\n   * console.log('Permission mode:', config?.permissionMode);\n   * ```\n   *\n   * @private\n   */\n  private getConfigBySessionId(sessionId: string): ConversationConfig | undefined {\n    const streamingId = Array.from(this.sessionIds.entries()).find(\n      ([_, sid]) => sid === sessionId\n    )?.[0];\n    return streamingId ? this.conversationConfigs.get(streamingId) : undefined;\n  }\n\n  /**\n   * Transform SDK message to StreamEvent format\n   *\n   * @description\n   * Routes SDK messages to appropriate transformation methods based on message type.\n   * This is the main dispatcher that converts SDK's message format to the application's\n   * StreamEvent format used throughout the CUI (Conversational User Interface).\n   *\n   * Supported message types:\n   * - 'assistant': Assistant's text and tool use responses\n   * - 'user': User messages (including tool results)\n   * - 'result': Tool execution results with metrics\n   * - 'stream_event': Partial messages during streaming\n   *\n   * The transformation ensures consistency across the application and adapts SDK's\n   * format to match the existing CUI event structure that the frontend expects.\n   *\n   * @param sdkMessage - SDK message to transform (assistant, user, result, or stream_event)\n   * @param sessionId - Session ID to include in transformed message\n   *\n   * @returns StreamEvent object in CUI format, or null if message type is unsupported\n   *\n   * @example\n   * ```typescript\n   * // Transform various SDK message types\n   * for await (const sdkMessage of queryInstance) {\n   *   const streamEvent = this.transformSdkMessage(sdkMessage, sessionId);\n   *   if (streamEvent) {\n   *     this.emit('claude-message', { streamingId, message: streamEvent });\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle different message types\n   * const event = this.transformSdkMessage(sdkMessage, sessionId);\n   * if (event?.type === 'assistant') {\n   *   console.log('Assistant response:', event.message.content);\n   * } else if (event?.type === 'result') {\n   *   console.log('Tool result:', event.result);\n   *   console.log('Token usage:', event.usage);\n   * }\n   * ```\n   *\n   * @private\n   */\n  private transformSdkMessage(sdkMessage: SDKMessage, sessionId: string): StreamEvent | null {\n    try {\n      switch (sdkMessage.type) {\n        case 'assistant':\n          return this.transformAssistantMessage(sdkMessage as SDKAssistantMessage, sessionId);\n\n        case 'user':\n          return this.transformUserMessage(sdkMessage as SDKUserMessage, sessionId);\n\n        case 'result':\n          return this.transformResultMessage(sdkMessage as SDKResultMessage, sessionId);\n\n        case 'stream_event':\n          return this.transformStreamEvent(sdkMessage as SDKPartialAssistantMessage, sessionId);\n\n        default:\n          this.logger.debug('Unhandled SDK message type', { type: (sdkMessage as any).type });\n          return null;\n      }\n    } catch (error) {\n      this.logger.error('Error transforming SDK message', error, {\n        messageType: sdkMessage.type,\n        sessionId,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Transform SDK assistant message\n   *\n   * @description\n   * Converts SDK assistant messages to CUI's AssistantStreamMessage format. This method:\n   * - Writes the message to conversation history asynchronously (non-blocking)\n   * - Extracts the Anthropic message content (text, tool use, etc.)\n   * - Preserves parent_tool_use_id for nested tool execution tracking\n   * - Includes session ID for message correlation\n   *\n   * Assistant messages contain Claude's responses, which may include:\n   * - Text content (explanations, answers, thoughts)\n   * - Tool use requests (asking to execute tools)\n   * - Multiple content blocks in a single message\n   *\n   * History writing is done asynchronously to avoid blocking the message stream.\n   * Any history write errors are logged but don't interrupt message processing.\n   *\n   * @param sdkMessage - SDK assistant message with Anthropic message content\n   * @param sdkMessage.message - Anthropic.Message with content blocks\n   * @param sdkMessage.parent_tool_use_id - Optional parent tool use ID for nested execution\n   * @param sessionId - Session ID to include in transformed message\n   *\n   * @returns AssistantStreamMessage in CUI format with message content and metadata\n   *\n   * @example\n   * ```typescript\n   * // Transform assistant message with text content\n   * const assistantMsg: SDKAssistantMessage = {\n   *   type: 'assistant',\n   *   message: {\n   *     id: 'msg_123',\n   *     role: 'assistant',\n   *     content: [{ type: 'text', text: 'Hello! How can I help you?' }],\n   *     model: 'claude-sonnet-4-5',\n   *     usage: { input_tokens: 10, output_tokens: 20 }\n   *   }\n   * };\n   *\n   * const streamEvent = this.transformAssistantMessage(assistantMsg, sessionId);\n   * // Result: { type: 'assistant', session_id: '...', message: {...} }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Transform assistant message with tool use\n   * const assistantMsg: SDKAssistantMessage = {\n   *   type: 'assistant',\n   *   message: {\n   *     content: [\n   *       { type: 'text', text: 'Let me read that file for you.' },\n   *       {\n   *         type: 'tool_use',\n   *         id: 'tool_abc',\n   *         name: 'Read',\n   *         input: { file_path: '/path/to/file.txt' }\n   *       }\n   *     ],\n   *     // ... other message fields\n   *   }\n   * };\n   *\n   * const streamEvent = this.transformAssistantMessage(assistantMsg, sessionId);\n   * // Message includes both text and tool use request\n   * ```\n   *\n   * @private\n   */\n  private transformAssistantMessage(\n    sdkMessage: SDKAssistantMessage,\n    sessionId: string\n  ): AssistantStreamMessage {\n    // Write to history asynchronously (don't block message processing)\n    const config = this.getConfigBySessionId(sessionId);\n    this.historyWriter.writeAssistantMessage(\n      sdkMessage,\n      config?.workingDirectory,\n      'sdk-0.1.0'\n    ).catch((error) => {\n      this.logger.error('Failed to write assistant message to history', error, { sessionId });\n    });\n\n    return {\n      type: 'assistant',\n      session_id: sessionId,\n      message: sdkMessage.message,\n      parent_tool_use_id: sdkMessage.parent_tool_use_id || undefined,\n    };\n  }\n\n  /**\n   * Transform SDK user message\n   *\n   * @description\n   * Converts SDK user messages to CUI's UserStreamMessage format. This method:\n   * - Writes the message to conversation history asynchronously (non-blocking)\n   * - Extracts the message content (typically tool results or user input)\n   * - Preserves parent_tool_use_id for tracking which tool execution this responds to\n   * - Includes session ID for message correlation\n   *\n   * User messages in SDK context typically represent:\n   * - Tool execution results being returned to Claude\n   * - User's follow-up input in the conversation\n   * - Replayed messages from conversation history (not written to history again)\n   *\n   * The method checks for 'isReplay' flag to avoid duplicating messages in history\n   * when resuming conversations from previous sessions.\n   *\n   * @param sdkMessage - SDK user message with content and optional tool result\n   * @param sdkMessage.message - Message content (text or tool result)\n   * @param sdkMessage.parent_tool_use_id - Optional parent tool use ID this message responds to\n   * @param sdkMessage.isReplay - Optional flag indicating this is a replayed message\n   * @param sessionId - Session ID to include in transformed message\n   *\n   * @returns UserStreamMessage in CUI format with message content and metadata\n   *\n   * @example\n   * ```typescript\n   * // Transform tool result user message\n   * const userMsg: SDKUserMessage = {\n   *   type: 'user',\n   *   message: {\n   *     role: 'user',\n   *     content: [\n   *       {\n   *         type: 'tool_result',\n   *         tool_use_id: 'tool_abc',\n   *         content: 'File contents: Hello, world!'\n   *       }\n   *     ]\n   *   },\n   *   parent_tool_use_id: 'tool_abc'\n   * };\n   *\n   * const streamEvent = this.transformUserMessage(userMsg, sessionId);\n   * // Result: { type: 'user', session_id: '...', message: {...} }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Transform user input message\n   * const userMsg: SDKUserMessage = {\n   *   type: 'user',\n   *   message: {\n   *     role: 'user',\n   *     content: 'Can you help me debug this code?'\n   *   }\n   * };\n   *\n   * const streamEvent = this.transformUserMessage(userMsg, sessionId);\n   * // User's question is transformed to stream event\n   * ```\n   *\n   * @private\n   */\n  private transformUserMessage(\n    sdkMessage: SDKUserMessage,\n    sessionId: string\n  ): UserStreamMessage {\n    // Write to history asynchronously\n    const config = this.getConfigBySessionId(sessionId);\n    this.historyWriter.writeUserMessage(\n      sdkMessage,\n      config?.workingDirectory,\n      'sdk-0.1.0'\n    ).catch((error) => {\n      this.logger.error('Failed to write user message to history', error, { sessionId });\n    });\n\n    return {\n      type: 'user',\n      session_id: sessionId,\n      message: sdkMessage.message,\n      parent_tool_use_id: sdkMessage.parent_tool_use_id || undefined,\n    };\n  }\n\n  /**\n   * Transform SDK result message with proper metrics\n   *\n   * @description\n   * Converts SDK result messages to CUI's ResultStreamMessage format with comprehensive\n   * metrics. This method:\n   * - Writes the result to conversation history asynchronously (non-blocking)\n   * - Extracts subtype (e.g., 'success', 'error', 'cancelled')\n   * - Preserves error state and result content\n   * - Transforms usage metrics (token counts, cache usage)\n   * - Includes timing metrics (duration, API duration)\n   * - Tracks conversation turns\n   *\n   * Result messages represent the outcome of tool executions or API calls, providing\n   * detailed metrics about resource usage, performance, and success/failure status.\n   * These metrics are essential for monitoring conversation costs and performance.\n   *\n   * Token usage breakdown:\n   * - input_tokens: Tokens sent in the request\n   * - cache_creation_input_tokens: Tokens used to create cache entries\n   * - cache_read_input_tokens: Tokens read from cache (cost savings)\n   * - output_tokens: Tokens generated in the response\n   *\n   * @param sdkMessage - SDK result message with metrics and outcome\n   * @param sdkMessage.subtype - Result subtype ('success', 'error', etc.)\n   * @param sdkMessage.is_error - Whether this represents an error condition\n   * @param sdkMessage.result - Result content or error details\n   * @param sdkMessage.usage - Token usage statistics\n   * @param sdkMessage.duration_ms - Total duration in milliseconds\n   * @param sdkMessage.duration_api_ms - API call duration in milliseconds\n   * @param sdkMessage.num_turns - Number of conversation turns\n   * @param sessionId - Session ID to include in transformed message\n   *\n   * @returns ResultStreamMessage in CUI format with full metrics\n   *\n   * @example\n   * ```typescript\n   * // Transform successful result with metrics\n   * const resultMsg: SDKResultMessage = {\n   *   type: 'result',\n   *   subtype: 'success',\n   *   is_error: false,\n   *   duration_ms: 1234,\n   *   duration_api_ms: 890,\n   *   num_turns: 3,\n   *   result: { output: 'Task completed successfully' },\n   *   usage: {\n   *     input_tokens: 150,\n   *     cache_creation_input_tokens: 0,\n   *     cache_read_input_tokens: 50,\n   *     output_tokens: 200\n   *   }\n   * };\n   *\n   * const streamEvent = this.transformResultMessage(resultMsg, sessionId);\n   * console.log('Total tokens:', streamEvent.usage.input_tokens + streamEvent.usage.output_tokens);\n   * console.log('Cache savings:', streamEvent.usage.cache_read_input_tokens);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Transform error result\n   * const errorMsg: SDKResultMessage = {\n   *   type: 'result',\n   *   subtype: 'error',\n   *   is_error: true,\n   *   result: { error: 'File not found', code: 'ENOENT' },\n   *   duration_ms: 50,\n   *   duration_api_ms: 0,\n   *   num_turns: 1,\n   *   usage: { input_tokens: 10, output_tokens: 0 }\n   * };\n   *\n   * const streamEvent = this.transformResultMessage(errorMsg, sessionId);\n   * // is_error flag preserved for error handling\n   * ```\n   *\n   * @private\n   */\n  private transformResultMessage(\n    sdkMessage: SDKResultMessage,\n    sessionId: string\n  ): ResultStreamMessage {\n    // Write to history asynchronously\n    const config = this.getConfigBySessionId(sessionId);\n    this.historyWriter.writeResultMessage(\n      sdkMessage,\n      config?.workingDirectory,\n      'sdk-0.1.0'\n    ).catch((error) => {\n      this.logger.error('Failed to write result message to history', error, { sessionId });\n    });\n\n    return {\n      type: 'result',\n      session_id: sessionId,\n      subtype: sdkMessage.subtype,\n      is_error: sdkMessage.is_error,\n      duration_ms: sdkMessage.duration_ms || 0,\n      duration_api_ms: sdkMessage.duration_api_ms || 0,\n      num_turns: sdkMessage.num_turns || 0,\n      result: sdkMessage.result,\n      usage: {\n        input_tokens: sdkMessage.usage?.input_tokens || 0,\n        cache_creation_input_tokens: sdkMessage.usage?.cache_creation_input_tokens || 0,\n        cache_read_input_tokens: sdkMessage.usage?.cache_read_input_tokens || 0,\n        output_tokens: sdkMessage.usage?.output_tokens || 0,\n        server_tool_use: {\n          web_search_requests: 0, // SDK doesn't provide this granularity\n        },\n      },\n    };\n  }\n\n  /**\n   * Transform SDK stream event for real-time updates\n   *\n   * @description\n   * Converts SDK streaming events to user-friendly status messages during real-time\n   * message generation. This method handles partial assistant messages and provides\n   * progress feedback to the frontend without overwhelming it with raw stream data.\n   *\n   * Stream event types handled:\n   * - message_start: Assistant begins thinking\n   * - content_block_start: New content block (text or tool use)\n   * - content_block_delta: Incremental content updates (skipped to reduce noise)\n   * - content_block_stop: Content block completed (skipped)\n   * - message_delta: Message metadata updates (stop reason, etc.)\n   * - message_stop: Response generation complete\n   *\n   * The method filters out high-frequency events (text deltas, input_json_delta) to\n   * avoid flooding the frontend with too many updates. Only meaningful status changes\n   * are converted to synthetic assistant messages with status text.\n   *\n   * Status messages are synthetic - they don't represent actual assistant content but\n   * provide user-friendly progress indicators like \"\ud83e\udd16 Assistant is thinking...\" or\n   * \"\ud83d\udd27 Using tool: Read\".\n   *\n   * @param sdkMessage - SDK partial assistant message with streaming event\n   * @param sdkMessage.event - The specific stream event (message_start, content_block_delta, etc.)\n   * @param sdkMessage.event.type - Event type identifier\n   * @param sdkMessage.event.content_block - Content block for block start events\n   * @param sdkMessage.event.delta - Delta information for incremental updates\n   * @param sdkMessage.parent_tool_use_id - Optional parent tool use ID for nested execution\n   * @param sessionId - Session ID to include in synthetic message\n   *\n   * @returns StreamEvent with synthetic status message, or null for skipped events\n   *\n   * @example\n   * ```typescript\n   * // Transform message_start event\n   * const streamEvent: SDKPartialAssistantMessage = {\n   *   type: 'stream_event',\n   *   event: { type: 'message_start' }\n   * };\n   *\n   * const result = this.transformStreamEvent(streamEvent, sessionId);\n   * // Result: { type: 'assistant', message: { content: [{ text: '\ud83e\udd16 Assistant is thinking...' }] } }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Transform tool use start\n   * const streamEvent: SDKPartialAssistantMessage = {\n   *   type: 'stream_event',\n   *   event: {\n   *     type: 'content_block_start',\n   *     content_block: { type: 'tool_use', name: 'Read' }\n   *   }\n   * };\n   *\n   * const result = this.transformStreamEvent(streamEvent, sessionId);\n   * // Result: { message: { content: [{ text: '\ud83d\udd27 Using tool: Read' }] } }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Text deltas are skipped to reduce noise\n   * const streamEvent: SDKPartialAssistantMessage = {\n   *   type: 'stream_event',\n   *   event: {\n   *     type: 'content_block_delta',\n   *     delta: { type: 'text_delta', text: 'Hello' }\n   *   }\n   * };\n   *\n   * const result = this.transformStreamEvent(streamEvent, sessionId);\n   * // Result: null (skipped to avoid too many updates)\n   * ```\n   *\n   * @private\n   */\n  private transformStreamEvent(\n    sdkMessage: SDKPartialAssistantMessage,\n    sessionId: string\n  ): StreamEvent | null {\n    // Log streaming events for debugging\n    this.logger.debug('SDK streaming event', {\n      sessionId,\n      eventType: sdkMessage.event.type,\n      parentToolUseId: sdkMessage.parent_tool_use_id,\n    });\n\n    // Extract useful information from stream events for progress updates\n    const event = sdkMessage.event;\n    let statusMessage = '';\n\n    // Handle different stream event types\n    switch (event.type) {\n      case 'message_start':\n        statusMessage = '\ud83e\udd16 Assistant is thinking...';\n        break;\n\n      case 'content_block_start':\n        if (event.content_block?.type === 'tool_use') {\n          const toolName = (event.content_block as any).name || 'tool';\n          statusMessage = `\ud83d\udd27 Using tool: ${toolName}`;\n        } else if (event.content_block?.type === 'text') {\n          statusMessage = '\ud83d\udcac Generating response...';\n        }\n        break;\n\n      case 'content_block_delta':\n        // For text deltas, we could accumulate text, but for now just show activity\n        if (event.delta?.type === 'text_delta') {\n          // Skip individual text deltas to avoid too many messages\n          return null;\n        } else if (event.delta?.type === 'input_json_delta') {\n          // Tool input is being streamed\n          return null;\n        }\n        break;\n\n      case 'content_block_stop':\n        // Content block finished\n        return null;\n\n      case 'message_delta':\n        if (event.delta?.stop_reason) {\n          statusMessage = `\u2705 Message complete (${event.delta.stop_reason})`;\n        }\n        break;\n\n      case 'message_stop':\n        statusMessage = '\u2705 Response complete';\n        break;\n\n      default:\n        // Unknown event type, skip it\n        return null;\n    }\n\n    // If we have a status message, create a synthetic assistant message\n    if (statusMessage) {\n      // Create a minimal Anthropic.Message structure for status updates\n      const syntheticMessage: any = {\n        id: `stream_${Date.now()}_${Math.random()}`,\n        type: 'message',\n        role: 'assistant',\n        content: [{\n          type: 'text',\n          text: statusMessage\n        }],\n        model: 'claude-3-5-sonnet-20241022', // Default model\n        stop_reason: null,\n        stop_sequence: null,\n        usage: {\n          input_tokens: 0,\n          output_tokens: 0\n        }\n      };\n\n      return {\n        type: 'assistant',\n        session_id: sessionId,\n        message: syntheticMessage,\n        parent_tool_use_id: sdkMessage.parent_tool_use_id || undefined,\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Get the count of currently active conversations\n   *\n   * @description\n   * Returns the number of SDK conversations currently running. This count includes\n   * all conversations that have been started but not yet stopped or completed.\n   * Useful for monitoring system load and enforcing concurrency limits.\n   *\n   * @returns Number of active conversations being managed by this service instance\n   *\n   * @example\n   * ```typescript\n   * // Check active conversation count before starting new one\n   * const activeCount = claudeSdk.getActiveConversationsCount();\n   * console.log(`Currently ${activeCount} conversations running`);\n   *\n   * if (activeCount < MAX_CONCURRENT_CONVERSATIONS) {\n   *   await claudeSdk.startConversation(config);\n   * } else {\n   *   console.log('Maximum concurrent conversations reached');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Monitor conversation load\n   * setInterval(() => {\n   *   const count = claudeSdk.getActiveConversationsCount();\n   *   console.log(`Active conversations: ${count}`);\n   *\n   *   if (count > 10) {\n   *     console.warn('High conversation load detected');\n   *   }\n   * }, 5000);\n   * ```\n   */\n  getActiveConversationsCount(): number {\n    return this.queries.size;\n  }\n\n  /**\n   * Check if a specific conversation is currently active\n   *\n   * @description\n   * Determines whether a conversation with the given streaming ID is currently running.\n   * A conversation is considered active from the time startConversation() returns until\n   * either stopConversation() is called or the SDK query completes naturally.\n   *\n   * @param streamingId - Unique identifier of the conversation to check\n   *\n   * @returns true if the conversation is active, false otherwise\n   *\n   * @example\n   * ```typescript\n   * // Check if conversation is still running before sending a stop command\n   * if (claudeSdk.isConversationActive(streamingId)) {\n   *   await claudeSdk.stopConversation(streamingId);\n   * } else {\n   *   console.log('Conversation already completed');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Prevent duplicate conversation starts\n   * let currentStreamingId: string | null = null;\n   *\n   * async function startNewConversation(prompt: string) {\n   *   if (currentStreamingId && claudeSdk.isConversationActive(currentStreamingId)) {\n   *     console.log('A conversation is already running');\n   *     return;\n   *   }\n   *\n   *   const { streamingId } = await claudeSdk.startConversation({\n   *     initialPrompt: prompt,\n   *     workingDirectory: process.cwd()\n   *   });\n   *\n   *   currentStreamingId = streamingId;\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Track conversation lifecycle\n   * const { streamingId } = await claudeSdk.startConversation(config);\n   *\n   * console.log('Active:', claudeSdk.isConversationActive(streamingId)); // true\n   *\n   * claudeSdk.on('process-closed', ({ streamingId: closedId }) => {\n   *   if (closedId === streamingId) {\n   *     console.log('Active:', claudeSdk.isConversationActive(streamingId)); // false\n   *   }\n   * });\n   * ```\n   */\n  isConversationActive(streamingId: string): boolean {\n    return this.queries.has(streamingId);\n  }\n}\n",
        "last_modified": "2026-01-02T14:06:15.757813"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.482659",
  "last_updated": "2026-01-02T14:06:15.500591"
}