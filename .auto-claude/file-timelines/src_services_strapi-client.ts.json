{
  "file_path": "src/services/strapi-client.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "/**\n * Claude Agent UI - Strapi Client Service\n *\n * This service provides a data access layer for interacting with the Strapi CMS API.\n * It handles HTTP communication, caching, and data transformation between Strapi's\n * response format and the application's domain models.\n *\n * Features:\n * - HTTP client with axios\n * - LRU cache with 5-minute TTL\n * - Request/response interceptors for logging\n * - Automatic data transformation\n * - Cache invalidation on mutations\n * - Error handling with detailed logging\n * - Support for populate, filters, sort, pagination\n * - Health check endpoint\n */\n\nimport axios, { AxiosInstance, AxiosError } from 'axios';\nimport { LRUCache } from 'lru-cache';\nimport type {\n  Agent,\n  Skill,\n  MCPServer,\n  MCPTool,\n  Task,\n  StrapiAttributes,\n  StrapiResponse,\n  StrapiData,\n  StrapiQueryParams,\n  CreateAgentDTO,\n  UpdateAgentDTO,\n  CreateSkillDTO,\n  UpdateSkillDTO,\n  CreateMCPServerDTO,\n  UpdateMCPServerDTO,\n  CreateTaskDTO,\n  UpdateTaskDTO,\n} from '../types/index.js';\n\n// ============= HELPER FUNCTIONS =============\n\n/**\n * Generate a URL-friendly slug from a string\n * @param text - Input text to slugify\n * @returns Slugified string (lowercase, hyphens, no special chars)\n */\nfunction generateSlug(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '') // Remove special characters\n    .replace(/\\s+/g, '-')      // Replace spaces with hyphens\n    .replace(/-+/g, '-')       // Replace multiple hyphens with single hyphen\n    .replace(/^-+|-+$/g, '');  // Remove leading/trailing hyphens\n}\n\n// ============= CONFIGURATION =============\n\nconst STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';\nconst STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;\n\n// Cache configuration\nconst CACHE_TTL = 1000 * 60 * 5; // 5 minutes\nconst CACHE_MAX_SIZE = 100;\n\n// ============= STRAPI CLIENT CLASS =============\n\n/**\n * StrapiClient - Singleton service for Strapi API interactions\n *\n * Provides CRUD operations for all content types with built-in caching,\n * data transformation, and error handling.\n */\nexport class StrapiClient {\n  private client: AxiosInstance;\n  private cache: LRUCache<string, any>;\n\n  constructor() {\n    // Initialize axios client with base configuration\n    this.client = axios.create({\n      baseURL: `${STRAPI_URL}/api`,\n      headers: {\n        'Authorization': STRAPI_API_TOKEN ? `Bearer ${STRAPI_API_TOKEN}` : '',\n        'Content-Type': 'application/json',\n      },\n      timeout: 10000, // 10 seconds\n    });\n\n    // Initialize LRU cache\n    this.cache = new LRUCache({\n      max: CACHE_MAX_SIZE,\n      ttl: CACHE_TTL,\n      updateAgeOnGet: true, // Refresh TTL on access\n    });\n\n    // Add request interceptor for logging\n    this.client.interceptors.request.use(\n      (config: any) => {\n        console.log(`[Strapi] ${config.method?.toUpperCase()} ${config.url}`);\n        return config;\n      },\n      (error: any) => {\n        console.error('[Strapi] Request error:', error);\n        return Promise.reject(error);\n      }\n    );\n\n    // Add response interceptor for error handling\n    this.client.interceptors.response.use(\n      (response: any) => response,\n      (error: AxiosError) => {\n        this.handleError(error);\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  // ============= HEALTH CHECK =============\n\n  /**\n   * Check if Strapi API is accessible\n   * @returns Promise<boolean> - true if healthy, false otherwise\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      await this.client.get('/');\n      console.log('[Strapi] Health check passed');\n      return true;\n    } catch (error) {\n      console.error('[Strapi] Health check failed:', error);\n      return false;\n    }\n  }\n\n  // ============= AGENTS =============\n\n  /**\n   * Get all agents with optional filtering, sorting, and pagination\n   */\n  async getAllAgents(options?: {\n    populate?: string[];\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Agent[]> {\n    const cacheKey = `agents:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams(options);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/agents',\n      { params }\n    );\n\n    const agents = data.data.map((item: StrapiAttributes<any>) => this.transformAgent(item));\n\n    this.cache.set(cacheKey, agents);\n\n    return agents;\n  }\n\n  /**\n   * Get a single agent by ID with populated relations\n   * Updated to populate component fields (Strapi 5)\n   */\n  async getAgent(id: string): Promise<Agent> {\n    const cacheKey = `agent:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/agents/${id}`,\n      {\n        params: {\n          // Populate component fields and nested relations\n          populate: {\n            toolConfig: true,\n            modelConfig: true,\n            analytics: true,\n            metadata: true,\n            mcpConfig: {\n              populate: {\n                mcpServer: true,\n                selectedTools: {\n                  populate: { mcpTool: true },\n                },\n              },\n            },\n            skillSelection: {\n              populate: { skill: true },\n            },\n            tasks: {\n              populate: { task: true },\n            },\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Agent with ID ${id} not found`);\n    }\n\n    const agent = this.transformAgent(data.data);\n    this.cache.set(cacheKey, agent);\n\n    return agent;\n  }\n\n  /**\n   * Create a new agent\n   */\n  async createAgent(agentData: CreateAgentDTO): Promise<Agent> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/agents',\n      {\n        data: this.prepareAgentData(agentData as any),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create agent');\n    }\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n\n    return this.transformAgent(data.data);\n  }\n\n  /**\n   * Update an existing agent\n   */\n  async updateAgent(id: string, agentData: UpdateAgentDTO): Promise<Agent> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/agents/${id}`,\n      {\n        data: this.prepareAgentData(agentData as any),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update agent with ID ${id}`);\n    }\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n    this.cache.delete(`agent:${id}`);\n\n    return this.transformAgent(data.data);\n  }\n\n  /**\n   * Delete an agent\n   */\n  async deleteAgent(id: string): Promise<void> {\n    await this.client.delete(`/agents/${id}`);\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n    this.cache.delete(`agent:${id}`);\n  }\n\n  // ============= SKILLS =============\n\n  /**\n   * Get all skills with optional filtering\n   */\n  async getAllSkills(options?: {\n    populate?: string[];\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Skill[]> {\n    const cacheKey = `skills:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    // Always populate component fields for skills\n    const populateOptions = {\n      ...options,\n      populate: options?.populate || [\n        'toolConfig',\n        'modelConfig',\n        'analytics',\n        'mcpConfig.mcpServer',\n        'mcpConfig.selectedTools.mcpTool',\n        'agentSelection',\n        'trainingHistory',\n        'additionalFiles.file',  // Deep populate: component + file relation\n        'inputFields'\n      ],\n      // Default pagination to fetch all skills (max 100)\n      pagination: options?.pagination || { page: 1, pageSize: 100 }\n    };\n\n    const params = this.buildQueryParams(populateOptions);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/skills',\n      { params }\n    );\n\n    // DEBUG: Log raw Strapi response to check mcpConfig\n    console.log('[DEBUG] getAllSkills - Raw Strapi response (first item):', JSON.stringify(data.data[0], null, 2));\n    if (data.data[0]?.attributes) {\n      console.log('[DEBUG] getAllSkills - First item attributes keys:', Object.keys(data.data[0].attributes));\n      console.log('[DEBUG] getAllSkills - mcpConfig value:', (data.data[0].attributes as any).mcpConfig);\n    }\n\n    const skills = data.data.map((item: StrapiAttributes<any>) => this.transformSkill(item));\n    this.cache.set(cacheKey, skills);\n\n    return skills;\n  }\n\n  /**\n   * Get a single skill by ID\n   * Updated to populate component fields (Strapi 5)\n   */\n  async getSkill(id: string): Promise<Skill> {\n    const cacheKey = `skill:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/skills/${id}`,\n      {\n        params: {\n          // Populate component fields and nested relations\n          populate: {\n            trainingHistory: true,\n            additionalFiles: {\n              populate: { file: true }  // Populate file relation inside component\n            },\n            agentSelection: {\n              populate: { agent: true },\n            },\n            toolConfig: true,\n            modelConfig: true,\n            analytics: true,\n            mcpConfig: {\n              populate: {\n                mcpServer: true,\n                selectedTools: {\n                  populate: { mcpTool: true },\n                },\n              },\n            },\n            tasks: {\n              populate: { task: true },\n            },\n            inputFields: true,\n            trainingAgent: true,\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Skill with ID ${id} not found`);\n    }\n\n    const skill = this.transformSkill(data.data);\n    this.cache.set(cacheKey, skill);\n\n    return skill;\n  }\n\n  /**\n   * Get multiple skills by their IDs\n   */\n  async getSkillsByIds(ids: string[]): Promise<Skill[]> {\n    if (ids.length === 0) return [];\n\n    const filters = {\n      documentId: { $in: ids },\n    };\n\n    return this.getAllSkills({ filters });\n  }\n\n  /**\n   * Create a new skill\n   */\n  async createSkill(skillData: CreateSkillDTO): Promise<Skill> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/skills',\n      {\n        data: this.prepareSkillData(skillData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create skill');\n    }\n\n    this.invalidateCache('skills');\n    return this.transformSkill(data.data);\n  }\n\n  /**\n   * Update an existing skill\n   */\n  async updateSkill(id: string, skillData: UpdateSkillDTO): Promise<Skill> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/skills/${id}`,\n      {\n        data: this.prepareSkillData(skillData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update skill with ID ${id}`);\n    }\n\n    this.invalidateCache('skills');\n    this.cache.delete(`skill:${id}`);\n\n    return this.transformSkill(data.data);\n  }\n\n  /**\n   * Delete a skill\n   */\n  async deleteSkill(id: string): Promise<void> {\n    await this.client.delete(`/skills/${id}`);\n    this.invalidateCache('skills');\n    this.cache.delete(`skill:${id}`);\n  }\n\n  // ============= MCP SERVERS =============\n\n  /**\n   * Get all MCP servers with optional filtering\n   */\n  async getAllMCPServers(options?: {\n    filters?: Record<string, any>;\n    populate?: boolean;\n  }): Promise<MCPServer[]> {\n    const cacheKey = `mcp-servers:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams({\n      ...options,\n      populate: options?.populate ? ['mcpTools'] : undefined\n    });\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/mcp-servers',\n      { params }\n    );\n\n    const mcpServers = data.data.map((item: StrapiAttributes<any>) => this.transformMCPServer(item));\n    this.cache.set(cacheKey, mcpServers);\n\n    return mcpServers;\n  }\n\n  /**\n   * Get a single MCP server by ID\n   */\n  async getMCPServer(id: string): Promise<MCPServer> {\n    const cacheKey = `mcp-server:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/mcp-servers/${id}`,\n      {\n        params: { populate: '*' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`MCP Server with ID ${id} not found`);\n    }\n\n    const mcpServer = this.transformMCPServer(data.data);\n    this.cache.set(cacheKey, mcpServer);\n\n    return mcpServer;\n  }\n\n  /**\n   * Get multiple MCP servers by their IDs\n   */\n  async getMCPServersByIds(ids: string[]): Promise<MCPServer[]> {\n    if (ids.length === 0) return [];\n\n    const filters = {\n      documentId: { $in: ids },\n    };\n\n    return this.getAllMCPServers({ filters });\n  }\n\n  /**\n   * Create a new MCP server\n   */\n  async createMCPServer(mcpData: CreateMCPServerDTO): Promise<MCPServer> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/mcp-servers',\n      {\n        data: this.prepareMCPServerData(mcpData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create MCP server');\n    }\n\n    this.invalidateCache('mcp-servers');\n    return this.transformMCPServer(data.data);\n  }\n\n  /**\n   * Update an existing MCP server\n   */\n  async updateMCPServer(id: string, mcpData: UpdateMCPServerDTO): Promise<MCPServer> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/mcp-servers/${id}`,\n      {\n        data: this.prepareMCPServerData(mcpData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update MCP server with ID ${id}`);\n    }\n\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${id}`);\n\n    return this.transformMCPServer(data.data);\n  }\n\n  /**\n   * Delete an MCP server\n   */\n  async deleteMCPServer(id: string): Promise<void> {\n    await this.client.delete(`/mcp-servers/${id}`);\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${id}`);\n  }\n\n  /**\n   * Update MCP server tools (DEPRECATED - use bulkSyncMCPTools instead)\n   */\n  async updateMCPServerTools(id: string, tools: any[]): Promise<MCPServer> {\n    console.warn('updateMCPServerTools is deprecated, use bulkSyncMCPTools instead');\n    return this.bulkSyncMCPTools(id, tools);\n  }\n\n  // ============= MCP TOOLS =============\n\n  /**\n   * Get all tools for an MCP server\n   */\n  async getMCPToolsByServerId(serverId: string): Promise<MCPTool[]> {\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/mcp-tools',\n      {\n        params: {\n          filters: { mcpServer: { documentId: serverId } },\n        },\n      }\n    );\n\n    return data.data.map((item: StrapiAttributes<any>) => this.transformMCPTool(item));\n  }\n\n  /**\n   * Create a new MCP tool\n   */\n  async createMCPTool(serverId: string, toolData: {\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }): Promise<MCPTool> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/mcp-tools',\n      {\n        data: {\n          ...toolData,\n          mcpServer: serverId,\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create MCP tool');\n    }\n\n    return this.transformMCPTool(data.data);\n  }\n\n  /**\n   * Update an existing MCP tool\n   */\n  async updateMCPTool(toolId: string, toolData: {\n    name?: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }): Promise<MCPTool> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/mcp-tools/${toolId}`,\n      {\n        data: toolData,\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update MCP tool with ID ${toolId}`);\n    }\n\n    return this.transformMCPTool(data.data);\n  }\n\n  /**\n   * Delete an MCP tool\n   */\n  async deleteMCPTool(toolId: string): Promise<void> {\n    await this.client.delete(`/mcp-tools/${toolId}`);\n  }\n\n  /**\n   * Bulk sync MCP tools for a server\n   * Compares fetched tools with existing tools and performs create/update/delete operations\n   */\n  async bulkSyncMCPTools(serverId: string, fetchedTools: Array<{\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }>): Promise<MCPServer> {\n    // Get existing tools for this server\n    const existingTools = await this.getMCPToolsByServerId(serverId);\n\n    // Create a map of existing tools by name\n    const existingToolsMap = new Map(existingTools.map(t => [t.name, t]));\n\n    // Create a set of fetched tool names\n    const fetchedToolNames = new Set(fetchedTools.map(t => t.name));\n\n    // Delete tools that no longer exist\n    const toolsToDelete = existingTools.filter(t => !fetchedToolNames.has(t.name));\n    await Promise.all(toolsToDelete.map(t => this.deleteMCPTool(t.id)));\n\n    // Create or update tools\n    for (const fetchedTool of fetchedTools) {\n      const existingTool = existingToolsMap.get(fetchedTool.name);\n\n      if (existingTool) {\n        // Update if changed\n        const hasChanged =\n          existingTool.description !== fetchedTool.description ||\n          JSON.stringify(existingTool.inputSchema) !== JSON.stringify(fetchedTool.inputSchema);\n\n        if (hasChanged) {\n          await this.updateMCPTool(existingTool.id, fetchedTool);\n        }\n      } else {\n        // Create new tool\n        await this.createMCPTool(serverId, fetchedTool);\n      }\n    }\n\n    // Update toolsFetchedAt timestamp on the server\n    await this.client.put(`/mcp-servers/${serverId}`, {\n      data: {\n        toolsFetchedAt: new Date().toISOString(),\n      },\n    });\n\n    // Invalidate cache\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${serverId}`);\n\n    // Return updated server with tools\n    return this.getMCPServer(serverId);\n  }\n\n  // ============= FILE UPLOAD =============\n\n  /**\n   * Upload a file to Strapi Media Library\n   * @param file - File to upload (Buffer or Blob)\n   * @param filename - Original filename\n   * @returns Strapi media object with file ID and URL\n   */\n  async uploadFile(file: Buffer | Blob, filename: string): Promise<{\n    id: number;\n    documentId: string;\n    name: string;\n    url: string;\n    mime: string;\n    size: number;\n  }> {\n    const FormData = (await import('form-data')).default;\n    const formData = new FormData();\n\n    formData.append('files', file, filename);\n\n    const { data } = await this.client.post('/upload', formData, {\n      headers: {\n        ...formData.getHeaders(),\n      },\n    });\n\n    if (!data || !data[0]) {\n      throw new Error('Failed to upload file');\n    }\n\n    const uploadedFile = data[0];\n\n    return {\n      id: uploadedFile.id,\n      documentId: uploadedFile.documentId,\n      name: uploadedFile.name,\n      url: uploadedFile.url,\n      mime: uploadedFile.mime,\n      size: uploadedFile.size,\n    };\n  }\n\n  /**\n   * Delete a file from Strapi Media Library\n   * @param fileId - File ID to delete\n   */\n  async deleteFile(fileId: string): Promise<void> {\n    await this.client.delete(`/upload/files/${fileId}`);\n  }\n\n  // ============= TASKS =============\n\n  /**\n   * Get all tasks with optional filtering\n   */\n  async getAllTasks(options?: {\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Task[]> {\n    const cacheKey = `tasks:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams(options);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/tasks',\n      { params }\n    );\n\n    const tasks = data.data.map((item: StrapiAttributes<any>) => this.transformTask(item));\n    this.cache.set(cacheKey, tasks);\n\n    return tasks;\n  }\n\n  /**\n   * Get a single task by ID\n   */\n  async getTask(id: string): Promise<Task> {\n    const cacheKey = `task:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/tasks/${id}`,\n      {\n        params: { populate: 'agent' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Task with ID ${id} not found`);\n    }\n\n    const task = this.transformTask(data.data);\n    this.cache.set(cacheKey, task);\n\n    return task;\n  }\n\n  /**\n   * Create a new task\n   */\n  async createTask(taskData: CreateTaskDTO): Promise<Task> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/tasks',\n      {\n        data: this.prepareTaskData(taskData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create task');\n    }\n\n    this.invalidateCache('tasks');\n    return this.transformTask(data.data);\n  }\n\n  /**\n   * Update an existing task\n   */\n  async updateTask(id: string, taskData: UpdateTaskDTO): Promise<Task> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/tasks/${id}`,\n      {\n        data: this.prepareTaskData(taskData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update task with ID ${id}`);\n    }\n\n    this.invalidateCache('tasks');\n    this.cache.delete(`task:${id}`);\n\n    return this.transformTask(data.data);\n  }\n\n  /**\n   * Delete a task\n   */\n  async deleteTask(id: string): Promise<void> {\n    await this.client.delete(`/tasks/${id}`);\n    this.invalidateCache('tasks');\n    this.cache.delete(`task:${id}`);\n  }\n\n  // ============= TRANSFORMERS =============\n  // Transform Strapi response format to domain models\n\n  /**\n   * Helper to extract attributes from Strapi response\n   * Handles both nested (attributes) and flat formats\n   */\n  private extractAttributes(strapiData: any): any {\n    // If data has attributes property, use it (Strapi 5 default format)\n    if (strapiData.attributes) {\n      return strapiData.attributes;\n    }\n\n    // Otherwise, data is already flat (some Strapi configurations)\n    return strapiData;\n  }\n\n  /**\n   * Transform Strapi agent response to Agent domain model\n   * Updated for component-based structure (Strapi 5)\n   */\n  private transformAgent(strapiData: StrapiAttributes<any>): Agent {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      slug: attrs.slug,\n      description: attrs.description || '',\n      systemPrompt: attrs.systemPrompt,\n      enabled: attrs.enabled ?? true,\n\n      // Component fields - pass through as-is\n      toolConfig: attrs.toolConfig || undefined,\n      modelConfig: attrs.modelConfig || {\n        model: 'sonnet',\n        temperature: 1.0,\n        timeout: 300000,\n      },\n      analytics: attrs.analytics || undefined,\n      metadata: attrs.metadata || [],\n\n      // Component-based relations - pass through as-is\n      mcpConfig: attrs.mcpConfig || [],\n      skillSelection: attrs.skillSelection || [],\n      tasks: attrs.tasks || [],\n\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi skill response to Skill domain model\n   * Updated for component-based structure (Strapi 5)\n   */\n  private transformSkill(strapiData: StrapiAttributes<any>): Skill {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      displayName: attrs.displayName,\n      description: attrs.description,\n      skillmd: attrs.skillmd, // Correct field name\n      skillConfig: attrs.skillConfig || undefined, // Add skillConfig (replaces systemPromptPrefix)\n      experienceScore: attrs.experienceScore || 0,\n      category: attrs.category || 'custom',\n      isPublic: attrs.isPublic ?? true,\n      version: attrs.version || '1.0.0',\n      license: attrs.license || undefined,\n\n      // Component fields - pass through as-is\n      trainingHistory: attrs.trainingHistory || [],\n      additionalFiles: attrs.additionalFiles || [],\n      agentSelection: attrs.agentSelection || [],\n      toolConfig: attrs.toolConfig || undefined,\n      modelConfig: attrs.modelConfig || undefined,\n      analytics: attrs.analytics || undefined,\n      mcpConfig: attrs.mcpConfig || [],\n      tasks: attrs.tasks || [],\n      inputFields: attrs.inputFields || [],\n\n      // Direct relation\n      trainingAgent: attrs.trainingAgent?.data?.documentId || attrs.trainingAgent,\n\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi MCP server response to MCPServer domain model\n   */\n  private transformMCPServer(strapiData: StrapiAttributes<any>): MCPServer {\n    const attrs = this.extractAttributes(strapiData);\n\n    // Create config object based on transport type to match frontend expectations\n    const config: any = {\n      type: attrs.transport || 'stdio',\n      command: attrs.command,\n      args: attrs.args || [],\n      env: attrs.env || {},\n      disabled: attrs.disabled ?? false,\n    };\n\n    // Transform mcpTools if populated\n    let mcpTools: MCPTool[] | undefined;\n    if (attrs.mcpTools) {\n      if (Array.isArray(attrs.mcpTools)) {\n        mcpTools = attrs.mcpTools.map((tool: any) => this.transformMCPTool(tool));\n      } else if (attrs.mcpTools.data && Array.isArray(attrs.mcpTools.data)) {\n        mcpTools = attrs.mcpTools.data.map((tool: any) => this.transformMCPTool(tool));\n      }\n    }\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      config: config,\n      command: attrs.command,\n      description: attrs.description || '',\n      args: attrs.args || [],\n      env: attrs.env || {},\n      disabled: attrs.disabled ?? false,\n      transport: attrs.transport || 'stdio',\n      healthCheckUrl: attrs.healthCheckUrl,\n      isHealthy: attrs.isHealthy ?? true,\n      lastHealthCheck: attrs.lastHealthCheck ? new Date(attrs.lastHealthCheck) : undefined,\n      startupTimeout: attrs.startupTimeout || 30000,\n      restartPolicy: attrs.restartPolicy || 'on-failure',\n      toolsFetchedAt: attrs.toolsFetchedAt ? new Date(attrs.toolsFetchedAt) : undefined,\n      mcpTools: mcpTools,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    } as MCPServer;\n  }\n\n  /**\n   * Transform Strapi MCP tool response to MCPTool domain model\n   */\n  private transformMCPTool(strapiData: StrapiAttributes<any>): MCPTool {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      description: attrs.description || undefined,\n      inputSchema: attrs.inputSchema || undefined,\n      mcpServer: attrs.mcpServer?.documentId || attrs.mcpServer?.data?.documentId || undefined,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi task response to Task domain model\n   */\n  private transformTask(strapiData: StrapiAttributes<any>): Task {\n    const attrs = this.extractAttributes(strapiData);\n    const metadata = attrs.metadata || {};\n\n    return {\n      id: strapiData.documentId,\n      agentId: attrs.agent?.documentId || attrs.agent?.data?.documentId || attrs.agentId,\n      agentName: attrs.agent?.name || attrs.agent?.data?.name || undefined,\n      name: metadata.name || attrs.message || 'Unnamed Task',\n      description: metadata.description || undefined,\n      message: attrs.message,\n      status: attrs.status || 'pending',\n      result: attrs.result,\n      error: attrs.error,\n      startedAt: attrs.startedAt ? new Date(attrs.startedAt) : undefined,\n      completedAt: attrs.completedAt ? new Date(attrs.completedAt) : undefined,\n      executionTime: attrs.executionTime,\n      tokensUsed: attrs.tokensUsed,\n      cost: attrs.cost,\n      metadata: metadata,\n      executionLog: attrs.executionLog || [], // Include execution log for viewing\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  // ============= DATA PREPARERS =============\n  // Prepare domain models for Strapi API\n\n  /**\n   * Prepare agent data for Strapi API\n   * Updated for component-based structure (Strapi 5)\n   */\n  private prepareAgentData(agent: Partial<Agent>) {\n    const data: any = {\n      name: agent.name,\n      description: agent.description,\n      systemPrompt: agent.systemPrompt,\n      enabled: agent.enabled,\n    };\n\n    // Generate slug from name if name is provided\n    // Strapi's auto-generation doesn't always work with programmatic API calls\n    if (agent.name) {\n      data.slug = generateSlug(agent.name);\n    }\n\n    // Component fields - pass through as-is\n    if (agent.toolConfig) {\n      data.toolConfig = agent.toolConfig;\n    }\n\n    if (agent.modelConfig) {\n      data.modelConfig = agent.modelConfig;\n    }\n\n    if (agent.analytics) {\n      data.analytics = agent.analytics;\n    }\n\n    if (agent.metadata) {\n      data.metadata = agent.metadata;\n    }\n\n    // Component-based relations\n    if (agent.mcpConfig) {\n      data.mcpConfig = agent.mcpConfig;\n    }\n\n    if (agent.skillSelection) {\n      data.skillSelection = agent.skillSelection;\n    }\n\n    if (agent.tasks) {\n      data.tasks = agent.tasks;\n    }\n\n    return data;\n  }\n\n  /**\n   * Prepare skill data for Strapi API\n   * Updated for component-based structure (Strapi 5)\n   */\n  private prepareSkillData(skill: Partial<Skill>) {\n    const data: any = {\n      name: skill.name,\n      displayName: skill.displayName,\n      description: skill.description,\n      skillmd: skill.skillmd, // Correct field name\n      experienceScore: skill.experienceScore,\n      category: skill.category,\n      isPublic: skill.isPublic,\n      version: skill.version,\n      license: skill.license,\n    };\n\n    // Component fields\n    if (skill.trainingHistory) {\n      data.trainingHistory = skill.trainingHistory;\n    }\n\n    if (skill.additionalFiles) {\n      data.additionalFiles = skill.additionalFiles;\n    }\n\n    if (skill.agentSelection) {\n      data.agentSelection = skill.agentSelection;\n    }\n\n    if (skill.toolConfig) {\n      data.toolConfig = skill.toolConfig;\n    }\n\n    if (skill.modelConfig) {\n      data.modelConfig = skill.modelConfig;\n    }\n\n    if (skill.analytics) {\n      data.analytics = skill.analytics;\n    }\n\n    if (skill.mcpConfig) {\n      data.mcpConfig = skill.mcpConfig;\n    }\n\n    if (skill.tasks) {\n      data.tasks = skill.tasks;\n    }\n\n    if (skill.inputFields) {\n      data.inputFields = skill.inputFields;\n    }\n\n    // Direct relation\n    if (skill.trainingAgent) {\n      data.trainingAgent = skill.trainingAgent;\n    }\n\n    return data;\n  }\n\n  /**\n   * Prepare MCP server data for Strapi API\n   */\n  private prepareMCPServerData(mcp: Partial<MCPServer>) {\n    return {\n      name: mcp.name,\n      command: mcp.command,\n      description: mcp.description,\n      args: mcp.args,\n      env: mcp.env,\n      disabled: mcp.disabled,\n      transport: mcp.transport,\n      healthCheckUrl: mcp.healthCheckUrl,\n      startupTimeout: mcp.startupTimeout,\n      restartPolicy: mcp.restartPolicy,\n    };\n  }\n\n  /**\n   * Prepare task data for Strapi API\n   */\n  private prepareTaskData(task: Partial<Task>) {\n    return {\n      agent: task.agentId,  // Strapi expects 'agent' relation field\n      message: task.message,\n      status: task.status,\n      result: task.result,\n      error: task.error,\n      startedAt: task.startedAt instanceof Date ? task.startedAt.toISOString() : task.startedAt,\n      completedAt: task.completedAt instanceof Date ? task.completedAt.toISOString() : task.completedAt,\n      executionTime: task.executionTime,\n      tokensUsed: task.tokensUsed,\n      cost: task.cost,\n      metadata: task.metadata,\n      executionLog: task.executionLog, // Include execution log for viewing\n    };\n  }\n\n  // ============= QUERY BUILDERS =============\n\n  /**\n   * Build Strapi query parameters from options\n   */\n  private buildQueryParams(options?: {\n    populate?: string[];\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Record<string, any> {\n    const params: Record<string, any> = {};\n\n    if (options?.populate) {\n      // Strapi v5 requires array bracket notation: populate[0]=field1&populate[1]=field2\n      // Pass array directly, axios will serialize it correctly\n      params.populate = options.populate;\n    }\n\n    if (options?.filters) {\n      params.filters = options.filters;\n    }\n\n    if (options?.sort) {\n      params.sort = options.sort;\n    }\n\n    if (options?.pagination) {\n      params.pagination = options.pagination;\n    }\n\n    return params;\n  }\n\n  // ============= CACHE MANAGEMENT =============\n\n  /**\n   * Invalidate all cache entries with a given prefix\n   */\n  private invalidateCache(prefix: string) {\n    const keys = Array.from(this.cache.keys());\n    let invalidatedCount = 0;\n\n    for (const key of keys) {\n      if (typeof key === 'string' && key.startsWith(prefix)) {\n        this.cache.delete(key);\n        invalidatedCount++;\n      }\n    }\n\n    if (invalidatedCount > 0) {\n      console.log(`[Strapi] Invalidated ${invalidatedCount} cache entries with prefix \"${prefix}\"`);\n    }\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clearCache() {\n    const size = this.cache.size;\n    this.cache.clear();\n    console.log(`[Strapi] Cleared ${size} cache entries`);\n  }\n\n  /**\n   * Get current cache statistics\n   */\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      max: this.cache.max,\n      ttl: this.cache.ttl,\n    };\n  }\n\n  // ============= ERROR HANDLING =============\n\n  /**\n   * Handle axios errors with detailed logging\n   */\n  private handleError(error: AxiosError) {\n    if (error.response) {\n      // Server responded with error status\n      console.error('[Strapi] Response error:', {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data,\n        url: error.config?.url,\n      });\n    } else if (error.request) {\n      // Request made but no response\n      console.error('[Strapi] No response received:', {\n        message: error.message,\n        url: error.config?.url,\n      });\n    } else {\n      // Error in request setup\n      console.error('[Strapi] Request setup error:', {\n        message: error.message,\n        url: error.config?.url,\n      });\n    }\n  }\n}\n\n// ============= SINGLETON EXPORT =============\n\n/**\n * Singleton instance of StrapiClient\n * Use this throughout the application for all Strapi interactions\n */\nexport const strapiClient = new StrapiClient();\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "/**\n * Claude Agent UI - Strapi Client Service\n *\n * This service provides a data access layer for interacting with the Strapi CMS API.\n * It handles HTTP communication, caching, and data transformation between Strapi's\n * response format and the application's domain models.\n *\n * Features:\n * - HTTP client with axios\n * - LRU cache with 5-minute TTL\n * - Request/response interceptors for logging\n * - Automatic data transformation\n * - Cache invalidation on mutations\n * - Error handling with detailed logging\n * - Support for populate, filters, sort, pagination\n * - Health check endpoint\n */\n\nimport axios, { AxiosInstance, AxiosError } from 'axios';\nimport { LRUCache } from 'lru-cache';\nimport type {\n  Agent,\n  Skill,\n  MCPServer,\n  MCPTool,\n  Task,\n  StrapiAttributes,\n  StrapiResponse,\n  StrapiData,\n  StrapiQueryParams,\n  CreateAgentDTO,\n  UpdateAgentDTO,\n  CreateSkillDTO,\n  UpdateSkillDTO,\n  CreateMCPServerDTO,\n  UpdateMCPServerDTO,\n  CreateTaskDTO,\n  UpdateTaskDTO,\n} from '../types/index.js';\n\n// ============= HELPER FUNCTIONS =============\n\n/**\n * Generate a URL-friendly slug from a string\n * @param text - Input text to slugify\n * @returns Slugified string (lowercase, hyphens, no special chars)\n */\nfunction generateSlug(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '') // Remove special characters\n    .replace(/\\s+/g, '-')      // Replace spaces with hyphens\n    .replace(/-+/g, '-')       // Replace multiple hyphens with single hyphen\n    .replace(/^-+|-+$/g, '');  // Remove leading/trailing hyphens\n}\n\n// ============= CONFIGURATION =============\n\n/**\n * Strapi API base URL\n * @description Configure via STRAPI_URL environment variable\n * @default 'http://localhost:1337'\n * @example\n * // In .env file:\n * STRAPI_URL=https://cms.example.com\n */\nconst STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';\n\n/**\n * Strapi API authentication token\n * @description Configure via STRAPI_API_TOKEN environment variable.\n * Generate tokens in Strapi Admin Panel: Settings > API Tokens > Create new API Token\n * @required Required for all API requests\n * @example\n * // In .env file:\n * STRAPI_API_TOKEN=your_strapi_api_token_here\n */\nconst STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;\n\n/**\n * Cache Time-To-Live (TTL) in milliseconds\n * @description How long cache entries remain valid before automatic expiration.\n * Cache entries are refreshed on access (updateAgeOnGet: true)\n * @default 300000 (5 minutes)\n */\nconst CACHE_TTL = 1000 * 60 * 5; // 5 minutes\n\n/**\n * Maximum number of cache entries\n * @description LRU cache evicts least recently used entries when limit is reached\n * @default 100\n */\nconst CACHE_MAX_SIZE = 100;\n\n// ============= STRAPI CLIENT CLASS =============\n\n/**\n * StrapiClient - Singleton service for Strapi API interactions\n *\n * @description\n * The StrapiClient provides a robust data access layer for the Strapi CMS API, handling\n * all HTTP communication, caching, and data transformation between Strapi's response format\n * and the application's domain models. It implements the singleton pattern to ensure a single\n * shared instance with consistent caching across the application.\n *\n * **Key Features:**\n * - HTTP client with axios and Bearer token authentication\n * - LRU cache with 5-minute TTL and automatic cache invalidation on mutations\n * - Request/response interceptors for logging and error handling\n * - Automatic data transformation between Strapi format and domain models\n * - Support for Strapi v5 features (populate, filters, sort, pagination, components)\n * - Health check endpoint for API availability monitoring\n * - CRUD operations for Agents, Skills, MCP Servers, MCP Tools, Tasks\n * - File upload/delete operations\n * - Cache management utilities\n *\n * **Environment Variables:**\n * - `STRAPI_URL`: Base URL for Strapi API (default: 'http://localhost:1337')\n * - `STRAPI_API_TOKEN`: Bearer token for API authentication (required)\n *\n * **Cache Configuration:**\n * - TTL: 5 minutes (300000ms) with refresh on access\n * - Max Size: 100 entries (LRU eviction)\n * - Automatic invalidation on mutations (create/update/delete)\n * - Manual cache management via clearCache() and getCacheStats()\n *\n * @example\n * // Basic usage - use the singleton instance\n * import { strapiClient } from './strapi-client';\n *\n * // Check API health\n * const isHealthy = await strapiClient.healthCheck();\n *\n * // Fetch all agents\n * const agents = await strapiClient.getAllAgents();\n *\n * @example\n * // Advanced filtering and population\n * import { strapiClient } from './strapi-client';\n *\n * // Get agents with custom filters and populated relations\n * const activeAgents = await strapiClient.getAllAgents({\n *   filters: { enabled: true },\n *   populate: ['mcpConfig', 'skillSelection', 'tasks'],\n *   sort: ['name:asc'],\n *   pagination: { page: 1, pageSize: 10 }\n * });\n *\n * // Get a single agent with all relations populated\n * const agent = await strapiClient.getAgent('agent-id');\n * console.log(agent.mcpConfig); // Populated component data\n *\n * @example\n * // CRUD operations\n * import { strapiClient } from './strapi-client';\n *\n * // Create a new agent\n * const newAgent = await strapiClient.createAgent({\n *   name: 'Code Assistant',\n *   description: 'Helps with coding tasks',\n *   systemPrompt: 'You are a helpful coding assistant.',\n *   enabled: true,\n *   modelConfig: {\n *     model: 'sonnet',\n *     temperature: 1.0,\n *     timeout: 300000\n *   }\n * });\n *\n * // Update the agent\n * const updatedAgent = await strapiClient.updateAgent(newAgent.id, {\n *   description: 'Updated description'\n * });\n *\n * // Delete the agent\n * await strapiClient.deleteAgent(newAgent.id);\n *\n * @example\n * // Cache management\n * import { strapiClient } from './strapi-client';\n *\n * // Get cache statistics\n * const stats = strapiClient.getCacheStats();\n * console.log(`Cache: ${stats.size}/${stats.max} entries, TTL: ${stats.ttl}ms`);\n *\n * // Clear all cache entries\n * strapiClient.clearCache();\n *\n * @example\n * // File upload workflow\n * import { strapiClient } from './strapi-client';\n * import fs from 'fs';\n *\n * // Upload a file\n * const fileBuffer = fs.readFileSync('./example.pdf');\n * const uploadedFile = await strapiClient.uploadFile(fileBuffer, 'example.pdf');\n * console.log(`File uploaded: ${uploadedFile.url}`);\n *\n * // Use the file in a skill's additionalFiles\n * const skill = await strapiClient.createSkill({\n *   name: 'example-skill',\n *   displayName: 'Example Skill',\n *   description: 'A skill with an additional file',\n *   skillmd: '# Skill content',\n *   additionalFiles: [\n *     { file: uploadedFile.documentId }\n *   ]\n * });\n *\n * // Delete the file when no longer needed\n * await strapiClient.deleteFile(uploadedFile.documentId);\n *\n * @see {@link https://docs.strapi.io/dev-docs/api/rest|Strapi REST API Documentation}\n * @see {@link https://github.com/isaacs/node-lru-cache|LRU Cache Documentation}\n */\nexport class StrapiClient {\n  /** Axios HTTP client instance configured with base URL and authentication */\n  private client: AxiosInstance;\n\n  /** LRU cache for GET responses with 5-minute TTL and 100-entry limit */\n  private cache: LRUCache<string, any>;\n\n  constructor() {\n    // Initialize axios client with base configuration\n    this.client = axios.create({\n      baseURL: `${STRAPI_URL}/api`,\n      headers: {\n        'Authorization': STRAPI_API_TOKEN ? `Bearer ${STRAPI_API_TOKEN}` : '',\n        'Content-Type': 'application/json',\n      },\n      timeout: 10000, // 10 seconds\n    });\n\n    // Initialize LRU cache\n    this.cache = new LRUCache({\n      max: CACHE_MAX_SIZE,\n      ttl: CACHE_TTL,\n      updateAgeOnGet: true, // Refresh TTL on access\n    });\n\n    // Add request interceptor for logging\n    this.client.interceptors.request.use(\n      (config: any) => {\n        console.log(`[Strapi] ${config.method?.toUpperCase()} ${config.url}`);\n        return config;\n      },\n      (error: any) => {\n        console.error('[Strapi] Request error:', error);\n        return Promise.reject(error);\n      }\n    );\n\n    // Add response interceptor for error handling\n    this.client.interceptors.response.use(\n      (response: any) => response,\n      (error: AxiosError) => {\n        this.handleError(error);\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  // ============= HEALTH CHECK =============\n\n  /**\n   * Check if Strapi API is accessible and responding\n   *\n   * @description\n   * Performs a health check by making a request to the Strapi API root endpoint.\n   * Use this method to verify API connectivity before performing operations, especially\n   * during application startup or when debugging connection issues.\n   *\n   * **Use Cases:**\n   * - Application startup validation\n   * - Periodic monitoring of Strapi availability\n   * - Pre-flight checks before critical operations\n   * - Debugging connection issues (CORS, network, authentication)\n   *\n   * **What This Checks:**\n   * - Network connectivity to Strapi server\n   * - Strapi server is running and responding\n   * - API token authentication is valid (if configured)\n   * - No CORS issues (for browser environments)\n   *\n   * @returns {Promise<boolean>} `true` if Strapi API is accessible and healthy, `false` if check fails\n   *\n   * @example\n   * // Basic health check\n   * const isHealthy = await strapiClient.healthCheck();\n   *\n   * if (isHealthy) {\n   *   console.log('Strapi API is healthy');\n   * } else {\n   *   console.error('Strapi API is unavailable');\n   * }\n   *\n   * @example\n   * // Application startup validation\n   * async function initializeApp() {\n   *   console.log('Checking Strapi connection...');\n   *\n   *   const isHealthy = await strapiClient.healthCheck();\n   *\n   *   if (!isHealthy) {\n   *     console.error('ERROR: Cannot connect to Strapi API');\n   *     console.error(`STRAPI_URL: ${process.env.STRAPI_URL || 'http://localhost:1337'}`);\n   *     console.error('Please ensure Strapi is running and STRAPI_URL is correct');\n   *     process.exit(1);\n   *   }\n   *\n   *   console.log('Strapi connection successful');\n   *   // Continue with app initialization\n   * }\n   *\n   * @example\n   * // Retry logic with health check\n   * async function connectWithRetry(maxRetries = 3) {\n   *   for (let i = 0; i < maxRetries; i++) {\n   *     const isHealthy = await strapiClient.healthCheck();\n   *\n   *     if (isHealthy) {\n   *       console.log('Connected to Strapi');\n   *       return true;\n   *     }\n   *\n   *     console.warn(`Connection attempt ${i + 1}/${maxRetries} failed`);\n   *\n   *     if (i < maxRetries - 1) {\n   *       await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s\n   *     }\n   *   }\n   *\n   *   console.error('Failed to connect to Strapi after retries');\n   *   return false;\n   * }\n   *\n   * @example\n   * // Periodic health monitoring\n   * setInterval(async () => {\n   *   const isHealthy = await strapiClient.healthCheck();\n   *\n   *   if (!isHealthy) {\n   *     console.error('[Monitor] Strapi API is down!');\n   *     // Send alert, update status indicator, etc.\n   *   }\n   * }, 60000); // Check every minute\n   *\n   * @example\n   * // Pre-flight check before critical operation\n   * async function syncAllData() {\n   *   // Check API health before starting sync\n   *   if (!await strapiClient.healthCheck()) {\n   *     throw new Error('Cannot sync: Strapi API is unavailable');\n   *   }\n   *\n   *   // Proceed with sync\n   *   const agents = await strapiClient.getAllAgents();\n   *   const skills = await strapiClient.getAllSkills();\n   *   // ... sync logic\n   * }\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      await this.client.get('/');\n      console.log('[Strapi] Health check passed');\n      return true;\n    } catch (error) {\n      console.error('[Strapi] Health check failed:', error);\n      return false;\n    }\n  }\n\n  // ============= AGENTS =============\n\n  /**\n   * Get all agents with optional filtering, sorting, and pagination\n   *\n   * @description\n   * Retrieves all agents from Strapi with support for advanced query features including\n   * filtering, sorting, pagination, and relation population. Results are cached with 5-minute\n   * TTL for improved performance on repeated queries.\n   *\n   * **Strapi v5 Component Support:**\n   * Agents use component-based architecture. The following component fields are available:\n   * - `toolConfig`: Tool configuration component (file_search, text_editor, computer_20241022, bash_20241022)\n   * - `modelConfig`: Model configuration component (model, temperature, timeout, etc.)\n   * - `analytics`: Analytics component (usage stats, performance metrics)\n   * - `metadata`: Key-value metadata pairs\n   * - `mcpConfig`: MCP server configuration components (array of mcpServer + selectedTools)\n   * - `skillSelection`: Skill selection components (array of skill references)\n   * - `tasks`: Task assignment components (array of task references)\n   *\n   * @param {Object} [options] - Query options for filtering, sorting, and pagination\n   * @param {string[]} [options.populate] - Relations/components to populate (e.g., ['mcpConfig', 'skillSelection'])\n   * @param {Record<string, any>} [options.filters] - Strapi v5 filters object (supports $eq, $ne, $in, $notIn, $lt, $lte, $gt, $gte, $contains, $notContains, $containsi, $notContainsi, $null, $notNull, $between, $startsWith, $endsWith, $or, $and, $not)\n   * @param {string[]} [options.sort] - Sort order array (e.g., ['name:asc', 'createdAt:desc'])\n   * @param {Object} [options.pagination] - Pagination configuration\n   * @param {number} [options.pagination.page] - Page number (1-indexed)\n   * @param {number} [options.pagination.pageSize] - Number of items per page\n   *\n   * @returns {Promise<Agent[]>} Array of Agent objects with populated component fields\n   *\n   * @example\n   * // Basic usage - get all agents\n   * const agents = await strapiClient.getAllAgents();\n   * console.log(`Found ${agents.length} agents`);\n   *\n   * @example\n   * // Filter enabled agents only\n   * const enabledAgents = await strapiClient.getAllAgents({\n   *   filters: { enabled: { $eq: true } }\n   * });\n   *\n   * @example\n   * // Advanced filtering with multiple conditions\n   * const filteredAgents = await strapiClient.getAllAgents({\n   *   filters: {\n   *     $and: [\n   *       { enabled: { $eq: true } },\n   *       { name: { $containsi: 'assistant' } }, // Case-insensitive contains\n   *       { createdAt: { $gte: '2024-01-01T00:00:00.000Z' } }\n   *     ]\n   *   },\n   *   sort: ['name:asc'],\n   *   pagination: { page: 1, pageSize: 10 }\n   * });\n   *\n   * @example\n   * // Populate component relations to access nested data\n   * const agentsWithRelations = await strapiClient.getAllAgents({\n   *   populate: ['mcpConfig', 'skillSelection', 'tasks'],\n   *   filters: { enabled: true }\n   * });\n   *\n   * // Access populated component data\n   * agentsWithRelations.forEach(agent => {\n   *   console.log(`Agent: ${agent.name}`);\n   *   console.log(`MCP Servers: ${agent.mcpConfig?.length || 0}`);\n   *   console.log(`Skills: ${agent.skillSelection?.length || 0}`);\n   *   console.log(`Model: ${agent.modelConfig?.model}`);\n   * });\n   *\n   * @example\n   * // Search agents by name with case-insensitive matching\n   * const searchResults = await strapiClient.getAllAgents({\n   *   filters: {\n   *     $or: [\n   *       { name: { $containsi: 'code' } },\n   *       { description: { $containsi: 'code' } }\n   *     ]\n   *   }\n   * });\n   *\n   * @example\n   * // Get agents with specific model configuration\n   * const sonnetAgents = await strapiClient.getAllAgents({\n   *   filters: {\n   *     'modelConfig.model': { $eq: 'sonnet' }\n   *   }\n   * });\n   *\n   * @example\n   * // Pagination - get second page of 20 agents\n   * const page2 = await strapiClient.getAllAgents({\n   *   pagination: { page: 2, pageSize: 20 },\n   *   sort: ['updatedAt:desc'] // Most recently updated first\n   * });\n   */\n  async getAllAgents(options?: {\n    populate?: string[] | Record<string, any>;\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Agent[]> {\n    const cacheKey = `agents:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams(options);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/agents',\n      { params }\n    );\n\n    const agents = data.data.map((item: StrapiAttributes<any>) => this.transformAgent(item));\n\n    this.cache.set(cacheKey, agents);\n\n    return agents;\n  }\n\n  /**\n   * Get a single agent by ID with all relations and components populated\n   *\n   * @description\n   * Retrieves a single agent by its unique document ID with deep population of all\n   * component fields and relations. This method automatically populates all nested data\n   * including MCP server configurations, skill selections, and task assignments.\n   *\n   * **Auto-populated Components:**\n   * - `toolConfig`: Tool configuration with enabled tools\n   * - `modelConfig`: Model configuration (model, temperature, timeout)\n   * - `analytics`: Usage analytics and performance metrics\n   * - `metadata`: Custom key-value metadata pairs\n   * - `mcpConfig`: MCP server configurations with nested mcpServer and selectedTools.mcpTool relations\n   * - `skillSelection`: Skill selections with nested skill relations\n   * - `tasks`: Task assignments with nested task relations\n   *\n   * **Strapi v5 Deep Population:**\n   * This method uses deep population syntax to retrieve nested relations within components:\n   * ```javascript\n   * mcpConfig: {\n   *   populate: {\n   *     mcpServer: true,           // Populate mcpServer relation\n   *     selectedTools: {\n   *       populate: { mcpTool: true }  // Populate mcpTool within selectedTools\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @param {string} id - Agent document ID (UUID format)\n   *\n   * @returns {Promise<Agent>} Agent object with all components and relations populated\n   *\n   * @throws {Error} If agent with the specified ID is not found\n   *\n   * @example\n   * // Basic usage - get agent with all relations\n   * const agent = await strapiClient.getAgent('abc123-def456-ghi789');\n   * console.log(agent.name);\n   * console.log(agent.systemPrompt);\n   * console.log(agent.modelConfig?.model); // 'sonnet' | 'haiku' | 'opus'\n   *\n   * @example\n   * // Access MCP server configuration\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * // mcpConfig is an array of components\n   * agent.mcpConfig?.forEach(config => {\n   *   console.log(`MCP Server: ${config.mcpServer?.name}`);\n   *   console.log(`Transport: ${config.mcpServer?.transport}`);\n   *\n   *   // Access selected tools (nested population)\n   *   config.selectedTools?.forEach(toolSelection => {\n   *     console.log(`  Tool: ${toolSelection.mcpTool?.name}`);\n   *     console.log(`  Description: ${toolSelection.mcpTool?.description}`);\n   *   });\n   * });\n   *\n   * @example\n   * // Access skill selection\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * // skillSelection is an array of components\n   * agent.skillSelection?.forEach(selection => {\n   *   const skill = selection.skill; // Populated skill relation\n   *   console.log(`Skill: ${skill?.displayName}`);\n   *   console.log(`Description: ${skill?.description}`);\n   * });\n   *\n   * @example\n   * // Access tool configuration component\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * if (agent.toolConfig) {\n   *   console.log('Enabled tools:');\n   *   if (agent.toolConfig.file_search) console.log('  - File Search');\n   *   if (agent.toolConfig.text_editor) console.log('  - Text Editor');\n   *   if (agent.toolConfig.computer_20241022) console.log('  - Computer Use');\n   *   if (agent.toolConfig.bash_20241022) console.log('  - Bash');\n   * }\n   *\n   * @example\n   * // Access model configuration component\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * const config = agent.modelConfig;\n   * console.log(`Model: ${config?.model || 'sonnet'}`);\n   * console.log(`Temperature: ${config?.temperature || 1.0}`);\n   * console.log(`Max tokens: ${config?.max_tokens || 4096}`);\n   * console.log(`Timeout: ${config?.timeout || 300000}ms`);\n   *\n   * @example\n   * // Error handling for non-existent agent\n   * try {\n   *   const agent = await strapiClient.getAgent('non-existent-id');\n   * } catch (error) {\n   *   console.error('Agent not found:', error.message);\n   *   // Error: Agent with ID non-existent-id not found\n   * }\n   *\n   * @example\n   * // Check agent enabled status before use\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * if (!agent.enabled) {\n   *   console.warn(`Agent \"${agent.name}\" is disabled`);\n   *   return;\n   * }\n   *\n   * // Use agent for conversation...\n   *\n   * @see {@link getAllAgents} for querying multiple agents with filters\n   */\n  async getAgent(id: string): Promise<Agent> {\n    const cacheKey = `agent:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/agents/${id}`,\n      {\n        params: {\n          // Populate component fields and nested relations\n          populate: {\n            toolConfig: true,\n            modelConfig: true,\n            analytics: true,\n            metadata: true,\n            mcpConfig: {\n              populate: {\n                mcpServer: true,\n                selectedTools: {\n                  populate: { mcpTool: true },\n                },\n              },\n            },\n            skillSelection: {\n              populate: { skill: true },\n            },\n            tasks: {\n              populate: { task: true },\n            },\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Agent with ID ${id} not found`);\n    }\n\n    const agent = this.transformAgent(data.data);\n    this.cache.set(cacheKey, agent);\n\n    return agent;\n  }\n\n  /**\n   * Create a new agent with component-based configuration\n   *\n   * @description\n   * Creates a new agent in Strapi with support for component-based architecture.\n   * The agent slug is automatically generated from the name. All component fields\n   * (toolConfig, modelConfig, mcpConfig, etc.) are supported in Strapi v5 format.\n   *\n   * **Component Fields:**\n   * - `toolConfig`: Configure enabled tools (file_search, text_editor, computer_20241022, bash_20241022)\n   * - `modelConfig`: Configure model settings (model, temperature, max_tokens, timeout)\n   * - `analytics`: Initialize analytics tracking\n   * - `metadata`: Add custom key-value metadata pairs\n   * - `mcpConfig`: Configure MCP servers (array of { mcpServer: id, selectedTools: [...] })\n   * - `skillSelection`: Assign skills (array of { skill: id })\n   * - `tasks`: Assign tasks (array of { task: id })\n   *\n   * **Cache Invalidation:**\n   * Creating an agent invalidates all cached agent queries to ensure fresh data.\n   *\n   * @param {CreateAgentDTO} agentData - Agent data transfer object\n   * @param {string} agentData.name - Agent name (required, used to generate slug)\n   * @param {string} [agentData.description] - Agent description\n   * @param {string} agentData.systemPrompt - System prompt for the agent (required)\n   * @param {boolean} [agentData.enabled=true] - Whether the agent is enabled\n   * @param {Object} [agentData.toolConfig] - Tool configuration component\n   * @param {Object} [agentData.modelConfig] - Model configuration component\n   * @param {Object} [agentData.analytics] - Analytics component\n   * @param {Array} [agentData.metadata] - Metadata key-value pairs\n   * @param {Array} [agentData.mcpConfig] - MCP server configuration components\n   * @param {Array} [agentData.skillSelection] - Skill selection components\n   * @param {Array} [agentData.tasks] - Task assignment components\n   *\n   * @returns {Promise<Agent>} Created agent with generated ID and auto-populated defaults\n   *\n   * @throws {Error} If agent creation fails (validation errors, network errors)\n   *\n   * @example\n   * // Basic agent creation with minimal fields\n   * const agent = await strapiClient.createAgent({\n   *   name: 'Code Assistant',\n   *   description: 'Helps with coding tasks',\n   *   systemPrompt: 'You are a helpful coding assistant specialized in TypeScript and React.',\n   *   enabled: true\n   * });\n   *\n   * console.log(agent.id);   // Auto-generated UUID\n   * console.log(agent.slug); // Auto-generated: 'code-assistant'\n   * console.log(agent.modelConfig); // Default: { model: 'sonnet', temperature: 1.0, timeout: 300000 }\n   *\n   * @example\n   * // Create agent with custom model configuration\n   * const agent = await strapiClient.createAgent({\n   *   name: 'Fast Assistant',\n   *   systemPrompt: 'You are a quick assistant for simple tasks.',\n   *   modelConfig: {\n   *     model: 'haiku',\n   *     temperature: 0.7,\n   *     max_tokens: 2048,\n   *     timeout: 60000\n   *   }\n   * });\n   *\n   * @example\n   * // Create agent with specific tools enabled\n   * const agent = await strapiClient.createAgent({\n   *   name: 'File Manager',\n   *   systemPrompt: 'You help users manage and search files.',\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: true,\n   *     bash_20241022: false,\n   *     computer_20241022: false\n   *   }\n   * });\n   *\n   * @example\n   * // Create agent with MCP server configuration\n   * // First, ensure MCP servers exist in Strapi\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const filesystemServer = mcpServers.find(s => s.name === 'filesystem');\n   * const filesystemTools = await strapiClient.getMCPToolsByServerId(filesystemServer.id);\n   *\n   * const agent = await strapiClient.createAgent({\n   *   name: 'File Assistant',\n   *   systemPrompt: 'You help users with file operations.',\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: filesystemServer.id,\n   *       selectedTools: filesystemTools.slice(0, 3).map(tool => ({\n   *         mcpTool: tool.id\n   *       }))\n   *     }\n   *   ]\n   * });\n   *\n   * @example\n   * // Create agent with skill selection\n   * const skills = await strapiClient.getAllSkills();\n   * const codingSkill = skills.find(s => s.name === 'typescript-expert');\n   *\n   * const agent = await strapiClient.createAgent({\n   *   name: 'TypeScript Expert',\n   *   systemPrompt: 'You are a TypeScript expert.',\n   *   skillSelection: [\n   *     { skill: codingSkill.id }\n   *   ]\n   * });\n   *\n   * @example\n   * // Create agent with custom metadata\n   * const agent = await strapiClient.createAgent({\n   *   name: 'Research Assistant',\n   *   systemPrompt: 'You help with research tasks.',\n   *   metadata: [\n   *     { key: 'department', value: 'Engineering' },\n   *     { key: 'priority', value: 'high' },\n   *     { key: 'version', value: '2.0' }\n   *   ]\n   * });\n   *\n   * @example\n   * // Error handling for validation failures\n   * try {\n   *   const agent = await strapiClient.createAgent({\n   *     name: '', // Invalid: empty name\n   *     systemPrompt: 'Test prompt'\n   *   });\n   * } catch (error) {\n   *   console.error('Validation failed:', error.message);\n   * }\n   *\n   * @see {@link updateAgent} for updating existing agents\n   * @see {@link getAgent} for retrieving created agent with full details\n   */\n  async createAgent(agentData: CreateAgentDTO): Promise<Agent> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/agents',\n      {\n        data: this.prepareAgentData(agentData as any),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create agent');\n    }\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n\n    return this.transformAgent(data.data);\n  }\n\n  /**\n   * Update an existing agent with partial data\n   *\n   * @description\n   * Updates an existing agent in Strapi using partial update semantics. Only the fields\n   * provided in the update DTO will be modified; omitted fields remain unchanged. This\n   * method supports updating all component fields and relations in Strapi v5 format.\n   *\n   * **Partial Updates:**\n   * You can update individual fields without affecting other fields:\n   * - Update only `name` without changing `systemPrompt`\n   * - Update only `modelConfig` without changing `toolConfig`\n   * - Update only specific tools within `mcpConfig` arrays\n   *\n   * **Component Field Updates:**\n   * - `toolConfig`: Update tool enablement settings\n   * - `modelConfig`: Update model configuration (temperature, timeout, etc.)\n   * - `analytics`: Update analytics data\n   * - `metadata`: Replace or append metadata pairs\n   * - `mcpConfig`: Replace MCP server configurations (array replacement)\n   * - `skillSelection`: Replace skill selections (array replacement)\n   * - `tasks`: Replace task assignments (array replacement)\n   *\n   * **Cache Invalidation:**\n   * Updating an agent invalidates both the specific agent cache and all agent list caches.\n   *\n   * @param {string} id - Agent document ID to update\n   * @param {UpdateAgentDTO} agentData - Partial agent data to update\n   * @param {string} [agentData.name] - Update agent name (updates slug automatically)\n   * @param {string} [agentData.description] - Update description\n   * @param {string} [agentData.systemPrompt] - Update system prompt\n   * @param {boolean} [agentData.enabled] - Update enabled status\n   * @param {Object} [agentData.toolConfig] - Update tool configuration\n   * @param {Object} [agentData.modelConfig] - Update model configuration\n   * @param {Object} [agentData.analytics] - Update analytics\n   * @param {Array} [agentData.metadata] - Replace metadata (not merged)\n   * @param {Array} [agentData.mcpConfig] - Replace MCP config (not merged)\n   * @param {Array} [agentData.skillSelection] - Replace skill selection (not merged)\n   * @param {Array} [agentData.tasks] - Replace task assignments (not merged)\n   *\n   * @returns {Promise<Agent>} Updated agent with all components populated\n   *\n   * @throws {Error} If agent with specified ID is not found or update fails\n   *\n   * @example\n   * // Basic update - change agent name and description\n   * const updatedAgent = await strapiClient.updateAgent('agent-id', {\n   *   name: 'Updated Assistant',\n   *   description: 'New description'\n   * });\n   *\n   * // systemPrompt, enabled, and other fields remain unchanged\n   *\n   * @example\n   * // Update only the system prompt\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   systemPrompt: 'You are an expert TypeScript developer with 10 years of experience.'\n   * });\n   *\n   * @example\n   * // Enable/disable an agent\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   enabled: false\n   * });\n   *\n   * @example\n   * // Update model configuration - change model and temperature\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   modelConfig: {\n   *     model: 'opus',\n   *     temperature: 0.5,\n   *     max_tokens: 8192,\n   *     timeout: 600000\n   *   }\n   * });\n   *\n   * @example\n   * // Update tool configuration - enable specific tools\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: true,\n   *     bash_20241022: true,\n   *     computer_20241022: false\n   *   }\n   * });\n   *\n   * @example\n   * // Update MCP configuration - replace all MCP servers\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const githubServer = mcpServers.find(s => s.name === 'github');\n   * const githubTools = await strapiClient.getMCPToolsByServerId(githubServer.id);\n   *\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: githubServer.id,\n   *       selectedTools: githubTools.map(tool => ({ mcpTool: tool.id }))\n   *     }\n   *   ]\n   * });\n   *\n   * @example\n   * // Add more skills to an agent (requires fetching existing first)\n   * const currentAgent = await strapiClient.getAgent('agent-id');\n   * const newSkill = await strapiClient.getAllSkills({ filters: { name: 'debugging' } });\n   *\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   skillSelection: [\n   *     ...(currentAgent.skillSelection || []), // Keep existing skills\n   *     { skill: newSkill[0].id } // Add new skill\n   *   ]\n   * });\n   *\n   * @example\n   * // Update metadata - completely replace metadata array\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   metadata: [\n   *     { key: 'environment', value: 'production' },\n   *     { key: 'version', value: '3.0' },\n   *     { key: 'last_updated', value: new Date().toISOString() }\n   *   ]\n   * });\n   *\n   * @example\n   * // Bulk update - change multiple fields at once\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   name: 'Production Assistant',\n   *   description: 'Production-ready AI assistant',\n   *   enabled: true,\n   *   modelConfig: {\n   *     model: 'sonnet',\n   *     temperature: 0.7,\n   *     timeout: 300000\n   *   },\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: true,\n   *     bash_20241022: false,\n   *     computer_20241022: false\n   *   }\n   * });\n   *\n   * @example\n   * // Error handling for non-existent agent\n   * try {\n   *   const agent = await strapiClient.updateAgent('non-existent-id', {\n   *     name: 'New Name'\n   *   });\n   * } catch (error) {\n   *   console.error('Update failed:', error.message);\n   *   // Error: Failed to update agent with ID non-existent-id\n   * }\n   *\n   * @see {@link createAgent} for creating new agents\n   * @see {@link getAgent} for retrieving current agent state before update\n   */\n  async updateAgent(id: string, agentData: UpdateAgentDTO): Promise<Agent> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/agents/${id}`,\n      {\n        data: this.prepareAgentData(agentData as any),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update agent with ID ${id}`);\n    }\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n    this.cache.delete(`agent:${id}`);\n\n    return this.transformAgent(data.data);\n  }\n\n  /**\n   * Delete an agent permanently from Strapi\n   *\n   * @description\n   * Permanently deletes an agent from the Strapi database. This operation cannot be undone.\n   * All associated component data (toolConfig, modelConfig, mcpConfig, skillSelection, etc.)\n   * is also deleted as they are part of the agent entity.\n   *\n   * **Important Considerations:**\n   * - This is a permanent deletion - there is no soft delete or trash bin\n   * - All component data is deleted with the agent\n   * - Related entities (Skills, MCP Servers, Tasks) are NOT deleted (only the associations)\n   * - Any active conversations using this agent may fail\n   * - Cache is automatically invalidated after deletion\n   *\n   * **Best Practices:**\n   * - Consider disabling the agent instead of deleting it to preserve history\n   * - Verify the agent ID before deletion to prevent accidental deletions\n   * - Check for active conversations or tasks before deletion\n   * - Export agent configuration before deletion if you may need it later\n   *\n   * @param {string} id - Agent document ID to delete\n   *\n   * @returns {Promise<void>} Resolves when deletion is complete\n   *\n   * @throws {Error} If agent with specified ID is not found or deletion fails\n   *\n   * @example\n   * // Basic deletion\n   * await strapiClient.deleteAgent('agent-id-to-delete');\n   * console.log('Agent deleted successfully');\n   *\n   * @example\n   * // Safe deletion with confirmation\n   * const agent = await strapiClient.getAgent('agent-id');\n   * console.log(`About to delete agent: ${agent.name}`);\n   * console.log(`Description: ${agent.description}`);\n   *\n   * // In a real application, prompt user for confirmation here\n   * const confirmed = true; // User confirmation\n   *\n   * if (confirmed) {\n   *   await strapiClient.deleteAgent(agent.id);\n   *   console.log('Agent deleted');\n   * }\n   *\n   * @example\n   * // Alternative: Disable instead of delete (preserves history)\n   * // This is often preferred over permanent deletion\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   enabled: false\n   * });\n   * console.log('Agent disabled (not deleted)');\n   *\n   * @example\n   * // Export agent configuration before deletion\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * // Save configuration to file or backup system\n   * const backup = {\n   *   name: agent.name,\n   *   description: agent.description,\n   *   systemPrompt: agent.systemPrompt,\n   *   modelConfig: agent.modelConfig,\n   *   toolConfig: agent.toolConfig,\n   *   mcpConfig: agent.mcpConfig,\n   *   skillSelection: agent.skillSelection,\n   *   exportedAt: new Date().toISOString()\n   * };\n   *\n   * // fs.writeFileSync(`./backups/agent-${agent.id}.json`, JSON.stringify(backup, null, 2));\n   *\n   * // Now safe to delete\n   * await strapiClient.deleteAgent(agent.id);\n   *\n   * @example\n   * // Error handling for non-existent agent\n   * try {\n   *   await strapiClient.deleteAgent('non-existent-id');\n   * } catch (error) {\n   *   console.error('Deletion failed:', error.message);\n   *   // Handle error (agent not found, network error, etc.)\n   * }\n   *\n   * @example\n   * // Batch deletion (use with caution!)\n   * const agentsToDelete = await strapiClient.getAllAgents({\n   *   filters: { enabled: false, updatedAt: { $lt: '2024-01-01' } }\n   * });\n   *\n   * console.log(`Found ${agentsToDelete.length} agents to delete`);\n   *\n   * for (const agent of agentsToDelete) {\n   *   console.log(`Deleting ${agent.name}...`);\n   *   await strapiClient.deleteAgent(agent.id);\n   * }\n   *\n   * console.log('Batch deletion complete');\n   *\n   * @see {@link updateAgent} for disabling agents without deletion\n   * @see {@link getAgent} for retrieving agent details before deletion\n   */\n  async deleteAgent(id: string): Promise<void> {\n    await this.client.delete(`/agents/${id}`);\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n    this.cache.delete(`agent:${id}`);\n  }\n\n  // ============= SKILLS =============\n\n  /**\n   * Get all skills with optional filtering, sorting, and pagination\n   *\n   * @description\n   * Retrieves all skills from Strapi with support for advanced query features including\n   * filtering, sorting, pagination, and relation population. Skills automatically populate\n   * component fields including trainingHistory, additionalFiles, and mcpConfig for comprehensive\n   * skill data. Results are cached with 5-minute TTL for improved performance.\n   *\n   * **Strapi v5 Component Support:**\n   * Skills use component-based architecture with the following component fields:\n   * - `trainingHistory`: Array of training records with date, description, score delta, notes\n   * - `additionalFiles`: Array of file attachments with file relation (PDFs, docs, images)\n   * - `mcpConfig`: MCP server configuration components (array of mcpServer + selectedTools)\n   * - `agentSelection`: Agent assignment components (array of agent references)\n   * - `toolConfig`: Tool configuration component (file_search, text_editor, etc.)\n   * - `modelConfig`: Model configuration component (model, temperature, timeout)\n   * - `analytics`: Analytics component (usage stats, performance metrics)\n   * - `inputFields`: Dynamic input fields for skill execution\n   * - `tasks`: Task assignment components (array of task references)\n   *\n   * **Default Population:**\n   * By default, this method auto-populates all component fields for complete skill data:\n   * - `trainingHistory`, `additionalFiles.file`, `mcpConfig.mcpServer`, `mcpConfig.selectedTools.mcpTool`\n   * - `agentSelection`, `toolConfig`, `modelConfig`, `analytics`, `inputFields`\n   *\n   * @param {Object} [options] - Query options for filtering, sorting, and pagination\n   * @param {string[]} [options.populate] - Relations/components to populate (defaults to all skill components)\n   * @param {Record<string, any>} [options.filters] - Strapi v5 filters object (supports $eq, $ne, $in, $containsi, $and, $or, etc.)\n   * @param {string[]} [options.sort] - Sort order array (e.g., ['name:asc', 'experienceScore:desc'])\n   * @param {Object} [options.pagination] - Pagination configuration (defaults to { page: 1, pageSize: 100 })\n   * @param {number} [options.pagination.page] - Page number (1-indexed)\n   * @param {number} [options.pagination.pageSize] - Number of items per page\n   *\n   * @returns {Promise<Skill[]>} Array of Skill objects with all component fields populated\n   *\n   * @example\n   * // Basic usage - get all skills with auto-populated components\n   * const skills = await strapiClient.getAllSkills();\n   * console.log(`Found ${skills.length} skills`);\n   *\n   * // Access populated component data\n   * skills.forEach(skill => {\n   *   console.log(`Skill: ${skill.displayName}`);\n   *   console.log(`Experience: ${skill.experienceScore}`);\n   *   console.log(`Training records: ${skill.trainingHistory?.length || 0}`);\n   *   console.log(`Additional files: ${skill.additionalFiles?.length || 0}`);\n   *   console.log(`MCP servers: ${skill.mcpConfig?.length || 0}`);\n   * });\n   *\n   * @example\n   * // Filter public skills only\n   * const publicSkills = await strapiClient.getAllSkills({\n   *   filters: { isPublic: { $eq: true } }\n   * });\n   *\n   * @example\n   * // Filter by category with case-insensitive search\n   * const codeSkills = await strapiClient.getAllSkills({\n   *   filters: {\n   *     category: { $eq: 'coding' }\n   *   },\n   *   sort: ['experienceScore:desc']\n   * });\n   *\n   * @example\n   * // Advanced filtering with multiple conditions\n   * const expertSkills = await strapiClient.getAllSkills({\n   *   filters: {\n   *     $and: [\n   *       { isPublic: { $eq: true } },\n   *       { experienceScore: { $gte: 50 } },\n   *       { category: { $in: ['coding', 'debugging', 'testing'] } }\n   *     ]\n   *   },\n   *   sort: ['experienceScore:desc', 'updatedAt:desc'],\n   *   pagination: { page: 1, pageSize: 20 }\n   * });\n   *\n   * @example\n   * // Search skills by name or description\n   * const searchResults = await strapiClient.getAllSkills({\n   *   filters: {\n   *     $or: [\n   *       { name: { $containsi: 'typescript' } },\n   *       { displayName: { $containsi: 'typescript' } },\n   *       { description: { $containsi: 'typescript' } }\n   *     ]\n   *   }\n   * });\n   *\n   * @example\n   * // Access trainingHistory component data\n   * const skills = await strapiClient.getAllSkills();\n   *\n   * skills.forEach(skill => {\n   *   console.log(`\\nSkill: ${skill.displayName}`);\n   *   console.log(`Total Experience: ${skill.experienceScore}`);\n   *\n   *   if (skill.trainingHistory && skill.trainingHistory.length > 0) {\n   *     console.log('Training History:');\n   *     skill.trainingHistory.forEach((record: any) => {\n   *       console.log(`  - ${record.date}: ${record.description}`);\n   *       console.log(`    Score change: +${record.scoreChange || 0}`);\n   *       if (record.notes) console.log(`    Notes: ${record.notes}`);\n   *     });\n   *   }\n   * });\n   *\n   * @example\n   * // Access additionalFiles component data\n   * const skills = await strapiClient.getAllSkills();\n   *\n   * skills.forEach(skill => {\n   *   if (skill.additionalFiles && skill.additionalFiles.length > 0) {\n   *     console.log(`\\nSkill: ${skill.displayName}`);\n   *     console.log('Additional Files:');\n   *\n   *     skill.additionalFiles.forEach((fileComponent: any) => {\n   *       // fileComponent.file is populated via deep population\n   *       const file = fileComponent.file;\n   *       console.log(`  - ${file?.name || 'unnamed'}`);\n   *       console.log(`    URL: ${file?.url}`);\n   *       console.log(`    Size: ${file?.size} bytes`);\n   *       console.log(`    Type: ${file?.mime}`);\n   *       if (fileComponent.description) {\n   *         console.log(`    Description: ${fileComponent.description}`);\n   *       }\n   *     });\n   *   }\n   * });\n   *\n   * @example\n   * // Access mcpConfig component data\n   * const skills = await strapiClient.getAllSkills();\n   *\n   * skills.forEach(skill => {\n   *   if (skill.mcpConfig && skill.mcpConfig.length > 0) {\n   *     console.log(`\\nSkill: ${skill.displayName}`);\n   *     console.log('MCP Configuration:');\n   *\n   *     skill.mcpConfig.forEach((config: any) => {\n   *       // mcpServer and selectedTools are populated\n   *       console.log(`  MCP Server: ${config.mcpServer?.name}`);\n   *       console.log(`  Transport: ${config.mcpServer?.transport}`);\n   *\n   *       if (config.selectedTools && config.selectedTools.length > 0) {\n   *         console.log('  Selected Tools:');\n   *         config.selectedTools.forEach((toolSelection: any) => {\n   *           const tool = toolSelection.mcpTool;\n   *           console.log(`    - ${tool?.name}: ${tool?.description || 'No description'}`);\n   *         });\n   *       }\n   *     });\n   *   }\n   * });\n   *\n   * @example\n   * // Pagination - get second page of 20 skills\n   * const page2 = await strapiClient.getAllSkills({\n   *   pagination: { page: 2, pageSize: 20 },\n   *   sort: ['updatedAt:desc']\n   * });\n   *\n   * @see {@link getSkill} for retrieving a single skill with full component population\n   * @see {@link getSkillsByIds} for retrieving multiple specific skills\n   */\n  async getAllSkills(options?: {\n    populate?: string[];\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Skill[]> {\n    const cacheKey = `skills:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    // Always populate component fields for skills\n    const populateOptions = {\n      ...options,\n      populate: options?.populate || [\n        'toolConfig',\n        'modelConfig',\n        'analytics',\n        'mcpConfig.mcpServer',\n        'mcpConfig.selectedTools.mcpTool',\n        'agentSelection',\n        'trainingHistory',\n        'additionalFiles.file',  // Deep populate: component + file relation\n        'inputFields'\n      ],\n      // Default pagination to fetch all skills (max 100)\n      pagination: options?.pagination || { page: 1, pageSize: 100 }\n    };\n\n    const params = this.buildQueryParams(populateOptions);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/skills',\n      { params }\n    );\n\n    // DEBUG: Log raw Strapi response to check mcpConfig\n    console.log('[DEBUG] getAllSkills - Raw Strapi response (first item):', JSON.stringify(data.data[0], null, 2));\n    if (data.data[0]?.attributes) {\n      console.log('[DEBUG] getAllSkills - First item attributes keys:', Object.keys(data.data[0].attributes));\n      console.log('[DEBUG] getAllSkills - mcpConfig value:', (data.data[0].attributes as any).mcpConfig);\n    }\n\n    const skills = data.data.map((item: StrapiAttributes<any>) => this.transformSkill(item));\n    this.cache.set(cacheKey, skills);\n\n    return skills;\n  }\n\n  /**\n   * Get a single skill by ID with all relations and components populated\n   *\n   * @description\n   * Retrieves a single skill by its unique document ID with deep population of all\n   * component fields and relations. This method automatically populates all nested data\n   * including trainingHistory, additionalFiles with file relations, mcpConfig with\n   * MCP server and tool selections, and agent selections.\n   *\n   * **Auto-populated Components:**\n   * - `trainingHistory`: Array of training records tracking skill improvement over time\n   * - `additionalFiles`: File attachments with populated file relation (documents, PDFs, images)\n   * - `mcpConfig`: MCP server configurations with nested mcpServer and selectedTools.mcpTool relations\n   * - `agentSelection`: Agent assignments with nested agent relations\n   * - `toolConfig`: Tool configuration with enabled tools\n   * - `modelConfig`: Model configuration (model, temperature, timeout)\n   * - `analytics`: Usage analytics and performance metrics\n   * - `inputFields`: Dynamic input field configurations for skill execution\n   * - `tasks`: Task assignments with nested task relations\n   * - `trainingAgent`: Direct relation to the agent used for training this skill\n   *\n   * **Strapi v5 Deep Population:**\n   * This method uses deep population syntax to retrieve nested relations within components:\n   * ```javascript\n   * additionalFiles: {\n   *   populate: { file: true }  // Populate file relation inside component\n   * }\n   * mcpConfig: {\n   *   populate: {\n   *     mcpServer: true,\n   *     selectedTools: { populate: { mcpTool: true } }\n   *   }\n   * }\n   * ```\n   *\n   * @param {string} id - Skill document ID (UUID format)\n   *\n   * @returns {Promise<Skill>} Skill object with all components and relations populated\n   *\n   * @throws {Error} If skill with the specified ID is not found\n   *\n   * @example\n   * // Basic usage - get skill with all relations\n   * const skill = await strapiClient.getSkill('skill-id');\n   * console.log(skill.displayName);\n   * console.log(skill.description);\n   * console.log(skill.experienceScore);\n   *\n   * @example\n   * // Access trainingHistory component\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * console.log(`\\n${skill.displayName} Training History:`);\n   * console.log(`Current Experience Score: ${skill.experienceScore}`);\n   *\n   * if (skill.trainingHistory && skill.trainingHistory.length > 0) {\n   *   skill.trainingHistory.forEach((record: any) => {\n   *     console.log(`\\nDate: ${new Date(record.date).toLocaleDateString()}`);\n   *     console.log(`Description: ${record.description}`);\n   *     console.log(`Score Change: +${record.scoreChange || 0}`);\n   *     console.log(`Agent: ${record.agentName || 'Unknown'}`);\n   *     if (record.notes) {\n   *       console.log(`Notes: ${record.notes}`);\n   *     }\n   *   });\n   * } else {\n   *   console.log('No training history yet');\n   * }\n   *\n   * @example\n   * // Access additionalFiles component with file relation\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * if (skill.additionalFiles && skill.additionalFiles.length > 0) {\n   *   console.log(`\\n${skill.displayName} Additional Files:`);\n   *\n   *   skill.additionalFiles.forEach((fileComponent: any, index: number) => {\n   *     // fileComponent.file is populated via deep population\n   *     const file = fileComponent.file;\n   *\n   *     console.log(`\\nFile ${index + 1}:`);\n   *     console.log(`  Name: ${file?.name || 'unnamed'}`);\n   *     console.log(`  URL: ${file?.url}`);\n   *     console.log(`  MIME: ${file?.mime}`);\n   *     console.log(`  Size: ${(file?.size / 1024).toFixed(2)} KB`);\n   *\n   *     if (fileComponent.description) {\n   *       console.log(`  Description: ${fileComponent.description}`);\n   *     }\n   *\n   *     // Download or reference the file\n   *     // const fileUrl = `${STRAPI_URL}${file?.url}`;\n   *   });\n   * }\n   *\n   * @example\n   * // Access mcpConfig component with nested relations\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * if (skill.mcpConfig && skill.mcpConfig.length > 0) {\n   *   console.log(`\\n${skill.displayName} MCP Configuration:`);\n   *\n   *   skill.mcpConfig.forEach((config: any, index: number) => {\n   *     const server = config.mcpServer;\n   *     console.log(`\\nMCP Server ${index + 1}:`);\n   *     console.log(`  Name: ${server?.name}`);\n   *     console.log(`  Transport: ${server?.transport}`);\n   *     console.log(`  Command: ${server?.command}`);\n   *\n   *     if (config.selectedTools && config.selectedTools.length > 0) {\n   *       console.log('  Selected Tools:');\n   *       config.selectedTools.forEach((toolSelection: any) => {\n   *         const tool = toolSelection.mcpTool;\n   *         console.log(`    - ${tool?.name}`);\n   *         console.log(`      ${tool?.description || 'No description'}`);\n   *       });\n   *     }\n   *   });\n   * }\n   *\n   * @example\n   * // Access agent selection and training agent\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * // Check which agents use this skill\n   * if (skill.agentSelection && skill.agentSelection.length > 0) {\n   *   console.log(`\\n${skill.displayName} is used by:`);\n   *   skill.agentSelection.forEach((selection: any) => {\n   *     const agent = selection.agent;\n   *     console.log(`  - ${agent?.name} (${agent?.enabled ? 'enabled' : 'disabled'})`);\n   *   });\n   * }\n   *\n   * // Check training agent\n   * if (skill.trainingAgent) {\n   *   console.log(`\\nTrained by: ${skill.trainingAgent}`);\n   * }\n   *\n   * @example\n   * // Access inputFields for dynamic skill execution\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * if (skill.inputFields && skill.inputFields.length > 0) {\n   *   console.log(`\\n${skill.displayName} Input Fields:`);\n   *\n   *   skill.inputFields.forEach((field: any) => {\n   *     console.log(`\\nField: ${field.name}`);\n   *     console.log(`  Label: ${field.label}`);\n   *     console.log(`  Type: ${field.type}`);\n   *     console.log(`  Required: ${field.required ? 'Yes' : 'No'}`);\n   *     if (field.defaultValue) {\n   *       console.log(`  Default: ${field.defaultValue}`);\n   *     }\n   *     if (field.placeholder) {\n   *       console.log(`  Placeholder: ${field.placeholder}`);\n   *     }\n   *   });\n   * }\n   *\n   * @example\n   * // Error handling for non-existent skill\n   * try {\n   *   const skill = await strapiClient.getSkill('non-existent-id');\n   * } catch (error) {\n   *   console.error('Skill not found:', error.message);\n   *   // Error: Skill with ID non-existent-id not found\n   * }\n   *\n   * @example\n   * // Complete skill inspection workflow\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * console.log(`\\n=== ${skill.displayName} ===`);\n   * console.log(`Category: ${skill.category}`);\n   * console.log(`Version: ${skill.version}`);\n   * console.log(`Experience: ${skill.experienceScore}`);\n   * console.log(`Public: ${skill.isPublic ? 'Yes' : 'No'}`);\n   * console.log(`\\nDescription:\\n${skill.description}`);\n   * console.log(`\\nSkill Content:\\n${skill.skillmd.substring(0, 200)}...`);\n   *\n   * // Check configuration\n   * if (skill.modelConfig) {\n   *   console.log(`\\nModel Config: ${skill.modelConfig.model} @ ${skill.modelConfig.temperature}`);\n   * }\n   *\n   * // Check analytics\n   * if (skill.analytics) {\n   *   console.log(`\\nUsage: ${skill.analytics.usageCount || 0} times`);\n   *   console.log(`Success Rate: ${skill.analytics.successRate || 0}%`);\n   * }\n   *\n   * @see {@link getAllSkills} for querying multiple skills with filters\n   * @see {@link updateSkill} for modifying skill data\n   */\n  async getSkill(id: string): Promise<Skill> {\n    const cacheKey = `skill:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/skills/${id}`,\n      {\n        params: {\n          // Populate component fields and nested relations\n          populate: {\n            trainingHistory: true,\n            additionalFiles: {\n              populate: { file: true }  // Populate file relation inside component\n            },\n            agentSelection: {\n              populate: { agent: true },\n            },\n            toolConfig: true,\n            modelConfig: true,\n            analytics: true,\n            mcpConfig: {\n              populate: {\n                mcpServer: true,\n                selectedTools: {\n                  populate: { mcpTool: true },\n                },\n              },\n            },\n            tasks: {\n              populate: { task: true },\n            },\n            inputFields: true,\n            trainingAgent: true,\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Skill with ID ${id} not found`);\n    }\n\n    const skill = this.transformSkill(data.data);\n    this.cache.set(cacheKey, skill);\n\n    return skill;\n  }\n\n  /**\n   * Get multiple skills by their IDs with all components populated\n   *\n   * @description\n   * Retrieves multiple skills by an array of document IDs. This is a convenience method\n   * that uses `getAllSkills` with a filter for the specified IDs. All component fields\n   * (trainingHistory, additionalFiles, mcpConfig, etc.) are automatically populated.\n   *\n   * **Use Cases:**\n   * - Bulk fetch skills for an agent's skillSelection\n   * - Load skills from a saved configuration or preset\n   * - Retrieve related skills for comparison or grouping\n   * - Hydrate skill references from other entities\n   *\n   * @param {string[]} ids - Array of skill document IDs (UUID format)\n   *\n   * @returns {Promise<Skill[]>} Array of Skill objects with all components populated\n   * Returns empty array if no IDs provided or no skills found\n   *\n   * @example\n   * // Basic usage - fetch multiple skills by IDs\n   * const skillIds = ['skill-id-1', 'skill-id-2', 'skill-id-3'];\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * console.log(`Fetched ${skills.length} skills`);\n   * skills.forEach(skill => {\n   *   console.log(`- ${skill.displayName} (${skill.category})`);\n   * });\n   *\n   * @example\n   * // Load skills from agent's skillSelection\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * // Extract skill IDs from skillSelection components\n   * const skillIds = agent.skillSelection?.map((selection: any) => selection.skill?.id || selection.skill).filter(Boolean) || [];\n   *\n   * // Fetch all skills at once\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * console.log(`Agent \"${agent.name}\" has ${skills.length} skills:`);\n   * skills.forEach(skill => {\n   *   console.log(`  - ${skill.displayName}: ${skill.description}`);\n   * });\n   *\n   * @example\n   * // Handle empty array gracefully\n   * const skills = await strapiClient.getSkillsByIds([]);\n   * console.log(skills); // []\n   *\n   * @example\n   * // Fetch skills and group by category\n   * const skillIds = ['id1', 'id2', 'id3', 'id4'];\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * const byCategory = skills.reduce((acc: any, skill) => {\n   *   const category = skill.category || 'uncategorized';\n   *   if (!acc[category]) acc[category] = [];\n   *   acc[category].push(skill);\n   *   return acc;\n   * }, {});\n   *\n   * Object.entries(byCategory).forEach(([category, categorySkills]: [string, any]) => {\n   *   console.log(`\\n${category}:`);\n   *   categorySkills.forEach((skill: any) => {\n   *     console.log(`  - ${skill.displayName}`);\n   *   });\n   * });\n   *\n   * @example\n   * // Check which skills have additional files\n   * const skillIds = ['id1', 'id2', 'id3'];\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * const skillsWithFiles = skills.filter(skill =>\n   *   skill.additionalFiles && skill.additionalFiles.length > 0\n   * );\n   *\n   * console.log(`${skillsWithFiles.length} skills have additional files:`);\n   * skillsWithFiles.forEach(skill => {\n   *   console.log(`  - ${skill.displayName}: ${skill.additionalFiles.length} files`);\n   * });\n   *\n   * @example\n   * // Calculate total experience across skills\n   * const skillIds = ['id1', 'id2', 'id3'];\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * const totalExperience = skills.reduce((sum, skill) => sum + (skill.experienceScore || 0), 0);\n   * const avgExperience = skills.length > 0 ? totalExperience / skills.length : 0;\n   *\n   * console.log(`Total Experience: ${totalExperience}`);\n   * console.log(`Average Experience: ${avgExperience.toFixed(1)}`);\n   *\n   * @see {@link getAllSkills} for advanced filtering options\n   * @see {@link getSkill} for retrieving a single skill\n   */\n  async getSkillsByIds(ids: string[]): Promise<Skill[]> {\n    if (ids.length === 0) return [];\n\n    const filters = {\n      documentId: { $in: ids },\n    };\n\n    return this.getAllSkills({ filters });\n  }\n\n  /**\n   * Create a new skill with component-based configuration\n   *\n   * @description\n   * Creates a new skill in Strapi with support for component-based architecture including\n   * trainingHistory, additionalFiles, and mcpConfig. All component fields are supported\n   * in Strapi v5 format.\n   *\n   * **Component Fields:**\n   * - `trainingHistory`: Initialize training records (array of { date, description, scoreChange, notes })\n   * - `additionalFiles`: Attach files (array of { file: uploadedFileId, description })\n   * - `mcpConfig`: Configure MCP servers (array of { mcpServer: id, selectedTools: [...] })\n   * - `agentSelection`: Assign agents (array of { agent: id })\n   * - `toolConfig`: Configure enabled tools (file_search, text_editor, etc.)\n   * - `modelConfig`: Configure model settings (model, temperature, timeout)\n   * - `analytics`: Initialize analytics tracking\n   * - `inputFields`: Define dynamic input fields (array of { name, label, type, required, defaultValue })\n   * - `tasks`: Assign tasks (array of { task: id })\n   * - `trainingAgent`: Reference to training agent (agent ID)\n   *\n   * **Cache Invalidation:**\n   * Creating a skill invalidates all cached skill queries to ensure fresh data.\n   *\n   * @param {CreateSkillDTO} skillData - Skill data transfer object\n   * @param {string} skillData.name - Skill identifier (slug-friendly, required)\n   * @param {string} skillData.displayName - Human-readable name (required)\n   * @param {string} skillData.description - Skill description (required)\n   * @param {string} skillData.skillmd - Skill content in markdown format (required)\n   * @param {number} [skillData.experienceScore=0] - Initial experience score\n   * @param {string} [skillData.category='custom'] - Skill category\n   * @param {boolean} [skillData.isPublic=true] - Whether the skill is publicly visible\n   * @param {string} [skillData.version='1.0.0'] - Skill version\n   * @param {string} [skillData.license] - License identifier\n   * @param {Array} [skillData.trainingHistory] - Training history records\n   * @param {Array} [skillData.additionalFiles] - File attachment components\n   * @param {Array} [skillData.mcpConfig] - MCP server configuration components\n   * @param {Array} [skillData.agentSelection] - Agent assignment components\n   * @param {Object} [skillData.toolConfig] - Tool configuration\n   * @param {Object} [skillData.modelConfig] - Model configuration\n   * @param {Object} [skillData.analytics] - Analytics data\n   * @param {Array} [skillData.inputFields] - Input field definitions\n   * @param {Array} [skillData.tasks] - Task assignments\n   * @param {string} [skillData.trainingAgent] - Training agent ID\n   *\n   * @returns {Promise<Skill>} Created skill with generated ID and auto-populated defaults\n   *\n   * @throws {Error} If skill creation fails (validation errors, network errors)\n   *\n   * @example\n   * // Basic skill creation with minimal fields\n   * const skill = await strapiClient.createSkill({\n   *   name: 'typescript-expert',\n   *   displayName: 'TypeScript Expert',\n   *   description: 'Expert knowledge in TypeScript programming',\n   *   skillmd: '# TypeScript Expert\\n\\nProvides expert TypeScript development assistance.',\n   *   category: 'coding',\n   *   experienceScore: 0\n   * });\n   *\n   * console.log(skill.id);   // Auto-generated UUID\n   * console.log(skill.version); // Default: '1.0.0'\n   * console.log(skill.isPublic); // Default: true\n   *\n   * @example\n   * // Create skill with trainingHistory component\n   * const skill = await strapiClient.createSkill({\n   *   name: 'debugging-expert',\n   *   displayName: 'Debugging Expert',\n   *   description: 'Expert in debugging complex issues',\n   *   skillmd: '# Debugging Expert\\n\\nHelps identify and fix bugs.',\n   *   category: 'debugging',\n   *   experienceScore: 25,\n   *   trainingHistory: [\n   *     {\n   *       date: new Date().toISOString(),\n   *       description: 'Initial training on React debugging',\n   *       scoreChange: 10,\n   *       agentName: 'Training Agent',\n   *       notes: 'Learned component lifecycle debugging'\n   *     },\n   *     {\n   *       date: new Date().toISOString(),\n   *       description: 'Advanced async debugging training',\n   *       scoreChange: 15,\n   *       agentName: 'Advanced Trainer',\n   *       notes: 'Mastered Promise rejection handling'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill created with ${skill.trainingHistory.length} training records`);\n   *\n   * @example\n   * // Create skill with additionalFiles component\n   * // First, upload files to Strapi Media Library\n   * import fs from 'fs';\n   *\n   * const guideFile = fs.readFileSync('./typescript-guide.pdf');\n   * const examplesFile = fs.readFileSync('./examples.zip');\n   *\n   * const uploadedGuide = await strapiClient.uploadFile(guideFile, 'typescript-guide.pdf');\n   * const uploadedExamples = await strapiClient.uploadFile(examplesFile, 'examples.zip');\n   *\n   * // Create skill with file attachments\n   * const skill = await strapiClient.createSkill({\n   *   name: 'typescript-advanced',\n   *   displayName: 'Advanced TypeScript',\n   *   description: 'Advanced TypeScript patterns',\n   *   skillmd: '# Advanced TypeScript\\n\\nRefer to attached guide and examples.',\n   *   category: 'coding',\n   *   additionalFiles: [\n   *     {\n   *       file: uploadedGuide.documentId,\n   *       description: 'Comprehensive TypeScript guide'\n   *     },\n   *     {\n   *       file: uploadedExamples.documentId,\n   *       description: 'Code examples and templates'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill created with ${skill.additionalFiles.length} attached files`);\n   *\n   * @example\n   * // Create skill with mcpConfig component\n   * // First, get MCP servers and tools from Strapi\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const filesystemServer = mcpServers.find(s => s.name === 'filesystem');\n   * const filesystemTools = await strapiClient.getMCPToolsByServerId(filesystemServer.id);\n   *\n   * const skill = await strapiClient.createSkill({\n   *   name: 'file-operations',\n   *   displayName: 'File Operations',\n   *   description: 'Expert in file system operations',\n   *   skillmd: '# File Operations\\n\\nUses filesystem MCP tools.',\n   *   category: 'system',\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: filesystemServer.id,\n   *       selectedTools: filesystemTools.slice(0, 5).map(tool => ({\n   *         mcpTool: tool.id\n   *       }))\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill created with ${skill.mcpConfig.length} MCP server config`);\n   *\n   * @example\n   * // Create skill with inputFields component for dynamic execution\n   * const skill = await strapiClient.createSkill({\n   *   name: 'code-generator',\n   *   displayName: 'Code Generator',\n   *   description: 'Generates code based on user input',\n   *   skillmd: '# Code Generator\\n\\nGenerates code from templates.',\n   *   category: 'coding',\n   *   inputFields: [\n   *     {\n   *       name: 'language',\n   *       label: 'Programming Language',\n   *       type: 'select',\n   *       required: true,\n   *       options: ['TypeScript', 'JavaScript', 'Python', 'Go'],\n   *       defaultValue: 'TypeScript'\n   *     },\n   *     {\n   *       name: 'framework',\n   *       label: 'Framework',\n   *       type: 'text',\n   *       required: false,\n   *       placeholder: 'e.g., React, Express, FastAPI'\n   *     },\n   *     {\n   *       name: 'features',\n   *       label: 'Features to Include',\n   *       type: 'textarea',\n   *       required: true,\n   *       placeholder: 'Describe the features you want...'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill created with ${skill.inputFields.length} input fields`);\n   *\n   * @example\n   * // Create skill with custom model and tool configuration\n   * const skill = await strapiClient.createSkill({\n   *   name: 'data-analyst',\n   *   displayName: 'Data Analyst',\n   *   description: 'Analyzes data and generates insights',\n   *   skillmd: '# Data Analyst\\n\\nPerforms data analysis tasks.',\n   *   category: 'analytics',\n   *   modelConfig: {\n   *     model: 'opus',\n   *     temperature: 0.3,\n   *     max_tokens: 8192,\n   *     timeout: 600000\n   *   },\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: false,\n   *     bash_20241022: true,\n   *     computer_20241022: false\n   *   },\n   *   analytics: {\n   *     usageCount: 0,\n   *     successRate: 100,\n   *     avgExecutionTime: 0\n   *   }\n   * });\n   *\n   * @example\n   * // Error handling for validation failures\n   * try {\n   *   const skill = await strapiClient.createSkill({\n   *     name: '', // Invalid: empty name\n   *     displayName: 'Test',\n   *     description: 'Test skill',\n   *     skillmd: '# Test'\n   *   });\n   * } catch (error) {\n   *   console.error('Validation failed:', error.message);\n   * }\n   *\n   * @see {@link updateSkill} for updating existing skills\n   * @see {@link getSkill} for retrieving created skill with full details\n   * @see {@link uploadFile} for uploading files before attaching to skills\n   */\n  async createSkill(skillData: CreateSkillDTO): Promise<Skill> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/skills',\n      {\n        data: this.prepareSkillData(skillData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create skill');\n    }\n\n    this.invalidateCache('skills');\n    return this.transformSkill(data.data);\n  }\n\n  /**\n   * Update an existing skill with partial data\n   *\n   * @description\n   * Updates an existing skill in Strapi using partial update semantics. Only the fields\n   * provided in the update DTO will be modified; omitted fields remain unchanged. This\n   * method supports updating all component fields including trainingHistory, additionalFiles,\n   * and mcpConfig in Strapi v5 format.\n   *\n   * **Partial Updates:**\n   * You can update individual fields without affecting other fields:\n   * - Update only `displayName` without changing `skillmd`\n   * - Update only `experienceScore` without changing `trainingHistory`\n   * - Update only specific components without affecting others\n   *\n   * **Component Field Updates:**\n   * - `trainingHistory`: Replace training records (array replacement, not merge)\n   * - `additionalFiles`: Replace file attachments (array replacement)\n   * - `mcpConfig`: Replace MCP server configurations (array replacement)\n   * - `agentSelection`: Replace agent assignments (array replacement)\n   * - `toolConfig`: Update tool enablement settings\n   * - `modelConfig`: Update model configuration\n   * - `analytics`: Update analytics data\n   * - `inputFields`: Replace input field definitions (array replacement)\n   * - `tasks`: Replace task assignments (array replacement)\n   * - `trainingAgent`: Update training agent reference\n   *\n   * **Important: Array Field Behavior**\n   * Arrays are replaced, not merged. To add items, fetch current data first:\n   * ```javascript\n   * const skill = await strapiClient.getSkill('skill-id');\n   * await strapiClient.updateSkill('skill-id', {\n   *   trainingHistory: [...skill.trainingHistory, newRecord]\n   * });\n   * ```\n   *\n   * **Cache Invalidation:**\n   * Updating a skill invalidates both the specific skill cache and all skill list caches.\n   *\n   * @param {string} id - Skill document ID to update\n   * @param {UpdateSkillDTO} skillData - Partial skill data to update\n   * @param {string} [skillData.name] - Update skill identifier\n   * @param {string} [skillData.displayName] - Update display name\n   * @param {string} [skillData.description] - Update description\n   * @param {string} [skillData.skillmd] - Update skill content\n   * @param {number} [skillData.experienceScore] - Update experience score\n   * @param {string} [skillData.category] - Update category\n   * @param {boolean} [skillData.isPublic] - Update visibility\n   * @param {string} [skillData.version] - Update version\n   * @param {string} [skillData.license] - Update license\n   * @param {Array} [skillData.trainingHistory] - Replace training history\n   * @param {Array} [skillData.additionalFiles] - Replace file attachments\n   * @param {Array} [skillData.mcpConfig] - Replace MCP config\n   * @param {Array} [skillData.agentSelection] - Replace agent assignments\n   * @param {Object} [skillData.toolConfig] - Update tool config\n   * @param {Object} [skillData.modelConfig] - Update model config\n   * @param {Object} [skillData.analytics] - Update analytics\n   * @param {Array} [skillData.inputFields] - Replace input fields\n   * @param {Array} [skillData.tasks] - Replace task assignments\n   * @param {string} [skillData.trainingAgent] - Update training agent\n   *\n   * @returns {Promise<Skill>} Updated skill with all components populated\n   *\n   * @throws {Error} If skill with specified ID is not found or update fails\n   *\n   * @example\n   * // Basic update - change display name and description\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   displayName: 'TypeScript Pro',\n   *   description: 'Professional TypeScript development expertise'\n   * });\n   *\n   * @example\n   * // Update experience score after training\n   * const skill = await strapiClient.updateSkill('skill-id', {\n   *   experienceScore: 75\n   * });\n   *\n   * @example\n   * // Add new training record (requires fetching current first)\n   * const currentSkill = await strapiClient.getSkill('skill-id');\n   *\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   experienceScore: currentSkill.experienceScore + 10,\n   *   trainingHistory: [\n   *     ...(currentSkill.trainingHistory || []),\n   *     {\n   *       date: new Date().toISOString(),\n   *       description: 'Completed advanced debugging training',\n   *       scoreChange: 10,\n   *       agentName: 'Training Bot',\n   *       notes: 'Improved error handling and async debugging'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill now has ${updatedSkill.trainingHistory.length} training records`);\n   * console.log(`New experience score: ${updatedSkill.experienceScore}`);\n   *\n   * @example\n   * // Add additional file to existing skill\n   * import fs from 'fs';\n   *\n   * // Upload new file first\n   * const cheatsheetFile = fs.readFileSync('./cheatsheet.pdf');\n   * const uploadedFile = await strapiClient.uploadFile(cheatsheetFile, 'cheatsheet.pdf');\n   *\n   * // Fetch current skill\n   * const currentSkill = await strapiClient.getSkill('skill-id');\n   *\n   * // Add new file to existing files\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   additionalFiles: [\n   *     ...(currentSkill.additionalFiles || []),\n   *     {\n   *       file: uploadedFile.documentId,\n   *       description: 'Quick reference cheatsheet'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill now has ${updatedSkill.additionalFiles.length} files`);\n   *\n   * @example\n   * // Update MCP configuration\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const githubServer = mcpServers.find(s => s.name === 'github');\n   * const githubTools = await strapiClient.getMCPToolsByServerId(githubServer.id);\n   *\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: githubServer.id,\n   *       selectedTools: githubTools.slice(0, 3).map(tool => ({\n   *         mcpTool: tool.id\n   *       }))\n   *     }\n   *   ]\n   * });\n   *\n   * @example\n   * // Update model and tool configuration\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   modelConfig: {\n   *     model: 'sonnet',\n   *     temperature: 0.8,\n   *     max_tokens: 4096,\n   *     timeout: 300000\n   *   },\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: true,\n   *     bash_20241022: false,\n   *     computer_20241022: false\n   *   }\n   * });\n   *\n   * @example\n   * // Update skill visibility and version\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   isPublic: true,\n   *   version: '2.0.0'\n   * });\n   *\n   * @example\n   * // Update skill content (skillmd)\n   * const newContent = `\n   * # Advanced TypeScript\n   *\n   * ## Updated Content\n   * This skill now includes advanced patterns for:\n   * - Type guards and discriminated unions\n   * - Generic constraints and inference\n   * - Conditional types and mapped types\n   *\n   * ## Examples\n   * ...\n   * `;\n   *\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   skillmd: newContent,\n   *   version: '2.1.0'\n   * });\n   *\n   * @example\n   * // Update analytics after skill execution\n   * const currentSkill = await strapiClient.getSkill('skill-id');\n   *\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   analytics: {\n   *     usageCount: (currentSkill.analytics?.usageCount || 0) + 1,\n   *     successRate: 95,\n   *     avgExecutionTime: 2500,\n   *     lastUsed: new Date().toISOString()\n   *   }\n   * });\n   *\n   * @example\n   * // Bulk update - change multiple fields at once\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   displayName: 'Expert TypeScript Developer',\n   *   description: 'Master-level TypeScript expertise',\n   *   category: 'coding',\n   *   experienceScore: 100,\n   *   version: '3.0.0',\n   *   modelConfig: {\n   *     model: 'opus',\n   *     temperature: 0.5,\n   *     timeout: 600000\n   *   }\n   * });\n   *\n   * @example\n   * // Error handling for non-existent skill\n   * try {\n   *   const skill = await strapiClient.updateSkill('non-existent-id', {\n   *     displayName: 'New Name'\n   *   });\n   * } catch (error) {\n   *   console.error('Update failed:', error.message);\n   *   // Error: Failed to update skill with ID non-existent-id\n   * }\n   *\n   * @see {@link createSkill} for creating new skills\n   * @see {@link getSkill} for retrieving current skill state before update\n   */\n  async updateSkill(id: string, skillData: UpdateSkillDTO): Promise<Skill> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/skills/${id}`,\n      {\n        data: this.prepareSkillData(skillData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update skill with ID ${id}`);\n    }\n\n    this.invalidateCache('skills');\n    this.cache.delete(`skill:${id}`);\n\n    return this.transformSkill(data.data);\n  }\n\n  /**\n   * Delete a skill permanently from Strapi\n   *\n   * @description\n   * Permanently deletes a skill from the Strapi database. This operation cannot be undone.\n   * All associated component data (trainingHistory, additionalFiles references, mcpConfig,\n   * agentSelection, etc.) is also deleted as they are part of the skill entity.\n   *\n   * **Important Considerations:**\n   * - This is a permanent deletion - there is no soft delete or trash bin\n   * - All component data is deleted with the skill\n   * - File attachments in additionalFiles are NOT deleted from Media Library (only references)\n   * - Related entities (Agents, MCP Servers, Tasks) are NOT deleted (only the associations)\n   * - Agents using this skill will have broken references in their skillSelection\n   * - Cache is automatically invalidated after deletion\n   *\n   * **Best Practices:**\n   * - Consider setting `isPublic: false` instead of deleting to preserve history\n   * - Verify the skill ID before deletion to prevent accidental deletions\n   * - Check which agents use the skill before deletion (via agentSelection)\n   * - Export skill data before deletion if you may need it later\n   * - Clean up file attachments separately if no longer needed\n   *\n   * @param {string} id - Skill document ID to delete\n   *\n   * @returns {Promise<void>} Resolves when deletion is complete\n   *\n   * @throws {Error} If skill with specified ID is not found or deletion fails\n   *\n   * @example\n   * // Basic deletion\n   * await strapiClient.deleteSkill('skill-id-to-delete');\n   * console.log('Skill deleted successfully');\n   *\n   * @example\n   * // Safe deletion with confirmation and dependency check\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * console.log(`About to delete skill: ${skill.displayName}`);\n   * console.log(`Category: ${skill.category}`);\n   * console.log(`Experience: ${skill.experienceScore}`);\n   *\n   * // Check which agents use this skill\n   * if (skill.agentSelection && skill.agentSelection.length > 0) {\n   *   console.warn(`Warning: This skill is used by ${skill.agentSelection.length} agents:`);\n   *   skill.agentSelection.forEach((selection: any) => {\n   *     console.log(`  - ${selection.agent?.name || 'Unknown agent'}`);\n   *   });\n   * }\n   *\n   * // In a real application, prompt user for confirmation here\n   * const confirmed = true; // User confirmation\n   *\n   * if (confirmed) {\n   *   await strapiClient.deleteSkill(skill.id);\n   *   console.log('Skill deleted');\n   * }\n   *\n   * @example\n   * // Alternative: Hide instead of delete (preserves history)\n   * // This is often preferred over permanent deletion\n   * const skill = await strapiClient.updateSkill('skill-id', {\n   *   isPublic: false\n   * });\n   * console.log('Skill hidden (not deleted)');\n   *\n   * @example\n   * // Export skill data before deletion\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * // Save configuration to file or backup system\n   * const backup = {\n   *   name: skill.name,\n   *   displayName: skill.displayName,\n   *   description: skill.description,\n   *   skillmd: skill.skillmd,\n   *   category: skill.category,\n   *   experienceScore: skill.experienceScore,\n   *   version: skill.version,\n   *   trainingHistory: skill.trainingHistory,\n   *   additionalFiles: skill.additionalFiles,\n   *   mcpConfig: skill.mcpConfig,\n   *   modelConfig: skill.modelConfig,\n   *   toolConfig: skill.toolConfig,\n   *   inputFields: skill.inputFields,\n   *   exportedAt: new Date().toISOString()\n   * };\n   *\n   * // fs.writeFileSync(`./backups/skill-${skill.id}.json`, JSON.stringify(backup, null, 2));\n   *\n   * // Now safe to delete\n   * await strapiClient.deleteSkill(skill.id);\n   *\n   * @example\n   * // Clean up attached files before deleting skill\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * // Delete file attachments from Media Library\n   * if (skill.additionalFiles && skill.additionalFiles.length > 0) {\n   *   for (const fileComponent of skill.additionalFiles) {\n   *     const file = fileComponent.file;\n   *     if (file?.documentId) {\n   *       await strapiClient.deleteFile(file.documentId);\n   *       console.log(`Deleted file: ${file.name}`);\n   *     }\n   *   }\n   * }\n   *\n   * // Now delete the skill\n   * await strapiClient.deleteSkill(skill.id);\n   * console.log('Skill and all attached files deleted');\n   *\n   * @example\n   * // Error handling for non-existent skill\n   * try {\n   *   await strapiClient.deleteSkill('non-existent-id');\n   * } catch (error) {\n   *   console.error('Deletion failed:', error.message);\n   *   // Handle error (skill not found, network error, etc.)\n   * }\n   *\n   * @example\n   * // Batch deletion with dependency checks (use with caution!)\n   * const skillsToDelete = await strapiClient.getAllSkills({\n   *   filters: {\n   *     $and: [\n   *       { isPublic: false },\n   *       { experienceScore: { $lt: 10 } },\n   *       { updatedAt: { $lt: '2024-01-01' } }\n   *     ]\n   *   }\n   * });\n   *\n   * console.log(`Found ${skillsToDelete.length} skills to delete`);\n   *\n   * for (const skill of skillsToDelete) {\n   *   // Check if skill is used by any agents\n   *   const isUsed = skill.agentSelection && skill.agentSelection.length > 0;\n   *\n   *   if (!isUsed) {\n   *     console.log(`Deleting ${skill.displayName}...`);\n   *     await strapiClient.deleteSkill(skill.id);\n   *   } else {\n   *     console.log(`Skipping ${skill.displayName} (in use by agents)`);\n   *   }\n   * }\n   *\n   * console.log('Batch deletion complete');\n   *\n   * @see {@link updateSkill} for hiding skills without deletion\n   * @see {@link getSkill} for retrieving skill details before deletion\n   * @see {@link deleteFile} for cleaning up attached files\n   */\n  async deleteSkill(id: string): Promise<void> {\n    await this.client.delete(`/skills/${id}`);\n    this.invalidateCache('skills');\n    this.cache.delete(`skill:${id}`);\n  }\n\n  // ============= MCP SERVERS =============\n\n  /**\n   * Get all MCP servers with optional filtering\n   *\n   * @description\n   * Retrieves all MCP (Model Context Protocol) servers from Strapi database with\n   * optional filtering and population of related tools. Supports Strapi v5 filter\n   * operators for advanced querying.\n   *\n   * **Filter Operators:**\n   * - `$eq`: Equal to\n   * - `$ne`: Not equal to\n   * - `$in`: In array\n   * - `$notIn`: Not in array\n   * - `$containsi`: Case-insensitive contains\n   * - `$and`, `$or`: Logical operators\n   *\n   * **Population:**\n   * Set `populate: true` to include related `mcpTools` in the response.\n   *\n   * **Cache Behavior:**\n   * Results are cached using options as cache key. Cache is invalidated on any\n   * MCP server create/update/delete operation.\n   *\n   * @param {Object} [options] - Query options\n   * @param {Object} [options.filters] - Strapi v5 filters object\n   * @param {boolean} [options.populate] - If true, populates mcpTools relation\n   * @returns {Promise<MCPServer[]>} Array of MCP servers\n   *\n   * @example\n   * // Get all MCP servers\n   * const allServers = await strapiClient.getAllMCPServers();\n   * console.log(allServers.length); // e.g., 5\n   *\n   * @example\n   * // Get only enabled MCP servers\n   * const enabledServers = await strapiClient.getAllMCPServers({\n   *   filters: { enabled: { $eq: true } }\n   * });\n   *\n   * @example\n   * // Get MCP servers with specific transport type\n   * const stdioServers = await strapiClient.getAllMCPServers({\n   *   filters: { transportType: { $eq: 'stdio' } }\n   * });\n   *\n   * @example\n   * // Get MCP servers with tools populated\n   * const serversWithTools = await strapiClient.getAllMCPServers({\n   *   populate: true\n   * });\n   * serversWithTools.forEach(server => {\n   *   console.log(`${server.name}: ${server.mcpTools?.length || 0} tools`);\n   * });\n   *\n   * @example\n   * // Filter by server name (case-insensitive)\n   * const filesystemServers = await strapiClient.getAllMCPServers({\n   *   filters: { name: { $containsi: 'filesystem' } }\n   * });\n   *\n   * @example\n   * // Get multiple servers by transport type\n   * const sdkOrStdioServers = await strapiClient.getAllMCPServers({\n   *   filters: {\n   *     transportType: { $in: ['stdio', 'sdk'] }\n   *   },\n   *   populate: true\n   * });\n   *\n   * @see {@link getMCPServer} for retrieving a single MCP server by ID\n   * @see {@link createMCPServer} for creating new MCP servers\n   */\n  async getAllMCPServers(options?: {\n    filters?: Record<string, any>;\n    populate?: boolean;\n  }): Promise<MCPServer[]> {\n    const cacheKey = `mcp-servers:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams({\n      ...options,\n      populate: options?.populate ? ['mcpTools'] : undefined\n    });\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/mcp-servers',\n      { params }\n    );\n\n    const mcpServers = data.data.map((item: StrapiAttributes<any>) => this.transformMCPServer(item));\n    this.cache.set(cacheKey, mcpServers);\n\n    return mcpServers;\n  }\n\n  /**\n   * Get a single MCP server by ID\n   *\n   * @description\n   * Retrieves a single MCP server by its document ID with all relations populated.\n   * Automatically populates the `mcpTools` relation to include all tools associated\n   * with this server.\n   *\n   * **Cache Behavior:**\n   * Individual servers are cached by ID. Cache is invalidated when the server is\n   * updated or deleted.\n   *\n   * **Error Handling:**\n   * Throws an error if the server with the specified ID is not found.\n   *\n   * @param {string} id - MCP server document ID\n   * @returns {Promise<MCPServer>} MCP server with populated tools\n   * @throws {Error} If MCP server with ID not found\n   *\n   * @example\n   * // Get MCP server by ID\n   * const server = await strapiClient.getMCPServer('abc123xyz');\n   * console.log(server.name);          // e.g., 'filesystem'\n   * console.log(server.transportType); // e.g., 'stdio'\n   * console.log(server.mcpTools?.length); // e.g., 15\n   *\n   * @example\n   * // Inspect server configuration\n   * const server = await strapiClient.getMCPServer('abc123xyz');\n   * if (server.transportType === 'stdio') {\n   *   console.log('Command:', server.command);\n   *   console.log('Args:', server.args);\n   *   console.log('Env:', server.env);\n   * }\n   *\n   * @example\n   * // Access populated tools\n   * const server = await strapiClient.getMCPServer('abc123xyz');\n   * const enabledTools = server.mcpTools?.filter(tool => tool.enabled) || [];\n   * console.log(`${enabledTools.length} enabled tools`);\n   *\n   * @example\n   * // Error handling for not found\n   * try {\n   *   const server = await strapiClient.getMCPServer('invalid-id');\n   * } catch (error) {\n   *   console.error('Server not found:', error.message);\n   *   // Error: MCP Server with ID invalid-id not found\n   * }\n   *\n   * @see {@link getAllMCPServers} for retrieving multiple MCP servers\n   * @see {@link updateMCPServer} for updating server configuration\n   */\n  async getMCPServer(id: string): Promise<MCPServer> {\n    const cacheKey = `mcp-server:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/mcp-servers/${id}`,\n      {\n        params: { populate: '*' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`MCP Server with ID ${id} not found`);\n    }\n\n    const mcpServer = this.transformMCPServer(data.data);\n    this.cache.set(cacheKey, mcpServer);\n\n    return mcpServer;\n  }\n\n  /**\n   * Get multiple MCP servers by their IDs\n   */\n  async getMCPServersByIds(ids: string[]): Promise<MCPServer[]> {\n    if (ids.length === 0) return [];\n\n    const filters = {\n      documentId: { $in: ids },\n    };\n\n    return this.getAllMCPServers({ filters });\n  }\n\n  /**\n   * Create a new MCP server\n   *\n   * @description\n   * Creates a new MCP (Model Context Protocol) server in Strapi database. Supports both\n   * stdio (external process) and SDK (in-process) transport types. After creation, the\n   * server can be configured with tools via `bulkSyncMCPTools`.\n   *\n   * **Transport Types:**\n   * - `stdio`: External process communication via stdin/stdout (requires command, args, env)\n   * - `sdk`: In-process SDK server (requires no additional config)\n   *\n   * **Cache Invalidation:**\n   * Creating a server invalidates all MCP server list caches.\n   *\n   * @param {CreateMCPServerDTO} mcpData - MCP server data to create\n   * @param {string} mcpData.name - Server name (e.g., 'filesystem', 'github')\n   * @param {string} [mcpData.description] - Optional server description\n   * @param {'stdio' | 'sdk'} mcpData.transportType - Transport type\n   * @param {string} [mcpData.command] - Command to execute (stdio only)\n   * @param {string[]} [mcpData.args] - Command arguments (stdio only)\n   * @param {Record<string, string>} [mcpData.env] - Environment variables (stdio only)\n   * @param {boolean} [mcpData.enabled] - Enable/disable server (default: true)\n   * @returns {Promise<MCPServer>} Created MCP server\n   * @throws {Error} If creation fails\n   *\n   * @example\n   * // Create stdio MCP server\n   * const server = await strapiClient.createMCPServer({\n   *   name: 'filesystem',\n   *   description: 'Local filesystem access',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/Users/me/projects'],\n   *   enabled: true\n   * });\n   * console.log(server.id); // Auto-generated UUID\n   *\n   * @example\n   * // Create stdio server with environment variables\n   * const githubServer = await strapiClient.createMCPServer({\n   *   name: 'github',\n   *   description: 'GitHub repository access',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-github'],\n   *   env: {\n   *     GITHUB_TOKEN: process.env.GITHUB_TOKEN || ''\n   *   },\n   *   enabled: true\n   * });\n   *\n   * @example\n   * // Create SDK MCP server (in-process)\n   * const sdkServer = await strapiClient.createMCPServer({\n   *   name: 'custom-sdk-server',\n   *   description: 'Custom in-process MCP server',\n   *   transportType: 'sdk',\n   *   enabled: true\n   * });\n   *\n   * @example\n   * // Create disabled server for later activation\n   * const server = await strapiClient.createMCPServer({\n   *   name: 'puppeteer',\n   *   description: 'Browser automation (disabled by default)',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-puppeteer'],\n   *   enabled: false // Disabled until needed\n   * });\n   *\n   * @example\n   * // Create server then sync tools\n   * const server = await strapiClient.createMCPServer({\n   *   name: 'filesystem',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()]\n   * });\n   *\n   * // Fetch and sync tools from the server\n   * const fetchedTools = [\n   *   { name: 'read_file', description: 'Read file contents' },\n   *   { name: 'write_file', description: 'Write file contents' }\n   * ];\n   * await strapiClient.bulkSyncMCPTools(server.id, fetchedTools);\n   *\n   * @see {@link updateMCPServer} for updating server configuration\n   * @see {@link bulkSyncMCPTools} for syncing server tools\n   * @see {@link deleteMCPServer} for deleting servers\n   */\n  async createMCPServer(mcpData: CreateMCPServerDTO): Promise<MCPServer> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/mcp-servers',\n      {\n        data: this.prepareMCPServerData(mcpData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create MCP server');\n    }\n\n    this.invalidateCache('mcp-servers');\n    return this.transformMCPServer(data.data);\n  }\n\n  /**\n   * Update an existing MCP server\n   *\n   * @description\n   * Updates an existing MCP server using partial update semantics. Only the fields\n   * provided in the update DTO will be modified; omitted fields remain unchanged.\n   *\n   * **Partial Updates:**\n   * You can update individual fields without affecting other fields:\n   * - Update only `enabled` without changing `command` or `args`\n   * - Update only `description` without changing configuration\n   * - Update environment variables without changing command\n   *\n   * **Cache Invalidation:**\n   * Updating invalidates both the specific server cache and all server list caches.\n   *\n   * @param {string} id - MCP server document ID\n   * @param {UpdateMCPServerDTO} mcpData - Partial server data to update\n   * @param {string} [mcpData.name] - Update server name\n   * @param {string} [mcpData.description] - Update description\n   * @param {boolean} [mcpData.enabled] - Update enabled status\n   * @param {string} [mcpData.command] - Update command (stdio only)\n   * @param {string[]} [mcpData.args] - Update arguments (stdio only)\n   * @param {Record<string, string>} [mcpData.env] - Update environment variables (stdio only)\n   * @returns {Promise<MCPServer>} Updated MCP server\n   * @throws {Error} If update fails or server not found\n   *\n   * @example\n   * // Enable/disable MCP server\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   enabled: false // Temporarily disable\n   * });\n   * console.log(server.enabled); // false\n   *\n   * @example\n   * // Update server description\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   description: 'Updated description with more details'\n   * });\n   *\n   * @example\n   * // Update command arguments\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/new/path']\n   * });\n   *\n   * @example\n   * // Update environment variables\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   env: {\n   *     GITHUB_TOKEN: process.env.NEW_GITHUB_TOKEN || '',\n   *     DEBUG: 'true'\n   *   }\n   * });\n   *\n   * @example\n   * // Update multiple fields\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   name: 'filesystem-v2',\n   *   description: 'Updated filesystem server',\n   *   enabled: true,\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()]\n   * });\n   *\n   * @example\n   * // Error handling\n   * try {\n   *   await strapiClient.updateMCPServer('invalid-id', { enabled: false });\n   * } catch (error) {\n   *   console.error('Update failed:', error.message);\n   * }\n   *\n   * @see {@link getMCPServer} for retrieving updated server\n   * @see {@link createMCPServer} for creating servers\n   */\n  async updateMCPServer(id: string, mcpData: UpdateMCPServerDTO): Promise<MCPServer> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/mcp-servers/${id}`,\n      {\n        data: this.prepareMCPServerData(mcpData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update MCP server with ID ${id}`);\n    }\n\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${id}`);\n\n    return this.transformMCPServer(data.data);\n  }\n\n  /**\n   * Delete an MCP server\n   *\n   * @description\n   * Permanently deletes an MCP server from Strapi database. This operation also\n   * cascades to delete all associated MCP tools. Use with caution as this operation\n   * cannot be undone.\n   *\n   * **Cascade Deletion:**\n   * Deleting a server automatically deletes all associated `mcpTools` records.\n   *\n   * **Cache Invalidation:**\n   * Deletion invalidates both the specific server cache and all server list caches.\n   *\n   * **Best Practices:**\n   * - Consider disabling (`enabled: false`) instead of deleting if you might need to restore\n   * - Check for agent/skill dependencies before deletion\n   * - Back up server configuration if needed\n   *\n   * @param {string} id - MCP server document ID to delete\n   * @returns {Promise<void>} Promise that resolves when deletion is complete\n   * @throws {Error} If deletion fails or server not found\n   *\n   * @example\n   * // Delete MCP server\n   * await strapiClient.deleteMCPServer('abc123');\n   * console.log('Server deleted');\n   *\n   * @example\n   * // Safe deletion with confirmation\n   * const serverId = 'abc123';\n   * const server = await strapiClient.getMCPServer(serverId);\n   * console.log(`About to delete: ${server.name}`);\n   * console.log(`This will delete ${server.mcpTools?.length || 0} tools`);\n   *\n   * // Confirm deletion\n   * await strapiClient.deleteMCPServer(serverId);\n   *\n   * @example\n   * // Check for agent dependencies before deletion\n   * const serverId = 'abc123';\n   * const agents = await strapiClient.getAllAgents({\n   *   populate: true,\n   *   filters: {\n   *     mcpConfig: {\n   *       mcpServer: { documentId: serverId }\n   *     }\n   *   }\n   * });\n   *\n   * if (agents.length > 0) {\n   *   console.warn(`Server is used by ${agents.length} agents. Cannot delete.`);\n   * } else {\n   *   await strapiClient.deleteMCPServer(serverId);\n   * }\n   *\n   * @example\n   * // Error handling\n   * try {\n   *   await strapiClient.deleteMCPServer('invalid-id');\n   * } catch (error) {\n   *   console.error('Deletion failed:', error.message);\n   * }\n   *\n   * @example\n   * // Alternative: Disable instead of delete\n   * // If you might want to restore the server later\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   enabled: false\n   * });\n   * console.log('Server disabled (can be re-enabled later)');\n   *\n   * @see {@link updateMCPServer} for disabling servers (non-destructive alternative)\n   * @see {@link createMCPServer} for recreating deleted servers\n   */\n  async deleteMCPServer(id: string): Promise<void> {\n    await this.client.delete(`/mcp-servers/${id}`);\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${id}`);\n  }\n\n  /**\n   * Update MCP server tools (DEPRECATED - use bulkSyncMCPTools instead)\n   */\n  async updateMCPServerTools(id: string, tools: any[]): Promise<MCPServer> {\n    console.warn('updateMCPServerTools is deprecated, use bulkSyncMCPTools instead');\n    return this.bulkSyncMCPTools(id, tools);\n  }\n\n  // ============= MCP TOOLS =============\n\n  /**\n   * Get all tools for an MCP server\n   *\n   * @description\n   * Retrieves all MCP tools associated with a specific MCP server. Tools represent\n   * the capabilities exposed by an MCP server and can be individually enabled/disabled\n   * in agent configurations.\n   *\n   * **Use Cases:**\n   * - List all tools for a server\n   * - Filter enabled/disabled tools\n   * - Display tools in UI for agent configuration\n   * - Validate tool availability before assignment\n   *\n   * **Tool Properties:**\n   * - `name`: Tool identifier (e.g., 'read_file', 'write_file')\n   * - `description`: Human-readable description\n   * - `inputSchema`: JSON Schema for tool parameters\n   * - `enabled`: Tool availability status\n   *\n   * @param {string} serverId - MCP server document ID\n   * @returns {Promise<MCPTool[]>} Array of MCP tools for the server\n   *\n   * @example\n   * // Get all tools for a server\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * console.log(`Found ${tools.length} tools`);\n   * tools.forEach(tool => {\n   *   console.log(`- ${tool.name}: ${tool.description}`);\n   * });\n   *\n   * @example\n   * // Filter enabled tools only\n   * const allTools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const enabledTools = allTools.filter(tool => tool.enabled !== false);\n   * console.log(`${enabledTools.length} enabled tools`);\n   *\n   * @example\n   * // Get tools for agent configuration\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const filesystemServer = mcpServers.find(s => s.name === 'filesystem');\n   *\n   * if (filesystemServer) {\n   *   const tools = await strapiClient.getMCPToolsByServerId(filesystemServer.id);\n   *   console.log('Available filesystem tools:');\n   *   tools.forEach(tool => {\n   *     console.log(`  ${tool.name}: ${tool.description}`);\n   *   });\n   * }\n   *\n   * @example\n   * // Inspect tool input schemas\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const readFileTool = tools.find(t => t.name === 'read_file');\n   *\n   * if (readFileTool?.inputSchema) {\n   *   console.log('Input schema:', JSON.stringify(readFileTool.inputSchema, null, 2));\n   *   // {\n   *   //   \"type\": \"object\",\n   *   //   \"properties\": {\n   *   //     \"path\": { \"type\": \"string\", \"description\": \"File path to read\" }\n   *   //   },\n   *   //   \"required\": [\"path\"]\n   *   // }\n   * }\n   *\n   * @example\n   * // Build tool selection for agent\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const selectedToolIds = tools\n   *   .filter(t => ['read_file', 'write_file', 'list_directory'].includes(t.name))\n   *   .map(t => ({ mcpTool: t.id }));\n   *\n   * // Use in agent mcpConfig\n   * await strapiClient.createAgent({\n   *   name: 'File Assistant',\n   *   systemPrompt: 'You help with file operations.',\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: 'abc123',\n   *       selectedTools: selectedToolIds\n   *     }\n   *   ]\n   * });\n   *\n   * @see {@link bulkSyncMCPTools} for syncing tools from MCP server\n   * @see {@link createMCPTool} for manually creating tools\n   * @see {@link updateMCPTool} for updating tool metadata\n   */\n  async getMCPToolsByServerId(serverId: string): Promise<MCPTool[]> {\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/mcp-tools',\n      {\n        params: {\n          filters: { mcpServer: { documentId: serverId } },\n        },\n      }\n    );\n\n    return data.data.map((item: StrapiAttributes<any>) => this.transformMCPTool(item));\n  }\n\n  /**\n   * Create a new MCP tool\n   *\n   * @description\n   * Creates a new MCP tool associated with a specific MCP server. Tools are typically\n   * created via `bulkSyncMCPTools` after fetching from the MCP server, but this method\n   * allows manual tool creation for custom scenarios.\n   *\n   * **Tool Schema:**\n   * The `inputSchema` follows JSON Schema specification to define tool parameters.\n   *\n   * **Common Use Cases:**\n   * - Manual tool creation for testing\n   * - Custom tool definitions not from MCP server\n   * - Placeholder tools before server sync\n   *\n   * @param {string} serverId - MCP server document ID to associate with\n   * @param {Object} toolData - Tool data\n   * @param {string} toolData.name - Unique tool name (e.g., 'read_file')\n   * @param {string} [toolData.description] - Human-readable description\n   * @param {Object} [toolData.inputSchema] - JSON Schema for tool parameters\n   * @returns {Promise<MCPTool>} Created MCP tool\n   * @throws {Error} If creation fails\n   *\n   * @example\n   * // Create basic tool\n   * const tool = await strapiClient.createMCPTool('abc123', {\n   *   name: 'read_file',\n   *   description: 'Read contents of a file'\n   * });\n   * console.log(tool.id); // Auto-generated UUID\n   *\n   * @example\n   * // Create tool with input schema\n   * const tool = await strapiClient.createMCPTool('abc123', {\n   *   name: 'write_file',\n   *   description: 'Write contents to a file',\n   *   inputSchema: {\n   *     type: 'object',\n   *     properties: {\n   *       path: {\n   *         type: 'string',\n   *         description: 'File path to write'\n   *       },\n   *       content: {\n   *         type: 'string',\n   *         description: 'Content to write'\n   *       }\n   *     },\n   *     required: ['path', 'content']\n   *   }\n   * });\n   *\n   * @example\n   * // Create multiple tools\n   * const serverId = 'abc123';\n   * const tools = [\n   *   { name: 'read_file', description: 'Read file' },\n   *   { name: 'write_file', description: 'Write file' },\n   *   { name: 'delete_file', description: 'Delete file' }\n   * ];\n   *\n   * for (const toolData of tools) {\n   *   await strapiClient.createMCPTool(serverId, toolData);\n   * }\n   *\n   * @example\n   * // Create tool with complex schema\n   * const tool = await strapiClient.createMCPTool('abc123', {\n   *   name: 'search_files',\n   *   description: 'Search for files matching criteria',\n   *   inputSchema: {\n   *     type: 'object',\n   *     properties: {\n   *       pattern: { type: 'string', description: 'Search pattern (glob)' },\n   *       path: { type: 'string', description: 'Directory to search' },\n   *       maxResults: { type: 'number', description: 'Max results to return', default: 100 }\n   *     },\n   *     required: ['pattern']\n   *   }\n   * });\n   *\n   * @see {@link bulkSyncMCPTools} for automated tool creation from MCP server\n   * @see {@link updateMCPTool} for updating tool metadata\n   * @see {@link deleteMCPTool} for removing tools\n   */\n  async createMCPTool(serverId: string, toolData: {\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }): Promise<MCPTool> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/mcp-tools',\n      {\n        data: {\n          ...toolData,\n          mcpServer: serverId,\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create MCP tool');\n    }\n\n    return this.transformMCPTool(data.data);\n  }\n\n  /**\n   * Update an existing MCP tool\n   *\n   * @description\n   * Updates an existing MCP tool using partial update semantics. Typically used\n   * by `bulkSyncMCPTools` to keep tools synchronized with MCP server metadata,\n   * but can also be used for manual updates.\n   *\n   * **Partial Updates:**\n   * Only the fields provided will be updated; omitted fields remain unchanged.\n   *\n   * **Common Updates:**\n   * - Update description for better clarity\n   * - Update inputSchema when tool parameters change\n   * - Update name if tool is renamed (rare)\n   *\n   * @param {string} toolId - MCP tool document ID\n   * @param {Object} toolData - Partial tool data to update\n   * @param {string} [toolData.name] - Update tool name\n   * @param {string} [toolData.description] - Update description\n   * @param {Object} [toolData.inputSchema] - Update input schema\n   * @returns {Promise<MCPTool>} Updated MCP tool\n   * @throws {Error} If update fails or tool not found\n   *\n   * @example\n   * // Update tool description\n   * const tool = await strapiClient.updateMCPTool('tool123', {\n   *   description: 'Read file contents with improved error handling'\n   * });\n   *\n   * @example\n   * // Update tool input schema\n   * const tool = await strapiClient.updateMCPTool('tool123', {\n   *   inputSchema: {\n   *     type: 'object',\n   *     properties: {\n   *       path: {\n   *         type: 'string',\n   *         description: 'Absolute or relative file path'\n   *       },\n   *       encoding: {\n   *         type: 'string',\n   *         description: 'File encoding',\n   *         default: 'utf-8',\n   *         enum: ['utf-8', 'ascii', 'base64']\n   *       }\n   *     },\n   *     required: ['path']\n   *   }\n   * });\n   *\n   * @example\n   * // Update multiple fields\n   * const tool = await strapiClient.updateMCPTool('tool123', {\n   *   name: 'read_file_v2',\n   *   description: 'Read file with encoding support',\n   *   inputSchema: {\n   *     type: 'object',\n   *     properties: {\n   *       path: { type: 'string' },\n   *       encoding: { type: 'string', default: 'utf-8' }\n   *     },\n   *     required: ['path']\n   *   }\n   * });\n   *\n   * @example\n   * // Update tools after server upgrade\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const readTool = tools.find(t => t.name === 'read_file');\n   *\n   * if (readTool) {\n   *   await strapiClient.updateMCPTool(readTool.id, {\n   *     description: 'Updated after server v2.0 upgrade',\n   *     inputSchema: newSchemaFromServer\n   *   });\n   * }\n   *\n   * @see {@link getMCPToolsByServerId} for retrieving tools to update\n   * @see {@link bulkSyncMCPTools} for automated tool updates\n   */\n  async updateMCPTool(toolId: string, toolData: {\n    name?: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }): Promise<MCPTool> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/mcp-tools/${toolId}`,\n      {\n        data: toolData,\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update MCP tool with ID ${toolId}`);\n    }\n\n    return this.transformMCPTool(data.data);\n  }\n\n  /**\n   * Delete an MCP tool\n   *\n   * @description\n   * Permanently deletes an MCP tool from Strapi database. This operation is typically\n   * performed by `bulkSyncMCPTools` when a tool no longer exists on the MCP server,\n   * but can also be used for manual cleanup.\n   *\n   * **Warning:**\n   * Deleting a tool may affect agent configurations that reference this tool.\n   * The tool will be removed from any agent's `mcpConfig.selectedTools` arrays.\n   *\n   * **Use Cases:**\n   * - Remove obsolete tools after server update\n   * - Clean up manually created test tools\n   * - Sync tool deletion from MCP server\n   *\n   * @param {string} toolId - MCP tool document ID to delete\n   * @returns {Promise<void>} Promise that resolves when deletion is complete\n   * @throws {Error} If deletion fails or tool not found\n   *\n   * @example\n   * // Delete a single tool\n   * await strapiClient.deleteMCPTool('tool123');\n   * console.log('Tool deleted');\n   *\n   * @example\n   * // Delete obsolete tools\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const obsoleteTools = tools.filter(t => t.name.includes('_deprecated'));\n   *\n   * for (const tool of obsoleteTools) {\n   *   await strapiClient.deleteMCPTool(tool.id);\n   *   console.log(`Deleted obsolete tool: ${tool.name}`);\n   * }\n   *\n   * @example\n   * // Delete all tools for a server before re-sync\n   * const serverId = 'abc123';\n   * const tools = await strapiClient.getMCPToolsByServerId(serverId);\n   *\n   * // Delete all existing tools\n   * await Promise.all(tools.map(t => strapiClient.deleteMCPTool(t.id)));\n   *\n   * // Now sync fresh tools\n   * await strapiClient.bulkSyncMCPTools(serverId, fetchedToolsFromServer);\n   *\n   * @example\n   * // Safe deletion with error handling\n   * try {\n   *   await strapiClient.deleteMCPTool('tool123');\n   *   console.log('Tool deleted successfully');\n   * } catch (error) {\n   *   console.error('Failed to delete tool:', error.message);\n   * }\n   *\n   * @see {@link bulkSyncMCPTools} for automated tool deletion during sync\n   * @see {@link getMCPToolsByServerId} for retrieving tools to delete\n   */\n  async deleteMCPTool(toolId: string): Promise<void> {\n    await this.client.delete(`/mcp-tools/${toolId}`);\n  }\n\n  /**\n   * Bulk sync MCP tools for a server\n   *\n   * @description\n   * Synchronizes MCP tools in Strapi database with tools fetched from an MCP server.\n   * This method performs intelligent 3-way sync:\n   * - **Create**: Adds new tools that don't exist in database\n   * - **Update**: Updates existing tools if description or inputSchema changed\n   * - **Delete**: Removes tools from database that no longer exist on server\n   *\n   * **Sync Algorithm:**\n   * 1. Fetch existing tools from database\n   * 2. Compare with fetched tools by name (name is the unique identifier)\n   * 3. Delete tools not in fetched list\n   * 4. Update tools with changed metadata (description, inputSchema)\n   * 5. Create tools that don't exist in database\n   * 6. Update server's `toolsFetchedAt` timestamp\n   *\n   * **Use Cases:**\n   * - Initial tool discovery after creating MCP server\n   * - Periodic sync to update tool metadata\n   * - Tool refresh after server upgrade\n   *\n   * **Cache Invalidation:**\n   * Invalidates MCP server caches after sync completes.\n   *\n   * @param {string} serverId - MCP server document ID\n   * @param {Array} fetchedTools - Tools fetched from MCP server\n   * @param {string} fetchedTools[].name - Tool name (unique identifier)\n   * @param {string} [fetchedTools[].description] - Tool description\n   * @param {Object} [fetchedTools[].inputSchema] - Tool input schema (JSON Schema)\n   * @returns {Promise<MCPServer>} Updated MCP server with tools populated\n   *\n   * @example\n   * // Basic tool sync after server creation\n   * const server = await strapiClient.createMCPServer({\n   *   name: 'filesystem',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()]\n   * });\n   *\n   * // Fetch tools from MCP server (pseudo-code)\n   * const fetchedTools = [\n   *   { name: 'read_file', description: 'Read file contents' },\n   *   { name: 'write_file', description: 'Write file contents' },\n   *   { name: 'list_directory', description: 'List directory contents' }\n   * ];\n   *\n   * // Sync tools to database\n   * const updatedServer = await strapiClient.bulkSyncMCPTools(server.id, fetchedTools);\n   * console.log(`Synced ${updatedServer.mcpTools?.length} tools`);\n   *\n   * @example\n   * // Sync with detailed tool schemas\n   * const fetchedTools = [\n   *   {\n   *     name: 'read_file',\n   *     description: 'Read contents of a file',\n   *     inputSchema: {\n   *       type: 'object',\n   *       properties: {\n   *         path: { type: 'string', description: 'File path to read' }\n   *       },\n   *       required: ['path']\n   *     }\n   *   },\n   *   {\n   *     name: 'write_file',\n   *     description: 'Write contents to a file',\n   *     inputSchema: {\n   *       type: 'object',\n   *       properties: {\n   *         path: { type: 'string', description: 'File path to write' },\n   *         content: { type: 'string', description: 'Content to write' }\n   *       },\n   *       required: ['path', 'content']\n   *     }\n   *   }\n   * ];\n   *\n   * await strapiClient.bulkSyncMCPTools('abc123', fetchedTools);\n   *\n   * @example\n   * // Sync workflow with MCPService integration\n   * import { mcpService } from './mcp-service';\n   *\n   * // Get MCP server from database\n   * const server = await strapiClient.getMCPServer('abc123');\n   *\n   * // Fetch tools from MCP server\n   * const fetchedTools = await mcpService.listMCPServerTools(server.id);\n   *\n   * // Sync to database\n   * const updatedServer = await strapiClient.bulkSyncMCPTools(server.id, fetchedTools);\n   * console.log(`Sync complete. ${updatedServer.mcpTools?.length} tools available.`);\n   *\n   * @example\n   * // Periodic sync to keep tools up-to-date\n   * async function syncAllMCPServers() {\n   *   const servers = await strapiClient.getAllMCPServers({\n   *     filters: { enabled: { $eq: true } }\n   *   });\n   *\n   *   for (const server of servers) {\n   *     console.log(`Syncing tools for ${server.name}...`);\n   *     const fetchedTools = await mcpService.listMCPServerTools(server.id);\n   *     await strapiClient.bulkSyncMCPTools(server.id, fetchedTools);\n   *     console.log(`\u2713 ${server.name} synced`);\n   *   }\n   * }\n   *\n   * @example\n   * // Handle sync errors gracefully\n   * try {\n   *   const fetchedTools = await mcpService.listMCPServerTools('abc123');\n   *   const server = await strapiClient.bulkSyncMCPTools('abc123', fetchedTools);\n   *   console.log(`Synced ${server.mcpTools?.length} tools successfully`);\n   * } catch (error) {\n   *   console.error('Tool sync failed:', error.message);\n   *   // Server tools remain unchanged\n   * }\n   *\n   * @example\n   * // Sync removes obsolete tools\n   * // Before sync: database has ['read_file', 'write_file', 'delete_file']\n   * // After MCP server upgrade: server only has ['read_file', 'write_file']\n   *\n   * const fetchedTools = [\n   *   { name: 'read_file', description: 'Read file' },\n   *   { name: 'write_file', description: 'Write file' }\n   *   // 'delete_file' is missing - will be deleted from database\n   * ];\n   *\n   * await strapiClient.bulkSyncMCPTools('abc123', fetchedTools);\n   * // Database now has only ['read_file', 'write_file']\n   * // 'delete_file' was automatically deleted\n   *\n   * @example\n   * // Check what changed during sync\n   * const beforeTools = await strapiClient.getMCPToolsByServerId('abc123');\n   * console.log(`Before sync: ${beforeTools.length} tools`);\n   *\n   * const fetchedTools = await mcpService.listMCPServerTools('abc123');\n   * await strapiClient.bulkSyncMCPTools('abc123', fetchedTools);\n   *\n   * const afterTools = await strapiClient.getMCPToolsByServerId('abc123');\n   * console.log(`After sync: ${afterTools.length} tools`);\n   *\n   * const added = afterTools.filter(t => !beforeTools.find(b => b.name === t.name));\n   * const removed = beforeTools.filter(t => !afterTools.find(a => a.name === t.name));\n   * console.log(`Added: ${added.map(t => t.name).join(', ')}`);\n   * console.log(`Removed: ${removed.map(t => t.name).join(', ')}`);\n   *\n   * @see {@link getMCPToolsByServerId} for retrieving synced tools\n   * @see {@link createMCPTool} for manual tool creation\n   * @see {@link updateMCPTool} for manual tool updates\n   * @see {@link deleteMCPTool} for manual tool deletion\n   */\n  async bulkSyncMCPTools(serverId: string, fetchedTools: Array<{\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }>): Promise<MCPServer> {\n    // Get existing tools for this server\n    const existingTools = await this.getMCPToolsByServerId(serverId);\n\n    // Create a map of existing tools by name\n    const existingToolsMap = new Map(existingTools.map(t => [t.name, t]));\n\n    // Create a set of fetched tool names\n    const fetchedToolNames = new Set(fetchedTools.map(t => t.name));\n\n    // Delete tools that no longer exist\n    const toolsToDelete = existingTools.filter(t => !fetchedToolNames.has(t.name));\n    await Promise.all(toolsToDelete.map(t => this.deleteMCPTool(t.id)));\n\n    // Create or update tools\n    for (const fetchedTool of fetchedTools) {\n      const existingTool = existingToolsMap.get(fetchedTool.name);\n\n      if (existingTool) {\n        // Update if changed\n        const hasChanged =\n          existingTool.description !== fetchedTool.description ||\n          JSON.stringify(existingTool.inputSchema) !== JSON.stringify(fetchedTool.inputSchema);\n\n        if (hasChanged) {\n          await this.updateMCPTool(existingTool.id, fetchedTool);\n        }\n      } else {\n        // Create new tool\n        await this.createMCPTool(serverId, fetchedTool);\n      }\n    }\n\n    // Update toolsFetchedAt timestamp on the server\n    await this.client.put(`/mcp-servers/${serverId}`, {\n      data: {\n        toolsFetchedAt: new Date().toISOString(),\n      },\n    });\n\n    // Invalidate cache\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${serverId}`);\n\n    // Return updated server with tools\n    return this.getMCPServer(serverId);\n  }\n\n  // ============= FILE UPLOAD =============\n\n  /**\n   * Upload a file to Strapi Media Library\n   *\n   * @description\n   * Uploads a file to Strapi's Media Library. The uploaded file is stored in Strapi's\n   * configured storage provider (local filesystem, S3, Cloudinary, etc.) and can be\n   * referenced in other content types via file relations. Common use cases include\n   * uploading skill attachments, agent documentation, or training materials.\n   *\n   * **Supported File Types:**\n   * - Images: .jpg, .jpeg, .png, .gif, .svg, .webp\n   * - Documents: .pdf, .doc, .docx, .txt, .md\n   * - Archives: .zip, .tar, .gz\n   * - Code: .js, .ts, .py, .java, .cpp, etc.\n   * - Any other file type (MIME type auto-detected)\n   *\n   * **File Size Limits:**\n   * - Default Strapi limit: 200MB (configurable in Strapi)\n   * - Large files may require adjusting Strapi's `strapi::body` middleware configuration\n   *\n   * @param {Buffer | Blob} file - File to upload (Buffer for Node.js, Blob for browsers)\n   * @param {string} filename - Original filename with extension (e.g., 'document.pdf')\n   *\n   * @returns {Promise<Object>} Strapi media object with file metadata\n   * @returns {number} returns.id - Numeric file ID (legacy)\n   * @returns {string} returns.documentId - UUID document ID (Strapi v5)\n   * @returns {string} returns.name - Stored filename\n   * @returns {string} returns.url - Public URL to access the file\n   * @returns {string} returns.mime - MIME type (e.g., 'application/pdf', 'image/png')\n   * @returns {number} returns.size - File size in bytes\n   *\n   * @throws {Error} If file upload fails\n   *\n   * @example\n   * // Upload a text file from Buffer\n   * import fs from 'fs/promises';\n   *\n   * const fileBuffer = await fs.readFile('./example.txt');\n   * const uploadedFile = await strapiClient.uploadFile(fileBuffer, 'example.txt');\n   *\n   * console.log('File uploaded:', uploadedFile.url);\n   * console.log('File ID:', uploadedFile.documentId);\n   *\n   * @example\n   * // Upload an image and attach to a skill\n   * const imageBuffer = await fs.readFile('./diagram.png');\n   * const uploadedImage = await strapiClient.uploadFile(imageBuffer, 'diagram.png');\n   *\n   * // Create skill with image attachment\n   * const skill = await strapiClient.createSkill({\n   *   name: 'image-processing',\n   *   displayName: 'Image Processing',\n   *   description: 'Process and analyze images',\n   *   additionalFiles: [\n   *     {\n   *       name: 'Architecture Diagram',\n   *       description: 'System architecture',\n   *       file: uploadedImage.documentId // Reference uploaded file\n   *     }\n   *   ]\n   * });\n   *\n   * @example\n   * // Upload PDF documentation\n   * const pdfBuffer = await fs.readFile('./user-guide.pdf');\n   * const uploadedPdf = await strapiClient.uploadFile(pdfBuffer, 'user-guide.pdf');\n   *\n   * console.log(`PDF uploaded: ${uploadedPdf.name}`);\n   * console.log(`Size: ${(uploadedPdf.size / 1024).toFixed(2)} KB`);\n   * console.log(`MIME: ${uploadedPdf.mime}`);\n   * console.log(`URL: ${uploadedPdf.url}`);\n   *\n   * @example\n   * // Upload multiple files sequentially\n   * const files = ['file1.txt', 'file2.txt', 'file3.txt'];\n   * const uploadedFiles = [];\n   *\n   * for (const filename of files) {\n   *   const buffer = await fs.readFile(`./uploads/${filename}`);\n   *   const uploaded = await strapiClient.uploadFile(buffer, filename);\n   *   uploadedFiles.push(uploaded);\n   *   console.log(`Uploaded: ${filename} -> ${uploaded.documentId}`);\n   * }\n   *\n   * @example\n   * // Error handling for file upload\n   * try {\n   *   const buffer = await fs.readFile('./large-file.zip');\n   *   const uploaded = await strapiClient.uploadFile(buffer, 'large-file.zip');\n   *   console.log('Upload successful');\n   * } catch (error) {\n   *   console.error('Upload failed:', error.message);\n   *   // Handle error (file too large, invalid type, network error, etc.)\n   * }\n   *\n   * @example\n   * // Upload file and use URL directly\n   * const logoBuffer = await fs.readFile('./logo.png');\n   * const uploadedLogo = await strapiClient.uploadFile(logoBuffer, 'logo.png');\n   *\n   * // Use the URL in your application\n   * const fullUrl = `${process.env.STRAPI_URL}${uploadedLogo.url}`;\n   * console.log(`Logo available at: ${fullUrl}`);\n   *\n   * @see {@link deleteFile} - Delete uploaded files\n   */\n  async uploadFile(file: Buffer | Blob, filename: string): Promise<{\n    id: number;\n    documentId: string;\n    name: string;\n    url: string;\n    mime: string;\n    size: number;\n  }> {\n    const FormData = (await import('form-data')).default;\n    const formData = new FormData();\n\n    formData.append('files', file, filename);\n\n    const { data } = await this.client.post('/upload', formData, {\n      headers: {\n        ...formData.getHeaders(),\n      },\n    });\n\n    if (!data || !data[0]) {\n      throw new Error('Failed to upload file');\n    }\n\n    const uploadedFile = data[0];\n\n    return {\n      id: uploadedFile.id,\n      documentId: uploadedFile.documentId,\n      name: uploadedFile.name,\n      url: uploadedFile.url,\n      mime: uploadedFile.mime,\n      size: uploadedFile.size,\n    };\n  }\n\n  /**\n   * Delete a file from Strapi Media Library\n   *\n   * @description\n   * Permanently deletes a file from Strapi's Media Library and its configured storage\n   * provider. This operation cannot be undone. Ensure the file is not referenced by any\n   * content types before deletion, as this will break file relations.\n   *\n   * **Important Notes:**\n   * - File is permanently deleted from storage (local/S3/Cloudinary/etc.)\n   * - Any content referencing this file will have broken file relations\n   * - Strapi does not prevent deletion of files in use\n   * - Consider verifying file references before deletion\n   *\n   * @param {string} fileId - File document ID (UUID format from Strapi v5) or numeric ID (legacy)\n   *\n   * @returns {Promise<void>}\n   *\n   * @throws {Error} If file deletion fails or file not found\n   *\n   * @example\n   * // Basic file deletion\n   * await strapiClient.deleteFile('file-uuid-123');\n   * console.log('File deleted successfully');\n   *\n   * @example\n   * // Delete file after uploading a replacement\n   * const oldFileId = 'old-file-uuid';\n   *\n   * // Upload new version\n   * const newBuffer = await fs.readFile('./updated-document.pdf');\n   * const newFile = await strapiClient.uploadFile(newBuffer, 'updated-document.pdf');\n   *\n   * // Update skill to reference new file\n   * await strapiClient.updateSkill('skill-uuid', {\n   *   additionalFiles: [\n   *     { name: 'Documentation', file: newFile.documentId }\n   *   ]\n   * });\n   *\n   * // Now safe to delete old file\n   * await strapiClient.deleteFile(oldFileId);\n   *\n   * @example\n   * // Error handling for file deletion\n   * try {\n   *   await strapiClient.deleteFile('file-uuid-123');\n   *   console.log('File deleted');\n   * } catch (error) {\n   *   console.error('Failed to delete file:', error.message);\n   *   // Handle error (file not found, permission denied, etc.)\n   * }\n   *\n   * @example\n   * // Delete multiple files (cleanup unused attachments)\n   * const fileIdsToDelete = [\n   *   'file-uuid-1',\n   *   'file-uuid-2',\n   *   'file-uuid-3'\n   * ];\n   *\n   * for (const fileId of fileIdsToDelete) {\n   *   try {\n   *     await strapiClient.deleteFile(fileId);\n   *     console.log(`Deleted: ${fileId}`);\n   *   } catch (error) {\n   *     console.error(`Failed to delete ${fileId}:`, error.message);\n   *   }\n   * }\n   *\n   * @example\n   * // Safe deletion workflow - verify no references first\n   * // Note: This is a conceptual example - actual implementation depends on your data model\n   * const fileId = 'file-uuid-123';\n   *\n   * // Check if any skills reference this file\n   * const skills = await strapiClient.getAllSkills();\n   * const isReferenced = skills.some(skill =>\n   *   skill.additionalFiles?.some(f => f.file === fileId)\n   * );\n   *\n   * if (!isReferenced) {\n   *   await strapiClient.deleteFile(fileId);\n   *   console.log('File safely deleted (no references found)');\n   * } else {\n   *   console.warn('File is still referenced - cannot delete');\n   * }\n   *\n   * @see {@link uploadFile} - Upload files to Media Library\n   */\n  async deleteFile(fileId: string): Promise<void> {\n    await this.client.delete(`/upload/files/${fileId}`);\n  }\n\n  // ============= TASKS =============\n\n  /**\n   * Get all tasks with optional filtering, sorting, and pagination\n   *\n   * @description\n   * Retrieves all tasks from Strapi with support for filtering by status, assigned agent,\n   * priority, and other fields. Tasks represent work items, automation jobs, or scheduled\n   * operations assigned to agents. Results are cached with 5-minute TTL for improved performance.\n   *\n   * **Common Task Fields:**\n   * - `title`: Task title/name\n   * - `description`: Task description\n   * - `status`: Task status (pending, in_progress, completed, failed, etc.)\n   * - `priority`: Priority level (low, medium, high, urgent)\n   * - `dueDate`: Optional due date\n   * - `agent`: Assigned agent (relation)\n   * - `result`: Task execution result/output\n   * - `metadata`: Custom task metadata\n   *\n   * @param {Object} [options] - Query options for filtering, sorting, and pagination\n   * @param {Record<string, any>} [options.filters] - Strapi v5 filters object (supports $eq, $ne, $in, $containsi, $and, $or, etc.)\n   * @param {string[]} [options.sort] - Sort order array (e.g., ['dueDate:asc', 'priority:desc'])\n   * @param {Object} [options.pagination] - Pagination configuration\n   * @param {number} [options.pagination.page] - Page number (1-indexed)\n   * @param {number} [options.pagination.pageSize] - Number of items per page\n   *\n   * @returns {Promise<Task[]>} Array of Task objects\n   *\n   * @example\n   * // Basic usage - get all tasks\n   * const tasks = await strapiClient.getAllTasks();\n   * console.log(`Found ${tasks.length} tasks`);\n   *\n   * @example\n   * // Filter by status - get pending tasks only\n   * const pendingTasks = await strapiClient.getAllTasks({\n   *   filters: { status: { $eq: 'pending' } }\n   * });\n   *\n   * @example\n   * // Filter by multiple statuses using $in operator\n   * const activeTasks = await strapiClient.getAllTasks({\n   *   filters: {\n   *     status: { $in: ['pending', 'in_progress'] }\n   *   }\n   * });\n   *\n   * @example\n   * // Filter by assigned agent\n   * const agentTasks = await strapiClient.getAllTasks({\n   *   filters: {\n   *     agent: { documentId: { $eq: 'agent-uuid-123' } }\n   *   }\n   * });\n   *\n   * @example\n   * // Sort by priority and due date\n   * const sortedTasks = await strapiClient.getAllTasks({\n   *   sort: ['priority:desc', 'dueDate:asc'],\n   *   filters: { status: { $ne: 'completed' } }\n   * });\n   *\n   * @example\n   * // Pagination - get first page of high-priority tasks\n   * const highPriorityTasks = await strapiClient.getAllTasks({\n   *   filters: { priority: { $eq: 'high' } },\n   *   pagination: { page: 1, pageSize: 20 },\n   *   sort: ['createdAt:desc']\n   * });\n   *\n   * @example\n   * // Search tasks by title (case-insensitive)\n   * const searchResults = await strapiClient.getAllTasks({\n   *   filters: {\n   *     title: { $containsi: 'backup' }\n   *   }\n   * });\n   *\n   * @example\n   * // Get overdue tasks (dueDate in the past and not completed)\n   * const overdueTasks = await strapiClient.getAllTasks({\n   *   filters: {\n   *     $and: [\n   *       { dueDate: { $lt: new Date().toISOString() } },\n   *       { status: { $ne: 'completed' } }\n   *     ]\n   *   }\n   * });\n   */\n  async getAllTasks(options?: {\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Task[]> {\n    const cacheKey = `tasks:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams(options);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/tasks',\n      { params }\n    );\n\n    const tasks = data.data.map((item: StrapiAttributes<any>) => this.transformTask(item));\n    this.cache.set(cacheKey, tasks);\n\n    return tasks;\n  }\n\n  /**\n   * Get a single task by ID with populated agent relation\n   *\n   * @description\n   * Retrieves a single task by its unique document ID with the assigned agent relation\n   * automatically populated. Use this method to get detailed task information including\n   * the full agent configuration.\n   *\n   * **Auto-populated Relations:**\n   * - `agent`: Assigned agent with full configuration\n   *\n   * @param {string} id - Task document ID (UUID format)\n   *\n   * @returns {Promise<Task>} Task object with populated agent relation\n   *\n   * @throws {Error} If task with the specified ID is not found\n   *\n   * @example\n   * // Basic usage - get task by ID\n   * const task = await strapiClient.getTask('task-uuid-123');\n   * console.log(`Task: ${task.title}`);\n   * console.log(`Status: ${task.status}`);\n   * console.log(`Assigned to: ${task.agent?.name}`);\n   *\n   * @example\n   * // Get task and check status\n   * try {\n   *   const task = await strapiClient.getTask('task-uuid-123');\n   *\n   *   if (task.status === 'completed') {\n   *     console.log('Task completed successfully');\n   *     console.log('Result:', task.result);\n   *   } else if (task.status === 'failed') {\n   *     console.error('Task failed:', task.result);\n   *   }\n   * } catch (error) {\n   *   console.error('Task not found');\n   * }\n   *\n   * @example\n   * // Get task and display detailed information\n   * const task = await strapiClient.getTask('task-uuid-123');\n   *\n   * console.log('Task Details:');\n   * console.log(`  Title: ${task.title}`);\n   * console.log(`  Status: ${task.status}`);\n   * console.log(`  Priority: ${task.priority}`);\n   * console.log(`  Due: ${task.dueDate || 'No due date'}`);\n   * console.log(`  Agent: ${task.agent?.name || 'Unassigned'}`);\n   * console.log(`  Created: ${task.createdAt}`);\n   * console.log(`  Updated: ${task.updatedAt}`);\n   *\n   * @example\n   * // Error handling for non-existent task\n   * try {\n   *   const task = await strapiClient.getTask('invalid-id');\n   * } catch (error) {\n   *   console.error('Failed to retrieve task:', error.message);\n   *   // Handle error (show error message to user, etc.)\n   * }\n   */\n  async getTask(id: string): Promise<Task> {\n    const cacheKey = `task:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/tasks/${id}`,\n      {\n        params: { populate: 'agent' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Task with ID ${id} not found`);\n    }\n\n    const task = this.transformTask(data.data);\n    this.cache.set(cacheKey, task);\n\n    return task;\n  }\n\n  /**\n   * Create a new task\n   *\n   * @description\n   * Creates a new task in Strapi. Tasks can be assigned to agents for execution and can\n   * include metadata, priority levels, and due dates. The task status defaults to 'pending'\n   * if not specified.\n   *\n   * **Cache Behavior:**\n   * - Invalidates all task list caches to ensure fresh data on next fetch\n   * - New task is not immediately cached (cached on first retrieval)\n   *\n   * @param {CreateTaskDTO} taskData - Task data to create\n   * @param {string} taskData.title - Task title/name (required)\n   * @param {string} [taskData.description] - Task description\n   * @param {string} [taskData.status] - Task status (pending, in_progress, completed, failed, etc.)\n   * @param {string} [taskData.priority] - Priority level (low, medium, high, urgent)\n   * @param {string} [taskData.dueDate] - Due date (ISO 8601 format)\n   * @param {string} [taskData.agent] - Assigned agent ID (UUID)\n   * @param {any} [taskData.metadata] - Custom task metadata\n   *\n   * @returns {Promise<Task>} Created task object\n   *\n   * @throws {Error} If task creation fails\n   *\n   * @example\n   * // Basic task creation\n   * const task = await strapiClient.createTask({\n   *   title: 'Process customer data',\n   *   description: 'Extract and validate customer information from CSV',\n   *   status: 'pending'\n   * });\n   * console.log(`Created task: ${task.id}`);\n   *\n   * @example\n   * // Create task with agent assignment\n   * const task = await strapiClient.createTask({\n   *   title: 'Generate monthly report',\n   *   description: 'Compile sales metrics and generate PDF report',\n   *   status: 'pending',\n   *   priority: 'high',\n   *   agent: 'agent-uuid-123' // Assign to specific agent\n   * });\n   *\n   * @example\n   * // Create task with due date and priority\n   * const tomorrow = new Date();\n   * tomorrow.setDate(tomorrow.getDate() + 1);\n   *\n   * const task = await strapiClient.createTask({\n   *   title: 'Backup database',\n   *   description: 'Perform full database backup to S3',\n   *   status: 'pending',\n   *   priority: 'urgent',\n   *   dueDate: tomorrow.toISOString(),\n   *   agent: 'backup-agent-uuid'\n   * });\n   *\n   * @example\n   * // Create task with custom metadata\n   * const task = await strapiClient.createTask({\n   *   title: 'Send email notifications',\n   *   description: 'Send weekly digest emails to subscribers',\n   *   status: 'pending',\n   *   priority: 'medium',\n   *   metadata: {\n   *     emailCount: 1500,\n   *     template: 'weekly-digest',\n   *     sendTime: '2024-01-15T09:00:00Z'\n   *   }\n   * });\n   *\n   * @example\n   * // Create task and immediately start execution\n   * const task = await strapiClient.createTask({\n   *   title: 'Index search documents',\n   *   description: 'Update Elasticsearch index with new documents',\n   *   status: 'in_progress', // Start immediately\n   *   priority: 'high',\n   *   agent: 'indexer-agent-uuid'\n   * });\n   *\n   * // Poll task status\n   * const checkStatus = async () => {\n   *   const updated = await strapiClient.getTask(task.id);\n   *   console.log(`Status: ${updated.status}`);\n   * };\n   *\n   * @example\n   * // Error handling for task creation\n   * try {\n   *   const task = await strapiClient.createTask({\n   *     title: 'Important task',\n   *     description: 'Critical operation',\n   *     agent: 'invalid-agent-id' // Invalid agent reference\n   *   });\n   * } catch (error) {\n   *   console.error('Failed to create task:', error.message);\n   *   // Handle error (show validation message, retry, etc.)\n   * }\n   */\n  async createTask(taskData: CreateTaskDTO): Promise<Task> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/tasks',\n      {\n        data: this.prepareTaskData(taskData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create task');\n    }\n\n    this.invalidateCache('tasks');\n    return this.transformTask(data.data);\n  }\n\n  /**\n   * Update an existing task\n   *\n   * @description\n   * Updates an existing task with partial data. Only provided fields are updated; omitted\n   * fields remain unchanged. Common use cases include updating task status, adding results,\n   * changing priority, or reassigning to a different agent.\n   *\n   * **Partial Update Semantics:**\n   * - Only fields present in `taskData` are updated\n   * - Omitted fields retain their current values\n   * - Pass `null` explicitly to clear a field value\n   *\n   * **Cache Behavior:**\n   * - Invalidates all task list caches\n   * - Invalidates the specific task cache entry\n   * - Updated task is returned but not immediately re-cached\n   *\n   * @param {string} id - Task document ID to update\n   * @param {UpdateTaskDTO} taskData - Partial task data to update\n   * @param {string} [taskData.title] - Update task title\n   * @param {string} [taskData.description] - Update task description\n   * @param {string} [taskData.status] - Update task status\n   * @param {string} [taskData.priority] - Update priority level\n   * @param {string} [taskData.dueDate] - Update due date\n   * @param {string} [taskData.agent] - Reassign to different agent\n   * @param {any} [taskData.result] - Set task execution result\n   * @param {any} [taskData.metadata] - Update task metadata\n   *\n   * @returns {Promise<Task>} Updated task object\n   *\n   * @throws {Error} If task update fails or task not found\n   *\n   * @example\n   * // Update task status\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'completed'\n   * });\n   * console.log(`Task status updated to: ${task.status}`);\n   *\n   * @example\n   * // Update task status and add result\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'completed',\n   *   result: {\n   *     processedRecords: 1500,\n   *     duration: '5.2s',\n   *     success: true\n   *   }\n   * });\n   *\n   * @example\n   * // Mark task as failed with error information\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'failed',\n   *   result: {\n   *     error: 'Database connection timeout',\n   *     retryCount: 3,\n   *     lastAttempt: new Date().toISOString()\n   *   }\n   * });\n   *\n   * @example\n   * // Change task priority\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   priority: 'urgent'\n   * });\n   *\n   * @example\n   * // Reassign task to different agent\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   agent: 'new-agent-uuid',\n   *   status: 'pending' // Reset status when reassigning\n   * });\n   *\n   * @example\n   * // Update multiple fields at once\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'in_progress',\n   *   priority: 'high',\n   *   metadata: {\n   *     startedAt: new Date().toISOString(),\n   *     assignedWorker: 'worker-3'\n   *   }\n   * });\n   *\n   * @example\n   * // Extend due date\n   * const nextWeek = new Date();\n   * nextWeek.setDate(nextWeek.getDate() + 7);\n   *\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   dueDate: nextWeek.toISOString()\n   * });\n   *\n   * @example\n   * // Error handling for task update\n   * try {\n   *   const task = await strapiClient.updateTask('task-uuid-123', {\n   *     status: 'completed',\n   *     result: { success: true }\n   *   });\n   * } catch (error) {\n   *   console.error('Failed to update task:', error.message);\n   *   // Handle error (task not found, validation error, etc.)\n   * }\n   */\n  async updateTask(id: string, taskData: UpdateTaskDTO): Promise<Task> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/tasks/${id}`,\n      {\n        data: this.prepareTaskData(taskData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update task with ID ${id}`);\n    }\n\n    this.invalidateCache('tasks');\n    this.cache.delete(`task:${id}`);\n\n    return this.transformTask(data.data);\n  }\n\n  /**\n   * Delete a task\n   *\n   * @description\n   * Permanently deletes a task from Strapi. This operation cannot be undone. Consider\n   * updating the task status to 'cancelled' or 'archived' instead if you need to preserve\n   * task history.\n   *\n   * **Cache Behavior:**\n   * - Invalidates all task list caches\n   * - Removes the specific task cache entry\n   *\n   * **Best Practices:**\n   * - Verify task can be safely deleted before calling (no critical dependencies)\n   * - Consider soft-delete approach (status = 'deleted') for audit trail\n   * - Ensure task is not currently being executed by an agent\n   *\n   * @param {string} id - Task document ID to delete\n   *\n   * @returns {Promise<void>}\n   *\n   * @throws {Error} If task deletion fails or task not found\n   *\n   * @example\n   * // Basic task deletion\n   * await strapiClient.deleteTask('task-uuid-123');\n   * console.log('Task deleted successfully');\n   *\n   * @example\n   * // Delete task with confirmation check\n   * const task = await strapiClient.getTask('task-uuid-123');\n   *\n   * if (task.status === 'completed' || task.status === 'cancelled') {\n   *   await strapiClient.deleteTask(task.id);\n   *   console.log('Task deleted successfully');\n   * } else {\n   *   console.warn('Cannot delete active task');\n   * }\n   *\n   * @example\n   * // Error handling for task deletion\n   * try {\n   *   await strapiClient.deleteTask('task-uuid-123');\n   *   console.log('Task deleted');\n   * } catch (error) {\n   *   console.error('Failed to delete task:', error.message);\n   *   // Handle error (task not found, permission denied, etc.)\n   * }\n   *\n   * @example\n   * // Soft delete alternative - preserve task history\n   * // Instead of permanently deleting, update status to 'deleted'\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'deleted',\n   *   metadata: {\n   *     deletedAt: new Date().toISOString(),\n   *     deletedBy: 'user-123'\n   *   }\n   * });\n   * // Task is hidden from normal queries but preserved in database\n   *\n   * @example\n   * // Bulk delete completed tasks older than 30 days\n   * const thirtyDaysAgo = new Date();\n   * thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n   *\n   * const oldTasks = await strapiClient.getAllTasks({\n   *   filters: {\n   *     $and: [\n   *       { status: { $eq: 'completed' } },\n   *       { updatedAt: { $lt: thirtyDaysAgo.toISOString() } }\n   *     ]\n   *   }\n   * });\n   *\n   * for (const task of oldTasks) {\n   *   await strapiClient.deleteTask(task.id);\n   * }\n   * console.log(`Deleted ${oldTasks.length} old tasks`);\n   */\n  async deleteTask(id: string): Promise<void> {\n    await this.client.delete(`/tasks/${id}`);\n    this.invalidateCache('tasks');\n    this.cache.delete(`task:${id}`);\n  }\n\n  // ============= TRANSFORMERS =============\n  // Transform Strapi response format to domain models\n\n  /**\n   * Extract attributes from Strapi response\n   *\n   * @description Handles both nested (attributes) and flat response formats from Strapi.\n   * Strapi v5 typically returns data in nested format with `attributes` property, but some\n   * configurations or API endpoints may return flat data directly.\n   *\n   * This method provides a unified interface for accessing response data regardless of format:\n   * - Nested format: `{ documentId: '...', attributes: { name: '...', ... } }`\n   * - Flat format: `{ documentId: '...', name: '...', ... }`\n   *\n   * @param strapiData - Raw Strapi response data (nested or flat)\n   * @returns Extracted attributes object containing all entity fields\n   *\n   * @example\n   * // Nested format (Strapi v5 default)\n   * const nestedData = {\n   *   documentId: 'agent-123',\n   *   attributes: {\n   *     name: 'Research Agent',\n   *     systemPrompt: 'You are a research assistant',\n   *     enabled: true,\n   *     createdAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const attrs = this.extractAttributes(nestedData);\n   * // Returns: { name: 'Research Agent', systemPrompt: '...', enabled: true, createdAt: '...' }\n   *\n   * @example\n   * // Flat format (some Strapi configurations)\n   * const flatData = {\n   *   documentId: 'agent-123',\n   *   name: 'Research Agent',\n   *   systemPrompt: 'You are a research assistant',\n   *   enabled: true,\n   *   createdAt: '2024-01-01T00:00:00.000Z'\n   * };\n   * const attrs = this.extractAttributes(flatData);\n   * // Returns: { documentId: '...', name: 'Research Agent', systemPrompt: '...', enabled: true, createdAt: '...' }\n   *\n   * @see transformAgent\n   * @see transformSkill\n   * @see transformMCPServer\n   * @see transformMCPTool\n   * @see transformTask\n   */\n  private extractAttributes(strapiData: any): any {\n    // If data has attributes property, use it (Strapi 5 default format)\n    if (strapiData.attributes) {\n      return strapiData.attributes;\n    }\n\n    // Otherwise, data is already flat (some Strapi configurations)\n    return strapiData;\n  }\n\n  /**\n   * Transform Strapi agent response to Agent domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's Agent domain model.\n   * Handles component-based structure including toolConfig, modelConfig, analytics, metadata,\n   * mcpConfig (component with nested MCP server and tool relations), skillSelection, and tasks.\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'agent-uuid',\n   *   attributes: {\n   *     name: string,\n   *     slug: string,\n   *     description: string,\n   *     systemPrompt: string,\n   *     enabled: boolean,\n   *     toolConfig: { allowedTools: string[], ... },\n   *     modelConfig: { model: string, temperature: number, ... },\n   *     analytics: { tokenUsage: number, ... },\n   *     metadata: [{ key: string, value: string }],\n   *     mcpConfig: [{ mcpServer: { data: {...} }, selectedTools: [...] }],\n   *     skillSelection: [{ skill: { data: {...} }, ... }],\n   *     tasks: [{ data: {...} }],\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   name: string,\n   *   slug: string,\n   *   description: string,\n   *   systemPrompt: string,\n   *   enabled: boolean,\n   *   toolConfig?: {...},\n   *   modelConfig: {...},\n   *   analytics?: {...},\n   *   metadata?: [...],\n   *   mcpConfig: [...],\n   *   skillSelection: [...],\n   *   tasks: [...],\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed Agent object ready for application use\n   *\n   * @example\n   * // Transform basic agent\n   * const strapiResponse = {\n   *   documentId: 'agent-123',\n   *   attributes: {\n   *     name: 'Research Agent',\n   *     slug: 'research-agent',\n   *     description: 'Agent for research tasks',\n   *     systemPrompt: 'You are a research assistant',\n   *     enabled: true,\n   *     modelConfig: {\n   *       model: 'sonnet',\n   *       temperature: 1.0,\n   *       timeout: 300000\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const agent = this.transformAgent(strapiResponse);\n   * // Returns: {\n   * //   id: 'agent-123',\n   * //   name: 'Research Agent',\n   * //   slug: 'research-agent',\n   * //   description: 'Agent for research tasks',\n   * //   systemPrompt: 'You are a research assistant',\n   * //   enabled: true,\n   * //   modelConfig: { model: 'sonnet', temperature: 1.0, timeout: 300000 },\n   * //   mcpConfig: [],\n   * //   skillSelection: [],\n   * //   tasks: [],\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform agent with component fields\n   * const strapiResponse = {\n   *   documentId: 'agent-456',\n   *   attributes: {\n   *     name: 'Code Agent',\n   *     slug: 'code-agent',\n   *     description: 'Agent for code generation',\n   *     systemPrompt: 'You are a coding assistant',\n   *     enabled: true,\n   *     toolConfig: {\n   *       allowedTools: ['bash', 'read', 'write'],\n   *       maxToolCalls: 50\n   *     },\n   *     modelConfig: {\n   *       model: 'opus',\n   *       temperature: 0.7,\n   *       timeout: 600000\n   *     },\n   *     analytics: {\n   *       totalConversations: 42,\n   *       tokenUsage: 150000\n   *     },\n   *     metadata: [\n   *       { key: 'version', value: '2.0' },\n   *       { key: 'author', value: 'team' }\n   *     ],\n   *     mcpConfig: [\n   *       {\n   *         mcpServer: {\n   *           data: {\n   *             documentId: 'mcp-server-1',\n   *             attributes: { name: 'filesystem' }\n   *           }\n   *         },\n   *         selectedTools: [\n   *           { mcpTool: { data: { documentId: 'tool-1' } } }\n   *         ]\n   *       }\n   *     ],\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const agent = this.transformAgent(strapiResponse);\n   * // Returns agent with all component fields populated\n   *\n   * @see prepareAgentData - Reverse transformation for API requests\n   * @see getAllAgents\n   * @see getAgent\n   */\n  private transformAgent(strapiData: StrapiAttributes<any>): Agent {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      slug: attrs.slug,\n      description: attrs.description || '',\n      systemPrompt: attrs.systemPrompt,\n      enabled: attrs.enabled ?? true,\n\n      // Component fields - pass through as-is\n      toolConfig: attrs.toolConfig || undefined,\n      modelConfig: attrs.modelConfig || {\n        model: 'sonnet',\n        temperature: 1.0,\n        timeout: 300000,\n      },\n      analytics: attrs.analytics || undefined,\n      metadata: attrs.metadata || [],\n\n      // Component-based relations - pass through as-is\n      mcpConfig: attrs.mcpConfig || [],\n      skillSelection: attrs.skillSelection || [],\n      tasks: attrs.tasks || [],\n\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi skill response to Skill domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's Skill domain model.\n   * Handles component-based structure including trainingHistory (training records), additionalFiles\n   * (file attachments with file relation), agentSelection, toolConfig, modelConfig, analytics,\n   * mcpConfig, tasks, and inputFields (dynamic form fields).\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'skill-uuid',\n   *   attributes: {\n   *     name: string,\n   *     displayName: string,\n   *     description: string,\n   *     skillmd: string,\n   *     skillConfig?: { systemPromptPrefix: string, ... },\n   *     experienceScore: number,\n   *     category: string,\n   *     isPublic: boolean,\n   *     version: string,\n   *     license?: string,\n   *     trainingHistory: [{ timestamp: string, agentId: string, ... }],\n   *     additionalFiles: [{ file: { data: {...} }, description: string }],\n   *     agentSelection: [{ agent: { data: {...} }, ... }],\n   *     toolConfig?: {...},\n   *     modelConfig?: {...},\n   *     analytics?: {...},\n   *     mcpConfig: [...],\n   *     tasks: [...],\n   *     inputFields: [{ name: string, type: string, ... }],\n   *     trainingAgent?: { data: { documentId: string } } | string,\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   name: string,\n   *   displayName: string,\n   *   description: string,\n   *   skillmd: string,\n   *   skillConfig?: {...},\n   *   experienceScore: number,\n   *   category: string,\n   *   isPublic: boolean,\n   *   version: string,\n   *   license?: string,\n   *   trainingHistory: [...],\n   *   additionalFiles: [...],\n   *   agentSelection: [...],\n   *   toolConfig?: {...},\n   *   modelConfig?: {...},\n   *   analytics?: {...},\n   *   mcpConfig: [...],\n   *   tasks: [...],\n   *   inputFields: [...],\n   *   trainingAgent?: string,\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed Skill object ready for application use\n   *\n   * @example\n   * // Transform basic skill\n   * const strapiResponse = {\n   *   documentId: 'skill-123',\n   *   attributes: {\n   *     name: 'git-workflow',\n   *     displayName: 'Git Workflow',\n   *     description: 'Manage git operations',\n   *     skillmd: '# Git Workflow\\n\\nManage git operations...',\n   *     experienceScore: 85,\n   *     category: 'development',\n   *     isPublic: true,\n   *     version: '1.0.0',\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const skill = this.transformSkill(strapiResponse);\n   * // Returns: {\n   * //   id: 'skill-123',\n   * //   name: 'git-workflow',\n   * //   displayName: 'Git Workflow',\n   * //   description: 'Manage git operations',\n   * //   skillmd: '# Git Workflow\\n\\nManage git operations...',\n   * //   experienceScore: 85,\n   * //   category: 'development',\n   * //   isPublic: true,\n   * //   version: '1.0.0',\n   * //   trainingHistory: [],\n   * //   additionalFiles: [],\n   * //   ...\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform skill with component fields\n   * const strapiResponse = {\n   *   documentId: 'skill-456',\n   *   attributes: {\n   *     name: 'api-testing',\n   *     displayName: 'API Testing',\n   *     description: 'Test REST APIs',\n   *     skillmd: '# API Testing\\n\\nTest REST APIs...',\n   *     skillConfig: {\n   *       systemPromptPrefix: 'You are an API testing expert'\n   *     },\n   *     experienceScore: 92,\n   *     category: 'testing',\n   *     isPublic: true,\n   *     version: '2.0.0',\n   *     license: 'MIT',\n   *     trainingHistory: [\n   *       {\n   *         timestamp: '2024-01-15T10:30:00.000Z',\n   *         agentId: 'agent-1',\n   *         feedback: 'positive',\n   *         experienceGained: 5\n   *       }\n   *     ],\n   *     additionalFiles: [\n   *       {\n   *         file: {\n   *           data: {\n   *             documentId: 'file-1',\n   *             attributes: { name: 'examples.json', url: '/uploads/...' }\n   *           }\n   *         },\n   *         description: 'API test examples'\n   *       }\n   *     ],\n   *     inputFields: [\n   *       { name: 'apiUrl', type: 'text', label: 'API URL', required: true },\n   *       { name: 'method', type: 'select', options: ['GET', 'POST', 'PUT', 'DELETE'] }\n   *     ],\n   *     trainingAgent: {\n   *       data: { documentId: 'agent-123' }\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-15T10:30:00.000Z'\n   *   }\n   * };\n   * const skill = this.transformSkill(strapiResponse);\n   * // Returns skill with all component fields populated\n   * // trainingAgent is normalized to 'agent-123'\n   *\n   * @see prepareSkillData - Reverse transformation for API requests\n   * @see getAllSkills\n   * @see getSkill\n   */\n  private transformSkill(strapiData: StrapiAttributes<any>): Skill {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      displayName: attrs.displayName,\n      description: attrs.description,\n      skillmd: attrs.skillmd, // Correct field name\n      skillConfig: attrs.skillConfig || undefined, // Add skillConfig (replaces systemPromptPrefix)\n      experienceScore: attrs.experienceScore || 0,\n      category: attrs.category || 'custom',\n      isPublic: attrs.isPublic ?? true,\n      version: attrs.version || '1.0.0',\n      license: attrs.license || undefined,\n\n      // Component fields - pass through as-is\n      trainingHistory: attrs.trainingHistory || [],\n      additionalFiles: attrs.additionalFiles || [],\n      agentSelection: attrs.agentSelection || [],\n      toolConfig: attrs.toolConfig || undefined,\n      modelConfig: attrs.modelConfig || undefined,\n      analytics: attrs.analytics || undefined,\n      mcpConfig: attrs.mcpConfig || [],\n      tasks: attrs.tasks || [],\n      inputFields: attrs.inputFields || [],\n\n      // Direct relation\n      trainingAgent: attrs.trainingAgent?.data?.documentId || attrs.trainingAgent,\n\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi MCP server response to MCPServer domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's MCPServer domain model.\n   * Handles both stdio and SDK transport types, builds config object for frontend compatibility,\n   * and recursively transforms nested mcpTools relation when populated.\n   *\n   * **Key Transformations:**\n   * - Creates `config` object with transport-specific fields for frontend use\n   * - Handles nested `mcpTools` relation (can be array or `{ data: [...] }` format)\n   * - Recursively transforms each tool using `transformMCPTool()`\n   * - Converts ISO date strings to Date objects\n   * - Normalizes disabled/enabled state\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'mcp-server-uuid',\n   *   attributes: {\n   *     name: string,\n   *     command: string,\n   *     description: string,\n   *     args: string[],\n   *     env: Record<string, string>,\n   *     disabled: boolean,\n   *     transport: 'stdio' | 'sse',\n   *     healthCheckUrl?: string,\n   *     isHealthy: boolean,\n   *     lastHealthCheck?: string,\n   *     startupTimeout: number,\n   *     restartPolicy: string,\n   *     toolsFetchedAt?: string,\n   *     mcpTools?: { data: [...] } | [...],\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   name: string,\n   *   config: {\n   *     type: 'stdio' | 'sse',\n   *     command: string,\n   *     args: string[],\n   *     env: Record<string, string>,\n   *     disabled: boolean\n   *   },\n   *   command: string,\n   *   description: string,\n   *   args: string[],\n   *   env: Record<string, string>,\n   *   disabled: boolean,\n   *   transport: 'stdio' | 'sse',\n   *   healthCheckUrl?: string,\n   *   isHealthy: boolean,\n   *   lastHealthCheck?: Date,\n   *   startupTimeout: number,\n   *   restartPolicy: string,\n   *   toolsFetchedAt?: Date,\n   *   mcpTools?: MCPTool[],\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed MCPServer object ready for application use\n   *\n   * @example\n   * // Transform stdio MCP server\n   * const strapiResponse = {\n   *   documentId: 'mcp-server-123',\n   *   attributes: {\n   *     name: 'filesystem',\n   *     command: 'npx',\n   *     description: 'File system MCP server',\n   *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *     env: { DEBUG: '1' },\n   *     disabled: false,\n   *     transport: 'stdio',\n   *     isHealthy: true,\n   *     startupTimeout: 30000,\n   *     restartPolicy: 'on-failure',\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const mcpServer = this.transformMCPServer(strapiResponse);\n   * // Returns: {\n   * //   id: 'mcp-server-123',\n   * //   name: 'filesystem',\n   * //   config: {\n   * //     type: 'stdio',\n   * //     command: 'npx',\n   * //     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   * //     env: { DEBUG: '1' },\n   * //     disabled: false\n   * //   },\n   * //   command: 'npx',\n   * //   description: 'File system MCP server',\n   * //   ...\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform MCP server with populated tools (nested data format)\n   * const strapiResponse = {\n   *   documentId: 'mcp-server-456',\n   *   attributes: {\n   *     name: 'github',\n   *     command: 'npx',\n   *     description: 'GitHub MCP server',\n   *     args: ['-y', '@modelcontextprotocol/server-github'],\n   *     env: { GITHUB_TOKEN: '${GITHUB_TOKEN}' },\n   *     disabled: false,\n   *     transport: 'stdio',\n   *     isHealthy: true,\n   *     toolsFetchedAt: '2024-01-15T10:30:00.000Z',\n   *     mcpTools: {\n   *       data: [\n   *         {\n   *           documentId: 'tool-1',\n   *           attributes: {\n   *             name: 'create_issue',\n   *             description: 'Create GitHub issue',\n   *             inputSchema: { type: 'object', properties: {...} }\n   *           }\n   *         },\n   *         {\n   *           documentId: 'tool-2',\n   *           attributes: {\n   *             name: 'list_repos',\n   *             description: 'List repositories'\n   *           }\n   *         }\n   *       ]\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-15T10:30:00.000Z'\n   *   }\n   * };\n   * const mcpServer = this.transformMCPServer(strapiResponse);\n   * // Returns MCP server with mcpTools array populated with 2 transformed tools\n   * // Each tool is transformed via transformMCPTool()\n   *\n   * @example\n   * // Transform MCP server with populated tools (flat array format)\n   * const strapiResponse = {\n   *   documentId: 'mcp-server-789',\n   *   attributes: {\n   *     name: 'slack',\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-slack'],\n   *     transport: 'stdio',\n   *     mcpTools: [  // Flat array (some Strapi configurations)\n   *       {\n   *         documentId: 'tool-3',\n   *         attributes: { name: 'send_message', description: 'Send Slack message' }\n   *       }\n   *     ],\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const mcpServer = this.transformMCPServer(strapiResponse);\n   * // Handles flat array format - mcpTools array populated with 1 transformed tool\n   *\n   * @see transformMCPTool - Used to transform nested tools\n   * @see prepareMCPServerData - Reverse transformation for API requests\n   * @see getAllMCPServers\n   * @see getMCPServer\n   */\n  private transformMCPServer(strapiData: StrapiAttributes<any>): MCPServer {\n    const attrs = this.extractAttributes(strapiData);\n\n    // Create config object based on transport type to match frontend expectations\n    const config: any = {\n      type: attrs.transport || 'stdio',\n      command: attrs.command,\n      args: attrs.args || [],\n      env: attrs.env || {},\n      disabled: attrs.disabled ?? false,\n    };\n\n    // Transform mcpTools if populated\n    let mcpTools: MCPTool[] | undefined;\n    if (attrs.mcpTools) {\n      if (Array.isArray(attrs.mcpTools)) {\n        mcpTools = attrs.mcpTools.map((tool: any) => this.transformMCPTool(tool));\n      } else if (attrs.mcpTools.data && Array.isArray(attrs.mcpTools.data)) {\n        mcpTools = attrs.mcpTools.data.map((tool: any) => this.transformMCPTool(tool));\n      }\n    }\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      config: config,\n      command: attrs.command,\n      description: attrs.description || '',\n      args: attrs.args || [],\n      env: attrs.env || {},\n      disabled: attrs.disabled ?? false,\n      transport: attrs.transport || 'stdio',\n      healthCheckUrl: attrs.healthCheckUrl,\n      isHealthy: attrs.isHealthy ?? true,\n      lastHealthCheck: attrs.lastHealthCheck ? new Date(attrs.lastHealthCheck) : undefined,\n      startupTimeout: attrs.startupTimeout || 30000,\n      restartPolicy: attrs.restartPolicy || 'on-failure',\n      toolsFetchedAt: attrs.toolsFetchedAt ? new Date(attrs.toolsFetchedAt) : undefined,\n      mcpTools: mcpTools,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    } as MCPServer;\n  }\n\n  /**\n   * Transform Strapi MCP tool response to MCPTool domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's MCPTool domain model.\n   * Handles tool metadata including name, description, JSON schema for input validation, and\n   * parent MCP server relation. Used both directly and as a helper for transformMCPServer.\n   *\n   * **Key Transformations:**\n   * - Normalizes `mcpServer` relation (handles both nested and flat formats)\n   * - Preserves `inputSchema` as-is (JSON Schema object for tool parameter validation)\n   * - Converts ISO date strings to Date objects\n   * - Sets undefined for optional fields instead of null\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'mcp-tool-uuid',\n   *   attributes: {\n   *     name: string,\n   *     description?: string,\n   *     inputSchema?: object,  // JSON Schema\n   *     mcpServer?: { documentId: string } | { data: { documentId: string } },\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   name: string,\n   *   description?: string,\n   *   inputSchema?: object,  // JSON Schema for parameter validation\n   *   mcpServer?: string,    // MCP server documentId\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed MCPTool object ready for application use\n   *\n   * @example\n   * // Transform basic MCP tool (no schema)\n   * const strapiResponse = {\n   *   documentId: 'tool-123',\n   *   attributes: {\n   *     name: 'list_files',\n   *     description: 'List files in a directory',\n   *     mcpServer: {\n   *       documentId: 'mcp-server-1'\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const tool = this.transformMCPTool(strapiResponse);\n   * // Returns: {\n   * //   id: 'tool-123',\n   * //   name: 'list_files',\n   * //   description: 'List files in a directory',\n   * //   inputSchema: undefined,\n   * //   mcpServer: 'mcp-server-1',\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform MCP tool with JSON Schema\n   * const strapiResponse = {\n   *   documentId: 'tool-456',\n   *   attributes: {\n   *     name: 'create_issue',\n   *     description: 'Create GitHub issue',\n   *     inputSchema: {\n   *       type: 'object',\n   *       properties: {\n   *         title: { type: 'string', description: 'Issue title' },\n   *         body: { type: 'string', description: 'Issue body' },\n   *         labels: { type: 'array', items: { type: 'string' } }\n   *       },\n   *       required: ['title', 'body']\n   *     },\n   *     mcpServer: {\n   *       data: {  // Nested data format\n   *         documentId: 'mcp-server-github'\n   *       }\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-15T10:30:00.000Z'\n   *   }\n   * };\n   * const tool = this.transformMCPTool(strapiResponse);\n   * // Returns tool with inputSchema preserved as JSON Schema object\n   * // mcpServer is normalized to 'mcp-server-github'\n   *\n   * @example\n   * // Transform MCP tool without server relation\n   * const strapiResponse = {\n   *   documentId: 'tool-789',\n   *   attributes: {\n   *     name: 'send_message',\n   *     description: 'Send Slack message',\n   *     inputSchema: {\n   *       type: 'object',\n   *       properties: {\n   *         channel: { type: 'string' },\n   *         text: { type: 'string' }\n   *       }\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const tool = this.transformMCPTool(strapiResponse);\n   * // Returns tool with mcpServer: undefined (orphaned tool)\n   *\n   * @see transformMCPServer - Uses this method to transform nested tools\n   * @see createMCPTool\n   * @see getMCPToolsByServerId\n   */\n  private transformMCPTool(strapiData: StrapiAttributes<any>): MCPTool {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      description: attrs.description || undefined,\n      inputSchema: attrs.inputSchema || undefined,\n      mcpServer: attrs.mcpServer?.documentId || attrs.mcpServer?.data?.documentId || undefined,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi task response to Task domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's Task domain model.\n   * Handles task metadata, execution state, agent relation, and extracts name/description from\n   * metadata object. Supports both running and completed task states.\n   *\n   * **Key Transformations:**\n   * - Normalizes `agent` relation to `agentId` and `agentName`\n   * - Extracts `name` from metadata.name (fallback to message or 'Unnamed Task')\n   * - Extracts `description` from metadata.description\n   * - Converts ISO date strings to Date objects (startedAt, completedAt)\n   * - Preserves execution metrics (executionTime, tokensUsed, cost)\n   * - Includes executionLog array for viewing task progress\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'task-uuid',\n   *   attributes: {\n   *     agent?: { documentId: string, name: string } | { data: {...} },\n   *     agentId?: string,\n   *     message: string,\n   *     status: 'pending' | 'running' | 'completed' | 'failed',\n   *     result?: string,\n   *     error?: string,\n   *     startedAt?: string,\n   *     completedAt?: string,\n   *     executionTime?: number,\n   *     tokensUsed?: number,\n   *     cost?: number,\n   *     metadata?: { name?: string, description?: string, ... },\n   *     executionLog?: Array<{ timestamp: string, message: string }>,\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   agentId?: string,\n   *   agentName?: string,\n   *   name: string,\n   *   description?: string,\n   *   message: string,\n   *   status: 'pending' | 'running' | 'completed' | 'failed',\n   *   result?: string,\n   *   error?: string,\n   *   startedAt?: Date,\n   *   completedAt?: Date,\n   *   executionTime?: number,\n   *   tokensUsed?: number,\n   *   cost?: number,\n   *   metadata: object,\n   *   executionLog: Array<object>,\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed Task object ready for application use\n   *\n   * @example\n   * // Transform pending task\n   * const strapiResponse = {\n   *   documentId: 'task-123',\n   *   attributes: {\n   *     agent: {\n   *       documentId: 'agent-1',\n   *       name: 'Research Agent'\n   *     },\n   *     message: 'Research latest AI trends',\n   *     status: 'pending',\n   *     metadata: {\n   *       name: 'AI Trends Research',\n   *       description: 'Gather info on latest AI developments',\n   *       priority: 'high'\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const task = this.transformTask(strapiResponse);\n   * // Returns: {\n   * //   id: 'task-123',\n   * //   agentId: 'agent-1',\n   * //   agentName: 'Research Agent',\n   * //   name: 'AI Trends Research',\n   * //   description: 'Gather info on latest AI developments',\n   * //   message: 'Research latest AI trends',\n   * //   status: 'pending',\n   * //   metadata: { name: '...', description: '...', priority: 'high' },\n   * //   executionLog: [],\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform completed task with metrics\n   * const strapiResponse = {\n   *   documentId: 'task-456',\n   *   attributes: {\n   *     agent: {\n   *       data: {\n   *         documentId: 'agent-2',\n   *         attributes: { name: 'Code Agent' }\n   *       }\n   *     },\n   *     message: 'Generate unit tests',\n   *     status: 'completed',\n   *     result: 'Successfully generated 15 unit tests',\n   *     startedAt: '2024-01-15T10:00:00.000Z',\n   *     completedAt: '2024-01-15T10:05:30.000Z',\n   *     executionTime: 330000,  // milliseconds\n   *     tokensUsed: 12500,\n   *     cost: 0.025,\n   *     metadata: {\n   *       name: 'Unit Test Generation',\n   *       description: 'Generate comprehensive unit tests for user service'\n   *     },\n   *     executionLog: [\n   *       { timestamp: '2024-01-15T10:00:00.000Z', message: 'Task started' },\n   *       { timestamp: '2024-01-15T10:02:00.000Z', message: 'Analyzing code structure' },\n   *       { timestamp: '2024-01-15T10:05:30.000Z', message: 'Tests generated' }\n   *     ],\n   *     createdAt: '2024-01-15T09:55:00.000Z',\n   *     updatedAt: '2024-01-15T10:05:30.000Z'\n   *   }\n   * };\n   * const task = this.transformTask(strapiResponse);\n   * // Returns completed task with execution metrics and log\n   * // executionTime: 330000ms (5.5 minutes), cost: $0.025\n   *\n   * @example\n   * // Transform failed task with error\n   * const strapiResponse = {\n   *   documentId: 'task-789',\n   *   attributes: {\n   *     agentId: 'agent-3',  // Direct ID (no populated relation)\n   *     message: 'Deploy to production',\n   *     status: 'failed',\n   *     error: 'Deployment failed: Invalid credentials',\n   *     startedAt: '2024-01-20T14:00:00.000Z',\n   *     completedAt: '2024-01-20T14:01:15.000Z',\n   *     executionTime: 75000,\n   *     metadata: {},  // No name in metadata\n   *     createdAt: '2024-01-20T13:55:00.000Z',\n   *     updatedAt: '2024-01-20T14:01:15.000Z'\n   *   }\n   * };\n   * const task = this.transformTask(strapiResponse);\n   * // Returns: {\n   * //   ...\n   * //   agentId: 'agent-3',\n   * //   agentName: undefined,  // Relation not populated\n   * //   name: 'Deploy to production',  // Fallback to message\n   * //   description: undefined,\n   * //   status: 'failed',\n   * //   error: 'Deployment failed: Invalid credentials',\n   * //   ...\n   * // }\n   *\n   * @see prepareTaskData - Reverse transformation for API requests\n   * @see getAllTasks\n   * @see getTask\n   * @see createTask\n   * @see updateTask\n   */\n  private transformTask(strapiData: StrapiAttributes<any>): Task {\n    const attrs = this.extractAttributes(strapiData);\n    const metadata = attrs.metadata || {};\n\n    return {\n      id: strapiData.documentId,\n      agentId: attrs.agent?.documentId || attrs.agent?.data?.documentId || attrs.agentId,\n      agentName: attrs.agent?.name || attrs.agent?.data?.name || undefined,\n      name: metadata.name || attrs.message || 'Unnamed Task',\n      description: metadata.description || undefined,\n      message: attrs.message,\n      status: attrs.status || 'pending',\n      result: attrs.result,\n      error: attrs.error,\n      startedAt: attrs.startedAt ? new Date(attrs.startedAt) : undefined,\n      completedAt: attrs.completedAt ? new Date(attrs.completedAt) : undefined,\n      executionTime: attrs.executionTime,\n      tokensUsed: attrs.tokensUsed,\n      cost: attrs.cost,\n      metadata: metadata,\n      executionLog: attrs.executionLog || [], // Include execution log for viewing\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  // ============= DATA PREPARERS =============\n  // Prepare domain models for Strapi API\n\n  /**\n   * Prepare agent data for Strapi API\n   *\n   * @description Prepares Agent domain model for Strapi v5 API requests (create/update operations).\n   * Reverse transformation of transformAgent - converts application format to Strapi's expected format.\n   * Automatically generates URL-friendly slug from name if provided.\n   *\n   * **Key Transformations:**\n   * - Auto-generates `slug` from `name` using generateSlug() helper\n   * - Only includes fields that are provided (partial updates supported)\n   * - Component fields (toolConfig, modelConfig, analytics, metadata) passed through as-is\n   * - Component-based relations (mcpConfig, skillSelection, tasks) passed through as-is\n   * - Omits undefined fields to support partial updates\n   *\n   * **Input (Domain Model):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   description?: string,\n   *   systemPrompt?: string,\n   *   enabled?: boolean,\n   *   toolConfig?: { allowedTools: string[], ... },\n   *   modelConfig?: { model: string, temperature: number, ... },\n   *   analytics?: { tokenUsage: number, ... },\n   *   metadata?: [{ key: string, value: string }],\n   *   mcpConfig?: [...],\n   *   skillSelection?: [...],\n   *   tasks?: [...]\n   * }\n   * ```\n   *\n   * **Output (Strapi Format):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   slug?: string,  // Auto-generated from name\n   *   description?: string,\n   *   systemPrompt?: string,\n   *   enabled?: boolean,\n   *   toolConfig?: {...},\n   *   modelConfig?: {...},\n   *   analytics?: {...},\n   *   metadata?: [...],\n   *   mcpConfig?: [...],\n   *   skillSelection?: [...],\n   *   tasks?: [...]\n   * }\n   * ```\n   *\n   * @param agent - Partial Agent object (supports partial updates)\n   * @returns Strapi-formatted data object ready for POST/PUT requests\n   *\n   * @example\n   * // Prepare basic agent for creation\n   * const agentData = {\n   *   name: 'Research Agent',\n   *   description: 'Agent for research tasks',\n   *   systemPrompt: 'You are a research assistant',\n   *   enabled: true\n   * };\n   * const strapiData = this.prepareAgentData(agentData);\n   * // Returns: {\n   * //   name: 'Research Agent',\n   * //   slug: 'research-agent',  // Auto-generated\n   * //   description: 'Agent for research tasks',\n   * //   systemPrompt: 'You are a research assistant',\n   * //   enabled: true\n   * // }\n   *\n   * @example\n   * // Prepare agent with component fields\n   * const agentData = {\n   *   name: 'Code Agent',\n   *   description: 'Agent for code generation',\n   *   systemPrompt: 'You are a coding assistant',\n   *   enabled: true,\n   *   toolConfig: {\n   *     allowedTools: ['bash', 'read', 'write'],\n   *     maxToolCalls: 50\n   *   },\n   *   modelConfig: {\n   *     model: 'opus',\n   *     temperature: 0.7,\n   *     timeout: 600000\n   *   },\n   *   metadata: [\n   *     { key: 'version', value: '2.0' },\n   *     { key: 'author', value: 'team' }\n   *   ],\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: 'mcp-server-1',\n   *       selectedTools: [\n   *         { mcpTool: 'tool-1' }\n   *       ]\n   *     }\n   *   ]\n   * };\n   * const strapiData = this.prepareAgentData(agentData);\n   * // Returns Strapi-formatted data with all component fields\n   * // Component fields passed through as-is for Strapi v5\n   *\n   * @example\n   * // Prepare partial update (only update description and enabled status)\n   * const updateData = {\n   *   description: 'Updated description',\n   *   enabled: false\n   * };\n   * const strapiData = this.prepareAgentData(updateData);\n   * // Returns: {\n   * //   description: 'Updated description',\n   * //   enabled: false\n   * // }\n   * // Only includes provided fields - supports partial updates\n   * // No slug generated since name not provided\n   *\n   * @see transformAgent - Reverse transformation from Strapi to domain model\n   * @see createAgent\n   * @see updateAgent\n   */\n  private prepareAgentData(agent: Partial<Agent>) {\n    const data: any = {\n      name: agent.name,\n      description: agent.description,\n      systemPrompt: agent.systemPrompt,\n      enabled: agent.enabled,\n    };\n\n    // Generate slug from name if name is provided\n    // Strapi's auto-generation doesn't always work with programmatic API calls\n    if (agent.name) {\n      data.slug = generateSlug(agent.name);\n    }\n\n    // Component fields - pass through as-is\n    if (agent.toolConfig) {\n      data.toolConfig = agent.toolConfig;\n    }\n\n    if (agent.modelConfig) {\n      data.modelConfig = agent.modelConfig;\n    }\n\n    if (agent.analytics) {\n      data.analytics = agent.analytics;\n    }\n\n    if (agent.metadata) {\n      data.metadata = agent.metadata;\n    }\n\n    // Component-based relations\n    if (agent.mcpConfig) {\n      data.mcpConfig = agent.mcpConfig;\n    }\n\n    if (agent.skillSelection) {\n      data.skillSelection = agent.skillSelection;\n    }\n\n    if (agent.tasks) {\n      data.tasks = agent.tasks;\n    }\n\n    return data;\n  }\n\n  /**\n   * Prepare skill data for Strapi API\n   *\n   * @description Prepares Skill domain model for Strapi v5 API requests (create/update operations).\n   * Reverse transformation of transformSkill - converts application format to Strapi's expected format.\n   * Supports partial updates by only including provided fields.\n   *\n   * **Key Transformations:**\n   * - Only includes fields that are provided (partial updates supported)\n   * - Component fields (trainingHistory, additionalFiles, toolConfig, etc.) passed through as-is\n   * - Direct relation (trainingAgent) passed through as agent documentId\n   * - Omits undefined fields to support partial updates\n   *\n   * **Input (Domain Model):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   displayName?: string,\n   *   description?: string,\n   *   skillmd?: string,\n   *   experienceScore?: number,\n   *   category?: string,\n   *   isPublic?: boolean,\n   *   version?: string,\n   *   license?: string,\n   *   trainingHistory?: [...],\n   *   additionalFiles?: [...],\n   *   agentSelection?: [...],\n   *   toolConfig?: {...},\n   *   modelConfig?: {...},\n   *   analytics?: {...},\n   *   mcpConfig?: [...],\n   *   tasks?: [...],\n   *   inputFields?: [...],\n   *   trainingAgent?: string\n   * }\n   * ```\n   *\n   * **Output (Strapi Format):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   displayName?: string,\n   *   description?: string,\n   *   skillmd?: string,\n   *   experienceScore?: number,\n   *   category?: string,\n   *   isPublic?: boolean,\n   *   version?: string,\n   *   license?: string,\n   *   trainingHistory?: [...],\n   *   additionalFiles?: [...],\n   *   agentSelection?: [...],\n   *   toolConfig?: {...},\n   *   modelConfig?: {...},\n   *   analytics?: {...},\n   *   mcpConfig?: [...],\n   *   tasks?: [...],\n   *   inputFields?: [...],\n   *   trainingAgent?: string\n   * }\n   * ```\n   *\n   * @param skill - Partial Skill object (supports partial updates)\n   * @returns Strapi-formatted data object ready for POST/PUT requests\n   *\n   * @example\n   * // Prepare basic skill for creation\n   * const skillData = {\n   *   name: 'git-workflow',\n   *   displayName: 'Git Workflow',\n   *   description: 'Manage git operations',\n   *   skillmd: '# Git Workflow\\n\\nManage git operations...',\n   *   category: 'development',\n   *   isPublic: true,\n   *   version: '1.0.0'\n   * };\n   * const strapiData = this.prepareSkillData(skillData);\n   * // Returns Strapi-formatted data with all basic fields\n   *\n   * @example\n   * // Prepare skill with component fields\n   * const skillData = {\n   *   name: 'api-testing',\n   *   displayName: 'API Testing',\n   *   description: 'Test REST APIs',\n   *   skillmd: '# API Testing\\n\\nTest REST APIs...',\n   *   category: 'testing',\n   *   isPublic: true,\n   *   version: '2.0.0',\n   *   license: 'MIT',\n   *   trainingHistory: [\n   *     {\n   *       timestamp: '2024-01-15T10:30:00.000Z',\n   *       agentId: 'agent-1',\n   *       feedback: 'positive',\n   *       experienceGained: 5\n   *     }\n   *   ],\n   *   additionalFiles: [\n   *     {\n   *       file: 'file-1',  // File documentId\n   *       description: 'API test examples'\n   *     }\n   *   ],\n   *   inputFields: [\n   *     { name: 'apiUrl', type: 'text', label: 'API URL', required: true },\n   *     { name: 'method', type: 'select', options: ['GET', 'POST', 'PUT', 'DELETE'] }\n   *   ],\n   *   trainingAgent: 'agent-123'\n   * };\n   * const strapiData = this.prepareSkillData(skillData);\n   * // Returns Strapi-formatted data with all component fields\n   * // Component fields passed through as-is for Strapi v5\n   *\n   * @example\n   * // Prepare partial update (only update experience score and training history)\n   * const updateData = {\n   *   experienceScore: 95,\n   *   trainingHistory: [\n   *     ...existingHistory,\n   *     { timestamp: new Date().toISOString(), agentId: 'agent-1', feedback: 'positive', experienceGained: 3 }\n   *   ]\n   * };\n   * const strapiData = this.prepareSkillData(updateData);\n   * // Returns: {\n   * //   experienceScore: 95,\n   * //   trainingHistory: [...]\n   * // }\n   * // Only includes provided fields - supports partial updates\n   *\n   * @see transformSkill - Reverse transformation from Strapi to domain model\n   * @see createSkill\n   * @see updateSkill\n   */\n  private prepareSkillData(skill: Partial<Skill>) {\n    const data: any = {\n      name: skill.name,\n      displayName: skill.displayName,\n      description: skill.description,\n      skillmd: skill.skillmd, // Correct field name\n      experienceScore: skill.experienceScore,\n      category: skill.category,\n      isPublic: skill.isPublic,\n      version: skill.version,\n      license: skill.license,\n    };\n\n    // Component fields\n    if (skill.trainingHistory) {\n      data.trainingHistory = skill.trainingHistory;\n    }\n\n    if (skill.additionalFiles) {\n      data.additionalFiles = skill.additionalFiles;\n    }\n\n    if (skill.agentSelection) {\n      data.agentSelection = skill.agentSelection;\n    }\n\n    if (skill.toolConfig) {\n      data.toolConfig = skill.toolConfig;\n    }\n\n    if (skill.modelConfig) {\n      data.modelConfig = skill.modelConfig;\n    }\n\n    if (skill.analytics) {\n      data.analytics = skill.analytics;\n    }\n\n    if (skill.mcpConfig) {\n      data.mcpConfig = skill.mcpConfig;\n    }\n\n    if (skill.tasks) {\n      data.tasks = skill.tasks;\n    }\n\n    if (skill.inputFields) {\n      data.inputFields = skill.inputFields;\n    }\n\n    // Direct relation\n    if (skill.trainingAgent) {\n      data.trainingAgent = skill.trainingAgent;\n    }\n\n    return data;\n  }\n\n  /**\n   * Prepare MCP server data for Strapi API\n   *\n   * @description Prepares MCPServer domain model for Strapi v5 API requests (create/update operations).\n   * Reverse transformation of transformMCPServer - converts application format to Strapi's expected format.\n   * Only includes core MCP server configuration fields (no nested tools).\n   *\n   * **Key Transformations:**\n   * - Only includes fields that are provided (partial updates supported)\n   * - Omits `config` object (frontend-specific, not stored in Strapi)\n   * - Omits `mcpTools` relation (managed separately via createMCPTool/bulkSyncMCPTools)\n   * - Omits computed fields (isHealthy, lastHealthCheck, toolsFetchedAt)\n   * - Preserves transport type, command, args, env for stdio/SDK servers\n   *\n   * **Input (Domain Model):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   command?: string,\n   *   description?: string,\n   *   args?: string[],\n   *   env?: Record<string, string>,\n   *   disabled?: boolean,\n   *   transport?: 'stdio' | 'sse',\n   *   healthCheckUrl?: string,\n   *   startupTimeout?: number,\n   *   restartPolicy?: string\n   * }\n   * ```\n   *\n   * **Output (Strapi Format):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   command?: string,\n   *   description?: string,\n   *   args?: string[],\n   *   env?: Record<string, string>,\n   *   disabled?: boolean,\n   *   transport?: 'stdio' | 'sse',\n   *   healthCheckUrl?: string,\n   *   startupTimeout?: number,\n   *   restartPolicy?: string\n   * }\n   * ```\n   *\n   * @param mcp - Partial MCPServer object (supports partial updates)\n   * @returns Strapi-formatted data object ready for POST/PUT requests\n   *\n   * @example\n   * // Prepare stdio MCP server for creation\n   * const mcpServerData = {\n   *   name: 'filesystem',\n   *   command: 'npx',\n   *   description: 'File system MCP server',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *   env: { DEBUG: '1' },\n   *   disabled: false,\n   *   transport: 'stdio',\n   *   startupTimeout: 30000,\n   *   restartPolicy: 'on-failure'\n   * };\n   * const strapiData = this.prepareMCPServerData(mcpServerData);\n   * // Returns Strapi-formatted data with all fields\n   *\n   * @example\n   * // Prepare MCP server with environment variables\n   * const mcpServerData = {\n   *   name: 'github',\n   *   command: 'npx',\n   *   description: 'GitHub MCP server',\n   *   args: ['-y', '@modelcontextprotocol/server-github'],\n   *   env: {\n   *     GITHUB_TOKEN: '${GITHUB_TOKEN}',  // Environment variable substitution\n   *     GITHUB_REPO: 'owner/repo'\n   *   },\n   *   transport: 'stdio'\n   * };\n   * const strapiData = this.prepareMCPServerData(mcpServerData);\n   * // Returns Strapi-formatted data\n   * // Environment variables will be substituted at runtime by MCPService\n   *\n   * @example\n   * // Prepare partial update (only update disabled status and description)\n   * const updateData = {\n   *   disabled: true,\n   *   description: 'Temporarily disabled for maintenance'\n   * };\n   * const strapiData = this.prepareMCPServerData(updateData);\n   * // Returns: {\n   * //   disabled: true,\n   * //   description: 'Temporarily disabled for maintenance'\n   * // }\n   * // Only includes provided fields - supports partial updates\n   *\n   * @see transformMCPServer - Reverse transformation from Strapi to domain model\n   * @see createMCPServer\n   * @see updateMCPServer\n   * @see bulkSyncMCPTools - Used to sync nested tools separately\n   */\n  private prepareMCPServerData(mcp: Partial<MCPServer>) {\n    return {\n      name: mcp.name,\n      command: mcp.command,\n      description: mcp.description,\n      args: mcp.args,\n      env: mcp.env,\n      disabled: mcp.disabled,\n      transport: mcp.transport,\n      healthCheckUrl: mcp.healthCheckUrl,\n      startupTimeout: mcp.startupTimeout,\n      restartPolicy: mcp.restartPolicy,\n    };\n  }\n\n  /**\n   * Prepare task data for Strapi API\n   *\n   * @description Prepares Task domain model for Strapi v5 API requests (create/update operations).\n   * Reverse transformation of transformTask - converts application format to Strapi's expected format.\n   * Handles Date-to-ISO string conversion and agentId-to-agent relation mapping.\n   *\n   * **Key Transformations:**\n   * - Maps `agentId` (domain model) to `agent` (Strapi relation field)\n   * - Converts Date objects to ISO 8601 strings (startedAt, completedAt)\n   * - Passes through ISO strings unchanged if already strings\n   * - Preserves execution metrics (executionTime, tokensUsed, cost)\n   * - Includes metadata and executionLog for task tracking\n   *\n   * **Input (Domain Model):**\n   * ```typescript\n   * {\n   *   agentId?: string,\n   *   message?: string,\n   *   status?: 'pending' | 'running' | 'completed' | 'failed',\n   *   result?: string,\n   *   error?: string,\n   *   startedAt?: Date | string,\n   *   completedAt?: Date | string,\n   *   executionTime?: number,\n   *   tokensUsed?: number,\n   *   cost?: number,\n   *   metadata?: object,\n   *   executionLog?: Array<object>\n   * }\n   * ```\n   *\n   * **Output (Strapi Format):**\n   * ```typescript\n   * {\n   *   agent?: string,  // Relation field (documentId)\n   *   message?: string,\n   *   status?: 'pending' | 'running' | 'completed' | 'failed',\n   *   result?: string,\n   *   error?: string,\n   *   startedAt?: string,  // ISO 8601 string\n   *   completedAt?: string,  // ISO 8601 string\n   *   executionTime?: number,\n   *   tokensUsed?: number,\n   *   cost?: number,\n   *   metadata?: object,\n   *   executionLog?: Array<object>\n   * }\n   * ```\n   *\n   * @param task - Partial Task object (supports partial updates)\n   * @returns Strapi-formatted data object ready for POST/PUT requests\n   *\n   * @example\n   * // Prepare new task for creation\n   * const taskData = {\n   *   agentId: 'agent-123',\n   *   message: 'Research latest AI trends',\n   *   status: 'pending',\n   *   metadata: {\n   *     name: 'AI Trends Research',\n   *     description: 'Gather info on latest AI developments',\n   *     priority: 'high'\n   *   }\n   * };\n   * const strapiData = this.prepareTaskData(taskData);\n   * // Returns: {\n   * //   agent: 'agent-123',  // Mapped from agentId\n   * //   message: 'Research latest AI trends',\n   * //   status: 'pending',\n   * //   metadata: { name: '...', description: '...', priority: 'high' }\n   * // }\n   *\n   * @example\n   * // Prepare task status update with Date objects\n   * const updateData = {\n   *   status: 'completed',\n   *   result: 'Successfully generated 15 unit tests',\n   *   startedAt: new Date('2024-01-15T10:00:00.000Z'),\n   *   completedAt: new Date('2024-01-15T10:05:30.000Z'),\n   *   executionTime: 330000,  // 5.5 minutes in milliseconds\n   *   tokensUsed: 12500,\n   *   cost: 0.025\n   * };\n   * const strapiData = this.prepareTaskData(updateData);\n   * // Returns: {\n   * //   status: 'completed',\n   * //   result: 'Successfully generated 15 unit tests',\n   * //   startedAt: '2024-01-15T10:00:00.000Z',  // Date converted to ISO string\n   * //   completedAt: '2024-01-15T10:05:30.000Z',  // Date converted to ISO string\n   * //   executionTime: 330000,\n   * //   tokensUsed: 12500,\n   * //   cost: 0.025\n   * // }\n   *\n   * @example\n   * // Prepare task with execution log\n   * const updateData = {\n   *   status: 'running',\n   *   startedAt: new Date(),\n   *   executionLog: [\n   *     { timestamp: new Date().toISOString(), message: 'Task started' },\n   *     { timestamp: new Date().toISOString(), message: 'Analyzing code structure' }\n   *   ]\n   * };\n   * const strapiData = this.prepareTaskData(updateData);\n   * // Returns task data with executionLog for real-time progress tracking\n   *\n   * @example\n   * // Prepare failed task update\n   * const updateData = {\n   *   status: 'failed',\n   *   error: 'Deployment failed: Invalid credentials',\n   *   completedAt: new Date(),\n   *   executionTime: 75000\n   * };\n   * const strapiData = this.prepareTaskData(updateData);\n   * // Returns: {\n   * //   status: 'failed',\n   * //   error: 'Deployment failed: Invalid credentials',\n   * //   completedAt: '2024-01-20T14:01:15.000Z',\n   * //   executionTime: 75000\n   * // }\n   *\n   * @see transformTask - Reverse transformation from Strapi to domain model\n   * @see createTask\n   * @see updateTask\n   */\n  private prepareTaskData(task: Partial<Task>) {\n    return {\n      agent: task.agentId,  // Strapi expects 'agent' relation field\n      message: task.message,\n      status: task.status,\n      result: task.result,\n      error: task.error,\n      startedAt: task.startedAt instanceof Date ? task.startedAt.toISOString() : task.startedAt,\n      completedAt: task.completedAt instanceof Date ? task.completedAt.toISOString() : task.completedAt,\n      executionTime: task.executionTime,\n      tokensUsed: task.tokensUsed,\n      cost: task.cost,\n      metadata: task.metadata,\n      executionLog: task.executionLog, // Include execution log for viewing\n    };\n  }\n\n  // ============= QUERY BUILDERS =============\n\n  /**\n   * Build Strapi query parameters from options\n   */\n  private buildQueryParams(options?: {\n    populate?: string[] | Record<string, any>;\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Record<string, any> {\n    const params: Record<string, any> = {};\n\n    if (options?.populate) {\n      // Strapi v5 requires array bracket notation: populate[0]=field1&populate[1]=field2\n      // Pass array directly, axios will serialize it correctly\n      params.populate = options.populate;\n    }\n\n    if (options?.filters) {\n      params.filters = options.filters;\n    }\n\n    if (options?.sort) {\n      params.sort = options.sort;\n    }\n\n    if (options?.pagination) {\n      params.pagination = options.pagination;\n    }\n\n    return params;\n  }\n\n  // ============= CACHE MANAGEMENT =============\n\n  /**\n   * Invalidate all cache entries with a given prefix\n   */\n  private invalidateCache(prefix: string) {\n    const keys = Array.from(this.cache.keys());\n    let invalidatedCount = 0;\n\n    for (const key of keys) {\n      if (typeof key === 'string' && key.startsWith(prefix)) {\n        this.cache.delete(key);\n        invalidatedCount++;\n      }\n    }\n\n    if (invalidatedCount > 0) {\n      console.log(`[Strapi] Invalidated ${invalidatedCount} cache entries with prefix \"${prefix}\"`);\n    }\n  }\n\n  /**\n   * Clear all cache entries\n   *\n   * @description\n   * Clears all entries from the LRU cache, forcing fresh API requests on next data access.\n   * Use this method when you need to ensure data freshness after external changes to Strapi\n   * data (e.g., manual edits in Strapi Admin Panel, bulk imports, database migrations).\n   *\n   * **Cache Configuration:**\n   * - TTL: 5 minutes (300,000ms)\n   * - Max Size: 100 entries\n   * - Eviction: LRU (Least Recently Used)\n   *\n   * **When to Clear Cache:**\n   * - After bulk data operations outside this client\n   * - When debugging stale data issues\n   * - After importing/migrating data to Strapi\n   * - Manual refresh triggered by user action\n   * - Testing scenarios requiring fresh data\n   *\n   * **Note:**\n   * - Cache is automatically invalidated on mutations (create/update/delete)\n   * - Individual cache entries auto-expire after 5 minutes\n   * - Clearing cache forces all subsequent requests to hit the API\n   *\n   * @returns {void}\n   *\n   * @example\n   * // Basic cache clear\n   * strapiClient.clearCache();\n   * console.log('Cache cleared - next requests will fetch fresh data');\n   *\n   * @example\n   * // Clear cache after external data modification\n   * // (e.g., after manual edits in Strapi Admin Panel)\n   * async function refreshData() {\n   *   strapiClient.clearCache();\n   *\n   *   // Subsequent requests fetch fresh data from API\n   *   const agents = await strapiClient.getAllAgents();\n   *   const skills = await strapiClient.getAllSkills();\n   *\n   *   console.log('Data refreshed from Strapi');\n   * }\n   *\n   * @example\n   * // User-triggered refresh in UI\n   * app.post('/api/refresh', (req, res) => {\n   *   strapiClient.clearCache();\n   *   res.json({ message: 'Cache cleared successfully' });\n   * });\n   *\n   * @example\n   * // Clear cache before testing\n   * describe('Strapi Client Tests', () => {\n   *   beforeEach(() => {\n   *     // Ensure tests start with clean cache\n   *     strapiClient.clearCache();\n   *   });\n   *\n   *   it('should fetch fresh data from API', async () => {\n   *     const agents = await strapiClient.getAllAgents();\n   *     expect(agents).toBeDefined();\n   *   });\n   * });\n   *\n   * @example\n   * // Periodic cache refresh for long-running processes\n   * setInterval(() => {\n   *   strapiClient.clearCache();\n   *   console.log('[Cache] Periodic cache cleared');\n   * }, 1000 * 60 * 15); // Clear every 15 minutes\n   *\n   * @example\n   * // Clear cache after bulk import\n   * async function importAgents(agentsData) {\n   *   // Bulk import agents via direct API calls\n   *   for (const agentData of agentsData) {\n   *     await strapiClient.createAgent(agentData);\n   *   }\n   *\n   *   // Clear cache to ensure fresh data\n   *   strapiClient.clearCache();\n   *\n   *   console.log('Import complete, cache cleared');\n   * }\n   *\n   * @see {@link getCacheStats} - Get cache statistics\n   */\n  clearCache() {\n    const size = this.cache.size;\n    this.cache.clear();\n    console.log(`[Strapi] Cleared ${size} cache entries`);\n  }\n\n  /**\n   * Get current cache statistics\n   *\n   * @description\n   * Returns current cache statistics including the number of entries, maximum capacity,\n   * and TTL configuration. Use this for monitoring cache utilization, debugging performance\n   * issues, or implementing cache health dashboards.\n   *\n   * **Returned Statistics:**\n   * - `size`: Current number of cached entries\n   * - `max`: Maximum cache capacity (100 entries)\n   * - `ttl`: Time-to-live in milliseconds (300,000ms = 5 minutes)\n   *\n   * **Cache Behavior:**\n   * - When `size` reaches `max`, least recently used entries are evicted\n   * - Each entry expires after `ttl` milliseconds\n   * - TTL is refreshed on cache hits (updateAgeOnGet: true)\n   *\n   * @returns {Object} Cache statistics object\n   * @returns {number} returns.size - Current number of entries in cache\n   * @returns {number} returns.max - Maximum cache capacity\n   * @returns {number} returns.ttl - Time-to-live in milliseconds\n   *\n   * @example\n   * // Basic usage - get cache stats\n   * const stats = strapiClient.getCacheStats();\n   *\n   * console.log('Cache Statistics:');\n   * console.log(`  Entries: ${stats.size}/${stats.max}`);\n   * console.log(`  TTL: ${stats.ttl / 1000}s`);\n   *\n   * @example\n   * // Check cache utilization\n   * const stats = strapiClient.getCacheStats();\n   * const utilizationPercent = (stats.size / stats.max) * 100;\n   *\n   * console.log(`Cache utilization: ${utilizationPercent.toFixed(1)}%`);\n   *\n   * if (utilizationPercent > 80) {\n   *   console.warn('Cache is nearly full - consider increasing max size');\n   * }\n   *\n   * @example\n   * // Display cache stats in monitoring dashboard\n   * app.get('/api/cache/stats', (req, res) => {\n   *   const stats = strapiClient.getCacheStats();\n   *\n   *   res.json({\n   *     cache: {\n   *       size: stats.size,\n   *       max: stats.max,\n   *       utilization: `${((stats.size / stats.max) * 100).toFixed(1)}%`,\n   *       ttl: `${stats.ttl / 1000}s`,\n   *       ttlMinutes: stats.ttl / 60000\n   *     }\n   *   });\n   * });\n   *\n   * @example\n   * // Monitor cache growth over time\n   * const monitorCache = () => {\n   *   const stats = strapiClient.getCacheStats();\n   *   const timestamp = new Date().toISOString();\n   *\n   *   console.log(`[${timestamp}] Cache: ${stats.size}/${stats.max} entries`);\n   * };\n   *\n   * // Log stats every 30 seconds\n   * setInterval(monitorCache, 30000);\n   *\n   * @example\n   * // Warn if cache is empty (potential configuration issue)\n   * const stats = strapiClient.getCacheStats();\n   *\n   * if (stats.size === 0) {\n   *   console.warn('Cache is empty - no data has been cached yet');\n   *   console.warn('This is normal on startup but unusual during operation');\n   * }\n   *\n   * @example\n   * // Debug cache effectiveness\n   * async function debugCacheEffectiveness() {\n   *   // Clear cache and get initial stats\n   *   strapiClient.clearCache();\n   *   let stats = strapiClient.getCacheStats();\n   *   console.log(`Initial cache size: ${stats.size}`);\n   *\n   *   // Make some API calls\n   *   await strapiClient.getAllAgents();\n   *   await strapiClient.getAllSkills();\n   *   await strapiClient.getAllMCPServers();\n   *\n   *   // Check cache growth\n   *   stats = strapiClient.getCacheStats();\n   *   console.log(`Cache size after API calls: ${stats.size}`);\n   *   console.log(`Cache is working: ${stats.size > 0 ? 'YES' : 'NO'}`);\n   * }\n   *\n   * @example\n   * // Format stats for logging\n   * const stats = strapiClient.getCacheStats();\n   *\n   * const formatted = {\n   *   entries: `${stats.size}/${stats.max}`,\n   *   utilizationPercent: ((stats.size / stats.max) * 100).toFixed(1),\n   *   ttlSeconds: stats.ttl / 1000,\n   *   ttlMinutes: stats.ttl / 60000,\n   *   expiryTime: new Date(Date.now() + stats.ttl).toISOString()\n   * };\n   *\n   * console.log('Cache Stats:', formatted);\n   *\n   * @see {@link clearCache} - Clear all cache entries\n   */\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      max: this.cache.max,\n      ttl: this.cache.ttl,\n    };\n  }\n\n  // ============= ERROR HANDLING =============\n\n  /**\n   * Handle axios errors with detailed logging\n   */\n  private handleError(error: AxiosError) {\n    if (error.response) {\n      // Server responded with error status\n      console.error('[Strapi] Response error:', {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data,\n        url: error.config?.url,\n      });\n    } else if (error.request) {\n      // Request made but no response\n      console.error('[Strapi] No response received:', {\n        message: error.message,\n        url: error.config?.url,\n      });\n    } else {\n      // Error in request setup\n      console.error('[Strapi] Request setup error:', {\n        message: error.message,\n        url: error.config?.url,\n      });\n    }\n  }\n}\n\n// ============= SINGLETON EXPORT =============\n\n/**\n * Singleton instance of StrapiClient\n * Use this throughout the application for all Strapi interactions\n */\nexport const strapiClient = new StrapiClient();\n",
        "last_modified": "2026-01-02T15:10:07.678661"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "/**\n * Claude Agent UI - Strapi Client Service\n *\n * This service provides a data access layer for interacting with the Strapi CMS API.\n * It handles HTTP communication, caching, and data transformation between Strapi's\n * response format and the application's domain models.\n *\n * Features:\n * - HTTP client with axios\n * - LRU cache with 5-minute TTL\n * - Request/response interceptors for logging\n * - Automatic data transformation\n * - Cache invalidation on mutations\n * - Error handling with detailed logging\n * - Support for populate, filters, sort, pagination\n * - Health check endpoint\n */\n\nimport axios, { AxiosInstance, AxiosError } from 'axios';\nimport { LRUCache } from 'lru-cache';\nimport type {\n  Agent,\n  Skill,\n  MCPServer,\n  MCPTool,\n  Task,\n  StrapiAttributes,\n  StrapiResponse,\n  StrapiData,\n  StrapiQueryParams,\n  CreateAgentDTO,\n  UpdateAgentDTO,\n  CreateSkillDTO,\n  UpdateSkillDTO,\n  CreateMCPServerDTO,\n  UpdateMCPServerDTO,\n  CreateTaskDTO,\n  UpdateTaskDTO,\n} from '../types/index.js';\n\n// ============= HELPER FUNCTIONS =============\n\n/**\n * Generate a URL-friendly slug from a string\n * @param text - Input text to slugify\n * @returns Slugified string (lowercase, hyphens, no special chars)\n */\nfunction generateSlug(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '') // Remove special characters\n    .replace(/\\s+/g, '-')      // Replace spaces with hyphens\n    .replace(/-+/g, '-')       // Replace multiple hyphens with single hyphen\n    .replace(/^-+|-+$/g, '');  // Remove leading/trailing hyphens\n}\n\n// ============= CONFIGURATION =============\n\n/**\n * Strapi API base URL\n * @description Configure via STRAPI_URL environment variable\n * @default 'http://localhost:1337'\n * @example\n * // In .env file:\n * STRAPI_URL=https://cms.example.com\n */\nconst STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';\n\n/**\n * Strapi API authentication token\n * @description Configure via STRAPI_API_TOKEN environment variable.\n * Generate tokens in Strapi Admin Panel: Settings > API Tokens > Create new API Token\n * @required Required for all API requests\n * @example\n * // In .env file:\n * STRAPI_API_TOKEN=your_strapi_api_token_here\n */\nconst STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;\n\n/**\n * Cache Time-To-Live (TTL) in milliseconds\n * @description How long cache entries remain valid before automatic expiration.\n * Cache entries are refreshed on access (updateAgeOnGet: true)\n * @default 300000 (5 minutes)\n */\nconst CACHE_TTL = 1000 * 60 * 5; // 5 minutes\n\n/**\n * Maximum number of cache entries\n * @description LRU cache evicts least recently used entries when limit is reached\n * @default 100\n */\nconst CACHE_MAX_SIZE = 100;\n\n// ============= STRAPI CLIENT CLASS =============\n\n/**\n * StrapiClient - Singleton service for Strapi API interactions\n *\n * @description\n * The StrapiClient provides a robust data access layer for the Strapi CMS API, handling\n * all HTTP communication, caching, and data transformation between Strapi's response format\n * and the application's domain models. It implements the singleton pattern to ensure a single\n * shared instance with consistent caching across the application.\n *\n * **Key Features:**\n * - HTTP client with axios and Bearer token authentication\n * - LRU cache with 5-minute TTL and automatic cache invalidation on mutations\n * - Request/response interceptors for logging and error handling\n * - Automatic data transformation between Strapi format and domain models\n * - Support for Strapi v5 features (populate, filters, sort, pagination, components)\n * - Health check endpoint for API availability monitoring\n * - CRUD operations for Agents, Skills, MCP Servers, MCP Tools, Tasks\n * - File upload/delete operations\n * - Cache management utilities\n *\n * **Environment Variables:**\n * - `STRAPI_URL`: Base URL for Strapi API (default: 'http://localhost:1337')\n * - `STRAPI_API_TOKEN`: Bearer token for API authentication (required)\n *\n * **Cache Configuration:**\n * - TTL: 5 minutes (300000ms) with refresh on access\n * - Max Size: 100 entries (LRU eviction)\n * - Automatic invalidation on mutations (create/update/delete)\n * - Manual cache management via clearCache() and getCacheStats()\n *\n * @example\n * // Basic usage - use the singleton instance\n * import { strapiClient } from './strapi-client';\n *\n * // Check API health\n * const isHealthy = await strapiClient.healthCheck();\n *\n * // Fetch all agents\n * const agents = await strapiClient.getAllAgents();\n *\n * @example\n * // Advanced filtering and population\n * import { strapiClient } from './strapi-client';\n *\n * // Get agents with custom filters and populated relations\n * const activeAgents = await strapiClient.getAllAgents({\n *   filters: { enabled: true },\n *   populate: ['mcpConfig', 'skillSelection', 'tasks'],\n *   sort: ['name:asc'],\n *   pagination: { page: 1, pageSize: 10 }\n * });\n *\n * // Get a single agent with all relations populated\n * const agent = await strapiClient.getAgent('agent-id');\n * console.log(agent.mcpConfig); // Populated component data\n *\n * @example\n * // CRUD operations\n * import { strapiClient } from './strapi-client';\n *\n * // Create a new agent\n * const newAgent = await strapiClient.createAgent({\n *   name: 'Code Assistant',\n *   description: 'Helps with coding tasks',\n *   systemPrompt: 'You are a helpful coding assistant.',\n *   enabled: true,\n *   modelConfig: {\n *     model: 'sonnet',\n *     temperature: 1.0,\n *     timeout: 300000\n *   }\n * });\n *\n * // Update the agent\n * const updatedAgent = await strapiClient.updateAgent(newAgent.id, {\n *   description: 'Updated description'\n * });\n *\n * // Delete the agent\n * await strapiClient.deleteAgent(newAgent.id);\n *\n * @example\n * // Cache management\n * import { strapiClient } from './strapi-client';\n *\n * // Get cache statistics\n * const stats = strapiClient.getCacheStats();\n * console.log(`Cache: ${stats.size}/${stats.max} entries, TTL: ${stats.ttl}ms`);\n *\n * // Clear all cache entries\n * strapiClient.clearCache();\n *\n * @example\n * // File upload workflow\n * import { strapiClient } from './strapi-client';\n * import fs from 'fs';\n *\n * // Upload a file\n * const fileBuffer = fs.readFileSync('./example.pdf');\n * const uploadedFile = await strapiClient.uploadFile(fileBuffer, 'example.pdf');\n * console.log(`File uploaded: ${uploadedFile.url}`);\n *\n * // Use the file in a skill's additionalFiles\n * const skill = await strapiClient.createSkill({\n *   name: 'example-skill',\n *   displayName: 'Example Skill',\n *   description: 'A skill with an additional file',\n *   skillmd: '# Skill content',\n *   additionalFiles: [\n *     { file: uploadedFile.documentId }\n *   ]\n * });\n *\n * // Delete the file when no longer needed\n * await strapiClient.deleteFile(uploadedFile.documentId);\n *\n * @see {@link https://docs.strapi.io/dev-docs/api/rest|Strapi REST API Documentation}\n * @see {@link https://github.com/isaacs/node-lru-cache|LRU Cache Documentation}\n */\nexport class StrapiClient {\n  /** Axios HTTP client instance configured with base URL and authentication */\n  private client: AxiosInstance;\n\n  /** LRU cache for GET responses with 5-minute TTL and 100-entry limit */\n  private cache: LRUCache<string, any>;\n\n  constructor() {\n    // Initialize axios client with base configuration\n    this.client = axios.create({\n      baseURL: `${STRAPI_URL}/api`,\n      headers: {\n        'Authorization': STRAPI_API_TOKEN ? `Bearer ${STRAPI_API_TOKEN}` : '',\n        'Content-Type': 'application/json',\n      },\n      timeout: 10000, // 10 seconds\n    });\n\n    // Initialize LRU cache\n    this.cache = new LRUCache({\n      max: CACHE_MAX_SIZE,\n      ttl: CACHE_TTL,\n      updateAgeOnGet: true, // Refresh TTL on access\n    });\n\n    // Add request interceptor for logging\n    this.client.interceptors.request.use(\n      (config: any) => {\n        console.log(`[Strapi] ${config.method?.toUpperCase()} ${config.url}`);\n        return config;\n      },\n      (error: any) => {\n        console.error('[Strapi] Request error:', error);\n        return Promise.reject(error);\n      }\n    );\n\n    // Add response interceptor for error handling\n    this.client.interceptors.response.use(\n      (response: any) => response,\n      (error: AxiosError) => {\n        this.handleError(error);\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  // ============= HEALTH CHECK =============\n\n  /**\n   * Check if Strapi API is accessible and responding\n   *\n   * @description\n   * Performs a health check by making a request to the Strapi API root endpoint.\n   * Use this method to verify API connectivity before performing operations, especially\n   * during application startup or when debugging connection issues.\n   *\n   * **Use Cases:**\n   * - Application startup validation\n   * - Periodic monitoring of Strapi availability\n   * - Pre-flight checks before critical operations\n   * - Debugging connection issues (CORS, network, authentication)\n   *\n   * **What This Checks:**\n   * - Network connectivity to Strapi server\n   * - Strapi server is running and responding\n   * - API token authentication is valid (if configured)\n   * - No CORS issues (for browser environments)\n   *\n   * @returns {Promise<boolean>} `true` if Strapi API is accessible and healthy, `false` if check fails\n   *\n   * @example\n   * // Basic health check\n   * const isHealthy = await strapiClient.healthCheck();\n   *\n   * if (isHealthy) {\n   *   console.log('Strapi API is healthy');\n   * } else {\n   *   console.error('Strapi API is unavailable');\n   * }\n   *\n   * @example\n   * // Application startup validation\n   * async function initializeApp() {\n   *   console.log('Checking Strapi connection...');\n   *\n   *   const isHealthy = await strapiClient.healthCheck();\n   *\n   *   if (!isHealthy) {\n   *     console.error('ERROR: Cannot connect to Strapi API');\n   *     console.error(`STRAPI_URL: ${process.env.STRAPI_URL || 'http://localhost:1337'}`);\n   *     console.error('Please ensure Strapi is running and STRAPI_URL is correct');\n   *     process.exit(1);\n   *   }\n   *\n   *   console.log('Strapi connection successful');\n   *   // Continue with app initialization\n   * }\n   *\n   * @example\n   * // Retry logic with health check\n   * async function connectWithRetry(maxRetries = 3) {\n   *   for (let i = 0; i < maxRetries; i++) {\n   *     const isHealthy = await strapiClient.healthCheck();\n   *\n   *     if (isHealthy) {\n   *       console.log('Connected to Strapi');\n   *       return true;\n   *     }\n   *\n   *     console.warn(`Connection attempt ${i + 1}/${maxRetries} failed`);\n   *\n   *     if (i < maxRetries - 1) {\n   *       await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s\n   *     }\n   *   }\n   *\n   *   console.error('Failed to connect to Strapi after retries');\n   *   return false;\n   * }\n   *\n   * @example\n   * // Periodic health monitoring\n   * setInterval(async () => {\n   *   const isHealthy = await strapiClient.healthCheck();\n   *\n   *   if (!isHealthy) {\n   *     console.error('[Monitor] Strapi API is down!');\n   *     // Send alert, update status indicator, etc.\n   *   }\n   * }, 60000); // Check every minute\n   *\n   * @example\n   * // Pre-flight check before critical operation\n   * async function syncAllData() {\n   *   // Check API health before starting sync\n   *   if (!await strapiClient.healthCheck()) {\n   *     throw new Error('Cannot sync: Strapi API is unavailable');\n   *   }\n   *\n   *   // Proceed with sync\n   *   const agents = await strapiClient.getAllAgents();\n   *   const skills = await strapiClient.getAllSkills();\n   *   // ... sync logic\n   * }\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      await this.client.get('/');\n      console.log('[Strapi] Health check passed');\n      return true;\n    } catch (error) {\n      console.error('[Strapi] Health check failed:', error);\n      return false;\n    }\n  }\n\n  // ============= AGENTS =============\n\n  /**\n   * Get all agents with optional filtering, sorting, and pagination\n   *\n   * @description\n   * Retrieves all agents from Strapi with support for advanced query features including\n   * filtering, sorting, pagination, and relation population. Results are cached with 5-minute\n   * TTL for improved performance on repeated queries.\n   *\n   * **Strapi v5 Component Support:**\n   * Agents use component-based architecture. The following component fields are available:\n   * - `toolConfig`: Tool configuration component (file_search, text_editor, computer_20241022, bash_20241022)\n   * - `modelConfig`: Model configuration component (model, temperature, timeout, etc.)\n   * - `analytics`: Analytics component (usage stats, performance metrics)\n   * - `metadata`: Key-value metadata pairs\n   * - `mcpConfig`: MCP server configuration components (array of mcpServer + selectedTools)\n   * - `skillSelection`: Skill selection components (array of skill references)\n   * - `tasks`: Task assignment components (array of task references)\n   *\n   * @param {Object} [options] - Query options for filtering, sorting, and pagination\n   * @param {string[]} [options.populate] - Relations/components to populate (e.g., ['mcpConfig', 'skillSelection'])\n   * @param {Record<string, any>} [options.filters] - Strapi v5 filters object (supports $eq, $ne, $in, $notIn, $lt, $lte, $gt, $gte, $contains, $notContains, $containsi, $notContainsi, $null, $notNull, $between, $startsWith, $endsWith, $or, $and, $not)\n   * @param {string[]} [options.sort] - Sort order array (e.g., ['name:asc', 'createdAt:desc'])\n   * @param {Object} [options.pagination] - Pagination configuration\n   * @param {number} [options.pagination.page] - Page number (1-indexed)\n   * @param {number} [options.pagination.pageSize] - Number of items per page\n   *\n   * @returns {Promise<Agent[]>} Array of Agent objects with populated component fields\n   *\n   * @example\n   * // Basic usage - get all agents\n   * const agents = await strapiClient.getAllAgents();\n   * console.log(`Found ${agents.length} agents`);\n   *\n   * @example\n   * // Filter enabled agents only\n   * const enabledAgents = await strapiClient.getAllAgents({\n   *   filters: { enabled: { $eq: true } }\n   * });\n   *\n   * @example\n   * // Advanced filtering with multiple conditions\n   * const filteredAgents = await strapiClient.getAllAgents({\n   *   filters: {\n   *     $and: [\n   *       { enabled: { $eq: true } },\n   *       { name: { $containsi: 'assistant' } }, // Case-insensitive contains\n   *       { createdAt: { $gte: '2024-01-01T00:00:00.000Z' } }\n   *     ]\n   *   },\n   *   sort: ['name:asc'],\n   *   pagination: { page: 1, pageSize: 10 }\n   * });\n   *\n   * @example\n   * // Populate component relations to access nested data\n   * const agentsWithRelations = await strapiClient.getAllAgents({\n   *   populate: ['mcpConfig', 'skillSelection', 'tasks'],\n   *   filters: { enabled: true }\n   * });\n   *\n   * // Access populated component data\n   * agentsWithRelations.forEach(agent => {\n   *   console.log(`Agent: ${agent.name}`);\n   *   console.log(`MCP Servers: ${agent.mcpConfig?.length || 0}`);\n   *   console.log(`Skills: ${agent.skillSelection?.length || 0}`);\n   *   console.log(`Model: ${agent.modelConfig?.model}`);\n   * });\n   *\n   * @example\n   * // Search agents by name with case-insensitive matching\n   * const searchResults = await strapiClient.getAllAgents({\n   *   filters: {\n   *     $or: [\n   *       { name: { $containsi: 'code' } },\n   *       { description: { $containsi: 'code' } }\n   *     ]\n   *   }\n   * });\n   *\n   * @example\n   * // Get agents with specific model configuration\n   * const sonnetAgents = await strapiClient.getAllAgents({\n   *   filters: {\n   *     'modelConfig.model': { $eq: 'sonnet' }\n   *   }\n   * });\n   *\n   * @example\n   * // Pagination - get second page of 20 agents\n   * const page2 = await strapiClient.getAllAgents({\n   *   pagination: { page: 2, pageSize: 20 },\n   *   sort: ['updatedAt:desc'] // Most recently updated first\n   * });\n   */\n  async getAllAgents(options?: {\n    populate?: string[] | Record<string, any>;\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Agent[]> {\n    const cacheKey = `agents:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams(options);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/agents',\n      { params }\n    );\n\n    const agents = data.data.map((item: StrapiAttributes<any>) => this.transformAgent(item));\n\n    this.cache.set(cacheKey, agents);\n\n    return agents;\n  }\n\n  /**\n   * Get a single agent by ID with all relations and components populated\n   *\n   * @description\n   * Retrieves a single agent by its unique document ID with deep population of all\n   * component fields and relations. This method automatically populates all nested data\n   * including MCP server configurations, skill selections, and task assignments.\n   *\n   * **Auto-populated Components:**\n   * - `toolConfig`: Tool configuration with enabled tools\n   * - `modelConfig`: Model configuration (model, temperature, timeout)\n   * - `analytics`: Usage analytics and performance metrics\n   * - `metadata`: Custom key-value metadata pairs\n   * - `mcpConfig`: MCP server configurations with nested mcpServer and selectedTools.mcpTool relations\n   * - `skillSelection`: Skill selections with nested skill relations\n   * - `tasks`: Task assignments with nested task relations\n   *\n   * **Strapi v5 Deep Population:**\n   * This method uses deep population syntax to retrieve nested relations within components:\n   * ```javascript\n   * mcpConfig: {\n   *   populate: {\n   *     mcpServer: true,           // Populate mcpServer relation\n   *     selectedTools: {\n   *       populate: { mcpTool: true }  // Populate mcpTool within selectedTools\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @param {string} id - Agent document ID (UUID format)\n   *\n   * @returns {Promise<Agent>} Agent object with all components and relations populated\n   *\n   * @throws {Error} If agent with the specified ID is not found\n   *\n   * @example\n   * // Basic usage - get agent with all relations\n   * const agent = await strapiClient.getAgent('abc123-def456-ghi789');\n   * console.log(agent.name);\n   * console.log(agent.systemPrompt);\n   * console.log(agent.modelConfig?.model); // 'sonnet' | 'haiku' | 'opus'\n   *\n   * @example\n   * // Access MCP server configuration\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * // mcpConfig is an array of components\n   * agent.mcpConfig?.forEach(config => {\n   *   console.log(`MCP Server: ${config.mcpServer?.name}`);\n   *   console.log(`Transport: ${config.mcpServer?.transport}`);\n   *\n   *   // Access selected tools (nested population)\n   *   config.selectedTools?.forEach(toolSelection => {\n   *     console.log(`  Tool: ${toolSelection.mcpTool?.name}`);\n   *     console.log(`  Description: ${toolSelection.mcpTool?.description}`);\n   *   });\n   * });\n   *\n   * @example\n   * // Access skill selection\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * // skillSelection is an array of components\n   * agent.skillSelection?.forEach(selection => {\n   *   const skill = selection.skill; // Populated skill relation\n   *   console.log(`Skill: ${skill?.displayName}`);\n   *   console.log(`Description: ${skill?.description}`);\n   * });\n   *\n   * @example\n   * // Access tool configuration component\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * if (agent.toolConfig) {\n   *   console.log('Enabled tools:');\n   *   if (agent.toolConfig.file_search) console.log('  - File Search');\n   *   if (agent.toolConfig.text_editor) console.log('  - Text Editor');\n   *   if (agent.toolConfig.computer_20241022) console.log('  - Computer Use');\n   *   if (agent.toolConfig.bash_20241022) console.log('  - Bash');\n   * }\n   *\n   * @example\n   * // Access model configuration component\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * const config = agent.modelConfig;\n   * console.log(`Model: ${config?.model || 'sonnet'}`);\n   * console.log(`Temperature: ${config?.temperature || 1.0}`);\n   * console.log(`Max tokens: ${config?.max_tokens || 4096}`);\n   * console.log(`Timeout: ${config?.timeout || 300000}ms`);\n   *\n   * @example\n   * // Error handling for non-existent agent\n   * try {\n   *   const agent = await strapiClient.getAgent('non-existent-id');\n   * } catch (error) {\n   *   console.error('Agent not found:', error.message);\n   *   // Error: Agent with ID non-existent-id not found\n   * }\n   *\n   * @example\n   * // Check agent enabled status before use\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * if (!agent.enabled) {\n   *   console.warn(`Agent \"${agent.name}\" is disabled`);\n   *   return;\n   * }\n   *\n   * // Use agent for conversation...\n   *\n   * @see {@link getAllAgents} for querying multiple agents with filters\n   */\n  async getAgent(id: string): Promise<Agent> {\n    const cacheKey = `agent:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/agents/${id}`,\n      {\n        params: {\n          // Populate component fields and nested relations\n          populate: {\n            toolConfig: true,\n            modelConfig: true,\n            analytics: true,\n            metadata: true,\n            mcpConfig: {\n              populate: {\n                mcpServer: true,\n                selectedTools: {\n                  populate: { mcpTool: true },\n                },\n              },\n            },\n            skillSelection: {\n              populate: { skill: true },\n            },\n            tasks: {\n              populate: { task: true },\n            },\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Agent with ID ${id} not found`);\n    }\n\n    const agent = this.transformAgent(data.data);\n    this.cache.set(cacheKey, agent);\n\n    return agent;\n  }\n\n  /**\n   * Create a new agent with component-based configuration\n   *\n   * @description\n   * Creates a new agent in Strapi with support for component-based architecture.\n   * The agent slug is automatically generated from the name. All component fields\n   * (toolConfig, modelConfig, mcpConfig, etc.) are supported in Strapi v5 format.\n   *\n   * **Component Fields:**\n   * - `toolConfig`: Configure enabled tools (file_search, text_editor, computer_20241022, bash_20241022)\n   * - `modelConfig`: Configure model settings (model, temperature, max_tokens, timeout)\n   * - `analytics`: Initialize analytics tracking\n   * - `metadata`: Add custom key-value metadata pairs\n   * - `mcpConfig`: Configure MCP servers (array of { mcpServer: id, selectedTools: [...] })\n   * - `skillSelection`: Assign skills (array of { skill: id })\n   * - `tasks`: Assign tasks (array of { task: id })\n   *\n   * **Cache Invalidation:**\n   * Creating an agent invalidates all cached agent queries to ensure fresh data.\n   *\n   * @param {CreateAgentDTO} agentData - Agent data transfer object\n   * @param {string} agentData.name - Agent name (required, used to generate slug)\n   * @param {string} [agentData.description] - Agent description\n   * @param {string} agentData.systemPrompt - System prompt for the agent (required)\n   * @param {boolean} [agentData.enabled=true] - Whether the agent is enabled\n   * @param {Object} [agentData.toolConfig] - Tool configuration component\n   * @param {Object} [agentData.modelConfig] - Model configuration component\n   * @param {Object} [agentData.analytics] - Analytics component\n   * @param {Array} [agentData.metadata] - Metadata key-value pairs\n   * @param {Array} [agentData.mcpConfig] - MCP server configuration components\n   * @param {Array} [agentData.skillSelection] - Skill selection components\n   * @param {Array} [agentData.tasks] - Task assignment components\n   *\n   * @returns {Promise<Agent>} Created agent with generated ID and auto-populated defaults\n   *\n   * @throws {Error} If agent creation fails (validation errors, network errors)\n   *\n   * @example\n   * // Basic agent creation with minimal fields\n   * const agent = await strapiClient.createAgent({\n   *   name: 'Code Assistant',\n   *   description: 'Helps with coding tasks',\n   *   systemPrompt: 'You are a helpful coding assistant specialized in TypeScript and React.',\n   *   enabled: true\n   * });\n   *\n   * console.log(agent.id);   // Auto-generated UUID\n   * console.log(agent.slug); // Auto-generated: 'code-assistant'\n   * console.log(agent.modelConfig); // Default: { model: 'sonnet', temperature: 1.0, timeout: 300000 }\n   *\n   * @example\n   * // Create agent with custom model configuration\n   * const agent = await strapiClient.createAgent({\n   *   name: 'Fast Assistant',\n   *   systemPrompt: 'You are a quick assistant for simple tasks.',\n   *   modelConfig: {\n   *     model: 'haiku',\n   *     temperature: 0.7,\n   *     max_tokens: 2048,\n   *     timeout: 60000\n   *   }\n   * });\n   *\n   * @example\n   * // Create agent with specific tools enabled\n   * const agent = await strapiClient.createAgent({\n   *   name: 'File Manager',\n   *   systemPrompt: 'You help users manage and search files.',\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: true,\n   *     bash_20241022: false,\n   *     computer_20241022: false\n   *   }\n   * });\n   *\n   * @example\n   * // Create agent with MCP server configuration\n   * // First, ensure MCP servers exist in Strapi\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const filesystemServer = mcpServers.find(s => s.name === 'filesystem');\n   * const filesystemTools = await strapiClient.getMCPToolsByServerId(filesystemServer.id);\n   *\n   * const agent = await strapiClient.createAgent({\n   *   name: 'File Assistant',\n   *   systemPrompt: 'You help users with file operations.',\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: filesystemServer.id,\n   *       selectedTools: filesystemTools.slice(0, 3).map(tool => ({\n   *         mcpTool: tool.id\n   *       }))\n   *     }\n   *   ]\n   * });\n   *\n   * @example\n   * // Create agent with skill selection\n   * const skills = await strapiClient.getAllSkills();\n   * const codingSkill = skills.find(s => s.name === 'typescript-expert');\n   *\n   * const agent = await strapiClient.createAgent({\n   *   name: 'TypeScript Expert',\n   *   systemPrompt: 'You are a TypeScript expert.',\n   *   skillSelection: [\n   *     { skill: codingSkill.id }\n   *   ]\n   * });\n   *\n   * @example\n   * // Create agent with custom metadata\n   * const agent = await strapiClient.createAgent({\n   *   name: 'Research Assistant',\n   *   systemPrompt: 'You help with research tasks.',\n   *   metadata: [\n   *     { key: 'department', value: 'Engineering' },\n   *     { key: 'priority', value: 'high' },\n   *     { key: 'version', value: '2.0' }\n   *   ]\n   * });\n   *\n   * @example\n   * // Error handling for validation failures\n   * try {\n   *   const agent = await strapiClient.createAgent({\n   *     name: '', // Invalid: empty name\n   *     systemPrompt: 'Test prompt'\n   *   });\n   * } catch (error) {\n   *   console.error('Validation failed:', error.message);\n   * }\n   *\n   * @see {@link updateAgent} for updating existing agents\n   * @see {@link getAgent} for retrieving created agent with full details\n   */\n  async createAgent(agentData: CreateAgentDTO): Promise<Agent> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/agents',\n      {\n        data: this.prepareAgentData(agentData as any),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create agent');\n    }\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n\n    return this.transformAgent(data.data);\n  }\n\n  /**\n   * Update an existing agent with partial data\n   *\n   * @description\n   * Updates an existing agent in Strapi using partial update semantics. Only the fields\n   * provided in the update DTO will be modified; omitted fields remain unchanged. This\n   * method supports updating all component fields and relations in Strapi v5 format.\n   *\n   * **Partial Updates:**\n   * You can update individual fields without affecting other fields:\n   * - Update only `name` without changing `systemPrompt`\n   * - Update only `modelConfig` without changing `toolConfig`\n   * - Update only specific tools within `mcpConfig` arrays\n   *\n   * **Component Field Updates:**\n   * - `toolConfig`: Update tool enablement settings\n   * - `modelConfig`: Update model configuration (temperature, timeout, etc.)\n   * - `analytics`: Update analytics data\n   * - `metadata`: Replace or append metadata pairs\n   * - `mcpConfig`: Replace MCP server configurations (array replacement)\n   * - `skillSelection`: Replace skill selections (array replacement)\n   * - `tasks`: Replace task assignments (array replacement)\n   *\n   * **Cache Invalidation:**\n   * Updating an agent invalidates both the specific agent cache and all agent list caches.\n   *\n   * @param {string} id - Agent document ID to update\n   * @param {UpdateAgentDTO} agentData - Partial agent data to update\n   * @param {string} [agentData.name] - Update agent name (updates slug automatically)\n   * @param {string} [agentData.description] - Update description\n   * @param {string} [agentData.systemPrompt] - Update system prompt\n   * @param {boolean} [agentData.enabled] - Update enabled status\n   * @param {Object} [agentData.toolConfig] - Update tool configuration\n   * @param {Object} [agentData.modelConfig] - Update model configuration\n   * @param {Object} [agentData.analytics] - Update analytics\n   * @param {Array} [agentData.metadata] - Replace metadata (not merged)\n   * @param {Array} [agentData.mcpConfig] - Replace MCP config (not merged)\n   * @param {Array} [agentData.skillSelection] - Replace skill selection (not merged)\n   * @param {Array} [agentData.tasks] - Replace task assignments (not merged)\n   *\n   * @returns {Promise<Agent>} Updated agent with all components populated\n   *\n   * @throws {Error} If agent with specified ID is not found or update fails\n   *\n   * @example\n   * // Basic update - change agent name and description\n   * const updatedAgent = await strapiClient.updateAgent('agent-id', {\n   *   name: 'Updated Assistant',\n   *   description: 'New description'\n   * });\n   *\n   * // systemPrompt, enabled, and other fields remain unchanged\n   *\n   * @example\n   * // Update only the system prompt\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   systemPrompt: 'You are an expert TypeScript developer with 10 years of experience.'\n   * });\n   *\n   * @example\n   * // Enable/disable an agent\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   enabled: false\n   * });\n   *\n   * @example\n   * // Update model configuration - change model and temperature\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   modelConfig: {\n   *     model: 'opus',\n   *     temperature: 0.5,\n   *     max_tokens: 8192,\n   *     timeout: 600000\n   *   }\n   * });\n   *\n   * @example\n   * // Update tool configuration - enable specific tools\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: true,\n   *     bash_20241022: true,\n   *     computer_20241022: false\n   *   }\n   * });\n   *\n   * @example\n   * // Update MCP configuration - replace all MCP servers\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const githubServer = mcpServers.find(s => s.name === 'github');\n   * const githubTools = await strapiClient.getMCPToolsByServerId(githubServer.id);\n   *\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: githubServer.id,\n   *       selectedTools: githubTools.map(tool => ({ mcpTool: tool.id }))\n   *     }\n   *   ]\n   * });\n   *\n   * @example\n   * // Add more skills to an agent (requires fetching existing first)\n   * const currentAgent = await strapiClient.getAgent('agent-id');\n   * const newSkill = await strapiClient.getAllSkills({ filters: { name: 'debugging' } });\n   *\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   skillSelection: [\n   *     ...(currentAgent.skillSelection || []), // Keep existing skills\n   *     { skill: newSkill[0].id } // Add new skill\n   *   ]\n   * });\n   *\n   * @example\n   * // Update metadata - completely replace metadata array\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   metadata: [\n   *     { key: 'environment', value: 'production' },\n   *     { key: 'version', value: '3.0' },\n   *     { key: 'last_updated', value: new Date().toISOString() }\n   *   ]\n   * });\n   *\n   * @example\n   * // Bulk update - change multiple fields at once\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   name: 'Production Assistant',\n   *   description: 'Production-ready AI assistant',\n   *   enabled: true,\n   *   modelConfig: {\n   *     model: 'sonnet',\n   *     temperature: 0.7,\n   *     timeout: 300000\n   *   },\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: true,\n   *     bash_20241022: false,\n   *     computer_20241022: false\n   *   }\n   * });\n   *\n   * @example\n   * // Error handling for non-existent agent\n   * try {\n   *   const agent = await strapiClient.updateAgent('non-existent-id', {\n   *     name: 'New Name'\n   *   });\n   * } catch (error) {\n   *   console.error('Update failed:', error.message);\n   *   // Error: Failed to update agent with ID non-existent-id\n   * }\n   *\n   * @see {@link createAgent} for creating new agents\n   * @see {@link getAgent} for retrieving current agent state before update\n   */\n  async updateAgent(id: string, agentData: UpdateAgentDTO): Promise<Agent> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/agents/${id}`,\n      {\n        data: this.prepareAgentData(agentData as any),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update agent with ID ${id}`);\n    }\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n    this.cache.delete(`agent:${id}`);\n\n    return this.transformAgent(data.data);\n  }\n\n  /**\n   * Delete an agent permanently from Strapi\n   *\n   * @description\n   * Permanently deletes an agent from the Strapi database. This operation cannot be undone.\n   * All associated component data (toolConfig, modelConfig, mcpConfig, skillSelection, etc.)\n   * is also deleted as they are part of the agent entity.\n   *\n   * **Important Considerations:**\n   * - This is a permanent deletion - there is no soft delete or trash bin\n   * - All component data is deleted with the agent\n   * - Related entities (Skills, MCP Servers, Tasks) are NOT deleted (only the associations)\n   * - Any active conversations using this agent may fail\n   * - Cache is automatically invalidated after deletion\n   *\n   * **Best Practices:**\n   * - Consider disabling the agent instead of deleting it to preserve history\n   * - Verify the agent ID before deletion to prevent accidental deletions\n   * - Check for active conversations or tasks before deletion\n   * - Export agent configuration before deletion if you may need it later\n   *\n   * @param {string} id - Agent document ID to delete\n   *\n   * @returns {Promise<void>} Resolves when deletion is complete\n   *\n   * @throws {Error} If agent with specified ID is not found or deletion fails\n   *\n   * @example\n   * // Basic deletion\n   * await strapiClient.deleteAgent('agent-id-to-delete');\n   * console.log('Agent deleted successfully');\n   *\n   * @example\n   * // Safe deletion with confirmation\n   * const agent = await strapiClient.getAgent('agent-id');\n   * console.log(`About to delete agent: ${agent.name}`);\n   * console.log(`Description: ${agent.description}`);\n   *\n   * // In a real application, prompt user for confirmation here\n   * const confirmed = true; // User confirmation\n   *\n   * if (confirmed) {\n   *   await strapiClient.deleteAgent(agent.id);\n   *   console.log('Agent deleted');\n   * }\n   *\n   * @example\n   * // Alternative: Disable instead of delete (preserves history)\n   * // This is often preferred over permanent deletion\n   * const agent = await strapiClient.updateAgent('agent-id', {\n   *   enabled: false\n   * });\n   * console.log('Agent disabled (not deleted)');\n   *\n   * @example\n   * // Export agent configuration before deletion\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * // Save configuration to file or backup system\n   * const backup = {\n   *   name: agent.name,\n   *   description: agent.description,\n   *   systemPrompt: agent.systemPrompt,\n   *   modelConfig: agent.modelConfig,\n   *   toolConfig: agent.toolConfig,\n   *   mcpConfig: agent.mcpConfig,\n   *   skillSelection: agent.skillSelection,\n   *   exportedAt: new Date().toISOString()\n   * };\n   *\n   * // fs.writeFileSync(`./backups/agent-${agent.id}.json`, JSON.stringify(backup, null, 2));\n   *\n   * // Now safe to delete\n   * await strapiClient.deleteAgent(agent.id);\n   *\n   * @example\n   * // Error handling for non-existent agent\n   * try {\n   *   await strapiClient.deleteAgent('non-existent-id');\n   * } catch (error) {\n   *   console.error('Deletion failed:', error.message);\n   *   // Handle error (agent not found, network error, etc.)\n   * }\n   *\n   * @example\n   * // Batch deletion (use with caution!)\n   * const agentsToDelete = await strapiClient.getAllAgents({\n   *   filters: { enabled: false, updatedAt: { $lt: '2024-01-01' } }\n   * });\n   *\n   * console.log(`Found ${agentsToDelete.length} agents to delete`);\n   *\n   * for (const agent of agentsToDelete) {\n   *   console.log(`Deleting ${agent.name}...`);\n   *   await strapiClient.deleteAgent(agent.id);\n   * }\n   *\n   * console.log('Batch deletion complete');\n   *\n   * @see {@link updateAgent} for disabling agents without deletion\n   * @see {@link getAgent} for retrieving agent details before deletion\n   */\n  async deleteAgent(id: string): Promise<void> {\n    await this.client.delete(`/agents/${id}`);\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n    this.cache.delete(`agent:${id}`);\n  }\n\n  // ============= SKILLS =============\n\n  /**\n   * Get all skills with optional filtering, sorting, and pagination\n   *\n   * @description\n   * Retrieves all skills from Strapi with support for advanced query features including\n   * filtering, sorting, pagination, and relation population. Skills automatically populate\n   * component fields including trainingHistory, additionalFiles, and mcpConfig for comprehensive\n   * skill data. Results are cached with 5-minute TTL for improved performance.\n   *\n   * **Strapi v5 Component Support:**\n   * Skills use component-based architecture with the following component fields:\n   * - `trainingHistory`: Array of training records with date, description, score delta, notes\n   * - `additionalFiles`: Array of file attachments with file relation (PDFs, docs, images)\n   * - `mcpConfig`: MCP server configuration components (array of mcpServer + selectedTools)\n   * - `agentSelection`: Agent assignment components (array of agent references)\n   * - `toolConfig`: Tool configuration component (file_search, text_editor, etc.)\n   * - `modelConfig`: Model configuration component (model, temperature, timeout)\n   * - `analytics`: Analytics component (usage stats, performance metrics)\n   * - `inputFields`: Dynamic input fields for skill execution\n   * - `tasks`: Task assignment components (array of task references)\n   *\n   * **Default Population:**\n   * By default, this method auto-populates all component fields for complete skill data:\n   * - `trainingHistory`, `additionalFiles.file`, `mcpConfig.mcpServer`, `mcpConfig.selectedTools.mcpTool`\n   * - `agentSelection`, `toolConfig`, `modelConfig`, `analytics`, `inputFields`\n   *\n   * @param {Object} [options] - Query options for filtering, sorting, and pagination\n   * @param {string[]} [options.populate] - Relations/components to populate (defaults to all skill components)\n   * @param {Record<string, any>} [options.filters] - Strapi v5 filters object (supports $eq, $ne, $in, $containsi, $and, $or, etc.)\n   * @param {string[]} [options.sort] - Sort order array (e.g., ['name:asc', 'experienceScore:desc'])\n   * @param {Object} [options.pagination] - Pagination configuration (defaults to { page: 1, pageSize: 100 })\n   * @param {number} [options.pagination.page] - Page number (1-indexed)\n   * @param {number} [options.pagination.pageSize] - Number of items per page\n   *\n   * @returns {Promise<Skill[]>} Array of Skill objects with all component fields populated\n   *\n   * @example\n   * // Basic usage - get all skills with auto-populated components\n   * const skills = await strapiClient.getAllSkills();\n   * console.log(`Found ${skills.length} skills`);\n   *\n   * // Access populated component data\n   * skills.forEach(skill => {\n   *   console.log(`Skill: ${skill.displayName}`);\n   *   console.log(`Experience: ${skill.experienceScore}`);\n   *   console.log(`Training records: ${skill.trainingHistory?.length || 0}`);\n   *   console.log(`Additional files: ${skill.additionalFiles?.length || 0}`);\n   *   console.log(`MCP servers: ${skill.mcpConfig?.length || 0}`);\n   * });\n   *\n   * @example\n   * // Filter public skills only\n   * const publicSkills = await strapiClient.getAllSkills({\n   *   filters: { isPublic: { $eq: true } }\n   * });\n   *\n   * @example\n   * // Filter by category with case-insensitive search\n   * const codeSkills = await strapiClient.getAllSkills({\n   *   filters: {\n   *     category: { $eq: 'coding' }\n   *   },\n   *   sort: ['experienceScore:desc']\n   * });\n   *\n   * @example\n   * // Advanced filtering with multiple conditions\n   * const expertSkills = await strapiClient.getAllSkills({\n   *   filters: {\n   *     $and: [\n   *       { isPublic: { $eq: true } },\n   *       { experienceScore: { $gte: 50 } },\n   *       { category: { $in: ['coding', 'debugging', 'testing'] } }\n   *     ]\n   *   },\n   *   sort: ['experienceScore:desc', 'updatedAt:desc'],\n   *   pagination: { page: 1, pageSize: 20 }\n   * });\n   *\n   * @example\n   * // Search skills by name or description\n   * const searchResults = await strapiClient.getAllSkills({\n   *   filters: {\n   *     $or: [\n   *       { name: { $containsi: 'typescript' } },\n   *       { displayName: { $containsi: 'typescript' } },\n   *       { description: { $containsi: 'typescript' } }\n   *     ]\n   *   }\n   * });\n   *\n   * @example\n   * // Access trainingHistory component data\n   * const skills = await strapiClient.getAllSkills();\n   *\n   * skills.forEach(skill => {\n   *   console.log(`\\nSkill: ${skill.displayName}`);\n   *   console.log(`Total Experience: ${skill.experienceScore}`);\n   *\n   *   if (skill.trainingHistory && skill.trainingHistory.length > 0) {\n   *     console.log('Training History:');\n   *     skill.trainingHistory.forEach((record: any) => {\n   *       console.log(`  - ${record.date}: ${record.description}`);\n   *       console.log(`    Score change: +${record.scoreChange || 0}`);\n   *       if (record.notes) console.log(`    Notes: ${record.notes}`);\n   *     });\n   *   }\n   * });\n   *\n   * @example\n   * // Access additionalFiles component data\n   * const skills = await strapiClient.getAllSkills();\n   *\n   * skills.forEach(skill => {\n   *   if (skill.additionalFiles && skill.additionalFiles.length > 0) {\n   *     console.log(`\\nSkill: ${skill.displayName}`);\n   *     console.log('Additional Files:');\n   *\n   *     skill.additionalFiles.forEach((fileComponent: any) => {\n   *       // fileComponent.file is populated via deep population\n   *       const file = fileComponent.file;\n   *       console.log(`  - ${file?.name || 'unnamed'}`);\n   *       console.log(`    URL: ${file?.url}`);\n   *       console.log(`    Size: ${file?.size} bytes`);\n   *       console.log(`    Type: ${file?.mime}`);\n   *       if (fileComponent.description) {\n   *         console.log(`    Description: ${fileComponent.description}`);\n   *       }\n   *     });\n   *   }\n   * });\n   *\n   * @example\n   * // Access mcpConfig component data\n   * const skills = await strapiClient.getAllSkills();\n   *\n   * skills.forEach(skill => {\n   *   if (skill.mcpConfig && skill.mcpConfig.length > 0) {\n   *     console.log(`\\nSkill: ${skill.displayName}`);\n   *     console.log('MCP Configuration:');\n   *\n   *     skill.mcpConfig.forEach((config: any) => {\n   *       // mcpServer and selectedTools are populated\n   *       console.log(`  MCP Server: ${config.mcpServer?.name}`);\n   *       console.log(`  Transport: ${config.mcpServer?.transport}`);\n   *\n   *       if (config.selectedTools && config.selectedTools.length > 0) {\n   *         console.log('  Selected Tools:');\n   *         config.selectedTools.forEach((toolSelection: any) => {\n   *           const tool = toolSelection.mcpTool;\n   *           console.log(`    - ${tool?.name}: ${tool?.description || 'No description'}`);\n   *         });\n   *       }\n   *     });\n   *   }\n   * });\n   *\n   * @example\n   * // Pagination - get second page of 20 skills\n   * const page2 = await strapiClient.getAllSkills({\n   *   pagination: { page: 2, pageSize: 20 },\n   *   sort: ['updatedAt:desc']\n   * });\n   *\n   * @see {@link getSkill} for retrieving a single skill with full component population\n   * @see {@link getSkillsByIds} for retrieving multiple specific skills\n   */\n  async getAllSkills(options?: {\n    populate?: string[];\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Skill[]> {\n    const cacheKey = `skills:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    // Always populate component fields for skills\n    const populateOptions = {\n      ...options,\n      populate: options?.populate || [\n        'toolConfig',\n        'modelConfig',\n        'analytics',\n        'mcpConfig.mcpServer',\n        'mcpConfig.selectedTools.mcpTool',\n        'agentSelection',\n        'trainingHistory',\n        'additionalFiles.file',  // Deep populate: component + file relation\n        'inputFields'\n      ],\n      // Default pagination to fetch all skills (max 100)\n      pagination: options?.pagination || { page: 1, pageSize: 100 }\n    };\n\n    const params = this.buildQueryParams(populateOptions);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/skills',\n      { params }\n    );\n\n    // DEBUG: Log raw Strapi response to check mcpConfig\n    console.log('[DEBUG] getAllSkills - Raw Strapi response (first item):', JSON.stringify(data.data[0], null, 2));\n    if (data.data[0]?.attributes) {\n      console.log('[DEBUG] getAllSkills - First item attributes keys:', Object.keys(data.data[0].attributes));\n      console.log('[DEBUG] getAllSkills - mcpConfig value:', (data.data[0].attributes as any).mcpConfig);\n    }\n\n    const skills = data.data.map((item: StrapiAttributes<any>) => this.transformSkill(item));\n    this.cache.set(cacheKey, skills);\n\n    return skills;\n  }\n\n  /**\n   * Get a single skill by ID with all relations and components populated\n   *\n   * @description\n   * Retrieves a single skill by its unique document ID with deep population of all\n   * component fields and relations. This method automatically populates all nested data\n   * including trainingHistory, additionalFiles with file relations, mcpConfig with\n   * MCP server and tool selections, and agent selections.\n   *\n   * **Auto-populated Components:**\n   * - `trainingHistory`: Array of training records tracking skill improvement over time\n   * - `additionalFiles`: File attachments with populated file relation (documents, PDFs, images)\n   * - `mcpConfig`: MCP server configurations with nested mcpServer and selectedTools.mcpTool relations\n   * - `agentSelection`: Agent assignments with nested agent relations\n   * - `toolConfig`: Tool configuration with enabled tools\n   * - `modelConfig`: Model configuration (model, temperature, timeout)\n   * - `analytics`: Usage analytics and performance metrics\n   * - `inputFields`: Dynamic input field configurations for skill execution\n   * - `tasks`: Task assignments with nested task relations\n   * - `trainingAgent`: Direct relation to the agent used for training this skill\n   *\n   * **Strapi v5 Deep Population:**\n   * This method uses deep population syntax to retrieve nested relations within components:\n   * ```javascript\n   * additionalFiles: {\n   *   populate: { file: true }  // Populate file relation inside component\n   * }\n   * mcpConfig: {\n   *   populate: {\n   *     mcpServer: true,\n   *     selectedTools: { populate: { mcpTool: true } }\n   *   }\n   * }\n   * ```\n   *\n   * @param {string} id - Skill document ID (UUID format)\n   *\n   * @returns {Promise<Skill>} Skill object with all components and relations populated\n   *\n   * @throws {Error} If skill with the specified ID is not found\n   *\n   * @example\n   * // Basic usage - get skill with all relations\n   * const skill = await strapiClient.getSkill('skill-id');\n   * console.log(skill.displayName);\n   * console.log(skill.description);\n   * console.log(skill.experienceScore);\n   *\n   * @example\n   * // Access trainingHistory component\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * console.log(`\\n${skill.displayName} Training History:`);\n   * console.log(`Current Experience Score: ${skill.experienceScore}`);\n   *\n   * if (skill.trainingHistory && skill.trainingHistory.length > 0) {\n   *   skill.trainingHistory.forEach((record: any) => {\n   *     console.log(`\\nDate: ${new Date(record.date).toLocaleDateString()}`);\n   *     console.log(`Description: ${record.description}`);\n   *     console.log(`Score Change: +${record.scoreChange || 0}`);\n   *     console.log(`Agent: ${record.agentName || 'Unknown'}`);\n   *     if (record.notes) {\n   *       console.log(`Notes: ${record.notes}`);\n   *     }\n   *   });\n   * } else {\n   *   console.log('No training history yet');\n   * }\n   *\n   * @example\n   * // Access additionalFiles component with file relation\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * if (skill.additionalFiles && skill.additionalFiles.length > 0) {\n   *   console.log(`\\n${skill.displayName} Additional Files:`);\n   *\n   *   skill.additionalFiles.forEach((fileComponent: any, index: number) => {\n   *     // fileComponent.file is populated via deep population\n   *     const file = fileComponent.file;\n   *\n   *     console.log(`\\nFile ${index + 1}:`);\n   *     console.log(`  Name: ${file?.name || 'unnamed'}`);\n   *     console.log(`  URL: ${file?.url}`);\n   *     console.log(`  MIME: ${file?.mime}`);\n   *     console.log(`  Size: ${(file?.size / 1024).toFixed(2)} KB`);\n   *\n   *     if (fileComponent.description) {\n   *       console.log(`  Description: ${fileComponent.description}`);\n   *     }\n   *\n   *     // Download or reference the file\n   *     // const fileUrl = `${STRAPI_URL}${file?.url}`;\n   *   });\n   * }\n   *\n   * @example\n   * // Access mcpConfig component with nested relations\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * if (skill.mcpConfig && skill.mcpConfig.length > 0) {\n   *   console.log(`\\n${skill.displayName} MCP Configuration:`);\n   *\n   *   skill.mcpConfig.forEach((config: any, index: number) => {\n   *     const server = config.mcpServer;\n   *     console.log(`\\nMCP Server ${index + 1}:`);\n   *     console.log(`  Name: ${server?.name}`);\n   *     console.log(`  Transport: ${server?.transport}`);\n   *     console.log(`  Command: ${server?.command}`);\n   *\n   *     if (config.selectedTools && config.selectedTools.length > 0) {\n   *       console.log('  Selected Tools:');\n   *       config.selectedTools.forEach((toolSelection: any) => {\n   *         const tool = toolSelection.mcpTool;\n   *         console.log(`    - ${tool?.name}`);\n   *         console.log(`      ${tool?.description || 'No description'}`);\n   *       });\n   *     }\n   *   });\n   * }\n   *\n   * @example\n   * // Access agent selection and training agent\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * // Check which agents use this skill\n   * if (skill.agentSelection && skill.agentSelection.length > 0) {\n   *   console.log(`\\n${skill.displayName} is used by:`);\n   *   skill.agentSelection.forEach((selection: any) => {\n   *     const agent = selection.agent;\n   *     console.log(`  - ${agent?.name} (${agent?.enabled ? 'enabled' : 'disabled'})`);\n   *   });\n   * }\n   *\n   * // Check training agent\n   * if (skill.trainingAgent) {\n   *   console.log(`\\nTrained by: ${skill.trainingAgent}`);\n   * }\n   *\n   * @example\n   * // Access inputFields for dynamic skill execution\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * if (skill.inputFields && skill.inputFields.length > 0) {\n   *   console.log(`\\n${skill.displayName} Input Fields:`);\n   *\n   *   skill.inputFields.forEach((field: any) => {\n   *     console.log(`\\nField: ${field.name}`);\n   *     console.log(`  Label: ${field.label}`);\n   *     console.log(`  Type: ${field.type}`);\n   *     console.log(`  Required: ${field.required ? 'Yes' : 'No'}`);\n   *     if (field.defaultValue) {\n   *       console.log(`  Default: ${field.defaultValue}`);\n   *     }\n   *     if (field.placeholder) {\n   *       console.log(`  Placeholder: ${field.placeholder}`);\n   *     }\n   *   });\n   * }\n   *\n   * @example\n   * // Error handling for non-existent skill\n   * try {\n   *   const skill = await strapiClient.getSkill('non-existent-id');\n   * } catch (error) {\n   *   console.error('Skill not found:', error.message);\n   *   // Error: Skill with ID non-existent-id not found\n   * }\n   *\n   * @example\n   * // Complete skill inspection workflow\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * console.log(`\\n=== ${skill.displayName} ===`);\n   * console.log(`Category: ${skill.category}`);\n   * console.log(`Version: ${skill.version}`);\n   * console.log(`Experience: ${skill.experienceScore}`);\n   * console.log(`Public: ${skill.isPublic ? 'Yes' : 'No'}`);\n   * console.log(`\\nDescription:\\n${skill.description}`);\n   * console.log(`\\nSkill Content:\\n${skill.skillmd.substring(0, 200)}...`);\n   *\n   * // Check configuration\n   * if (skill.modelConfig) {\n   *   console.log(`\\nModel Config: ${skill.modelConfig.model} @ ${skill.modelConfig.temperature}`);\n   * }\n   *\n   * // Check analytics\n   * if (skill.analytics) {\n   *   console.log(`\\nUsage: ${skill.analytics.usageCount || 0} times`);\n   *   console.log(`Success Rate: ${skill.analytics.successRate || 0}%`);\n   * }\n   *\n   * @see {@link getAllSkills} for querying multiple skills with filters\n   * @see {@link updateSkill} for modifying skill data\n   */\n  async getSkill(id: string): Promise<Skill> {\n    const cacheKey = `skill:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/skills/${id}`,\n      {\n        params: {\n          // Populate component fields and nested relations\n          populate: {\n            trainingHistory: true,\n            additionalFiles: {\n              populate: { file: true }  // Populate file relation inside component\n            },\n            agentSelection: {\n              populate: { agent: true },\n            },\n            toolConfig: true,\n            modelConfig: true,\n            analytics: true,\n            mcpConfig: {\n              populate: {\n                mcpServer: true,\n                selectedTools: {\n                  populate: { mcpTool: true },\n                },\n              },\n            },\n            tasks: {\n              populate: { task: true },\n            },\n            inputFields: true,\n            trainingAgent: true,\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Skill with ID ${id} not found`);\n    }\n\n    const skill = this.transformSkill(data.data);\n    this.cache.set(cacheKey, skill);\n\n    return skill;\n  }\n\n  /**\n   * Get multiple skills by their IDs with all components populated\n   *\n   * @description\n   * Retrieves multiple skills by an array of document IDs. This is a convenience method\n   * that uses `getAllSkills` with a filter for the specified IDs. All component fields\n   * (trainingHistory, additionalFiles, mcpConfig, etc.) are automatically populated.\n   *\n   * **Use Cases:**\n   * - Bulk fetch skills for an agent's skillSelection\n   * - Load skills from a saved configuration or preset\n   * - Retrieve related skills for comparison or grouping\n   * - Hydrate skill references from other entities\n   *\n   * @param {string[]} ids - Array of skill document IDs (UUID format)\n   *\n   * @returns {Promise<Skill[]>} Array of Skill objects with all components populated\n   * Returns empty array if no IDs provided or no skills found\n   *\n   * @example\n   * // Basic usage - fetch multiple skills by IDs\n   * const skillIds = ['skill-id-1', 'skill-id-2', 'skill-id-3'];\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * console.log(`Fetched ${skills.length} skills`);\n   * skills.forEach(skill => {\n   *   console.log(`- ${skill.displayName} (${skill.category})`);\n   * });\n   *\n   * @example\n   * // Load skills from agent's skillSelection\n   * const agent = await strapiClient.getAgent('agent-id');\n   *\n   * // Extract skill IDs from skillSelection components\n   * const skillIds = agent.skillSelection?.map((selection: any) => selection.skill?.id || selection.skill).filter(Boolean) || [];\n   *\n   * // Fetch all skills at once\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * console.log(`Agent \"${agent.name}\" has ${skills.length} skills:`);\n   * skills.forEach(skill => {\n   *   console.log(`  - ${skill.displayName}: ${skill.description}`);\n   * });\n   *\n   * @example\n   * // Handle empty array gracefully\n   * const skills = await strapiClient.getSkillsByIds([]);\n   * console.log(skills); // []\n   *\n   * @example\n   * // Fetch skills and group by category\n   * const skillIds = ['id1', 'id2', 'id3', 'id4'];\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * const byCategory = skills.reduce((acc: any, skill) => {\n   *   const category = skill.category || 'uncategorized';\n   *   if (!acc[category]) acc[category] = [];\n   *   acc[category].push(skill);\n   *   return acc;\n   * }, {});\n   *\n   * Object.entries(byCategory).forEach(([category, categorySkills]: [string, any]) => {\n   *   console.log(`\\n${category}:`);\n   *   categorySkills.forEach((skill: any) => {\n   *     console.log(`  - ${skill.displayName}`);\n   *   });\n   * });\n   *\n   * @example\n   * // Check which skills have additional files\n   * const skillIds = ['id1', 'id2', 'id3'];\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * const skillsWithFiles = skills.filter(skill =>\n   *   skill.additionalFiles && skill.additionalFiles.length > 0\n   * );\n   *\n   * console.log(`${skillsWithFiles.length} skills have additional files:`);\n   * skillsWithFiles.forEach(skill => {\n   *   console.log(`  - ${skill.displayName}: ${skill.additionalFiles.length} files`);\n   * });\n   *\n   * @example\n   * // Calculate total experience across skills\n   * const skillIds = ['id1', 'id2', 'id3'];\n   * const skills = await strapiClient.getSkillsByIds(skillIds);\n   *\n   * const totalExperience = skills.reduce((sum, skill) => sum + (skill.experienceScore || 0), 0);\n   * const avgExperience = skills.length > 0 ? totalExperience / skills.length : 0;\n   *\n   * console.log(`Total Experience: ${totalExperience}`);\n   * console.log(`Average Experience: ${avgExperience.toFixed(1)}`);\n   *\n   * @see {@link getAllSkills} for advanced filtering options\n   * @see {@link getSkill} for retrieving a single skill\n   */\n  async getSkillsByIds(ids: string[]): Promise<Skill[]> {\n    if (ids.length === 0) return [];\n\n    const filters = {\n      documentId: { $in: ids },\n    };\n\n    return this.getAllSkills({ filters });\n  }\n\n  /**\n   * Create a new skill with component-based configuration\n   *\n   * @description\n   * Creates a new skill in Strapi with support for component-based architecture including\n   * trainingHistory, additionalFiles, and mcpConfig. All component fields are supported\n   * in Strapi v5 format.\n   *\n   * **Component Fields:**\n   * - `trainingHistory`: Initialize training records (array of { date, description, scoreChange, notes })\n   * - `additionalFiles`: Attach files (array of { file: uploadedFileId, description })\n   * - `mcpConfig`: Configure MCP servers (array of { mcpServer: id, selectedTools: [...] })\n   * - `agentSelection`: Assign agents (array of { agent: id })\n   * - `toolConfig`: Configure enabled tools (file_search, text_editor, etc.)\n   * - `modelConfig`: Configure model settings (model, temperature, timeout)\n   * - `analytics`: Initialize analytics tracking\n   * - `inputFields`: Define dynamic input fields (array of { name, label, type, required, defaultValue })\n   * - `tasks`: Assign tasks (array of { task: id })\n   * - `trainingAgent`: Reference to training agent (agent ID)\n   *\n   * **Cache Invalidation:**\n   * Creating a skill invalidates all cached skill queries to ensure fresh data.\n   *\n   * @param {CreateSkillDTO} skillData - Skill data transfer object\n   * @param {string} skillData.name - Skill identifier (slug-friendly, required)\n   * @param {string} skillData.displayName - Human-readable name (required)\n   * @param {string} skillData.description - Skill description (required)\n   * @param {string} skillData.skillmd - Skill content in markdown format (required)\n   * @param {number} [skillData.experienceScore=0] - Initial experience score\n   * @param {string} [skillData.category='custom'] - Skill category\n   * @param {boolean} [skillData.isPublic=true] - Whether the skill is publicly visible\n   * @param {string} [skillData.version='1.0.0'] - Skill version\n   * @param {string} [skillData.license] - License identifier\n   * @param {Array} [skillData.trainingHistory] - Training history records\n   * @param {Array} [skillData.additionalFiles] - File attachment components\n   * @param {Array} [skillData.mcpConfig] - MCP server configuration components\n   * @param {Array} [skillData.agentSelection] - Agent assignment components\n   * @param {Object} [skillData.toolConfig] - Tool configuration\n   * @param {Object} [skillData.modelConfig] - Model configuration\n   * @param {Object} [skillData.analytics] - Analytics data\n   * @param {Array} [skillData.inputFields] - Input field definitions\n   * @param {Array} [skillData.tasks] - Task assignments\n   * @param {string} [skillData.trainingAgent] - Training agent ID\n   *\n   * @returns {Promise<Skill>} Created skill with generated ID and auto-populated defaults\n   *\n   * @throws {Error} If skill creation fails (validation errors, network errors)\n   *\n   * @example\n   * // Basic skill creation with minimal fields\n   * const skill = await strapiClient.createSkill({\n   *   name: 'typescript-expert',\n   *   displayName: 'TypeScript Expert',\n   *   description: 'Expert knowledge in TypeScript programming',\n   *   skillmd: '# TypeScript Expert\\n\\nProvides expert TypeScript development assistance.',\n   *   category: 'coding',\n   *   experienceScore: 0\n   * });\n   *\n   * console.log(skill.id);   // Auto-generated UUID\n   * console.log(skill.version); // Default: '1.0.0'\n   * console.log(skill.isPublic); // Default: true\n   *\n   * @example\n   * // Create skill with trainingHistory component\n   * const skill = await strapiClient.createSkill({\n   *   name: 'debugging-expert',\n   *   displayName: 'Debugging Expert',\n   *   description: 'Expert in debugging complex issues',\n   *   skillmd: '# Debugging Expert\\n\\nHelps identify and fix bugs.',\n   *   category: 'debugging',\n   *   experienceScore: 25,\n   *   trainingHistory: [\n   *     {\n   *       date: new Date().toISOString(),\n   *       description: 'Initial training on React debugging',\n   *       scoreChange: 10,\n   *       agentName: 'Training Agent',\n   *       notes: 'Learned component lifecycle debugging'\n   *     },\n   *     {\n   *       date: new Date().toISOString(),\n   *       description: 'Advanced async debugging training',\n   *       scoreChange: 15,\n   *       agentName: 'Advanced Trainer',\n   *       notes: 'Mastered Promise rejection handling'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill created with ${skill.trainingHistory.length} training records`);\n   *\n   * @example\n   * // Create skill with additionalFiles component\n   * // First, upload files to Strapi Media Library\n   * import fs from 'fs';\n   *\n   * const guideFile = fs.readFileSync('./typescript-guide.pdf');\n   * const examplesFile = fs.readFileSync('./examples.zip');\n   *\n   * const uploadedGuide = await strapiClient.uploadFile(guideFile, 'typescript-guide.pdf');\n   * const uploadedExamples = await strapiClient.uploadFile(examplesFile, 'examples.zip');\n   *\n   * // Create skill with file attachments\n   * const skill = await strapiClient.createSkill({\n   *   name: 'typescript-advanced',\n   *   displayName: 'Advanced TypeScript',\n   *   description: 'Advanced TypeScript patterns',\n   *   skillmd: '# Advanced TypeScript\\n\\nRefer to attached guide and examples.',\n   *   category: 'coding',\n   *   additionalFiles: [\n   *     {\n   *       file: uploadedGuide.documentId,\n   *       description: 'Comprehensive TypeScript guide'\n   *     },\n   *     {\n   *       file: uploadedExamples.documentId,\n   *       description: 'Code examples and templates'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill created with ${skill.additionalFiles.length} attached files`);\n   *\n   * @example\n   * // Create skill with mcpConfig component\n   * // First, get MCP servers and tools from Strapi\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const filesystemServer = mcpServers.find(s => s.name === 'filesystem');\n   * const filesystemTools = await strapiClient.getMCPToolsByServerId(filesystemServer.id);\n   *\n   * const skill = await strapiClient.createSkill({\n   *   name: 'file-operations',\n   *   displayName: 'File Operations',\n   *   description: 'Expert in file system operations',\n   *   skillmd: '# File Operations\\n\\nUses filesystem MCP tools.',\n   *   category: 'system',\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: filesystemServer.id,\n   *       selectedTools: filesystemTools.slice(0, 5).map(tool => ({\n   *         mcpTool: tool.id\n   *       }))\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill created with ${skill.mcpConfig.length} MCP server config`);\n   *\n   * @example\n   * // Create skill with inputFields component for dynamic execution\n   * const skill = await strapiClient.createSkill({\n   *   name: 'code-generator',\n   *   displayName: 'Code Generator',\n   *   description: 'Generates code based on user input',\n   *   skillmd: '# Code Generator\\n\\nGenerates code from templates.',\n   *   category: 'coding',\n   *   inputFields: [\n   *     {\n   *       name: 'language',\n   *       label: 'Programming Language',\n   *       type: 'select',\n   *       required: true,\n   *       options: ['TypeScript', 'JavaScript', 'Python', 'Go'],\n   *       defaultValue: 'TypeScript'\n   *     },\n   *     {\n   *       name: 'framework',\n   *       label: 'Framework',\n   *       type: 'text',\n   *       required: false,\n   *       placeholder: 'e.g., React, Express, FastAPI'\n   *     },\n   *     {\n   *       name: 'features',\n   *       label: 'Features to Include',\n   *       type: 'textarea',\n   *       required: true,\n   *       placeholder: 'Describe the features you want...'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill created with ${skill.inputFields.length} input fields`);\n   *\n   * @example\n   * // Create skill with custom model and tool configuration\n   * const skill = await strapiClient.createSkill({\n   *   name: 'data-analyst',\n   *   displayName: 'Data Analyst',\n   *   description: 'Analyzes data and generates insights',\n   *   skillmd: '# Data Analyst\\n\\nPerforms data analysis tasks.',\n   *   category: 'analytics',\n   *   modelConfig: {\n   *     model: 'opus',\n   *     temperature: 0.3,\n   *     max_tokens: 8192,\n   *     timeout: 600000\n   *   },\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: false,\n   *     bash_20241022: true,\n   *     computer_20241022: false\n   *   },\n   *   analytics: {\n   *     usageCount: 0,\n   *     successRate: 100,\n   *     avgExecutionTime: 0\n   *   }\n   * });\n   *\n   * @example\n   * // Error handling for validation failures\n   * try {\n   *   const skill = await strapiClient.createSkill({\n   *     name: '', // Invalid: empty name\n   *     displayName: 'Test',\n   *     description: 'Test skill',\n   *     skillmd: '# Test'\n   *   });\n   * } catch (error) {\n   *   console.error('Validation failed:', error.message);\n   * }\n   *\n   * @see {@link updateSkill} for updating existing skills\n   * @see {@link getSkill} for retrieving created skill with full details\n   * @see {@link uploadFile} for uploading files before attaching to skills\n   */\n  async createSkill(skillData: CreateSkillDTO): Promise<Skill> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/skills',\n      {\n        data: this.prepareSkillData(skillData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create skill');\n    }\n\n    this.invalidateCache('skills');\n    return this.transformSkill(data.data);\n  }\n\n  /**\n   * Update an existing skill with partial data\n   *\n   * @description\n   * Updates an existing skill in Strapi using partial update semantics. Only the fields\n   * provided in the update DTO will be modified; omitted fields remain unchanged. This\n   * method supports updating all component fields including trainingHistory, additionalFiles,\n   * and mcpConfig in Strapi v5 format.\n   *\n   * **Partial Updates:**\n   * You can update individual fields without affecting other fields:\n   * - Update only `displayName` without changing `skillmd`\n   * - Update only `experienceScore` without changing `trainingHistory`\n   * - Update only specific components without affecting others\n   *\n   * **Component Field Updates:**\n   * - `trainingHistory`: Replace training records (array replacement, not merge)\n   * - `additionalFiles`: Replace file attachments (array replacement)\n   * - `mcpConfig`: Replace MCP server configurations (array replacement)\n   * - `agentSelection`: Replace agent assignments (array replacement)\n   * - `toolConfig`: Update tool enablement settings\n   * - `modelConfig`: Update model configuration\n   * - `analytics`: Update analytics data\n   * - `inputFields`: Replace input field definitions (array replacement)\n   * - `tasks`: Replace task assignments (array replacement)\n   * - `trainingAgent`: Update training agent reference\n   *\n   * **Important: Array Field Behavior**\n   * Arrays are replaced, not merged. To add items, fetch current data first:\n   * ```javascript\n   * const skill = await strapiClient.getSkill('skill-id');\n   * await strapiClient.updateSkill('skill-id', {\n   *   trainingHistory: [...skill.trainingHistory, newRecord]\n   * });\n   * ```\n   *\n   * **Cache Invalidation:**\n   * Updating a skill invalidates both the specific skill cache and all skill list caches.\n   *\n   * @param {string} id - Skill document ID to update\n   * @param {UpdateSkillDTO} skillData - Partial skill data to update\n   * @param {string} [skillData.name] - Update skill identifier\n   * @param {string} [skillData.displayName] - Update display name\n   * @param {string} [skillData.description] - Update description\n   * @param {string} [skillData.skillmd] - Update skill content\n   * @param {number} [skillData.experienceScore] - Update experience score\n   * @param {string} [skillData.category] - Update category\n   * @param {boolean} [skillData.isPublic] - Update visibility\n   * @param {string} [skillData.version] - Update version\n   * @param {string} [skillData.license] - Update license\n   * @param {Array} [skillData.trainingHistory] - Replace training history\n   * @param {Array} [skillData.additionalFiles] - Replace file attachments\n   * @param {Array} [skillData.mcpConfig] - Replace MCP config\n   * @param {Array} [skillData.agentSelection] - Replace agent assignments\n   * @param {Object} [skillData.toolConfig] - Update tool config\n   * @param {Object} [skillData.modelConfig] - Update model config\n   * @param {Object} [skillData.analytics] - Update analytics\n   * @param {Array} [skillData.inputFields] - Replace input fields\n   * @param {Array} [skillData.tasks] - Replace task assignments\n   * @param {string} [skillData.trainingAgent] - Update training agent\n   *\n   * @returns {Promise<Skill>} Updated skill with all components populated\n   *\n   * @throws {Error} If skill with specified ID is not found or update fails\n   *\n   * @example\n   * // Basic update - change display name and description\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   displayName: 'TypeScript Pro',\n   *   description: 'Professional TypeScript development expertise'\n   * });\n   *\n   * @example\n   * // Update experience score after training\n   * const skill = await strapiClient.updateSkill('skill-id', {\n   *   experienceScore: 75\n   * });\n   *\n   * @example\n   * // Add new training record (requires fetching current first)\n   * const currentSkill = await strapiClient.getSkill('skill-id');\n   *\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   experienceScore: currentSkill.experienceScore + 10,\n   *   trainingHistory: [\n   *     ...(currentSkill.trainingHistory || []),\n   *     {\n   *       date: new Date().toISOString(),\n   *       description: 'Completed advanced debugging training',\n   *       scoreChange: 10,\n   *       agentName: 'Training Bot',\n   *       notes: 'Improved error handling and async debugging'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill now has ${updatedSkill.trainingHistory.length} training records`);\n   * console.log(`New experience score: ${updatedSkill.experienceScore}`);\n   *\n   * @example\n   * // Add additional file to existing skill\n   * import fs from 'fs';\n   *\n   * // Upload new file first\n   * const cheatsheetFile = fs.readFileSync('./cheatsheet.pdf');\n   * const uploadedFile = await strapiClient.uploadFile(cheatsheetFile, 'cheatsheet.pdf');\n   *\n   * // Fetch current skill\n   * const currentSkill = await strapiClient.getSkill('skill-id');\n   *\n   * // Add new file to existing files\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   additionalFiles: [\n   *     ...(currentSkill.additionalFiles || []),\n   *     {\n   *       file: uploadedFile.documentId,\n   *       description: 'Quick reference cheatsheet'\n   *     }\n   *   ]\n   * });\n   *\n   * console.log(`Skill now has ${updatedSkill.additionalFiles.length} files`);\n   *\n   * @example\n   * // Update MCP configuration\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const githubServer = mcpServers.find(s => s.name === 'github');\n   * const githubTools = await strapiClient.getMCPToolsByServerId(githubServer.id);\n   *\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: githubServer.id,\n   *       selectedTools: githubTools.slice(0, 3).map(tool => ({\n   *         mcpTool: tool.id\n   *       }))\n   *     }\n   *   ]\n   * });\n   *\n   * @example\n   * // Update model and tool configuration\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   modelConfig: {\n   *     model: 'sonnet',\n   *     temperature: 0.8,\n   *     max_tokens: 4096,\n   *     timeout: 300000\n   *   },\n   *   toolConfig: {\n   *     file_search: true,\n   *     text_editor: true,\n   *     bash_20241022: false,\n   *     computer_20241022: false\n   *   }\n   * });\n   *\n   * @example\n   * // Update skill visibility and version\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   isPublic: true,\n   *   version: '2.0.0'\n   * });\n   *\n   * @example\n   * // Update skill content (skillmd)\n   * const newContent = `\n   * # Advanced TypeScript\n   *\n   * ## Updated Content\n   * This skill now includes advanced patterns for:\n   * - Type guards and discriminated unions\n   * - Generic constraints and inference\n   * - Conditional types and mapped types\n   *\n   * ## Examples\n   * ...\n   * `;\n   *\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   skillmd: newContent,\n   *   version: '2.1.0'\n   * });\n   *\n   * @example\n   * // Update analytics after skill execution\n   * const currentSkill = await strapiClient.getSkill('skill-id');\n   *\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   analytics: {\n   *     usageCount: (currentSkill.analytics?.usageCount || 0) + 1,\n   *     successRate: 95,\n   *     avgExecutionTime: 2500,\n   *     lastUsed: new Date().toISOString()\n   *   }\n   * });\n   *\n   * @example\n   * // Bulk update - change multiple fields at once\n   * const updatedSkill = await strapiClient.updateSkill('skill-id', {\n   *   displayName: 'Expert TypeScript Developer',\n   *   description: 'Master-level TypeScript expertise',\n   *   category: 'coding',\n   *   experienceScore: 100,\n   *   version: '3.0.0',\n   *   modelConfig: {\n   *     model: 'opus',\n   *     temperature: 0.5,\n   *     timeout: 600000\n   *   }\n   * });\n   *\n   * @example\n   * // Error handling for non-existent skill\n   * try {\n   *   const skill = await strapiClient.updateSkill('non-existent-id', {\n   *     displayName: 'New Name'\n   *   });\n   * } catch (error) {\n   *   console.error('Update failed:', error.message);\n   *   // Error: Failed to update skill with ID non-existent-id\n   * }\n   *\n   * @see {@link createSkill} for creating new skills\n   * @see {@link getSkill} for retrieving current skill state before update\n   */\n  async updateSkill(id: string, skillData: UpdateSkillDTO): Promise<Skill> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/skills/${id}`,\n      {\n        data: this.prepareSkillData(skillData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update skill with ID ${id}`);\n    }\n\n    this.invalidateCache('skills');\n    this.cache.delete(`skill:${id}`);\n\n    return this.transformSkill(data.data);\n  }\n\n  /**\n   * Delete a skill permanently from Strapi\n   *\n   * @description\n   * Permanently deletes a skill from the Strapi database. This operation cannot be undone.\n   * All associated component data (trainingHistory, additionalFiles references, mcpConfig,\n   * agentSelection, etc.) is also deleted as they are part of the skill entity.\n   *\n   * **Important Considerations:**\n   * - This is a permanent deletion - there is no soft delete or trash bin\n   * - All component data is deleted with the skill\n   * - File attachments in additionalFiles are NOT deleted from Media Library (only references)\n   * - Related entities (Agents, MCP Servers, Tasks) are NOT deleted (only the associations)\n   * - Agents using this skill will have broken references in their skillSelection\n   * - Cache is automatically invalidated after deletion\n   *\n   * **Best Practices:**\n   * - Consider setting `isPublic: false` instead of deleting to preserve history\n   * - Verify the skill ID before deletion to prevent accidental deletions\n   * - Check which agents use the skill before deletion (via agentSelection)\n   * - Export skill data before deletion if you may need it later\n   * - Clean up file attachments separately if no longer needed\n   *\n   * @param {string} id - Skill document ID to delete\n   *\n   * @returns {Promise<void>} Resolves when deletion is complete\n   *\n   * @throws {Error} If skill with specified ID is not found or deletion fails\n   *\n   * @example\n   * // Basic deletion\n   * await strapiClient.deleteSkill('skill-id-to-delete');\n   * console.log('Skill deleted successfully');\n   *\n   * @example\n   * // Safe deletion with confirmation and dependency check\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * console.log(`About to delete skill: ${skill.displayName}`);\n   * console.log(`Category: ${skill.category}`);\n   * console.log(`Experience: ${skill.experienceScore}`);\n   *\n   * // Check which agents use this skill\n   * if (skill.agentSelection && skill.agentSelection.length > 0) {\n   *   console.warn(`Warning: This skill is used by ${skill.agentSelection.length} agents:`);\n   *   skill.agentSelection.forEach((selection: any) => {\n   *     console.log(`  - ${selection.agent?.name || 'Unknown agent'}`);\n   *   });\n   * }\n   *\n   * // In a real application, prompt user for confirmation here\n   * const confirmed = true; // User confirmation\n   *\n   * if (confirmed) {\n   *   await strapiClient.deleteSkill(skill.id);\n   *   console.log('Skill deleted');\n   * }\n   *\n   * @example\n   * // Alternative: Hide instead of delete (preserves history)\n   * // This is often preferred over permanent deletion\n   * const skill = await strapiClient.updateSkill('skill-id', {\n   *   isPublic: false\n   * });\n   * console.log('Skill hidden (not deleted)');\n   *\n   * @example\n   * // Export skill data before deletion\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * // Save configuration to file or backup system\n   * const backup = {\n   *   name: skill.name,\n   *   displayName: skill.displayName,\n   *   description: skill.description,\n   *   skillmd: skill.skillmd,\n   *   category: skill.category,\n   *   experienceScore: skill.experienceScore,\n   *   version: skill.version,\n   *   trainingHistory: skill.trainingHistory,\n   *   additionalFiles: skill.additionalFiles,\n   *   mcpConfig: skill.mcpConfig,\n   *   modelConfig: skill.modelConfig,\n   *   toolConfig: skill.toolConfig,\n   *   inputFields: skill.inputFields,\n   *   exportedAt: new Date().toISOString()\n   * };\n   *\n   * // fs.writeFileSync(`./backups/skill-${skill.id}.json`, JSON.stringify(backup, null, 2));\n   *\n   * // Now safe to delete\n   * await strapiClient.deleteSkill(skill.id);\n   *\n   * @example\n   * // Clean up attached files before deleting skill\n   * const skill = await strapiClient.getSkill('skill-id');\n   *\n   * // Delete file attachments from Media Library\n   * if (skill.additionalFiles && skill.additionalFiles.length > 0) {\n   *   for (const fileComponent of skill.additionalFiles) {\n   *     const file = fileComponent.file;\n   *     if (file?.documentId) {\n   *       await strapiClient.deleteFile(file.documentId);\n   *       console.log(`Deleted file: ${file.name}`);\n   *     }\n   *   }\n   * }\n   *\n   * // Now delete the skill\n   * await strapiClient.deleteSkill(skill.id);\n   * console.log('Skill and all attached files deleted');\n   *\n   * @example\n   * // Error handling for non-existent skill\n   * try {\n   *   await strapiClient.deleteSkill('non-existent-id');\n   * } catch (error) {\n   *   console.error('Deletion failed:', error.message);\n   *   // Handle error (skill not found, network error, etc.)\n   * }\n   *\n   * @example\n   * // Batch deletion with dependency checks (use with caution!)\n   * const skillsToDelete = await strapiClient.getAllSkills({\n   *   filters: {\n   *     $and: [\n   *       { isPublic: false },\n   *       { experienceScore: { $lt: 10 } },\n   *       { updatedAt: { $lt: '2024-01-01' } }\n   *     ]\n   *   }\n   * });\n   *\n   * console.log(`Found ${skillsToDelete.length} skills to delete`);\n   *\n   * for (const skill of skillsToDelete) {\n   *   // Check if skill is used by any agents\n   *   const isUsed = skill.agentSelection && skill.agentSelection.length > 0;\n   *\n   *   if (!isUsed) {\n   *     console.log(`Deleting ${skill.displayName}...`);\n   *     await strapiClient.deleteSkill(skill.id);\n   *   } else {\n   *     console.log(`Skipping ${skill.displayName} (in use by agents)`);\n   *   }\n   * }\n   *\n   * console.log('Batch deletion complete');\n   *\n   * @see {@link updateSkill} for hiding skills without deletion\n   * @see {@link getSkill} for retrieving skill details before deletion\n   * @see {@link deleteFile} for cleaning up attached files\n   */\n  async deleteSkill(id: string): Promise<void> {\n    await this.client.delete(`/skills/${id}`);\n    this.invalidateCache('skills');\n    this.cache.delete(`skill:${id}`);\n  }\n\n  // ============= MCP SERVERS =============\n\n  /**\n   * Get all MCP servers with optional filtering\n   *\n   * @description\n   * Retrieves all MCP (Model Context Protocol) servers from Strapi database with\n   * optional filtering and population of related tools. Supports Strapi v5 filter\n   * operators for advanced querying.\n   *\n   * **Filter Operators:**\n   * - `$eq`: Equal to\n   * - `$ne`: Not equal to\n   * - `$in`: In array\n   * - `$notIn`: Not in array\n   * - `$containsi`: Case-insensitive contains\n   * - `$and`, `$or`: Logical operators\n   *\n   * **Population:**\n   * Set `populate: true` to include related `mcpTools` in the response.\n   *\n   * **Cache Behavior:**\n   * Results are cached using options as cache key. Cache is invalidated on any\n   * MCP server create/update/delete operation.\n   *\n   * @param {Object} [options] - Query options\n   * @param {Object} [options.filters] - Strapi v5 filters object\n   * @param {boolean} [options.populate] - If true, populates mcpTools relation\n   * @returns {Promise<MCPServer[]>} Array of MCP servers\n   *\n   * @example\n   * // Get all MCP servers\n   * const allServers = await strapiClient.getAllMCPServers();\n   * console.log(allServers.length); // e.g., 5\n   *\n   * @example\n   * // Get only enabled MCP servers\n   * const enabledServers = await strapiClient.getAllMCPServers({\n   *   filters: { enabled: { $eq: true } }\n   * });\n   *\n   * @example\n   * // Get MCP servers with specific transport type\n   * const stdioServers = await strapiClient.getAllMCPServers({\n   *   filters: { transportType: { $eq: 'stdio' } }\n   * });\n   *\n   * @example\n   * // Get MCP servers with tools populated\n   * const serversWithTools = await strapiClient.getAllMCPServers({\n   *   populate: true\n   * });\n   * serversWithTools.forEach(server => {\n   *   console.log(`${server.name}: ${server.mcpTools?.length || 0} tools`);\n   * });\n   *\n   * @example\n   * // Filter by server name (case-insensitive)\n   * const filesystemServers = await strapiClient.getAllMCPServers({\n   *   filters: { name: { $containsi: 'filesystem' } }\n   * });\n   *\n   * @example\n   * // Get multiple servers by transport type\n   * const sdkOrStdioServers = await strapiClient.getAllMCPServers({\n   *   filters: {\n   *     transportType: { $in: ['stdio', 'sdk'] }\n   *   },\n   *   populate: true\n   * });\n   *\n   * @see {@link getMCPServer} for retrieving a single MCP server by ID\n   * @see {@link createMCPServer} for creating new MCP servers\n   */\n  async getAllMCPServers(options?: {\n    filters?: Record<string, any>;\n    populate?: boolean;\n  }): Promise<MCPServer[]> {\n    const cacheKey = `mcp-servers:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams({\n      ...options,\n      populate: options?.populate ? ['mcpTools'] : undefined\n    });\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/mcp-servers',\n      { params }\n    );\n\n    const mcpServers = data.data.map((item: StrapiAttributes<any>) => this.transformMCPServer(item));\n    this.cache.set(cacheKey, mcpServers);\n\n    return mcpServers;\n  }\n\n  /**\n   * Get a single MCP server by ID\n   *\n   * @description\n   * Retrieves a single MCP server by its document ID with all relations populated.\n   * Automatically populates the `mcpTools` relation to include all tools associated\n   * with this server.\n   *\n   * **Cache Behavior:**\n   * Individual servers are cached by ID. Cache is invalidated when the server is\n   * updated or deleted.\n   *\n   * **Error Handling:**\n   * Throws an error if the server with the specified ID is not found.\n   *\n   * @param {string} id - MCP server document ID\n   * @returns {Promise<MCPServer>} MCP server with populated tools\n   * @throws {Error} If MCP server with ID not found\n   *\n   * @example\n   * // Get MCP server by ID\n   * const server = await strapiClient.getMCPServer('abc123xyz');\n   * console.log(server.name);          // e.g., 'filesystem'\n   * console.log(server.transportType); // e.g., 'stdio'\n   * console.log(server.mcpTools?.length); // e.g., 15\n   *\n   * @example\n   * // Inspect server configuration\n   * const server = await strapiClient.getMCPServer('abc123xyz');\n   * if (server.transportType === 'stdio') {\n   *   console.log('Command:', server.command);\n   *   console.log('Args:', server.args);\n   *   console.log('Env:', server.env);\n   * }\n   *\n   * @example\n   * // Access populated tools\n   * const server = await strapiClient.getMCPServer('abc123xyz');\n   * const enabledTools = server.mcpTools?.filter(tool => tool.enabled) || [];\n   * console.log(`${enabledTools.length} enabled tools`);\n   *\n   * @example\n   * // Error handling for not found\n   * try {\n   *   const server = await strapiClient.getMCPServer('invalid-id');\n   * } catch (error) {\n   *   console.error('Server not found:', error.message);\n   *   // Error: MCP Server with ID invalid-id not found\n   * }\n   *\n   * @see {@link getAllMCPServers} for retrieving multiple MCP servers\n   * @see {@link updateMCPServer} for updating server configuration\n   */\n  async getMCPServer(id: string): Promise<MCPServer> {\n    const cacheKey = `mcp-server:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/mcp-servers/${id}`,\n      {\n        params: { populate: '*' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`MCP Server with ID ${id} not found`);\n    }\n\n    const mcpServer = this.transformMCPServer(data.data);\n    this.cache.set(cacheKey, mcpServer);\n\n    return mcpServer;\n  }\n\n  /**\n   * Get multiple MCP servers by their IDs\n   */\n  async getMCPServersByIds(ids: string[]): Promise<MCPServer[]> {\n    if (ids.length === 0) return [];\n\n    const filters = {\n      documentId: { $in: ids },\n    };\n\n    return this.getAllMCPServers({ filters });\n  }\n\n  /**\n   * Create a new MCP server\n   *\n   * @description\n   * Creates a new MCP (Model Context Protocol) server in Strapi database. Supports both\n   * stdio (external process) and SDK (in-process) transport types. After creation, the\n   * server can be configured with tools via `bulkSyncMCPTools`.\n   *\n   * **Transport Types:**\n   * - `stdio`: External process communication via stdin/stdout (requires command, args, env)\n   * - `sdk`: In-process SDK server (requires no additional config)\n   *\n   * **Cache Invalidation:**\n   * Creating a server invalidates all MCP server list caches.\n   *\n   * @param {CreateMCPServerDTO} mcpData - MCP server data to create\n   * @param {string} mcpData.name - Server name (e.g., 'filesystem', 'github')\n   * @param {string} [mcpData.description] - Optional server description\n   * @param {'stdio' | 'sdk'} mcpData.transportType - Transport type\n   * @param {string} [mcpData.command] - Command to execute (stdio only)\n   * @param {string[]} [mcpData.args] - Command arguments (stdio only)\n   * @param {Record<string, string>} [mcpData.env] - Environment variables (stdio only)\n   * @param {boolean} [mcpData.enabled] - Enable/disable server (default: true)\n   * @returns {Promise<MCPServer>} Created MCP server\n   * @throws {Error} If creation fails\n   *\n   * @example\n   * // Create stdio MCP server\n   * const server = await strapiClient.createMCPServer({\n   *   name: 'filesystem',\n   *   description: 'Local filesystem access',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/Users/me/projects'],\n   *   enabled: true\n   * });\n   * console.log(server.id); // Auto-generated UUID\n   *\n   * @example\n   * // Create stdio server with environment variables\n   * const githubServer = await strapiClient.createMCPServer({\n   *   name: 'github',\n   *   description: 'GitHub repository access',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-github'],\n   *   env: {\n   *     GITHUB_TOKEN: process.env.GITHUB_TOKEN || ''\n   *   },\n   *   enabled: true\n   * });\n   *\n   * @example\n   * // Create SDK MCP server (in-process)\n   * const sdkServer = await strapiClient.createMCPServer({\n   *   name: 'custom-sdk-server',\n   *   description: 'Custom in-process MCP server',\n   *   transportType: 'sdk',\n   *   enabled: true\n   * });\n   *\n   * @example\n   * // Create disabled server for later activation\n   * const server = await strapiClient.createMCPServer({\n   *   name: 'puppeteer',\n   *   description: 'Browser automation (disabled by default)',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-puppeteer'],\n   *   enabled: false // Disabled until needed\n   * });\n   *\n   * @example\n   * // Create server then sync tools\n   * const server = await strapiClient.createMCPServer({\n   *   name: 'filesystem',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()]\n   * });\n   *\n   * // Fetch and sync tools from the server\n   * const fetchedTools = [\n   *   { name: 'read_file', description: 'Read file contents' },\n   *   { name: 'write_file', description: 'Write file contents' }\n   * ];\n   * await strapiClient.bulkSyncMCPTools(server.id, fetchedTools);\n   *\n   * @see {@link updateMCPServer} for updating server configuration\n   * @see {@link bulkSyncMCPTools} for syncing server tools\n   * @see {@link deleteMCPServer} for deleting servers\n   */\n  async createMCPServer(mcpData: CreateMCPServerDTO): Promise<MCPServer> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/mcp-servers',\n      {\n        data: this.prepareMCPServerData(mcpData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create MCP server');\n    }\n\n    this.invalidateCache('mcp-servers');\n    return this.transformMCPServer(data.data);\n  }\n\n  /**\n   * Update an existing MCP server\n   *\n   * @description\n   * Updates an existing MCP server using partial update semantics. Only the fields\n   * provided in the update DTO will be modified; omitted fields remain unchanged.\n   *\n   * **Partial Updates:**\n   * You can update individual fields without affecting other fields:\n   * - Update only `enabled` without changing `command` or `args`\n   * - Update only `description` without changing configuration\n   * - Update environment variables without changing command\n   *\n   * **Cache Invalidation:**\n   * Updating invalidates both the specific server cache and all server list caches.\n   *\n   * @param {string} id - MCP server document ID\n   * @param {UpdateMCPServerDTO} mcpData - Partial server data to update\n   * @param {string} [mcpData.name] - Update server name\n   * @param {string} [mcpData.description] - Update description\n   * @param {boolean} [mcpData.enabled] - Update enabled status\n   * @param {string} [mcpData.command] - Update command (stdio only)\n   * @param {string[]} [mcpData.args] - Update arguments (stdio only)\n   * @param {Record<string, string>} [mcpData.env] - Update environment variables (stdio only)\n   * @returns {Promise<MCPServer>} Updated MCP server\n   * @throws {Error} If update fails or server not found\n   *\n   * @example\n   * // Enable/disable MCP server\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   enabled: false // Temporarily disable\n   * });\n   * console.log(server.enabled); // false\n   *\n   * @example\n   * // Update server description\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   description: 'Updated description with more details'\n   * });\n   *\n   * @example\n   * // Update command arguments\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/new/path']\n   * });\n   *\n   * @example\n   * // Update environment variables\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   env: {\n   *     GITHUB_TOKEN: process.env.NEW_GITHUB_TOKEN || '',\n   *     DEBUG: 'true'\n   *   }\n   * });\n   *\n   * @example\n   * // Update multiple fields\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   name: 'filesystem-v2',\n   *   description: 'Updated filesystem server',\n   *   enabled: true,\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()]\n   * });\n   *\n   * @example\n   * // Error handling\n   * try {\n   *   await strapiClient.updateMCPServer('invalid-id', { enabled: false });\n   * } catch (error) {\n   *   console.error('Update failed:', error.message);\n   * }\n   *\n   * @see {@link getMCPServer} for retrieving updated server\n   * @see {@link createMCPServer} for creating servers\n   */\n  async updateMCPServer(id: string, mcpData: UpdateMCPServerDTO): Promise<MCPServer> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/mcp-servers/${id}`,\n      {\n        data: this.prepareMCPServerData(mcpData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update MCP server with ID ${id}`);\n    }\n\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${id}`);\n\n    return this.transformMCPServer(data.data);\n  }\n\n  /**\n   * Delete an MCP server\n   *\n   * @description\n   * Permanently deletes an MCP server from Strapi database. This operation also\n   * cascades to delete all associated MCP tools. Use with caution as this operation\n   * cannot be undone.\n   *\n   * **Cascade Deletion:**\n   * Deleting a server automatically deletes all associated `mcpTools` records.\n   *\n   * **Cache Invalidation:**\n   * Deletion invalidates both the specific server cache and all server list caches.\n   *\n   * **Best Practices:**\n   * - Consider disabling (`enabled: false`) instead of deleting if you might need to restore\n   * - Check for agent/skill dependencies before deletion\n   * - Back up server configuration if needed\n   *\n   * @param {string} id - MCP server document ID to delete\n   * @returns {Promise<void>} Promise that resolves when deletion is complete\n   * @throws {Error} If deletion fails or server not found\n   *\n   * @example\n   * // Delete MCP server\n   * await strapiClient.deleteMCPServer('abc123');\n   * console.log('Server deleted');\n   *\n   * @example\n   * // Safe deletion with confirmation\n   * const serverId = 'abc123';\n   * const server = await strapiClient.getMCPServer(serverId);\n   * console.log(`About to delete: ${server.name}`);\n   * console.log(`This will delete ${server.mcpTools?.length || 0} tools`);\n   *\n   * // Confirm deletion\n   * await strapiClient.deleteMCPServer(serverId);\n   *\n   * @example\n   * // Check for agent dependencies before deletion\n   * const serverId = 'abc123';\n   * const agents = await strapiClient.getAllAgents({\n   *   populate: true,\n   *   filters: {\n   *     mcpConfig: {\n   *       mcpServer: { documentId: serverId }\n   *     }\n   *   }\n   * });\n   *\n   * if (agents.length > 0) {\n   *   console.warn(`Server is used by ${agents.length} agents. Cannot delete.`);\n   * } else {\n   *   await strapiClient.deleteMCPServer(serverId);\n   * }\n   *\n   * @example\n   * // Error handling\n   * try {\n   *   await strapiClient.deleteMCPServer('invalid-id');\n   * } catch (error) {\n   *   console.error('Deletion failed:', error.message);\n   * }\n   *\n   * @example\n   * // Alternative: Disable instead of delete\n   * // If you might want to restore the server later\n   * const server = await strapiClient.updateMCPServer('abc123', {\n   *   enabled: false\n   * });\n   * console.log('Server disabled (can be re-enabled later)');\n   *\n   * @see {@link updateMCPServer} for disabling servers (non-destructive alternative)\n   * @see {@link createMCPServer} for recreating deleted servers\n   */\n  async deleteMCPServer(id: string): Promise<void> {\n    await this.client.delete(`/mcp-servers/${id}`);\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${id}`);\n  }\n\n  /**\n   * Update MCP server tools (DEPRECATED - use bulkSyncMCPTools instead)\n   */\n  async updateMCPServerTools(id: string, tools: any[]): Promise<MCPServer> {\n    console.warn('updateMCPServerTools is deprecated, use bulkSyncMCPTools instead');\n    return this.bulkSyncMCPTools(id, tools);\n  }\n\n  // ============= MCP TOOLS =============\n\n  /**\n   * Get all tools for an MCP server\n   *\n   * @description\n   * Retrieves all MCP tools associated with a specific MCP server. Tools represent\n   * the capabilities exposed by an MCP server and can be individually enabled/disabled\n   * in agent configurations.\n   *\n   * **Use Cases:**\n   * - List all tools for a server\n   * - Filter enabled/disabled tools\n   * - Display tools in UI for agent configuration\n   * - Validate tool availability before assignment\n   *\n   * **Tool Properties:**\n   * - `name`: Tool identifier (e.g., 'read_file', 'write_file')\n   * - `description`: Human-readable description\n   * - `inputSchema`: JSON Schema for tool parameters\n   * - `enabled`: Tool availability status\n   *\n   * @param {string} serverId - MCP server document ID\n   * @returns {Promise<MCPTool[]>} Array of MCP tools for the server\n   *\n   * @example\n   * // Get all tools for a server\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * console.log(`Found ${tools.length} tools`);\n   * tools.forEach(tool => {\n   *   console.log(`- ${tool.name}: ${tool.description}`);\n   * });\n   *\n   * @example\n   * // Filter enabled tools only\n   * const allTools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const enabledTools = allTools.filter(tool => tool.enabled !== false);\n   * console.log(`${enabledTools.length} enabled tools`);\n   *\n   * @example\n   * // Get tools for agent configuration\n   * const mcpServers = await strapiClient.getAllMCPServers();\n   * const filesystemServer = mcpServers.find(s => s.name === 'filesystem');\n   *\n   * if (filesystemServer) {\n   *   const tools = await strapiClient.getMCPToolsByServerId(filesystemServer.id);\n   *   console.log('Available filesystem tools:');\n   *   tools.forEach(tool => {\n   *     console.log(`  ${tool.name}: ${tool.description}`);\n   *   });\n   * }\n   *\n   * @example\n   * // Inspect tool input schemas\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const readFileTool = tools.find(t => t.name === 'read_file');\n   *\n   * if (readFileTool?.inputSchema) {\n   *   console.log('Input schema:', JSON.stringify(readFileTool.inputSchema, null, 2));\n   *   // {\n   *   //   \"type\": \"object\",\n   *   //   \"properties\": {\n   *   //     \"path\": { \"type\": \"string\", \"description\": \"File path to read\" }\n   *   //   },\n   *   //   \"required\": [\"path\"]\n   *   // }\n   * }\n   *\n   * @example\n   * // Build tool selection for agent\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const selectedToolIds = tools\n   *   .filter(t => ['read_file', 'write_file', 'list_directory'].includes(t.name))\n   *   .map(t => ({ mcpTool: t.id }));\n   *\n   * // Use in agent mcpConfig\n   * await strapiClient.createAgent({\n   *   name: 'File Assistant',\n   *   systemPrompt: 'You help with file operations.',\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: 'abc123',\n   *       selectedTools: selectedToolIds\n   *     }\n   *   ]\n   * });\n   *\n   * @see {@link bulkSyncMCPTools} for syncing tools from MCP server\n   * @see {@link createMCPTool} for manually creating tools\n   * @see {@link updateMCPTool} for updating tool metadata\n   */\n  async getMCPToolsByServerId(serverId: string): Promise<MCPTool[]> {\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/mcp-tools',\n      {\n        params: {\n          filters: { mcpServer: { documentId: serverId } },\n        },\n      }\n    );\n\n    return data.data.map((item: StrapiAttributes<any>) => this.transformMCPTool(item));\n  }\n\n  /**\n   * Create a new MCP tool\n   *\n   * @description\n   * Creates a new MCP tool associated with a specific MCP server. Tools are typically\n   * created via `bulkSyncMCPTools` after fetching from the MCP server, but this method\n   * allows manual tool creation for custom scenarios.\n   *\n   * **Tool Schema:**\n   * The `inputSchema` follows JSON Schema specification to define tool parameters.\n   *\n   * **Common Use Cases:**\n   * - Manual tool creation for testing\n   * - Custom tool definitions not from MCP server\n   * - Placeholder tools before server sync\n   *\n   * @param {string} serverId - MCP server document ID to associate with\n   * @param {Object} toolData - Tool data\n   * @param {string} toolData.name - Unique tool name (e.g., 'read_file')\n   * @param {string} [toolData.description] - Human-readable description\n   * @param {Object} [toolData.inputSchema] - JSON Schema for tool parameters\n   * @returns {Promise<MCPTool>} Created MCP tool\n   * @throws {Error} If creation fails\n   *\n   * @example\n   * // Create basic tool\n   * const tool = await strapiClient.createMCPTool('abc123', {\n   *   name: 'read_file',\n   *   description: 'Read contents of a file'\n   * });\n   * console.log(tool.id); // Auto-generated UUID\n   *\n   * @example\n   * // Create tool with input schema\n   * const tool = await strapiClient.createMCPTool('abc123', {\n   *   name: 'write_file',\n   *   description: 'Write contents to a file',\n   *   inputSchema: {\n   *     type: 'object',\n   *     properties: {\n   *       path: {\n   *         type: 'string',\n   *         description: 'File path to write'\n   *       },\n   *       content: {\n   *         type: 'string',\n   *         description: 'Content to write'\n   *       }\n   *     },\n   *     required: ['path', 'content']\n   *   }\n   * });\n   *\n   * @example\n   * // Create multiple tools\n   * const serverId = 'abc123';\n   * const tools = [\n   *   { name: 'read_file', description: 'Read file' },\n   *   { name: 'write_file', description: 'Write file' },\n   *   { name: 'delete_file', description: 'Delete file' }\n   * ];\n   *\n   * for (const toolData of tools) {\n   *   await strapiClient.createMCPTool(serverId, toolData);\n   * }\n   *\n   * @example\n   * // Create tool with complex schema\n   * const tool = await strapiClient.createMCPTool('abc123', {\n   *   name: 'search_files',\n   *   description: 'Search for files matching criteria',\n   *   inputSchema: {\n   *     type: 'object',\n   *     properties: {\n   *       pattern: { type: 'string', description: 'Search pattern (glob)' },\n   *       path: { type: 'string', description: 'Directory to search' },\n   *       maxResults: { type: 'number', description: 'Max results to return', default: 100 }\n   *     },\n   *     required: ['pattern']\n   *   }\n   * });\n   *\n   * @see {@link bulkSyncMCPTools} for automated tool creation from MCP server\n   * @see {@link updateMCPTool} for updating tool metadata\n   * @see {@link deleteMCPTool} for removing tools\n   */\n  async createMCPTool(serverId: string, toolData: {\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }): Promise<MCPTool> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/mcp-tools',\n      {\n        data: {\n          ...toolData,\n          mcpServer: serverId,\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create MCP tool');\n    }\n\n    return this.transformMCPTool(data.data);\n  }\n\n  /**\n   * Update an existing MCP tool\n   *\n   * @description\n   * Updates an existing MCP tool using partial update semantics. Typically used\n   * by `bulkSyncMCPTools` to keep tools synchronized with MCP server metadata,\n   * but can also be used for manual updates.\n   *\n   * **Partial Updates:**\n   * Only the fields provided will be updated; omitted fields remain unchanged.\n   *\n   * **Common Updates:**\n   * - Update description for better clarity\n   * - Update inputSchema when tool parameters change\n   * - Update name if tool is renamed (rare)\n   *\n   * @param {string} toolId - MCP tool document ID\n   * @param {Object} toolData - Partial tool data to update\n   * @param {string} [toolData.name] - Update tool name\n   * @param {string} [toolData.description] - Update description\n   * @param {Object} [toolData.inputSchema] - Update input schema\n   * @returns {Promise<MCPTool>} Updated MCP tool\n   * @throws {Error} If update fails or tool not found\n   *\n   * @example\n   * // Update tool description\n   * const tool = await strapiClient.updateMCPTool('tool123', {\n   *   description: 'Read file contents with improved error handling'\n   * });\n   *\n   * @example\n   * // Update tool input schema\n   * const tool = await strapiClient.updateMCPTool('tool123', {\n   *   inputSchema: {\n   *     type: 'object',\n   *     properties: {\n   *       path: {\n   *         type: 'string',\n   *         description: 'Absolute or relative file path'\n   *       },\n   *       encoding: {\n   *         type: 'string',\n   *         description: 'File encoding',\n   *         default: 'utf-8',\n   *         enum: ['utf-8', 'ascii', 'base64']\n   *       }\n   *     },\n   *     required: ['path']\n   *   }\n   * });\n   *\n   * @example\n   * // Update multiple fields\n   * const tool = await strapiClient.updateMCPTool('tool123', {\n   *   name: 'read_file_v2',\n   *   description: 'Read file with encoding support',\n   *   inputSchema: {\n   *     type: 'object',\n   *     properties: {\n   *       path: { type: 'string' },\n   *       encoding: { type: 'string', default: 'utf-8' }\n   *     },\n   *     required: ['path']\n   *   }\n   * });\n   *\n   * @example\n   * // Update tools after server upgrade\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const readTool = tools.find(t => t.name === 'read_file');\n   *\n   * if (readTool) {\n   *   await strapiClient.updateMCPTool(readTool.id, {\n   *     description: 'Updated after server v2.0 upgrade',\n   *     inputSchema: newSchemaFromServer\n   *   });\n   * }\n   *\n   * @see {@link getMCPToolsByServerId} for retrieving tools to update\n   * @see {@link bulkSyncMCPTools} for automated tool updates\n   */\n  async updateMCPTool(toolId: string, toolData: {\n    name?: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }): Promise<MCPTool> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/mcp-tools/${toolId}`,\n      {\n        data: toolData,\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update MCP tool with ID ${toolId}`);\n    }\n\n    return this.transformMCPTool(data.data);\n  }\n\n  /**\n   * Delete an MCP tool\n   *\n   * @description\n   * Permanently deletes an MCP tool from Strapi database. This operation is typically\n   * performed by `bulkSyncMCPTools` when a tool no longer exists on the MCP server,\n   * but can also be used for manual cleanup.\n   *\n   * **Warning:**\n   * Deleting a tool may affect agent configurations that reference this tool.\n   * The tool will be removed from any agent's `mcpConfig.selectedTools` arrays.\n   *\n   * **Use Cases:**\n   * - Remove obsolete tools after server update\n   * - Clean up manually created test tools\n   * - Sync tool deletion from MCP server\n   *\n   * @param {string} toolId - MCP tool document ID to delete\n   * @returns {Promise<void>} Promise that resolves when deletion is complete\n   * @throws {Error} If deletion fails or tool not found\n   *\n   * @example\n   * // Delete a single tool\n   * await strapiClient.deleteMCPTool('tool123');\n   * console.log('Tool deleted');\n   *\n   * @example\n   * // Delete obsolete tools\n   * const tools = await strapiClient.getMCPToolsByServerId('abc123');\n   * const obsoleteTools = tools.filter(t => t.name.includes('_deprecated'));\n   *\n   * for (const tool of obsoleteTools) {\n   *   await strapiClient.deleteMCPTool(tool.id);\n   *   console.log(`Deleted obsolete tool: ${tool.name}`);\n   * }\n   *\n   * @example\n   * // Delete all tools for a server before re-sync\n   * const serverId = 'abc123';\n   * const tools = await strapiClient.getMCPToolsByServerId(serverId);\n   *\n   * // Delete all existing tools\n   * await Promise.all(tools.map(t => strapiClient.deleteMCPTool(t.id)));\n   *\n   * // Now sync fresh tools\n   * await strapiClient.bulkSyncMCPTools(serverId, fetchedToolsFromServer);\n   *\n   * @example\n   * // Safe deletion with error handling\n   * try {\n   *   await strapiClient.deleteMCPTool('tool123');\n   *   console.log('Tool deleted successfully');\n   * } catch (error) {\n   *   console.error('Failed to delete tool:', error.message);\n   * }\n   *\n   * @see {@link bulkSyncMCPTools} for automated tool deletion during sync\n   * @see {@link getMCPToolsByServerId} for retrieving tools to delete\n   */\n  async deleteMCPTool(toolId: string): Promise<void> {\n    await this.client.delete(`/mcp-tools/${toolId}`);\n  }\n\n  /**\n   * Bulk sync MCP tools for a server\n   *\n   * @description\n   * Synchronizes MCP tools in Strapi database with tools fetched from an MCP server.\n   * This method performs intelligent 3-way sync:\n   * - **Create**: Adds new tools that don't exist in database\n   * - **Update**: Updates existing tools if description or inputSchema changed\n   * - **Delete**: Removes tools from database that no longer exist on server\n   *\n   * **Sync Algorithm:**\n   * 1. Fetch existing tools from database\n   * 2. Compare with fetched tools by name (name is the unique identifier)\n   * 3. Delete tools not in fetched list\n   * 4. Update tools with changed metadata (description, inputSchema)\n   * 5. Create tools that don't exist in database\n   * 6. Update server's `toolsFetchedAt` timestamp\n   *\n   * **Use Cases:**\n   * - Initial tool discovery after creating MCP server\n   * - Periodic sync to update tool metadata\n   * - Tool refresh after server upgrade\n   *\n   * **Cache Invalidation:**\n   * Invalidates MCP server caches after sync completes.\n   *\n   * @param {string} serverId - MCP server document ID\n   * @param {Array} fetchedTools - Tools fetched from MCP server\n   * @param {string} fetchedTools[].name - Tool name (unique identifier)\n   * @param {string} [fetchedTools[].description] - Tool description\n   * @param {Object} [fetchedTools[].inputSchema] - Tool input schema (JSON Schema)\n   * @returns {Promise<MCPServer>} Updated MCP server with tools populated\n   *\n   * @example\n   * // Basic tool sync after server creation\n   * const server = await strapiClient.createMCPServer({\n   *   name: 'filesystem',\n   *   transportType: 'stdio',\n   *   command: 'npx',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()]\n   * });\n   *\n   * // Fetch tools from MCP server (pseudo-code)\n   * const fetchedTools = [\n   *   { name: 'read_file', description: 'Read file contents' },\n   *   { name: 'write_file', description: 'Write file contents' },\n   *   { name: 'list_directory', description: 'List directory contents' }\n   * ];\n   *\n   * // Sync tools to database\n   * const updatedServer = await strapiClient.bulkSyncMCPTools(server.id, fetchedTools);\n   * console.log(`Synced ${updatedServer.mcpTools?.length} tools`);\n   *\n   * @example\n   * // Sync with detailed tool schemas\n   * const fetchedTools = [\n   *   {\n   *     name: 'read_file',\n   *     description: 'Read contents of a file',\n   *     inputSchema: {\n   *       type: 'object',\n   *       properties: {\n   *         path: { type: 'string', description: 'File path to read' }\n   *       },\n   *       required: ['path']\n   *     }\n   *   },\n   *   {\n   *     name: 'write_file',\n   *     description: 'Write contents to a file',\n   *     inputSchema: {\n   *       type: 'object',\n   *       properties: {\n   *         path: { type: 'string', description: 'File path to write' },\n   *         content: { type: 'string', description: 'Content to write' }\n   *       },\n   *       required: ['path', 'content']\n   *     }\n   *   }\n   * ];\n   *\n   * await strapiClient.bulkSyncMCPTools('abc123', fetchedTools);\n   *\n   * @example\n   * // Sync workflow with MCPService integration\n   * import { mcpService } from './mcp-service';\n   *\n   * // Get MCP server from database\n   * const server = await strapiClient.getMCPServer('abc123');\n   *\n   * // Fetch tools from MCP server\n   * const fetchedTools = await mcpService.listMCPServerTools(server.id);\n   *\n   * // Sync to database\n   * const updatedServer = await strapiClient.bulkSyncMCPTools(server.id, fetchedTools);\n   * console.log(`Sync complete. ${updatedServer.mcpTools?.length} tools available.`);\n   *\n   * @example\n   * // Periodic sync to keep tools up-to-date\n   * async function syncAllMCPServers() {\n   *   const servers = await strapiClient.getAllMCPServers({\n   *     filters: { enabled: { $eq: true } }\n   *   });\n   *\n   *   for (const server of servers) {\n   *     console.log(`Syncing tools for ${server.name}...`);\n   *     const fetchedTools = await mcpService.listMCPServerTools(server.id);\n   *     await strapiClient.bulkSyncMCPTools(server.id, fetchedTools);\n   *     console.log(`\u2713 ${server.name} synced`);\n   *   }\n   * }\n   *\n   * @example\n   * // Handle sync errors gracefully\n   * try {\n   *   const fetchedTools = await mcpService.listMCPServerTools('abc123');\n   *   const server = await strapiClient.bulkSyncMCPTools('abc123', fetchedTools);\n   *   console.log(`Synced ${server.mcpTools?.length} tools successfully`);\n   * } catch (error) {\n   *   console.error('Tool sync failed:', error.message);\n   *   // Server tools remain unchanged\n   * }\n   *\n   * @example\n   * // Sync removes obsolete tools\n   * // Before sync: database has ['read_file', 'write_file', 'delete_file']\n   * // After MCP server upgrade: server only has ['read_file', 'write_file']\n   *\n   * const fetchedTools = [\n   *   { name: 'read_file', description: 'Read file' },\n   *   { name: 'write_file', description: 'Write file' }\n   *   // 'delete_file' is missing - will be deleted from database\n   * ];\n   *\n   * await strapiClient.bulkSyncMCPTools('abc123', fetchedTools);\n   * // Database now has only ['read_file', 'write_file']\n   * // 'delete_file' was automatically deleted\n   *\n   * @example\n   * // Check what changed during sync\n   * const beforeTools = await strapiClient.getMCPToolsByServerId('abc123');\n   * console.log(`Before sync: ${beforeTools.length} tools`);\n   *\n   * const fetchedTools = await mcpService.listMCPServerTools('abc123');\n   * await strapiClient.bulkSyncMCPTools('abc123', fetchedTools);\n   *\n   * const afterTools = await strapiClient.getMCPToolsByServerId('abc123');\n   * console.log(`After sync: ${afterTools.length} tools`);\n   *\n   * const added = afterTools.filter(t => !beforeTools.find(b => b.name === t.name));\n   * const removed = beforeTools.filter(t => !afterTools.find(a => a.name === t.name));\n   * console.log(`Added: ${added.map(t => t.name).join(', ')}`);\n   * console.log(`Removed: ${removed.map(t => t.name).join(', ')}`);\n   *\n   * @see {@link getMCPToolsByServerId} for retrieving synced tools\n   * @see {@link createMCPTool} for manual tool creation\n   * @see {@link updateMCPTool} for manual tool updates\n   * @see {@link deleteMCPTool} for manual tool deletion\n   */\n  async bulkSyncMCPTools(serverId: string, fetchedTools: Array<{\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }>): Promise<MCPServer> {\n    // Get existing tools for this server\n    const existingTools = await this.getMCPToolsByServerId(serverId);\n\n    // Create a map of existing tools by name\n    const existingToolsMap = new Map(existingTools.map(t => [t.name, t]));\n\n    // Create a set of fetched tool names\n    const fetchedToolNames = new Set(fetchedTools.map(t => t.name));\n\n    // Delete tools that no longer exist\n    const toolsToDelete = existingTools.filter(t => !fetchedToolNames.has(t.name));\n    await Promise.all(toolsToDelete.map(t => this.deleteMCPTool(t.id)));\n\n    // Create or update tools\n    for (const fetchedTool of fetchedTools) {\n      const existingTool = existingToolsMap.get(fetchedTool.name);\n\n      if (existingTool) {\n        // Update if changed\n        const hasChanged =\n          existingTool.description !== fetchedTool.description ||\n          JSON.stringify(existingTool.inputSchema) !== JSON.stringify(fetchedTool.inputSchema);\n\n        if (hasChanged) {\n          await this.updateMCPTool(existingTool.id, fetchedTool);\n        }\n      } else {\n        // Create new tool\n        await this.createMCPTool(serverId, fetchedTool);\n      }\n    }\n\n    // Update toolsFetchedAt timestamp on the server\n    await this.client.put(`/mcp-servers/${serverId}`, {\n      data: {\n        toolsFetchedAt: new Date().toISOString(),\n      },\n    });\n\n    // Invalidate cache\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${serverId}`);\n\n    // Return updated server with tools\n    return this.getMCPServer(serverId);\n  }\n\n  // ============= FILE UPLOAD =============\n\n  /**\n   * Upload a file to Strapi Media Library\n   *\n   * @description\n   * Uploads a file to Strapi's Media Library. The uploaded file is stored in Strapi's\n   * configured storage provider (local filesystem, S3, Cloudinary, etc.) and can be\n   * referenced in other content types via file relations. Common use cases include\n   * uploading skill attachments, agent documentation, or training materials.\n   *\n   * **Supported File Types:**\n   * - Images: .jpg, .jpeg, .png, .gif, .svg, .webp\n   * - Documents: .pdf, .doc, .docx, .txt, .md\n   * - Archives: .zip, .tar, .gz\n   * - Code: .js, .ts, .py, .java, .cpp, etc.\n   * - Any other file type (MIME type auto-detected)\n   *\n   * **File Size Limits:**\n   * - Default Strapi limit: 200MB (configurable in Strapi)\n   * - Large files may require adjusting Strapi's `strapi::body` middleware configuration\n   *\n   * @param {Buffer | Blob} file - File to upload (Buffer for Node.js, Blob for browsers)\n   * @param {string} filename - Original filename with extension (e.g., 'document.pdf')\n   *\n   * @returns {Promise<Object>} Strapi media object with file metadata\n   * @returns {number} returns.id - Numeric file ID (legacy)\n   * @returns {string} returns.documentId - UUID document ID (Strapi v5)\n   * @returns {string} returns.name - Stored filename\n   * @returns {string} returns.url - Public URL to access the file\n   * @returns {string} returns.mime - MIME type (e.g., 'application/pdf', 'image/png')\n   * @returns {number} returns.size - File size in bytes\n   *\n   * @throws {Error} If file upload fails\n   *\n   * @example\n   * // Upload a text file from Buffer\n   * import fs from 'fs/promises';\n   *\n   * const fileBuffer = await fs.readFile('./example.txt');\n   * const uploadedFile = await strapiClient.uploadFile(fileBuffer, 'example.txt');\n   *\n   * console.log('File uploaded:', uploadedFile.url);\n   * console.log('File ID:', uploadedFile.documentId);\n   *\n   * @example\n   * // Upload an image and attach to a skill\n   * const imageBuffer = await fs.readFile('./diagram.png');\n   * const uploadedImage = await strapiClient.uploadFile(imageBuffer, 'diagram.png');\n   *\n   * // Create skill with image attachment\n   * const skill = await strapiClient.createSkill({\n   *   name: 'image-processing',\n   *   displayName: 'Image Processing',\n   *   description: 'Process and analyze images',\n   *   additionalFiles: [\n   *     {\n   *       name: 'Architecture Diagram',\n   *       description: 'System architecture',\n   *       file: uploadedImage.documentId // Reference uploaded file\n   *     }\n   *   ]\n   * });\n   *\n   * @example\n   * // Upload PDF documentation\n   * const pdfBuffer = await fs.readFile('./user-guide.pdf');\n   * const uploadedPdf = await strapiClient.uploadFile(pdfBuffer, 'user-guide.pdf');\n   *\n   * console.log(`PDF uploaded: ${uploadedPdf.name}`);\n   * console.log(`Size: ${(uploadedPdf.size / 1024).toFixed(2)} KB`);\n   * console.log(`MIME: ${uploadedPdf.mime}`);\n   * console.log(`URL: ${uploadedPdf.url}`);\n   *\n   * @example\n   * // Upload multiple files sequentially\n   * const files = ['file1.txt', 'file2.txt', 'file3.txt'];\n   * const uploadedFiles = [];\n   *\n   * for (const filename of files) {\n   *   const buffer = await fs.readFile(`./uploads/${filename}`);\n   *   const uploaded = await strapiClient.uploadFile(buffer, filename);\n   *   uploadedFiles.push(uploaded);\n   *   console.log(`Uploaded: ${filename} -> ${uploaded.documentId}`);\n   * }\n   *\n   * @example\n   * // Error handling for file upload\n   * try {\n   *   const buffer = await fs.readFile('./large-file.zip');\n   *   const uploaded = await strapiClient.uploadFile(buffer, 'large-file.zip');\n   *   console.log('Upload successful');\n   * } catch (error) {\n   *   console.error('Upload failed:', error.message);\n   *   // Handle error (file too large, invalid type, network error, etc.)\n   * }\n   *\n   * @example\n   * // Upload file and use URL directly\n   * const logoBuffer = await fs.readFile('./logo.png');\n   * const uploadedLogo = await strapiClient.uploadFile(logoBuffer, 'logo.png');\n   *\n   * // Use the URL in your application\n   * const fullUrl = `${process.env.STRAPI_URL}${uploadedLogo.url}`;\n   * console.log(`Logo available at: ${fullUrl}`);\n   *\n   * @see {@link deleteFile} - Delete uploaded files\n   */\n  async uploadFile(file: Buffer | Blob, filename: string): Promise<{\n    id: number;\n    documentId: string;\n    name: string;\n    url: string;\n    mime: string;\n    size: number;\n  }> {\n    const FormData = (await import('form-data')).default;\n    const formData = new FormData();\n\n    formData.append('files', file, filename);\n\n    const { data } = await this.client.post('/upload', formData, {\n      headers: {\n        ...formData.getHeaders(),\n      },\n    });\n\n    if (!data || !data[0]) {\n      throw new Error('Failed to upload file');\n    }\n\n    const uploadedFile = data[0];\n\n    return {\n      id: uploadedFile.id,\n      documentId: uploadedFile.documentId,\n      name: uploadedFile.name,\n      url: uploadedFile.url,\n      mime: uploadedFile.mime,\n      size: uploadedFile.size,\n    };\n  }\n\n  /**\n   * Delete a file from Strapi Media Library\n   *\n   * @description\n   * Permanently deletes a file from Strapi's Media Library and its configured storage\n   * provider. This operation cannot be undone. Ensure the file is not referenced by any\n   * content types before deletion, as this will break file relations.\n   *\n   * **Important Notes:**\n   * - File is permanently deleted from storage (local/S3/Cloudinary/etc.)\n   * - Any content referencing this file will have broken file relations\n   * - Strapi does not prevent deletion of files in use\n   * - Consider verifying file references before deletion\n   *\n   * @param {string} fileId - File document ID (UUID format from Strapi v5) or numeric ID (legacy)\n   *\n   * @returns {Promise<void>}\n   *\n   * @throws {Error} If file deletion fails or file not found\n   *\n   * @example\n   * // Basic file deletion\n   * await strapiClient.deleteFile('file-uuid-123');\n   * console.log('File deleted successfully');\n   *\n   * @example\n   * // Delete file after uploading a replacement\n   * const oldFileId = 'old-file-uuid';\n   *\n   * // Upload new version\n   * const newBuffer = await fs.readFile('./updated-document.pdf');\n   * const newFile = await strapiClient.uploadFile(newBuffer, 'updated-document.pdf');\n   *\n   * // Update skill to reference new file\n   * await strapiClient.updateSkill('skill-uuid', {\n   *   additionalFiles: [\n   *     { name: 'Documentation', file: newFile.documentId }\n   *   ]\n   * });\n   *\n   * // Now safe to delete old file\n   * await strapiClient.deleteFile(oldFileId);\n   *\n   * @example\n   * // Error handling for file deletion\n   * try {\n   *   await strapiClient.deleteFile('file-uuid-123');\n   *   console.log('File deleted');\n   * } catch (error) {\n   *   console.error('Failed to delete file:', error.message);\n   *   // Handle error (file not found, permission denied, etc.)\n   * }\n   *\n   * @example\n   * // Delete multiple files (cleanup unused attachments)\n   * const fileIdsToDelete = [\n   *   'file-uuid-1',\n   *   'file-uuid-2',\n   *   'file-uuid-3'\n   * ];\n   *\n   * for (const fileId of fileIdsToDelete) {\n   *   try {\n   *     await strapiClient.deleteFile(fileId);\n   *     console.log(`Deleted: ${fileId}`);\n   *   } catch (error) {\n   *     console.error(`Failed to delete ${fileId}:`, error.message);\n   *   }\n   * }\n   *\n   * @example\n   * // Safe deletion workflow - verify no references first\n   * // Note: This is a conceptual example - actual implementation depends on your data model\n   * const fileId = 'file-uuid-123';\n   *\n   * // Check if any skills reference this file\n   * const skills = await strapiClient.getAllSkills();\n   * const isReferenced = skills.some(skill =>\n   *   skill.additionalFiles?.some(f => f.file === fileId)\n   * );\n   *\n   * if (!isReferenced) {\n   *   await strapiClient.deleteFile(fileId);\n   *   console.log('File safely deleted (no references found)');\n   * } else {\n   *   console.warn('File is still referenced - cannot delete');\n   * }\n   *\n   * @see {@link uploadFile} - Upload files to Media Library\n   */\n  async deleteFile(fileId: string): Promise<void> {\n    await this.client.delete(`/upload/files/${fileId}`);\n  }\n\n  // ============= TASKS =============\n\n  /**\n   * Get all tasks with optional filtering, sorting, and pagination\n   *\n   * @description\n   * Retrieves all tasks from Strapi with support for filtering by status, assigned agent,\n   * priority, and other fields. Tasks represent work items, automation jobs, or scheduled\n   * operations assigned to agents. Results are cached with 5-minute TTL for improved performance.\n   *\n   * **Common Task Fields:**\n   * - `title`: Task title/name\n   * - `description`: Task description\n   * - `status`: Task status (pending, in_progress, completed, failed, etc.)\n   * - `priority`: Priority level (low, medium, high, urgent)\n   * - `dueDate`: Optional due date\n   * - `agent`: Assigned agent (relation)\n   * - `result`: Task execution result/output\n   * - `metadata`: Custom task metadata\n   *\n   * @param {Object} [options] - Query options for filtering, sorting, and pagination\n   * @param {Record<string, any>} [options.filters] - Strapi v5 filters object (supports $eq, $ne, $in, $containsi, $and, $or, etc.)\n   * @param {string[]} [options.sort] - Sort order array (e.g., ['dueDate:asc', 'priority:desc'])\n   * @param {Object} [options.pagination] - Pagination configuration\n   * @param {number} [options.pagination.page] - Page number (1-indexed)\n   * @param {number} [options.pagination.pageSize] - Number of items per page\n   *\n   * @returns {Promise<Task[]>} Array of Task objects\n   *\n   * @example\n   * // Basic usage - get all tasks\n   * const tasks = await strapiClient.getAllTasks();\n   * console.log(`Found ${tasks.length} tasks`);\n   *\n   * @example\n   * // Filter by status - get pending tasks only\n   * const pendingTasks = await strapiClient.getAllTasks({\n   *   filters: { status: { $eq: 'pending' } }\n   * });\n   *\n   * @example\n   * // Filter by multiple statuses using $in operator\n   * const activeTasks = await strapiClient.getAllTasks({\n   *   filters: {\n   *     status: { $in: ['pending', 'in_progress'] }\n   *   }\n   * });\n   *\n   * @example\n   * // Filter by assigned agent\n   * const agentTasks = await strapiClient.getAllTasks({\n   *   filters: {\n   *     agent: { documentId: { $eq: 'agent-uuid-123' } }\n   *   }\n   * });\n   *\n   * @example\n   * // Sort by priority and due date\n   * const sortedTasks = await strapiClient.getAllTasks({\n   *   sort: ['priority:desc', 'dueDate:asc'],\n   *   filters: { status: { $ne: 'completed' } }\n   * });\n   *\n   * @example\n   * // Pagination - get first page of high-priority tasks\n   * const highPriorityTasks = await strapiClient.getAllTasks({\n   *   filters: { priority: { $eq: 'high' } },\n   *   pagination: { page: 1, pageSize: 20 },\n   *   sort: ['createdAt:desc']\n   * });\n   *\n   * @example\n   * // Search tasks by title (case-insensitive)\n   * const searchResults = await strapiClient.getAllTasks({\n   *   filters: {\n   *     title: { $containsi: 'backup' }\n   *   }\n   * });\n   *\n   * @example\n   * // Get overdue tasks (dueDate in the past and not completed)\n   * const overdueTasks = await strapiClient.getAllTasks({\n   *   filters: {\n   *     $and: [\n   *       { dueDate: { $lt: new Date().toISOString() } },\n   *       { status: { $ne: 'completed' } }\n   *     ]\n   *   }\n   * });\n   */\n  async getAllTasks(options?: {\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Task[]> {\n    const cacheKey = `tasks:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams(options);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/tasks',\n      { params }\n    );\n\n    const tasks = data.data.map((item: StrapiAttributes<any>) => this.transformTask(item));\n    this.cache.set(cacheKey, tasks);\n\n    return tasks;\n  }\n\n  /**\n   * Get a single task by ID with populated agent relation\n   *\n   * @description\n   * Retrieves a single task by its unique document ID with the assigned agent relation\n   * automatically populated. Use this method to get detailed task information including\n   * the full agent configuration.\n   *\n   * **Auto-populated Relations:**\n   * - `agent`: Assigned agent with full configuration\n   *\n   * @param {string} id - Task document ID (UUID format)\n   *\n   * @returns {Promise<Task>} Task object with populated agent relation\n   *\n   * @throws {Error} If task with the specified ID is not found\n   *\n   * @example\n   * // Basic usage - get task by ID\n   * const task = await strapiClient.getTask('task-uuid-123');\n   * console.log(`Task: ${task.title}`);\n   * console.log(`Status: ${task.status}`);\n   * console.log(`Assigned to: ${task.agent?.name}`);\n   *\n   * @example\n   * // Get task and check status\n   * try {\n   *   const task = await strapiClient.getTask('task-uuid-123');\n   *\n   *   if (task.status === 'completed') {\n   *     console.log('Task completed successfully');\n   *     console.log('Result:', task.result);\n   *   } else if (task.status === 'failed') {\n   *     console.error('Task failed:', task.result);\n   *   }\n   * } catch (error) {\n   *   console.error('Task not found');\n   * }\n   *\n   * @example\n   * // Get task and display detailed information\n   * const task = await strapiClient.getTask('task-uuid-123');\n   *\n   * console.log('Task Details:');\n   * console.log(`  Title: ${task.title}`);\n   * console.log(`  Status: ${task.status}`);\n   * console.log(`  Priority: ${task.priority}`);\n   * console.log(`  Due: ${task.dueDate || 'No due date'}`);\n   * console.log(`  Agent: ${task.agent?.name || 'Unassigned'}`);\n   * console.log(`  Created: ${task.createdAt}`);\n   * console.log(`  Updated: ${task.updatedAt}`);\n   *\n   * @example\n   * // Error handling for non-existent task\n   * try {\n   *   const task = await strapiClient.getTask('invalid-id');\n   * } catch (error) {\n   *   console.error('Failed to retrieve task:', error.message);\n   *   // Handle error (show error message to user, etc.)\n   * }\n   */\n  async getTask(id: string): Promise<Task> {\n    const cacheKey = `task:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/tasks/${id}`,\n      {\n        params: { populate: 'agent' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Task with ID ${id} not found`);\n    }\n\n    const task = this.transformTask(data.data);\n    this.cache.set(cacheKey, task);\n\n    return task;\n  }\n\n  /**\n   * Create a new task\n   *\n   * @description\n   * Creates a new task in Strapi. Tasks can be assigned to agents for execution and can\n   * include metadata, priority levels, and due dates. The task status defaults to 'pending'\n   * if not specified.\n   *\n   * **Cache Behavior:**\n   * - Invalidates all task list caches to ensure fresh data on next fetch\n   * - New task is not immediately cached (cached on first retrieval)\n   *\n   * @param {CreateTaskDTO} taskData - Task data to create\n   * @param {string} taskData.title - Task title/name (required)\n   * @param {string} [taskData.description] - Task description\n   * @param {string} [taskData.status] - Task status (pending, in_progress, completed, failed, etc.)\n   * @param {string} [taskData.priority] - Priority level (low, medium, high, urgent)\n   * @param {string} [taskData.dueDate] - Due date (ISO 8601 format)\n   * @param {string} [taskData.agent] - Assigned agent ID (UUID)\n   * @param {any} [taskData.metadata] - Custom task metadata\n   *\n   * @returns {Promise<Task>} Created task object\n   *\n   * @throws {Error} If task creation fails\n   *\n   * @example\n   * // Basic task creation\n   * const task = await strapiClient.createTask({\n   *   title: 'Process customer data',\n   *   description: 'Extract and validate customer information from CSV',\n   *   status: 'pending'\n   * });\n   * console.log(`Created task: ${task.id}`);\n   *\n   * @example\n   * // Create task with agent assignment\n   * const task = await strapiClient.createTask({\n   *   title: 'Generate monthly report',\n   *   description: 'Compile sales metrics and generate PDF report',\n   *   status: 'pending',\n   *   priority: 'high',\n   *   agent: 'agent-uuid-123' // Assign to specific agent\n   * });\n   *\n   * @example\n   * // Create task with due date and priority\n   * const tomorrow = new Date();\n   * tomorrow.setDate(tomorrow.getDate() + 1);\n   *\n   * const task = await strapiClient.createTask({\n   *   title: 'Backup database',\n   *   description: 'Perform full database backup to S3',\n   *   status: 'pending',\n   *   priority: 'urgent',\n   *   dueDate: tomorrow.toISOString(),\n   *   agent: 'backup-agent-uuid'\n   * });\n   *\n   * @example\n   * // Create task with custom metadata\n   * const task = await strapiClient.createTask({\n   *   title: 'Send email notifications',\n   *   description: 'Send weekly digest emails to subscribers',\n   *   status: 'pending',\n   *   priority: 'medium',\n   *   metadata: {\n   *     emailCount: 1500,\n   *     template: 'weekly-digest',\n   *     sendTime: '2024-01-15T09:00:00Z'\n   *   }\n   * });\n   *\n   * @example\n   * // Create task and immediately start execution\n   * const task = await strapiClient.createTask({\n   *   title: 'Index search documents',\n   *   description: 'Update Elasticsearch index with new documents',\n   *   status: 'in_progress', // Start immediately\n   *   priority: 'high',\n   *   agent: 'indexer-agent-uuid'\n   * });\n   *\n   * // Poll task status\n   * const checkStatus = async () => {\n   *   const updated = await strapiClient.getTask(task.id);\n   *   console.log(`Status: ${updated.status}`);\n   * };\n   *\n   * @example\n   * // Error handling for task creation\n   * try {\n   *   const task = await strapiClient.createTask({\n   *     title: 'Important task',\n   *     description: 'Critical operation',\n   *     agent: 'invalid-agent-id' // Invalid agent reference\n   *   });\n   * } catch (error) {\n   *   console.error('Failed to create task:', error.message);\n   *   // Handle error (show validation message, retry, etc.)\n   * }\n   */\n  async createTask(taskData: CreateTaskDTO): Promise<Task> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/tasks',\n      {\n        data: this.prepareTaskData(taskData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create task');\n    }\n\n    this.invalidateCache('tasks');\n    return this.transformTask(data.data);\n  }\n\n  /**\n   * Update an existing task\n   *\n   * @description\n   * Updates an existing task with partial data. Only provided fields are updated; omitted\n   * fields remain unchanged. Common use cases include updating task status, adding results,\n   * changing priority, or reassigning to a different agent.\n   *\n   * **Partial Update Semantics:**\n   * - Only fields present in `taskData` are updated\n   * - Omitted fields retain their current values\n   * - Pass `null` explicitly to clear a field value\n   *\n   * **Cache Behavior:**\n   * - Invalidates all task list caches\n   * - Invalidates the specific task cache entry\n   * - Updated task is returned but not immediately re-cached\n   *\n   * @param {string} id - Task document ID to update\n   * @param {UpdateTaskDTO} taskData - Partial task data to update\n   * @param {string} [taskData.title] - Update task title\n   * @param {string} [taskData.description] - Update task description\n   * @param {string} [taskData.status] - Update task status\n   * @param {string} [taskData.priority] - Update priority level\n   * @param {string} [taskData.dueDate] - Update due date\n   * @param {string} [taskData.agent] - Reassign to different agent\n   * @param {any} [taskData.result] - Set task execution result\n   * @param {any} [taskData.metadata] - Update task metadata\n   *\n   * @returns {Promise<Task>} Updated task object\n   *\n   * @throws {Error} If task update fails or task not found\n   *\n   * @example\n   * // Update task status\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'completed'\n   * });\n   * console.log(`Task status updated to: ${task.status}`);\n   *\n   * @example\n   * // Update task status and add result\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'completed',\n   *   result: {\n   *     processedRecords: 1500,\n   *     duration: '5.2s',\n   *     success: true\n   *   }\n   * });\n   *\n   * @example\n   * // Mark task as failed with error information\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'failed',\n   *   result: {\n   *     error: 'Database connection timeout',\n   *     retryCount: 3,\n   *     lastAttempt: new Date().toISOString()\n   *   }\n   * });\n   *\n   * @example\n   * // Change task priority\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   priority: 'urgent'\n   * });\n   *\n   * @example\n   * // Reassign task to different agent\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   agent: 'new-agent-uuid',\n   *   status: 'pending' // Reset status when reassigning\n   * });\n   *\n   * @example\n   * // Update multiple fields at once\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'in_progress',\n   *   priority: 'high',\n   *   metadata: {\n   *     startedAt: new Date().toISOString(),\n   *     assignedWorker: 'worker-3'\n   *   }\n   * });\n   *\n   * @example\n   * // Extend due date\n   * const nextWeek = new Date();\n   * nextWeek.setDate(nextWeek.getDate() + 7);\n   *\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   dueDate: nextWeek.toISOString()\n   * });\n   *\n   * @example\n   * // Error handling for task update\n   * try {\n   *   const task = await strapiClient.updateTask('task-uuid-123', {\n   *     status: 'completed',\n   *     result: { success: true }\n   *   });\n   * } catch (error) {\n   *   console.error('Failed to update task:', error.message);\n   *   // Handle error (task not found, validation error, etc.)\n   * }\n   */\n  async updateTask(id: string, taskData: UpdateTaskDTO): Promise<Task> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/tasks/${id}`,\n      {\n        data: this.prepareTaskData(taskData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update task with ID ${id}`);\n    }\n\n    this.invalidateCache('tasks');\n    this.cache.delete(`task:${id}`);\n\n    return this.transformTask(data.data);\n  }\n\n  /**\n   * Delete a task\n   *\n   * @description\n   * Permanently deletes a task from Strapi. This operation cannot be undone. Consider\n   * updating the task status to 'cancelled' or 'archived' instead if you need to preserve\n   * task history.\n   *\n   * **Cache Behavior:**\n   * - Invalidates all task list caches\n   * - Removes the specific task cache entry\n   *\n   * **Best Practices:**\n   * - Verify task can be safely deleted before calling (no critical dependencies)\n   * - Consider soft-delete approach (status = 'deleted') for audit trail\n   * - Ensure task is not currently being executed by an agent\n   *\n   * @param {string} id - Task document ID to delete\n   *\n   * @returns {Promise<void>}\n   *\n   * @throws {Error} If task deletion fails or task not found\n   *\n   * @example\n   * // Basic task deletion\n   * await strapiClient.deleteTask('task-uuid-123');\n   * console.log('Task deleted successfully');\n   *\n   * @example\n   * // Delete task with confirmation check\n   * const task = await strapiClient.getTask('task-uuid-123');\n   *\n   * if (task.status === 'completed' || task.status === 'cancelled') {\n   *   await strapiClient.deleteTask(task.id);\n   *   console.log('Task deleted successfully');\n   * } else {\n   *   console.warn('Cannot delete active task');\n   * }\n   *\n   * @example\n   * // Error handling for task deletion\n   * try {\n   *   await strapiClient.deleteTask('task-uuid-123');\n   *   console.log('Task deleted');\n   * } catch (error) {\n   *   console.error('Failed to delete task:', error.message);\n   *   // Handle error (task not found, permission denied, etc.)\n   * }\n   *\n   * @example\n   * // Soft delete alternative - preserve task history\n   * // Instead of permanently deleting, update status to 'deleted'\n   * const task = await strapiClient.updateTask('task-uuid-123', {\n   *   status: 'deleted',\n   *   metadata: {\n   *     deletedAt: new Date().toISOString(),\n   *     deletedBy: 'user-123'\n   *   }\n   * });\n   * // Task is hidden from normal queries but preserved in database\n   *\n   * @example\n   * // Bulk delete completed tasks older than 30 days\n   * const thirtyDaysAgo = new Date();\n   * thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n   *\n   * const oldTasks = await strapiClient.getAllTasks({\n   *   filters: {\n   *     $and: [\n   *       { status: { $eq: 'completed' } },\n   *       { updatedAt: { $lt: thirtyDaysAgo.toISOString() } }\n   *     ]\n   *   }\n   * });\n   *\n   * for (const task of oldTasks) {\n   *   await strapiClient.deleteTask(task.id);\n   * }\n   * console.log(`Deleted ${oldTasks.length} old tasks`);\n   */\n  async deleteTask(id: string): Promise<void> {\n    await this.client.delete(`/tasks/${id}`);\n    this.invalidateCache('tasks');\n    this.cache.delete(`task:${id}`);\n  }\n\n  // ============= TRANSFORMERS =============\n  // Transform Strapi response format to domain models\n\n  /**\n   * Extract attributes from Strapi response\n   *\n   * @description Handles both nested (attributes) and flat response formats from Strapi.\n   * Strapi v5 typically returns data in nested format with `attributes` property, but some\n   * configurations or API endpoints may return flat data directly.\n   *\n   * This method provides a unified interface for accessing response data regardless of format:\n   * - Nested format: `{ documentId: '...', attributes: { name: '...', ... } }`\n   * - Flat format: `{ documentId: '...', name: '...', ... }`\n   *\n   * @param strapiData - Raw Strapi response data (nested or flat)\n   * @returns Extracted attributes object containing all entity fields\n   *\n   * @example\n   * // Nested format (Strapi v5 default)\n   * const nestedData = {\n   *   documentId: 'agent-123',\n   *   attributes: {\n   *     name: 'Research Agent',\n   *     systemPrompt: 'You are a research assistant',\n   *     enabled: true,\n   *     createdAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const attrs = this.extractAttributes(nestedData);\n   * // Returns: { name: 'Research Agent', systemPrompt: '...', enabled: true, createdAt: '...' }\n   *\n   * @example\n   * // Flat format (some Strapi configurations)\n   * const flatData = {\n   *   documentId: 'agent-123',\n   *   name: 'Research Agent',\n   *   systemPrompt: 'You are a research assistant',\n   *   enabled: true,\n   *   createdAt: '2024-01-01T00:00:00.000Z'\n   * };\n   * const attrs = this.extractAttributes(flatData);\n   * // Returns: { documentId: '...', name: 'Research Agent', systemPrompt: '...', enabled: true, createdAt: '...' }\n   *\n   * @see transformAgent\n   * @see transformSkill\n   * @see transformMCPServer\n   * @see transformMCPTool\n   * @see transformTask\n   */\n  private extractAttributes(strapiData: any): any {\n    // If data has attributes property, use it (Strapi 5 default format)\n    if (strapiData.attributes) {\n      return strapiData.attributes;\n    }\n\n    // Otherwise, data is already flat (some Strapi configurations)\n    return strapiData;\n  }\n\n  /**\n   * Transform Strapi agent response to Agent domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's Agent domain model.\n   * Handles component-based structure including toolConfig, modelConfig, analytics, metadata,\n   * mcpConfig (component with nested MCP server and tool relations), skillSelection, and tasks.\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'agent-uuid',\n   *   attributes: {\n   *     name: string,\n   *     slug: string,\n   *     description: string,\n   *     systemPrompt: string,\n   *     enabled: boolean,\n   *     toolConfig: { allowedTools: string[], ... },\n   *     modelConfig: { model: string, temperature: number, ... },\n   *     analytics: { tokenUsage: number, ... },\n   *     metadata: [{ key: string, value: string }],\n   *     mcpConfig: [{ mcpServer: { data: {...} }, selectedTools: [...] }],\n   *     skillSelection: [{ skill: { data: {...} }, ... }],\n   *     tasks: [{ data: {...} }],\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   name: string,\n   *   slug: string,\n   *   description: string,\n   *   systemPrompt: string,\n   *   enabled: boolean,\n   *   toolConfig?: {...},\n   *   modelConfig: {...},\n   *   analytics?: {...},\n   *   metadata?: [...],\n   *   mcpConfig: [...],\n   *   skillSelection: [...],\n   *   tasks: [...],\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed Agent object ready for application use\n   *\n   * @example\n   * // Transform basic agent\n   * const strapiResponse = {\n   *   documentId: 'agent-123',\n   *   attributes: {\n   *     name: 'Research Agent',\n   *     slug: 'research-agent',\n   *     description: 'Agent for research tasks',\n   *     systemPrompt: 'You are a research assistant',\n   *     enabled: true,\n   *     modelConfig: {\n   *       model: 'sonnet',\n   *       temperature: 1.0,\n   *       timeout: 300000\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const agent = this.transformAgent(strapiResponse);\n   * // Returns: {\n   * //   id: 'agent-123',\n   * //   name: 'Research Agent',\n   * //   slug: 'research-agent',\n   * //   description: 'Agent for research tasks',\n   * //   systemPrompt: 'You are a research assistant',\n   * //   enabled: true,\n   * //   modelConfig: { model: 'sonnet', temperature: 1.0, timeout: 300000 },\n   * //   mcpConfig: [],\n   * //   skillSelection: [],\n   * //   tasks: [],\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform agent with component fields\n   * const strapiResponse = {\n   *   documentId: 'agent-456',\n   *   attributes: {\n   *     name: 'Code Agent',\n   *     slug: 'code-agent',\n   *     description: 'Agent for code generation',\n   *     systemPrompt: 'You are a coding assistant',\n   *     enabled: true,\n   *     toolConfig: {\n   *       allowedTools: ['bash', 'read', 'write'],\n   *       maxToolCalls: 50\n   *     },\n   *     modelConfig: {\n   *       model: 'opus',\n   *       temperature: 0.7,\n   *       timeout: 600000\n   *     },\n   *     analytics: {\n   *       totalConversations: 42,\n   *       tokenUsage: 150000\n   *     },\n   *     metadata: [\n   *       { key: 'version', value: '2.0' },\n   *       { key: 'author', value: 'team' }\n   *     ],\n   *     mcpConfig: [\n   *       {\n   *         mcpServer: {\n   *           data: {\n   *             documentId: 'mcp-server-1',\n   *             attributes: { name: 'filesystem' }\n   *           }\n   *         },\n   *         selectedTools: [\n   *           { mcpTool: { data: { documentId: 'tool-1' } } }\n   *         ]\n   *       }\n   *     ],\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const agent = this.transformAgent(strapiResponse);\n   * // Returns agent with all component fields populated\n   *\n   * @see prepareAgentData - Reverse transformation for API requests\n   * @see getAllAgents\n   * @see getAgent\n   */\n  private transformAgent(strapiData: StrapiAttributes<any>): Agent {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      slug: attrs.slug,\n      description: attrs.description || '',\n      systemPrompt: attrs.systemPrompt,\n      enabled: attrs.enabled ?? true,\n\n      // Component fields - pass through as-is\n      toolConfig: attrs.toolConfig || undefined,\n      modelConfig: attrs.modelConfig || {\n        model: 'sonnet',\n        temperature: 1.0,\n        timeout: 300000,\n      },\n      analytics: attrs.analytics || undefined,\n      metadata: attrs.metadata || [],\n\n      // Component-based relations - pass through as-is\n      mcpConfig: attrs.mcpConfig || [],\n      skillSelection: attrs.skillSelection || [],\n      tasks: attrs.tasks || [],\n\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi skill response to Skill domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's Skill domain model.\n   * Handles component-based structure including trainingHistory (training records), additionalFiles\n   * (file attachments with file relation), agentSelection, toolConfig, modelConfig, analytics,\n   * mcpConfig, tasks, and inputFields (dynamic form fields).\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'skill-uuid',\n   *   attributes: {\n   *     name: string,\n   *     displayName: string,\n   *     description: string,\n   *     skillmd: string,\n   *     skillConfig?: { systemPromptPrefix: string, ... },\n   *     experienceScore: number,\n   *     category: string,\n   *     isPublic: boolean,\n   *     version: string,\n   *     license?: string,\n   *     trainingHistory: [{ timestamp: string, agentId: string, ... }],\n   *     additionalFiles: [{ file: { data: {...} }, description: string }],\n   *     agentSelection: [{ agent: { data: {...} }, ... }],\n   *     toolConfig?: {...},\n   *     modelConfig?: {...},\n   *     analytics?: {...},\n   *     mcpConfig: [...],\n   *     tasks: [...],\n   *     inputFields: [{ name: string, type: string, ... }],\n   *     trainingAgent?: { data: { documentId: string } } | string,\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   name: string,\n   *   displayName: string,\n   *   description: string,\n   *   skillmd: string,\n   *   skillConfig?: {...},\n   *   experienceScore: number,\n   *   category: string,\n   *   isPublic: boolean,\n   *   version: string,\n   *   license?: string,\n   *   trainingHistory: [...],\n   *   additionalFiles: [...],\n   *   agentSelection: [...],\n   *   toolConfig?: {...},\n   *   modelConfig?: {...},\n   *   analytics?: {...},\n   *   mcpConfig: [...],\n   *   tasks: [...],\n   *   inputFields: [...],\n   *   trainingAgent?: string,\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed Skill object ready for application use\n   *\n   * @example\n   * // Transform basic skill\n   * const strapiResponse = {\n   *   documentId: 'skill-123',\n   *   attributes: {\n   *     name: 'git-workflow',\n   *     displayName: 'Git Workflow',\n   *     description: 'Manage git operations',\n   *     skillmd: '# Git Workflow\\n\\nManage git operations...',\n   *     experienceScore: 85,\n   *     category: 'development',\n   *     isPublic: true,\n   *     version: '1.0.0',\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const skill = this.transformSkill(strapiResponse);\n   * // Returns: {\n   * //   id: 'skill-123',\n   * //   name: 'git-workflow',\n   * //   displayName: 'Git Workflow',\n   * //   description: 'Manage git operations',\n   * //   skillmd: '# Git Workflow\\n\\nManage git operations...',\n   * //   experienceScore: 85,\n   * //   category: 'development',\n   * //   isPublic: true,\n   * //   version: '1.0.0',\n   * //   trainingHistory: [],\n   * //   additionalFiles: [],\n   * //   ...\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform skill with component fields\n   * const strapiResponse = {\n   *   documentId: 'skill-456',\n   *   attributes: {\n   *     name: 'api-testing',\n   *     displayName: 'API Testing',\n   *     description: 'Test REST APIs',\n   *     skillmd: '# API Testing\\n\\nTest REST APIs...',\n   *     skillConfig: {\n   *       systemPromptPrefix: 'You are an API testing expert'\n   *     },\n   *     experienceScore: 92,\n   *     category: 'testing',\n   *     isPublic: true,\n   *     version: '2.0.0',\n   *     license: 'MIT',\n   *     trainingHistory: [\n   *       {\n   *         timestamp: '2024-01-15T10:30:00.000Z',\n   *         agentId: 'agent-1',\n   *         feedback: 'positive',\n   *         experienceGained: 5\n   *       }\n   *     ],\n   *     additionalFiles: [\n   *       {\n   *         file: {\n   *           data: {\n   *             documentId: 'file-1',\n   *             attributes: { name: 'examples.json', url: '/uploads/...' }\n   *           }\n   *         },\n   *         description: 'API test examples'\n   *       }\n   *     ],\n   *     inputFields: [\n   *       { name: 'apiUrl', type: 'text', label: 'API URL', required: true },\n   *       { name: 'method', type: 'select', options: ['GET', 'POST', 'PUT', 'DELETE'] }\n   *     ],\n   *     trainingAgent: {\n   *       data: { documentId: 'agent-123' }\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-15T10:30:00.000Z'\n   *   }\n   * };\n   * const skill = this.transformSkill(strapiResponse);\n   * // Returns skill with all component fields populated\n   * // trainingAgent is normalized to 'agent-123'\n   *\n   * @see prepareSkillData - Reverse transformation for API requests\n   * @see getAllSkills\n   * @see getSkill\n   */\n  private transformSkill(strapiData: StrapiAttributes<any>): Skill {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      displayName: attrs.displayName,\n      description: attrs.description,\n      skillmd: attrs.skillmd, // Correct field name\n      skillConfig: attrs.skillConfig || undefined, // Add skillConfig (replaces systemPromptPrefix)\n      experienceScore: attrs.experienceScore || 0,\n      category: attrs.category || 'custom',\n      isPublic: attrs.isPublic ?? true,\n      version: attrs.version || '1.0.0',\n      license: attrs.license || undefined,\n\n      // Component fields - pass through as-is\n      trainingHistory: attrs.trainingHistory || [],\n      additionalFiles: attrs.additionalFiles || [],\n      agentSelection: attrs.agentSelection || [],\n      toolConfig: attrs.toolConfig || undefined,\n      modelConfig: attrs.modelConfig || undefined,\n      analytics: attrs.analytics || undefined,\n      mcpConfig: attrs.mcpConfig || [],\n      tasks: attrs.tasks || [],\n      inputFields: attrs.inputFields || [],\n\n      // Direct relation\n      trainingAgent: attrs.trainingAgent?.data?.documentId || attrs.trainingAgent,\n\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi MCP server response to MCPServer domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's MCPServer domain model.\n   * Handles both stdio and SDK transport types, builds config object for frontend compatibility,\n   * and recursively transforms nested mcpTools relation when populated.\n   *\n   * **Key Transformations:**\n   * - Creates `config` object with transport-specific fields for frontend use\n   * - Handles nested `mcpTools` relation (can be array or `{ data: [...] }` format)\n   * - Recursively transforms each tool using `transformMCPTool()`\n   * - Converts ISO date strings to Date objects\n   * - Normalizes disabled/enabled state\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'mcp-server-uuid',\n   *   attributes: {\n   *     name: string,\n   *     command: string,\n   *     description: string,\n   *     args: string[],\n   *     env: Record<string, string>,\n   *     disabled: boolean,\n   *     transport: 'stdio' | 'sse',\n   *     healthCheckUrl?: string,\n   *     isHealthy: boolean,\n   *     lastHealthCheck?: string,\n   *     startupTimeout: number,\n   *     restartPolicy: string,\n   *     toolsFetchedAt?: string,\n   *     mcpTools?: { data: [...] } | [...],\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   name: string,\n   *   config: {\n   *     type: 'stdio' | 'sse',\n   *     command: string,\n   *     args: string[],\n   *     env: Record<string, string>,\n   *     disabled: boolean\n   *   },\n   *   command: string,\n   *   description: string,\n   *   args: string[],\n   *   env: Record<string, string>,\n   *   disabled: boolean,\n   *   transport: 'stdio' | 'sse',\n   *   healthCheckUrl?: string,\n   *   isHealthy: boolean,\n   *   lastHealthCheck?: Date,\n   *   startupTimeout: number,\n   *   restartPolicy: string,\n   *   toolsFetchedAt?: Date,\n   *   mcpTools?: MCPTool[],\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed MCPServer object ready for application use\n   *\n   * @example\n   * // Transform stdio MCP server\n   * const strapiResponse = {\n   *   documentId: 'mcp-server-123',\n   *   attributes: {\n   *     name: 'filesystem',\n   *     command: 'npx',\n   *     description: 'File system MCP server',\n   *     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *     env: { DEBUG: '1' },\n   *     disabled: false,\n   *     transport: 'stdio',\n   *     isHealthy: true,\n   *     startupTimeout: 30000,\n   *     restartPolicy: 'on-failure',\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const mcpServer = this.transformMCPServer(strapiResponse);\n   * // Returns: {\n   * //   id: 'mcp-server-123',\n   * //   name: 'filesystem',\n   * //   config: {\n   * //     type: 'stdio',\n   * //     command: 'npx',\n   * //     args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   * //     env: { DEBUG: '1' },\n   * //     disabled: false\n   * //   },\n   * //   command: 'npx',\n   * //   description: 'File system MCP server',\n   * //   ...\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform MCP server with populated tools (nested data format)\n   * const strapiResponse = {\n   *   documentId: 'mcp-server-456',\n   *   attributes: {\n   *     name: 'github',\n   *     command: 'npx',\n   *     description: 'GitHub MCP server',\n   *     args: ['-y', '@modelcontextprotocol/server-github'],\n   *     env: { GITHUB_TOKEN: '${GITHUB_TOKEN}' },\n   *     disabled: false,\n   *     transport: 'stdio',\n   *     isHealthy: true,\n   *     toolsFetchedAt: '2024-01-15T10:30:00.000Z',\n   *     mcpTools: {\n   *       data: [\n   *         {\n   *           documentId: 'tool-1',\n   *           attributes: {\n   *             name: 'create_issue',\n   *             description: 'Create GitHub issue',\n   *             inputSchema: { type: 'object', properties: {...} }\n   *           }\n   *         },\n   *         {\n   *           documentId: 'tool-2',\n   *           attributes: {\n   *             name: 'list_repos',\n   *             description: 'List repositories'\n   *           }\n   *         }\n   *       ]\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-15T10:30:00.000Z'\n   *   }\n   * };\n   * const mcpServer = this.transformMCPServer(strapiResponse);\n   * // Returns MCP server with mcpTools array populated with 2 transformed tools\n   * // Each tool is transformed via transformMCPTool()\n   *\n   * @example\n   * // Transform MCP server with populated tools (flat array format)\n   * const strapiResponse = {\n   *   documentId: 'mcp-server-789',\n   *   attributes: {\n   *     name: 'slack',\n   *     command: 'npx',\n   *     args: ['-y', '@modelcontextprotocol/server-slack'],\n   *     transport: 'stdio',\n   *     mcpTools: [  // Flat array (some Strapi configurations)\n   *       {\n   *         documentId: 'tool-3',\n   *         attributes: { name: 'send_message', description: 'Send Slack message' }\n   *       }\n   *     ],\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const mcpServer = this.transformMCPServer(strapiResponse);\n   * // Handles flat array format - mcpTools array populated with 1 transformed tool\n   *\n   * @see transformMCPTool - Used to transform nested tools\n   * @see prepareMCPServerData - Reverse transformation for API requests\n   * @see getAllMCPServers\n   * @see getMCPServer\n   */\n  private transformMCPServer(strapiData: StrapiAttributes<any>): MCPServer {\n    const attrs = this.extractAttributes(strapiData);\n\n    // Create config object based on transport type to match frontend expectations\n    const config: any = {\n      type: attrs.transport || 'stdio',\n      command: attrs.command,\n      args: attrs.args || [],\n      env: attrs.env || {},\n      disabled: attrs.disabled ?? false,\n    };\n\n    // Transform mcpTools if populated\n    let mcpTools: MCPTool[] | undefined;\n    if (attrs.mcpTools) {\n      if (Array.isArray(attrs.mcpTools)) {\n        mcpTools = attrs.mcpTools.map((tool: any) => this.transformMCPTool(tool));\n      } else if (attrs.mcpTools.data && Array.isArray(attrs.mcpTools.data)) {\n        mcpTools = attrs.mcpTools.data.map((tool: any) => this.transformMCPTool(tool));\n      }\n    }\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      config: config,\n      command: attrs.command,\n      description: attrs.description || '',\n      args: attrs.args || [],\n      env: attrs.env || {},\n      disabled: attrs.disabled ?? false,\n      transport: attrs.transport || 'stdio',\n      healthCheckUrl: attrs.healthCheckUrl,\n      isHealthy: attrs.isHealthy ?? true,\n      lastHealthCheck: attrs.lastHealthCheck ? new Date(attrs.lastHealthCheck) : undefined,\n      startupTimeout: attrs.startupTimeout || 30000,\n      restartPolicy: attrs.restartPolicy || 'on-failure',\n      toolsFetchedAt: attrs.toolsFetchedAt ? new Date(attrs.toolsFetchedAt) : undefined,\n      mcpTools: mcpTools,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    } as MCPServer;\n  }\n\n  /**\n   * Transform Strapi MCP tool response to MCPTool domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's MCPTool domain model.\n   * Handles tool metadata including name, description, JSON schema for input validation, and\n   * parent MCP server relation. Used both directly and as a helper for transformMCPServer.\n   *\n   * **Key Transformations:**\n   * - Normalizes `mcpServer` relation (handles both nested and flat formats)\n   * - Preserves `inputSchema` as-is (JSON Schema object for tool parameter validation)\n   * - Converts ISO date strings to Date objects\n   * - Sets undefined for optional fields instead of null\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'mcp-tool-uuid',\n   *   attributes: {\n   *     name: string,\n   *     description?: string,\n   *     inputSchema?: object,  // JSON Schema\n   *     mcpServer?: { documentId: string } | { data: { documentId: string } },\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   name: string,\n   *   description?: string,\n   *   inputSchema?: object,  // JSON Schema for parameter validation\n   *   mcpServer?: string,    // MCP server documentId\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed MCPTool object ready for application use\n   *\n   * @example\n   * // Transform basic MCP tool (no schema)\n   * const strapiResponse = {\n   *   documentId: 'tool-123',\n   *   attributes: {\n   *     name: 'list_files',\n   *     description: 'List files in a directory',\n   *     mcpServer: {\n   *       documentId: 'mcp-server-1'\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const tool = this.transformMCPTool(strapiResponse);\n   * // Returns: {\n   * //   id: 'tool-123',\n   * //   name: 'list_files',\n   * //   description: 'List files in a directory',\n   * //   inputSchema: undefined,\n   * //   mcpServer: 'mcp-server-1',\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform MCP tool with JSON Schema\n   * const strapiResponse = {\n   *   documentId: 'tool-456',\n   *   attributes: {\n   *     name: 'create_issue',\n   *     description: 'Create GitHub issue',\n   *     inputSchema: {\n   *       type: 'object',\n   *       properties: {\n   *         title: { type: 'string', description: 'Issue title' },\n   *         body: { type: 'string', description: 'Issue body' },\n   *         labels: { type: 'array', items: { type: 'string' } }\n   *       },\n   *       required: ['title', 'body']\n   *     },\n   *     mcpServer: {\n   *       data: {  // Nested data format\n   *         documentId: 'mcp-server-github'\n   *       }\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-15T10:30:00.000Z'\n   *   }\n   * };\n   * const tool = this.transformMCPTool(strapiResponse);\n   * // Returns tool with inputSchema preserved as JSON Schema object\n   * // mcpServer is normalized to 'mcp-server-github'\n   *\n   * @example\n   * // Transform MCP tool without server relation\n   * const strapiResponse = {\n   *   documentId: 'tool-789',\n   *   attributes: {\n   *     name: 'send_message',\n   *     description: 'Send Slack message',\n   *     inputSchema: {\n   *       type: 'object',\n   *       properties: {\n   *         channel: { type: 'string' },\n   *         text: { type: 'string' }\n   *       }\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const tool = this.transformMCPTool(strapiResponse);\n   * // Returns tool with mcpServer: undefined (orphaned tool)\n   *\n   * @see transformMCPServer - Uses this method to transform nested tools\n   * @see createMCPTool\n   * @see getMCPToolsByServerId\n   */\n  private transformMCPTool(strapiData: StrapiAttributes<any>): MCPTool {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      description: attrs.description || undefined,\n      inputSchema: attrs.inputSchema || undefined,\n      mcpServer: attrs.mcpServer?.documentId || attrs.mcpServer?.data?.documentId || undefined,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi task response to Task domain model\n   *\n   * @description Converts Strapi v5 API response format to the application's Task domain model.\n   * Handles task metadata, execution state, agent relation, and extracts name/description from\n   * metadata object. Supports both running and completed task states.\n   *\n   * **Key Transformations:**\n   * - Normalizes `agent` relation to `agentId` and `agentName`\n   * - Extracts `name` from metadata.name (fallback to message or 'Unnamed Task')\n   * - Extracts `description` from metadata.description\n   * - Converts ISO date strings to Date objects (startedAt, completedAt)\n   * - Preserves execution metrics (executionTime, tokensUsed, cost)\n   * - Includes executionLog array for viewing task progress\n   *\n   * **Strapi Response Format:**\n   * ```typescript\n   * {\n   *   documentId: 'task-uuid',\n   *   attributes: {\n   *     agent?: { documentId: string, name: string } | { data: {...} },\n   *     agentId?: string,\n   *     message: string,\n   *     status: 'pending' | 'running' | 'completed' | 'failed',\n   *     result?: string,\n   *     error?: string,\n   *     startedAt?: string,\n   *     completedAt?: string,\n   *     executionTime?: number,\n   *     tokensUsed?: number,\n   *     cost?: number,\n   *     metadata?: { name?: string, description?: string, ... },\n   *     executionLog?: Array<{ timestamp: string, message: string }>,\n   *     createdAt: string,\n   *     updatedAt: string\n   *   }\n   * }\n   * ```\n   *\n   * **Domain Model Format:**\n   * ```typescript\n   * {\n   *   id: string,\n   *   agentId?: string,\n   *   agentName?: string,\n   *   name: string,\n   *   description?: string,\n   *   message: string,\n   *   status: 'pending' | 'running' | 'completed' | 'failed',\n   *   result?: string,\n   *   error?: string,\n   *   startedAt?: Date,\n   *   completedAt?: Date,\n   *   executionTime?: number,\n   *   tokensUsed?: number,\n   *   cost?: number,\n   *   metadata: object,\n   *   executionLog: Array<object>,\n   *   createdAt: Date,\n   *   updatedAt: Date\n   * }\n   * ```\n   *\n   * @param strapiData - Raw Strapi response data with nested attributes\n   * @returns Transformed Task object ready for application use\n   *\n   * @example\n   * // Transform pending task\n   * const strapiResponse = {\n   *   documentId: 'task-123',\n   *   attributes: {\n   *     agent: {\n   *       documentId: 'agent-1',\n   *       name: 'Research Agent'\n   *     },\n   *     message: 'Research latest AI trends',\n   *     status: 'pending',\n   *     metadata: {\n   *       name: 'AI Trends Research',\n   *       description: 'Gather info on latest AI developments',\n   *       priority: 'high'\n   *     },\n   *     createdAt: '2024-01-01T00:00:00.000Z',\n   *     updatedAt: '2024-01-01T00:00:00.000Z'\n   *   }\n   * };\n   * const task = this.transformTask(strapiResponse);\n   * // Returns: {\n   * //   id: 'task-123',\n   * //   agentId: 'agent-1',\n   * //   agentName: 'Research Agent',\n   * //   name: 'AI Trends Research',\n   * //   description: 'Gather info on latest AI developments',\n   * //   message: 'Research latest AI trends',\n   * //   status: 'pending',\n   * //   metadata: { name: '...', description: '...', priority: 'high' },\n   * //   executionLog: [],\n   * //   createdAt: Date object,\n   * //   updatedAt: Date object\n   * // }\n   *\n   * @example\n   * // Transform completed task with metrics\n   * const strapiResponse = {\n   *   documentId: 'task-456',\n   *   attributes: {\n   *     agent: {\n   *       data: {\n   *         documentId: 'agent-2',\n   *         attributes: { name: 'Code Agent' }\n   *       }\n   *     },\n   *     message: 'Generate unit tests',\n   *     status: 'completed',\n   *     result: 'Successfully generated 15 unit tests',\n   *     startedAt: '2024-01-15T10:00:00.000Z',\n   *     completedAt: '2024-01-15T10:05:30.000Z',\n   *     executionTime: 330000,  // milliseconds\n   *     tokensUsed: 12500,\n   *     cost: 0.025,\n   *     metadata: {\n   *       name: 'Unit Test Generation',\n   *       description: 'Generate comprehensive unit tests for user service'\n   *     },\n   *     executionLog: [\n   *       { timestamp: '2024-01-15T10:00:00.000Z', message: 'Task started' },\n   *       { timestamp: '2024-01-15T10:02:00.000Z', message: 'Analyzing code structure' },\n   *       { timestamp: '2024-01-15T10:05:30.000Z', message: 'Tests generated' }\n   *     ],\n   *     createdAt: '2024-01-15T09:55:00.000Z',\n   *     updatedAt: '2024-01-15T10:05:30.000Z'\n   *   }\n   * };\n   * const task = this.transformTask(strapiResponse);\n   * // Returns completed task with execution metrics and log\n   * // executionTime: 330000ms (5.5 minutes), cost: $0.025\n   *\n   * @example\n   * // Transform failed task with error\n   * const strapiResponse = {\n   *   documentId: 'task-789',\n   *   attributes: {\n   *     agentId: 'agent-3',  // Direct ID (no populated relation)\n   *     message: 'Deploy to production',\n   *     status: 'failed',\n   *     error: 'Deployment failed: Invalid credentials',\n   *     startedAt: '2024-01-20T14:00:00.000Z',\n   *     completedAt: '2024-01-20T14:01:15.000Z',\n   *     executionTime: 75000,\n   *     metadata: {},  // No name in metadata\n   *     createdAt: '2024-01-20T13:55:00.000Z',\n   *     updatedAt: '2024-01-20T14:01:15.000Z'\n   *   }\n   * };\n   * const task = this.transformTask(strapiResponse);\n   * // Returns: {\n   * //   ...\n   * //   agentId: 'agent-3',\n   * //   agentName: undefined,  // Relation not populated\n   * //   name: 'Deploy to production',  // Fallback to message\n   * //   description: undefined,\n   * //   status: 'failed',\n   * //   error: 'Deployment failed: Invalid credentials',\n   * //   ...\n   * // }\n   *\n   * @see prepareTaskData - Reverse transformation for API requests\n   * @see getAllTasks\n   * @see getTask\n   * @see createTask\n   * @see updateTask\n   */\n  private transformTask(strapiData: StrapiAttributes<any>): Task {\n    const attrs = this.extractAttributes(strapiData);\n    const metadata = attrs.metadata || {};\n\n    return {\n      id: strapiData.documentId,\n      agentId: attrs.agent?.documentId || attrs.agent?.data?.documentId || attrs.agentId,\n      agentName: attrs.agent?.name || attrs.agent?.data?.name || undefined,\n      name: metadata.name || attrs.message || 'Unnamed Task',\n      description: metadata.description || undefined,\n      message: attrs.message,\n      status: attrs.status || 'pending',\n      result: attrs.result,\n      error: attrs.error,\n      startedAt: attrs.startedAt ? new Date(attrs.startedAt) : undefined,\n      completedAt: attrs.completedAt ? new Date(attrs.completedAt) : undefined,\n      executionTime: attrs.executionTime,\n      tokensUsed: attrs.tokensUsed,\n      cost: attrs.cost,\n      metadata: metadata,\n      executionLog: attrs.executionLog || [], // Include execution log for viewing\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  // ============= DATA PREPARERS =============\n  // Prepare domain models for Strapi API\n\n  /**\n   * Prepare agent data for Strapi API\n   *\n   * @description Prepares Agent domain model for Strapi v5 API requests (create/update operations).\n   * Reverse transformation of transformAgent - converts application format to Strapi's expected format.\n   * Automatically generates URL-friendly slug from name if provided.\n   *\n   * **Key Transformations:**\n   * - Auto-generates `slug` from `name` using generateSlug() helper\n   * - Only includes fields that are provided (partial updates supported)\n   * - Component fields (toolConfig, modelConfig, analytics, metadata) passed through as-is\n   * - Component-based relations (mcpConfig, skillSelection, tasks) passed through as-is\n   * - Omits undefined fields to support partial updates\n   *\n   * **Input (Domain Model):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   description?: string,\n   *   systemPrompt?: string,\n   *   enabled?: boolean,\n   *   toolConfig?: { allowedTools: string[], ... },\n   *   modelConfig?: { model: string, temperature: number, ... },\n   *   analytics?: { tokenUsage: number, ... },\n   *   metadata?: [{ key: string, value: string }],\n   *   mcpConfig?: [...],\n   *   skillSelection?: [...],\n   *   tasks?: [...]\n   * }\n   * ```\n   *\n   * **Output (Strapi Format):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   slug?: string,  // Auto-generated from name\n   *   description?: string,\n   *   systemPrompt?: string,\n   *   enabled?: boolean,\n   *   toolConfig?: {...},\n   *   modelConfig?: {...},\n   *   analytics?: {...},\n   *   metadata?: [...],\n   *   mcpConfig?: [...],\n   *   skillSelection?: [...],\n   *   tasks?: [...]\n   * }\n   * ```\n   *\n   * @param agent - Partial Agent object (supports partial updates)\n   * @returns Strapi-formatted data object ready for POST/PUT requests\n   *\n   * @example\n   * // Prepare basic agent for creation\n   * const agentData = {\n   *   name: 'Research Agent',\n   *   description: 'Agent for research tasks',\n   *   systemPrompt: 'You are a research assistant',\n   *   enabled: true\n   * };\n   * const strapiData = this.prepareAgentData(agentData);\n   * // Returns: {\n   * //   name: 'Research Agent',\n   * //   slug: 'research-agent',  // Auto-generated\n   * //   description: 'Agent for research tasks',\n   * //   systemPrompt: 'You are a research assistant',\n   * //   enabled: true\n   * // }\n   *\n   * @example\n   * // Prepare agent with component fields\n   * const agentData = {\n   *   name: 'Code Agent',\n   *   description: 'Agent for code generation',\n   *   systemPrompt: 'You are a coding assistant',\n   *   enabled: true,\n   *   toolConfig: {\n   *     allowedTools: ['bash', 'read', 'write'],\n   *     maxToolCalls: 50\n   *   },\n   *   modelConfig: {\n   *     model: 'opus',\n   *     temperature: 0.7,\n   *     timeout: 600000\n   *   },\n   *   metadata: [\n   *     { key: 'version', value: '2.0' },\n   *     { key: 'author', value: 'team' }\n   *   ],\n   *   mcpConfig: [\n   *     {\n   *       mcpServer: 'mcp-server-1',\n   *       selectedTools: [\n   *         { mcpTool: 'tool-1' }\n   *       ]\n   *     }\n   *   ]\n   * };\n   * const strapiData = this.prepareAgentData(agentData);\n   * // Returns Strapi-formatted data with all component fields\n   * // Component fields passed through as-is for Strapi v5\n   *\n   * @example\n   * // Prepare partial update (only update description and enabled status)\n   * const updateData = {\n   *   description: 'Updated description',\n   *   enabled: false\n   * };\n   * const strapiData = this.prepareAgentData(updateData);\n   * // Returns: {\n   * //   description: 'Updated description',\n   * //   enabled: false\n   * // }\n   * // Only includes provided fields - supports partial updates\n   * // No slug generated since name not provided\n   *\n   * @see transformAgent - Reverse transformation from Strapi to domain model\n   * @see createAgent\n   * @see updateAgent\n   */\n  private prepareAgentData(agent: Partial<Agent>) {\n    const data: any = {\n      name: agent.name,\n      description: agent.description,\n      systemPrompt: agent.systemPrompt,\n      enabled: agent.enabled,\n    };\n\n    // Generate slug from name if name is provided\n    // Strapi's auto-generation doesn't always work with programmatic API calls\n    if (agent.name) {\n      data.slug = generateSlug(agent.name);\n    }\n\n    // Component fields - pass through as-is\n    if (agent.toolConfig) {\n      data.toolConfig = agent.toolConfig;\n    }\n\n    if (agent.modelConfig) {\n      data.modelConfig = agent.modelConfig;\n    }\n\n    if (agent.analytics) {\n      data.analytics = agent.analytics;\n    }\n\n    if (agent.metadata) {\n      data.metadata = agent.metadata;\n    }\n\n    // Component-based relations\n    if (agent.mcpConfig) {\n      data.mcpConfig = agent.mcpConfig;\n    }\n\n    if (agent.skillSelection) {\n      data.skillSelection = agent.skillSelection;\n    }\n\n    if (agent.tasks) {\n      data.tasks = agent.tasks;\n    }\n\n    return data;\n  }\n\n  /**\n   * Prepare skill data for Strapi API\n   *\n   * @description Prepares Skill domain model for Strapi v5 API requests (create/update operations).\n   * Reverse transformation of transformSkill - converts application format to Strapi's expected format.\n   * Supports partial updates by only including provided fields.\n   *\n   * **Key Transformations:**\n   * - Only includes fields that are provided (partial updates supported)\n   * - Component fields (trainingHistory, additionalFiles, toolConfig, etc.) passed through as-is\n   * - Direct relation (trainingAgent) passed through as agent documentId\n   * - Omits undefined fields to support partial updates\n   *\n   * **Input (Domain Model):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   displayName?: string,\n   *   description?: string,\n   *   skillmd?: string,\n   *   experienceScore?: number,\n   *   category?: string,\n   *   isPublic?: boolean,\n   *   version?: string,\n   *   license?: string,\n   *   trainingHistory?: [...],\n   *   additionalFiles?: [...],\n   *   agentSelection?: [...],\n   *   toolConfig?: {...},\n   *   modelConfig?: {...},\n   *   analytics?: {...},\n   *   mcpConfig?: [...],\n   *   tasks?: [...],\n   *   inputFields?: [...],\n   *   trainingAgent?: string\n   * }\n   * ```\n   *\n   * **Output (Strapi Format):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   displayName?: string,\n   *   description?: string,\n   *   skillmd?: string,\n   *   experienceScore?: number,\n   *   category?: string,\n   *   isPublic?: boolean,\n   *   version?: string,\n   *   license?: string,\n   *   trainingHistory?: [...],\n   *   additionalFiles?: [...],\n   *   agentSelection?: [...],\n   *   toolConfig?: {...},\n   *   modelConfig?: {...},\n   *   analytics?: {...},\n   *   mcpConfig?: [...],\n   *   tasks?: [...],\n   *   inputFields?: [...],\n   *   trainingAgent?: string\n   * }\n   * ```\n   *\n   * @param skill - Partial Skill object (supports partial updates)\n   * @returns Strapi-formatted data object ready for POST/PUT requests\n   *\n   * @example\n   * // Prepare basic skill for creation\n   * const skillData = {\n   *   name: 'git-workflow',\n   *   displayName: 'Git Workflow',\n   *   description: 'Manage git operations',\n   *   skillmd: '# Git Workflow\\n\\nManage git operations...',\n   *   category: 'development',\n   *   isPublic: true,\n   *   version: '1.0.0'\n   * };\n   * const strapiData = this.prepareSkillData(skillData);\n   * // Returns Strapi-formatted data with all basic fields\n   *\n   * @example\n   * // Prepare skill with component fields\n   * const skillData = {\n   *   name: 'api-testing',\n   *   displayName: 'API Testing',\n   *   description: 'Test REST APIs',\n   *   skillmd: '# API Testing\\n\\nTest REST APIs...',\n   *   category: 'testing',\n   *   isPublic: true,\n   *   version: '2.0.0',\n   *   license: 'MIT',\n   *   trainingHistory: [\n   *     {\n   *       timestamp: '2024-01-15T10:30:00.000Z',\n   *       agentId: 'agent-1',\n   *       feedback: 'positive',\n   *       experienceGained: 5\n   *     }\n   *   ],\n   *   additionalFiles: [\n   *     {\n   *       file: 'file-1',  // File documentId\n   *       description: 'API test examples'\n   *     }\n   *   ],\n   *   inputFields: [\n   *     { name: 'apiUrl', type: 'text', label: 'API URL', required: true },\n   *     { name: 'method', type: 'select', options: ['GET', 'POST', 'PUT', 'DELETE'] }\n   *   ],\n   *   trainingAgent: 'agent-123'\n   * };\n   * const strapiData = this.prepareSkillData(skillData);\n   * // Returns Strapi-formatted data with all component fields\n   * // Component fields passed through as-is for Strapi v5\n   *\n   * @example\n   * // Prepare partial update (only update experience score and training history)\n   * const updateData = {\n   *   experienceScore: 95,\n   *   trainingHistory: [\n   *     ...existingHistory,\n   *     { timestamp: new Date().toISOString(), agentId: 'agent-1', feedback: 'positive', experienceGained: 3 }\n   *   ]\n   * };\n   * const strapiData = this.prepareSkillData(updateData);\n   * // Returns: {\n   * //   experienceScore: 95,\n   * //   trainingHistory: [...]\n   * // }\n   * // Only includes provided fields - supports partial updates\n   *\n   * @see transformSkill - Reverse transformation from Strapi to domain model\n   * @see createSkill\n   * @see updateSkill\n   */\n  private prepareSkillData(skill: Partial<Skill>) {\n    const data: any = {\n      name: skill.name,\n      displayName: skill.displayName,\n      description: skill.description,\n      skillmd: skill.skillmd, // Correct field name\n      experienceScore: skill.experienceScore,\n      category: skill.category,\n      isPublic: skill.isPublic,\n      version: skill.version,\n      license: skill.license,\n    };\n\n    // Component fields\n    if (skill.trainingHistory) {\n      data.trainingHistory = skill.trainingHistory;\n    }\n\n    if (skill.additionalFiles) {\n      data.additionalFiles = skill.additionalFiles;\n    }\n\n    if (skill.agentSelection) {\n      data.agentSelection = skill.agentSelection;\n    }\n\n    if (skill.toolConfig) {\n      data.toolConfig = skill.toolConfig;\n    }\n\n    if (skill.modelConfig) {\n      data.modelConfig = skill.modelConfig;\n    }\n\n    if (skill.analytics) {\n      data.analytics = skill.analytics;\n    }\n\n    if (skill.mcpConfig) {\n      data.mcpConfig = skill.mcpConfig;\n    }\n\n    if (skill.tasks) {\n      data.tasks = skill.tasks;\n    }\n\n    if (skill.inputFields) {\n      data.inputFields = skill.inputFields;\n    }\n\n    // Direct relation\n    if (skill.trainingAgent) {\n      data.trainingAgent = skill.trainingAgent;\n    }\n\n    return data;\n  }\n\n  /**\n   * Prepare MCP server data for Strapi API\n   *\n   * @description Prepares MCPServer domain model for Strapi v5 API requests (create/update operations).\n   * Reverse transformation of transformMCPServer - converts application format to Strapi's expected format.\n   * Only includes core MCP server configuration fields (no nested tools).\n   *\n   * **Key Transformations:**\n   * - Only includes fields that are provided (partial updates supported)\n   * - Omits `config` object (frontend-specific, not stored in Strapi)\n   * - Omits `mcpTools` relation (managed separately via createMCPTool/bulkSyncMCPTools)\n   * - Omits computed fields (isHealthy, lastHealthCheck, toolsFetchedAt)\n   * - Preserves transport type, command, args, env for stdio/SDK servers\n   *\n   * **Input (Domain Model):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   command?: string,\n   *   description?: string,\n   *   args?: string[],\n   *   env?: Record<string, string>,\n   *   disabled?: boolean,\n   *   transport?: 'stdio' | 'sse',\n   *   healthCheckUrl?: string,\n   *   startupTimeout?: number,\n   *   restartPolicy?: string\n   * }\n   * ```\n   *\n   * **Output (Strapi Format):**\n   * ```typescript\n   * {\n   *   name?: string,\n   *   command?: string,\n   *   description?: string,\n   *   args?: string[],\n   *   env?: Record<string, string>,\n   *   disabled?: boolean,\n   *   transport?: 'stdio' | 'sse',\n   *   healthCheckUrl?: string,\n   *   startupTimeout?: number,\n   *   restartPolicy?: string\n   * }\n   * ```\n   *\n   * @param mcp - Partial MCPServer object (supports partial updates)\n   * @returns Strapi-formatted data object ready for POST/PUT requests\n   *\n   * @example\n   * // Prepare stdio MCP server for creation\n   * const mcpServerData = {\n   *   name: 'filesystem',\n   *   command: 'npx',\n   *   description: 'File system MCP server',\n   *   args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp'],\n   *   env: { DEBUG: '1' },\n   *   disabled: false,\n   *   transport: 'stdio',\n   *   startupTimeout: 30000,\n   *   restartPolicy: 'on-failure'\n   * };\n   * const strapiData = this.prepareMCPServerData(mcpServerData);\n   * // Returns Strapi-formatted data with all fields\n   *\n   * @example\n   * // Prepare MCP server with environment variables\n   * const mcpServerData = {\n   *   name: 'github',\n   *   command: 'npx',\n   *   description: 'GitHub MCP server',\n   *   args: ['-y', '@modelcontextprotocol/server-github'],\n   *   env: {\n   *     GITHUB_TOKEN: '${GITHUB_TOKEN}',  // Environment variable substitution\n   *     GITHUB_REPO: 'owner/repo'\n   *   },\n   *   transport: 'stdio'\n   * };\n   * const strapiData = this.prepareMCPServerData(mcpServerData);\n   * // Returns Strapi-formatted data\n   * // Environment variables will be substituted at runtime by MCPService\n   *\n   * @example\n   * // Prepare partial update (only update disabled status and description)\n   * const updateData = {\n   *   disabled: true,\n   *   description: 'Temporarily disabled for maintenance'\n   * };\n   * const strapiData = this.prepareMCPServerData(updateData);\n   * // Returns: {\n   * //   disabled: true,\n   * //   description: 'Temporarily disabled for maintenance'\n   * // }\n   * // Only includes provided fields - supports partial updates\n   *\n   * @see transformMCPServer - Reverse transformation from Strapi to domain model\n   * @see createMCPServer\n   * @see updateMCPServer\n   * @see bulkSyncMCPTools - Used to sync nested tools separately\n   */\n  private prepareMCPServerData(mcp: Partial<MCPServer>) {\n    return {\n      name: mcp.name,\n      command: mcp.command,\n      description: mcp.description,\n      args: mcp.args,\n      env: mcp.env,\n      disabled: mcp.disabled,\n      transport: mcp.transport,\n      healthCheckUrl: mcp.healthCheckUrl,\n      startupTimeout: mcp.startupTimeout,\n      restartPolicy: mcp.restartPolicy,\n    };\n  }\n\n  /**\n   * Prepare task data for Strapi API\n   *\n   * @description Prepares Task domain model for Strapi v5 API requests (create/update operations).\n   * Reverse transformation of transformTask - converts application format to Strapi's expected format.\n   * Handles Date-to-ISO string conversion and agentId-to-agent relation mapping.\n   *\n   * **Key Transformations:**\n   * - Maps `agentId` (domain model) to `agent` (Strapi relation field)\n   * - Converts Date objects to ISO 8601 strings (startedAt, completedAt)\n   * - Passes through ISO strings unchanged if already strings\n   * - Preserves execution metrics (executionTime, tokensUsed, cost)\n   * - Includes metadata and executionLog for task tracking\n   *\n   * **Input (Domain Model):**\n   * ```typescript\n   * {\n   *   agentId?: string,\n   *   message?: string,\n   *   status?: 'pending' | 'running' | 'completed' | 'failed',\n   *   result?: string,\n   *   error?: string,\n   *   startedAt?: Date | string,\n   *   completedAt?: Date | string,\n   *   executionTime?: number,\n   *   tokensUsed?: number,\n   *   cost?: number,\n   *   metadata?: object,\n   *   executionLog?: Array<object>\n   * }\n   * ```\n   *\n   * **Output (Strapi Format):**\n   * ```typescript\n   * {\n   *   agent?: string,  // Relation field (documentId)\n   *   message?: string,\n   *   status?: 'pending' | 'running' | 'completed' | 'failed',\n   *   result?: string,\n   *   error?: string,\n   *   startedAt?: string,  // ISO 8601 string\n   *   completedAt?: string,  // ISO 8601 string\n   *   executionTime?: number,\n   *   tokensUsed?: number,\n   *   cost?: number,\n   *   metadata?: object,\n   *   executionLog?: Array<object>\n   * }\n   * ```\n   *\n   * @param task - Partial Task object (supports partial updates)\n   * @returns Strapi-formatted data object ready for POST/PUT requests\n   *\n   * @example\n   * // Prepare new task for creation\n   * const taskData = {\n   *   agentId: 'agent-123',\n   *   message: 'Research latest AI trends',\n   *   status: 'pending',\n   *   metadata: {\n   *     name: 'AI Trends Research',\n   *     description: 'Gather info on latest AI developments',\n   *     priority: 'high'\n   *   }\n   * };\n   * const strapiData = this.prepareTaskData(taskData);\n   * // Returns: {\n   * //   agent: 'agent-123',  // Mapped from agentId\n   * //   message: 'Research latest AI trends',\n   * //   status: 'pending',\n   * //   metadata: { name: '...', description: '...', priority: 'high' }\n   * // }\n   *\n   * @example\n   * // Prepare task status update with Date objects\n   * const updateData = {\n   *   status: 'completed',\n   *   result: 'Successfully generated 15 unit tests',\n   *   startedAt: new Date('2024-01-15T10:00:00.000Z'),\n   *   completedAt: new Date('2024-01-15T10:05:30.000Z'),\n   *   executionTime: 330000,  // 5.5 minutes in milliseconds\n   *   tokensUsed: 12500,\n   *   cost: 0.025\n   * };\n   * const strapiData = this.prepareTaskData(updateData);\n   * // Returns: {\n   * //   status: 'completed',\n   * //   result: 'Successfully generated 15 unit tests',\n   * //   startedAt: '2024-01-15T10:00:00.000Z',  // Date converted to ISO string\n   * //   completedAt: '2024-01-15T10:05:30.000Z',  // Date converted to ISO string\n   * //   executionTime: 330000,\n   * //   tokensUsed: 12500,\n   * //   cost: 0.025\n   * // }\n   *\n   * @example\n   * // Prepare task with execution log\n   * const updateData = {\n   *   status: 'running',\n   *   startedAt: new Date(),\n   *   executionLog: [\n   *     { timestamp: new Date().toISOString(), message: 'Task started' },\n   *     { timestamp: new Date().toISOString(), message: 'Analyzing code structure' }\n   *   ]\n   * };\n   * const strapiData = this.prepareTaskData(updateData);\n   * // Returns task data with executionLog for real-time progress tracking\n   *\n   * @example\n   * // Prepare failed task update\n   * const updateData = {\n   *   status: 'failed',\n   *   error: 'Deployment failed: Invalid credentials',\n   *   completedAt: new Date(),\n   *   executionTime: 75000\n   * };\n   * const strapiData = this.prepareTaskData(updateData);\n   * // Returns: {\n   * //   status: 'failed',\n   * //   error: 'Deployment failed: Invalid credentials',\n   * //   completedAt: '2024-01-20T14:01:15.000Z',\n   * //   executionTime: 75000\n   * // }\n   *\n   * @see transformTask - Reverse transformation from Strapi to domain model\n   * @see createTask\n   * @see updateTask\n   */\n  private prepareTaskData(task: Partial<Task>) {\n    return {\n      agent: task.agentId,  // Strapi expects 'agent' relation field\n      message: task.message,\n      status: task.status,\n      result: task.result,\n      error: task.error,\n      startedAt: task.startedAt instanceof Date ? task.startedAt.toISOString() : task.startedAt,\n      completedAt: task.completedAt instanceof Date ? task.completedAt.toISOString() : task.completedAt,\n      executionTime: task.executionTime,\n      tokensUsed: task.tokensUsed,\n      cost: task.cost,\n      metadata: task.metadata,\n      executionLog: task.executionLog, // Include execution log for viewing\n    };\n  }\n\n  // ============= QUERY BUILDERS =============\n\n  /**\n   * Build Strapi query parameters from options\n   */\n  private buildQueryParams(options?: {\n    populate?: string[] | Record<string, any>;\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Record<string, any> {\n    const params: Record<string, any> = {};\n\n    if (options?.populate) {\n      // Strapi v5 requires array bracket notation: populate[0]=field1&populate[1]=field2\n      // Pass array directly, axios will serialize it correctly\n      params.populate = options.populate;\n    }\n\n    if (options?.filters) {\n      params.filters = options.filters;\n    }\n\n    if (options?.sort) {\n      params.sort = options.sort;\n    }\n\n    if (options?.pagination) {\n      params.pagination = options.pagination;\n    }\n\n    return params;\n  }\n\n  // ============= CACHE MANAGEMENT =============\n\n  /**\n   * Invalidate all cache entries with a given prefix\n   */\n  private invalidateCache(prefix: string) {\n    const keys = Array.from(this.cache.keys());\n    let invalidatedCount = 0;\n\n    for (const key of keys) {\n      if (typeof key === 'string' && key.startsWith(prefix)) {\n        this.cache.delete(key);\n        invalidatedCount++;\n      }\n    }\n\n    if (invalidatedCount > 0) {\n      console.log(`[Strapi] Invalidated ${invalidatedCount} cache entries with prefix \"${prefix}\"`);\n    }\n  }\n\n  /**\n   * Clear all cache entries\n   *\n   * @description\n   * Clears all entries from the LRU cache, forcing fresh API requests on next data access.\n   * Use this method when you need to ensure data freshness after external changes to Strapi\n   * data (e.g., manual edits in Strapi Admin Panel, bulk imports, database migrations).\n   *\n   * **Cache Configuration:**\n   * - TTL: 5 minutes (300,000ms)\n   * - Max Size: 100 entries\n   * - Eviction: LRU (Least Recently Used)\n   *\n   * **When to Clear Cache:**\n   * - After bulk data operations outside this client\n   * - When debugging stale data issues\n   * - After importing/migrating data to Strapi\n   * - Manual refresh triggered by user action\n   * - Testing scenarios requiring fresh data\n   *\n   * **Note:**\n   * - Cache is automatically invalidated on mutations (create/update/delete)\n   * - Individual cache entries auto-expire after 5 minutes\n   * - Clearing cache forces all subsequent requests to hit the API\n   *\n   * @returns {void}\n   *\n   * @example\n   * // Basic cache clear\n   * strapiClient.clearCache();\n   * console.log('Cache cleared - next requests will fetch fresh data');\n   *\n   * @example\n   * // Clear cache after external data modification\n   * // (e.g., after manual edits in Strapi Admin Panel)\n   * async function refreshData() {\n   *   strapiClient.clearCache();\n   *\n   *   // Subsequent requests fetch fresh data from API\n   *   const agents = await strapiClient.getAllAgents();\n   *   const skills = await strapiClient.getAllSkills();\n   *\n   *   console.log('Data refreshed from Strapi');\n   * }\n   *\n   * @example\n   * // User-triggered refresh in UI\n   * app.post('/api/refresh', (req, res) => {\n   *   strapiClient.clearCache();\n   *   res.json({ message: 'Cache cleared successfully' });\n   * });\n   *\n   * @example\n   * // Clear cache before testing\n   * describe('Strapi Client Tests', () => {\n   *   beforeEach(() => {\n   *     // Ensure tests start with clean cache\n   *     strapiClient.clearCache();\n   *   });\n   *\n   *   it('should fetch fresh data from API', async () => {\n   *     const agents = await strapiClient.getAllAgents();\n   *     expect(agents).toBeDefined();\n   *   });\n   * });\n   *\n   * @example\n   * // Periodic cache refresh for long-running processes\n   * setInterval(() => {\n   *   strapiClient.clearCache();\n   *   console.log('[Cache] Periodic cache cleared');\n   * }, 1000 * 60 * 15); // Clear every 15 minutes\n   *\n   * @example\n   * // Clear cache after bulk import\n   * async function importAgents(agentsData) {\n   *   // Bulk import agents via direct API calls\n   *   for (const agentData of agentsData) {\n   *     await strapiClient.createAgent(agentData);\n   *   }\n   *\n   *   // Clear cache to ensure fresh data\n   *   strapiClient.clearCache();\n   *\n   *   console.log('Import complete, cache cleared');\n   * }\n   *\n   * @see {@link getCacheStats} - Get cache statistics\n   */\n  clearCache() {\n    const size = this.cache.size;\n    this.cache.clear();\n    console.log(`[Strapi] Cleared ${size} cache entries`);\n  }\n\n  /**\n   * Get current cache statistics\n   *\n   * @description\n   * Returns current cache statistics including the number of entries, maximum capacity,\n   * and TTL configuration. Use this for monitoring cache utilization, debugging performance\n   * issues, or implementing cache health dashboards.\n   *\n   * **Returned Statistics:**\n   * - `size`: Current number of cached entries\n   * - `max`: Maximum cache capacity (100 entries)\n   * - `ttl`: Time-to-live in milliseconds (300,000ms = 5 minutes)\n   *\n   * **Cache Behavior:**\n   * - When `size` reaches `max`, least recently used entries are evicted\n   * - Each entry expires after `ttl` milliseconds\n   * - TTL is refreshed on cache hits (updateAgeOnGet: true)\n   *\n   * @returns {Object} Cache statistics object\n   * @returns {number} returns.size - Current number of entries in cache\n   * @returns {number} returns.max - Maximum cache capacity\n   * @returns {number} returns.ttl - Time-to-live in milliseconds\n   *\n   * @example\n   * // Basic usage - get cache stats\n   * const stats = strapiClient.getCacheStats();\n   *\n   * console.log('Cache Statistics:');\n   * console.log(`  Entries: ${stats.size}/${stats.max}`);\n   * console.log(`  TTL: ${stats.ttl / 1000}s`);\n   *\n   * @example\n   * // Check cache utilization\n   * const stats = strapiClient.getCacheStats();\n   * const utilizationPercent = (stats.size / stats.max) * 100;\n   *\n   * console.log(`Cache utilization: ${utilizationPercent.toFixed(1)}%`);\n   *\n   * if (utilizationPercent > 80) {\n   *   console.warn('Cache is nearly full - consider increasing max size');\n   * }\n   *\n   * @example\n   * // Display cache stats in monitoring dashboard\n   * app.get('/api/cache/stats', (req, res) => {\n   *   const stats = strapiClient.getCacheStats();\n   *\n   *   res.json({\n   *     cache: {\n   *       size: stats.size,\n   *       max: stats.max,\n   *       utilization: `${((stats.size / stats.max) * 100).toFixed(1)}%`,\n   *       ttl: `${stats.ttl / 1000}s`,\n   *       ttlMinutes: stats.ttl / 60000\n   *     }\n   *   });\n   * });\n   *\n   * @example\n   * // Monitor cache growth over time\n   * const monitorCache = () => {\n   *   const stats = strapiClient.getCacheStats();\n   *   const timestamp = new Date().toISOString();\n   *\n   *   console.log(`[${timestamp}] Cache: ${stats.size}/${stats.max} entries`);\n   * };\n   *\n   * // Log stats every 30 seconds\n   * setInterval(monitorCache, 30000);\n   *\n   * @example\n   * // Warn if cache is empty (potential configuration issue)\n   * const stats = strapiClient.getCacheStats();\n   *\n   * if (stats.size === 0) {\n   *   console.warn('Cache is empty - no data has been cached yet');\n   *   console.warn('This is normal on startup but unusual during operation');\n   * }\n   *\n   * @example\n   * // Debug cache effectiveness\n   * async function debugCacheEffectiveness() {\n   *   // Clear cache and get initial stats\n   *   strapiClient.clearCache();\n   *   let stats = strapiClient.getCacheStats();\n   *   console.log(`Initial cache size: ${stats.size}`);\n   *\n   *   // Make some API calls\n   *   await strapiClient.getAllAgents();\n   *   await strapiClient.getAllSkills();\n   *   await strapiClient.getAllMCPServers();\n   *\n   *   // Check cache growth\n   *   stats = strapiClient.getCacheStats();\n   *   console.log(`Cache size after API calls: ${stats.size}`);\n   *   console.log(`Cache is working: ${stats.size > 0 ? 'YES' : 'NO'}`);\n   * }\n   *\n   * @example\n   * // Format stats for logging\n   * const stats = strapiClient.getCacheStats();\n   *\n   * const formatted = {\n   *   entries: `${stats.size}/${stats.max}`,\n   *   utilizationPercent: ((stats.size / stats.max) * 100).toFixed(1),\n   *   ttlSeconds: stats.ttl / 1000,\n   *   ttlMinutes: stats.ttl / 60000,\n   *   expiryTime: new Date(Date.now() + stats.ttl).toISOString()\n   * };\n   *\n   * console.log('Cache Stats:', formatted);\n   *\n   * @see {@link clearCache} - Clear all cache entries\n   */\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      max: this.cache.max,\n      ttl: this.cache.ttl,\n    };\n  }\n\n  // ============= FLOWS =============\n\n  /**\n   * Get all flows with optional filtering\n   */\n  async getAllFlows(options?: {\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<any[]> {\n    const cacheKey = `flows:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams({\n      ...options,\n      populate: ['nodes'],\n    });\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/flows',\n      { params }\n    );\n\n    const flows = data.data.map((item: StrapiAttributes<any>) => this.transformFlow(item));\n    this.cache.set(cacheKey, flows);\n\n    return flows;\n  }\n\n  /**\n   * Get a single flow by ID with populated relations\n   */\n  async getFlow(id: string): Promise<any> {\n    const cacheKey = `flow:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/flows/${id}`,\n      {\n        params: { populate: '*' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Flow with ID ${id} not found`);\n    }\n\n    const flow = this.transformFlow(data.data);\n    this.cache.set(cacheKey, flow);\n\n    return flow;\n  }\n\n  /**\n   * Create a new flow\n   */\n  async createFlow(flowData: any): Promise<any> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/flows',\n      { data: flowData }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create flow');\n    }\n\n    this.invalidateCache('flows');\n    return this.transformFlow(data.data);\n  }\n\n  /**\n   * Update an existing flow\n   */\n  async updateFlow(id: string, flowData: any): Promise<any> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/flows/${id}`,\n      { data: flowData }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update flow with ID ${id}`);\n    }\n\n    this.invalidateCache('flows');\n    this.cache.delete(`flow:${id}`);\n\n    return this.transformFlow(data.data);\n  }\n\n  /**\n   * Delete a flow\n   */\n  async deleteFlow(id: string): Promise<void> {\n    await this.client.delete(`/flows/${id}`);\n    this.invalidateCache('flows');\n    this.cache.delete(`flow:${id}`);\n  }\n\n  /**\n   * Transform Strapi flow response to Flow domain model\n   */\n  private transformFlow(strapiData: StrapiAttributes<any>): any {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      slug: attrs.slug,\n      description: attrs.description,\n      nodes: attrs.nodes || [],\n      status: attrs.status || 'draft',\n      inputSchema: attrs.inputSchema || { properties: {}, required: [] },\n      outputSchema: attrs.outputSchema || { properties: {} },\n      isActive: attrs.isActive ?? false,\n      version: attrs.version || '1.0.0',\n      category: attrs.category || 'custom',\n      metadata: attrs.metadata,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  // ============= FLOW EXECUTIONS =============\n\n  /**\n   * Get all flow executions with optional filtering\n   */\n  async getAllFlowExecutions(options?: {\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<any[]> {\n    const params = this.buildQueryParams({\n      ...options,\n      populate: ['flow'],\n    });\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/flow-executions',\n      { params }\n    );\n\n    return data.data.map((item: StrapiAttributes<any>) => this.transformFlowExecution(item));\n  }\n\n  /**\n   * Get a single flow execution by ID\n   */\n  async getFlowExecution(id: string): Promise<any> {\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/flow-executions/${id}`,\n      {\n        params: {\n          populate: {\n            flow: true,\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Flow execution with ID ${id} not found`);\n    }\n\n    return this.transformFlowExecution(data.data);\n  }\n\n  /**\n   * Create a new flow execution record\n   */\n  async createFlowExecution(executionData: {\n    flowId: string;\n    status: string;\n    input?: Record<string, any>;\n    triggeredBy: string;\n    triggerData?: Record<string, any>;\n    startedAt?: Date;\n    logs?: any[];\n    nodeExecutions?: any[];\n    tokensUsed?: number;\n    cost?: number;\n    retryCount?: number;\n  }): Promise<any> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/flow-executions',\n      {\n        data: {\n          flow: executionData.flowId,\n          status: executionData.status,\n          input: executionData.input,\n          triggeredBy: executionData.triggeredBy,\n          triggerData: executionData.triggerData,\n          startedAt: executionData.startedAt?.toISOString(),\n          logs: executionData.logs || [],\n          nodeExecutions: executionData.nodeExecutions || [],\n          tokensUsed: executionData.tokensUsed || 0,\n          cost: executionData.cost || 0,\n          retryCount: executionData.retryCount || 0,\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create flow execution');\n    }\n\n    return this.transformFlowExecution(data.data);\n  }\n\n  /**\n   * Update a flow execution record\n   */\n  async updateFlowExecution(id: string, executionData: {\n    status?: string;\n    output?: Record<string, any>;\n    logs?: any[];\n    error?: string;\n    errorDetails?: Record<string, any>;\n    completedAt?: Date;\n    executionTime?: number;\n    nodeExecutions?: any[];\n    currentNodeId?: string;\n    tokensUsed?: number;\n    cost?: number;\n  }): Promise<any> {\n    const updateData: Record<string, any> = {};\n\n    if (executionData.status !== undefined) updateData.status = executionData.status;\n    if (executionData.output !== undefined) updateData.output = executionData.output;\n    if (executionData.logs !== undefined) updateData.logs = executionData.logs;\n    if (executionData.error !== undefined) updateData.error = executionData.error;\n    if (executionData.errorDetails !== undefined) updateData.errorDetails = executionData.errorDetails;\n    if (executionData.completedAt !== undefined) updateData.completedAt = executionData.completedAt.toISOString();\n    if (executionData.executionTime !== undefined) updateData.executionTime = executionData.executionTime;\n    if (executionData.nodeExecutions !== undefined) updateData.nodeExecutions = executionData.nodeExecutions;\n    if (executionData.currentNodeId !== undefined) updateData.currentNodeId = executionData.currentNodeId;\n    if (executionData.tokensUsed !== undefined) updateData.tokensUsed = executionData.tokensUsed;\n    if (executionData.cost !== undefined) updateData.cost = executionData.cost;\n\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/flow-executions/${id}`,\n      { data: updateData }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update flow execution with ID ${id}`);\n    }\n\n    return this.transformFlowExecution(data.data);\n  }\n\n  /**\n   * Delete a flow execution record\n   */\n  async deleteFlowExecution(id: string): Promise<void> {\n    await this.client.delete(`/flow-executions/${id}`);\n  }\n\n  /**\n   * Get flow executions by flow ID\n   */\n  async getFlowExecutionsByFlowId(flowId: string, options?: {\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<any[]> {\n    return this.getAllFlowExecutions({\n      ...options,\n      filters: { flow: { documentId: flowId } },\n    });\n  }\n\n  /**\n   * Get running flow executions\n   */\n  async getRunningFlowExecutions(): Promise<any[]> {\n    return this.getAllFlowExecutions({\n      filters: { status: 'running' },\n      sort: ['startedAt:desc'],\n    });\n  }\n\n  /**\n   * Transform Strapi flow execution response to FlowExecution domain model\n   */\n  private transformFlowExecution(strapiData: StrapiAttributes<any>): any {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      flowId: attrs.flow?.documentId || attrs.flow,\n      flow: attrs.flow?.documentId ? this.transformFlow(attrs.flow) : undefined,\n      status: attrs.status || 'pending',\n      input: attrs.input,\n      output: attrs.output,\n      logs: attrs.logs || [],\n      error: attrs.error,\n      errorDetails: attrs.errorDetails,\n      startedAt: attrs.startedAt ? new Date(attrs.startedAt) : undefined,\n      completedAt: attrs.completedAt ? new Date(attrs.completedAt) : undefined,\n      executionTime: attrs.executionTime,\n      nodeExecutions: attrs.nodeExecutions || [],\n      currentNodeId: attrs.currentNodeId,\n      tokensUsed: attrs.tokensUsed || 0,\n      cost: attrs.cost || 0,\n      triggeredBy: attrs.triggeredBy || 'manual',\n      triggerData: attrs.triggerData,\n      retryCount: attrs.retryCount || 0,\n      parentExecutionId: attrs.parentExecutionId,\n      metadata: attrs.metadata,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  // ============= ERROR HANDLING =============\n\n  /**\n   * Handle axios errors with detailed logging\n   */\n  private handleError(error: AxiosError) {\n    if (error.response) {\n      // Server responded with error status\n      console.error('[Strapi] Response error:', {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data,\n        url: error.config?.url,\n      });\n    } else if (error.request) {\n      // Request made but no response\n      console.error('[Strapi] No response received:', {\n        message: error.message,\n        url: error.config?.url,\n      });\n    } else {\n      // Error in request setup\n      console.error('[Strapi] Request setup error:', {\n        message: error.message,\n        url: error.config?.url,\n      });\n    }\n  }\n}\n\n// ============= SINGLETON EXPORT =============\n\n/**\n * Singleton instance of StrapiClient\n * Use this throughout the application for all Strapi interactions\n */\nexport const strapiClient = new StrapiClient();\n",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": {
        "content": "/**\n * Claude Agent UI - Strapi Client Service\n *\n * This service provides a data access layer for interacting with the Strapi CMS API.\n * It handles HTTP communication, caching, and data transformation between Strapi's\n * response format and the application's domain models.\n *\n * Features:\n * - HTTP client with axios\n * - LRU cache with 5-minute TTL\n * - Request/response interceptors for logging\n * - Automatic data transformation\n * - Cache invalidation on mutations\n * - Error handling with detailed logging\n * - Support for populate, filters, sort, pagination\n * - Health check endpoint\n */\n\nimport axios, { AxiosInstance, AxiosError } from 'axios';\nimport { LRUCache } from 'lru-cache';\nimport type {\n  Agent,\n  Skill,\n  MCPServer,\n  MCPTool,\n  Task,\n  StrapiAttributes,\n  StrapiResponse,\n  StrapiData,\n  StrapiQueryParams,\n  CreateAgentDTO,\n  UpdateAgentDTO,\n  CreateSkillDTO,\n  UpdateSkillDTO,\n  CreateMCPServerDTO,\n  UpdateMCPServerDTO,\n  CreateTaskDTO,\n  UpdateTaskDTO,\n} from '../types/index.js';\nimport type {\n  Flow,\n  FlowExecution,\n  FlowExecutionStatus,\n  FlowTriggerType,\n  FlowStatus,\n  FlowCategory,\n  FlowStats,\n  GlobalFlowStats,\n  FlowNode,\n  FlowInputSchema,\n  FlowOutputSchema,\n  FlowSchedule,\n  NodeExecution,\n  FlowExecutionLog,\n} from '../types/flow-types.js';\n\n// ============= HELPER FUNCTIONS =============\n\n/**\n * Generate a URL-friendly slug from a string\n * @param text - Input text to slugify\n * @returns Slugified string (lowercase, hyphens, no special chars)\n */\nfunction generateSlug(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '') // Remove special characters\n    .replace(/\\s+/g, '-')      // Replace spaces with hyphens\n    .replace(/-+/g, '-')       // Replace multiple hyphens with single hyphen\n    .replace(/^-+|-+$/g, '');  // Remove leading/trailing hyphens\n}\n\n// ============= CONFIGURATION =============\n\nconst STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';\nconst STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;\n\n// Cache configuration\nconst CACHE_TTL = 1000 * 60 * 5; // 5 minutes\nconst CACHE_MAX_SIZE = 100;\n\n// ============= STRAPI CLIENT CLASS =============\n\n/**\n * StrapiClient - Singleton service for Strapi API interactions\n *\n * Provides CRUD operations for all content types with built-in caching,\n * data transformation, and error handling.\n */\nexport class StrapiClient {\n  private client: AxiosInstance;\n  private cache: LRUCache<string, any>;\n\n  constructor() {\n    // Initialize axios client with base configuration\n    this.client = axios.create({\n      baseURL: `${STRAPI_URL}/api`,\n      headers: {\n        'Authorization': STRAPI_API_TOKEN ? `Bearer ${STRAPI_API_TOKEN}` : '',\n        'Content-Type': 'application/json',\n      },\n      timeout: 10000, // 10 seconds\n    });\n\n    // Initialize LRU cache\n    this.cache = new LRUCache({\n      max: CACHE_MAX_SIZE,\n      ttl: CACHE_TTL,\n      updateAgeOnGet: true, // Refresh TTL on access\n    });\n\n    // Add request interceptor for logging\n    this.client.interceptors.request.use(\n      (config: any) => {\n        console.log(`[Strapi] ${config.method?.toUpperCase()} ${config.url}`);\n        return config;\n      },\n      (error: any) => {\n        console.error('[Strapi] Request error:', error);\n        return Promise.reject(error);\n      }\n    );\n\n    // Add response interceptor for error handling\n    this.client.interceptors.response.use(\n      (response: any) => response,\n      (error: AxiosError) => {\n        this.handleError(error);\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  // ============= HEALTH CHECK =============\n\n  /**\n   * Check if Strapi API is accessible\n   * @returns Promise<boolean> - true if healthy, false otherwise\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      await this.client.get('/');\n      console.log('[Strapi] Health check passed');\n      return true;\n    } catch (error) {\n      console.error('[Strapi] Health check failed:', error);\n      return false;\n    }\n  }\n\n  // ============= AGENTS =============\n\n  /**\n   * Get all agents with optional filtering, sorting, and pagination\n   */\n  async getAllAgents(options?: {\n    populate?: string[] | Record<string, any>;\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Agent[]> {\n    const cacheKey = `agents:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams(options);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/agents',\n      { params }\n    );\n\n    const agents = data.data.map((item: StrapiAttributes<any>) => this.transformAgent(item));\n\n    this.cache.set(cacheKey, agents);\n\n    return agents;\n  }\n\n  /**\n   * Get a single agent by ID with populated relations\n   * Updated to populate component fields (Strapi 5)\n   */\n  async getAgent(id: string): Promise<Agent> {\n    const cacheKey = `agent:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/agents/${id}`,\n      {\n        params: {\n          // Populate component fields and nested relations\n          populate: {\n            toolConfig: true,\n            modelConfig: true,\n            analytics: true,\n            metadata: true,\n            mcpConfig: {\n              populate: {\n                mcpServer: true,\n                selectedTools: {\n                  populate: { mcpTool: true },\n                },\n              },\n            },\n            skillSelection: {\n              populate: { skill: true },\n            },\n            tasks: {\n              populate: { task: true },\n            },\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Agent with ID ${id} not found`);\n    }\n\n    const agent = this.transformAgent(data.data);\n    this.cache.set(cacheKey, agent);\n\n    return agent;\n  }\n\n  /**\n   * Create a new agent\n   */\n  async createAgent(agentData: CreateAgentDTO): Promise<Agent> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/agents',\n      {\n        data: this.prepareAgentData(agentData as any),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create agent');\n    }\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n\n    return this.transformAgent(data.data);\n  }\n\n  /**\n   * Update an existing agent\n   */\n  async updateAgent(id: string, agentData: UpdateAgentDTO): Promise<Agent> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/agents/${id}`,\n      {\n        data: this.prepareAgentData(agentData as any),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update agent with ID ${id}`);\n    }\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n    this.cache.delete(`agent:${id}`);\n\n    return this.transformAgent(data.data);\n  }\n\n  /**\n   * Delete an agent\n   */\n  async deleteAgent(id: string): Promise<void> {\n    await this.client.delete(`/agents/${id}`);\n\n    // Invalidate cache\n    this.invalidateCache('agents');\n    this.cache.delete(`agent:${id}`);\n  }\n\n  // ============= SKILLS =============\n\n  /**\n   * Get all skills with optional filtering\n   */\n  async getAllSkills(options?: {\n    populate?: string[];\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Skill[]> {\n    const cacheKey = `skills:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    // Always populate component fields for skills\n    const populateOptions = {\n      ...options,\n      populate: options?.populate || [\n        'toolConfig',\n        'modelConfig',\n        'analytics',\n        'mcpConfig.mcpServer',\n        'mcpConfig.selectedTools.mcpTool',\n        'agentSelection',\n        'trainingHistory',\n        'additionalFiles.file',  // Deep populate: component + file relation\n        'inputFields'\n      ],\n      // Default pagination to fetch all skills (max 100)\n      pagination: options?.pagination || { page: 1, pageSize: 100 }\n    };\n\n    const params = this.buildQueryParams(populateOptions);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/skills',\n      { params }\n    );\n\n    // DEBUG: Log raw Strapi response to check mcpConfig\n    console.log('[DEBUG] getAllSkills - Raw Strapi response (first item):', JSON.stringify(data.data[0], null, 2));\n    if (data.data[0]?.attributes) {\n      console.log('[DEBUG] getAllSkills - First item attributes keys:', Object.keys(data.data[0].attributes));\n      console.log('[DEBUG] getAllSkills - mcpConfig value:', (data.data[0].attributes as any).mcpConfig);\n    }\n\n    const skills = data.data.map((item: StrapiAttributes<any>) => this.transformSkill(item));\n    this.cache.set(cacheKey, skills);\n\n    return skills;\n  }\n\n  /**\n   * Get a single skill by ID\n   * Updated to populate component fields (Strapi 5)\n   */\n  async getSkill(id: string): Promise<Skill> {\n    const cacheKey = `skill:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/skills/${id}`,\n      {\n        params: {\n          // Populate component fields and nested relations\n          populate: {\n            trainingHistory: true,\n            additionalFiles: {\n              populate: { file: true }  // Populate file relation inside component\n            },\n            agentSelection: {\n              populate: { agent: true },\n            },\n            toolConfig: true,\n            modelConfig: true,\n            analytics: true,\n            mcpConfig: {\n              populate: {\n                mcpServer: true,\n                selectedTools: {\n                  populate: { mcpTool: true },\n                },\n              },\n            },\n            tasks: {\n              populate: { task: true },\n            },\n            inputFields: true,\n            trainingAgent: true,\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Skill with ID ${id} not found`);\n    }\n\n    const skill = this.transformSkill(data.data);\n    this.cache.set(cacheKey, skill);\n\n    return skill;\n  }\n\n  /**\n   * Get multiple skills by their IDs\n   */\n  async getSkillsByIds(ids: string[]): Promise<Skill[]> {\n    if (ids.length === 0) return [];\n\n    const filters = {\n      documentId: { $in: ids },\n    };\n\n    return this.getAllSkills({ filters });\n  }\n\n  /**\n   * Create a new skill\n   */\n  async createSkill(skillData: CreateSkillDTO): Promise<Skill> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/skills',\n      {\n        data: this.prepareSkillData(skillData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create skill');\n    }\n\n    this.invalidateCache('skills');\n    return this.transformSkill(data.data);\n  }\n\n  /**\n   * Update an existing skill\n   */\n  async updateSkill(id: string, skillData: UpdateSkillDTO): Promise<Skill> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/skills/${id}`,\n      {\n        data: this.prepareSkillData(skillData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update skill with ID ${id}`);\n    }\n\n    this.invalidateCache('skills');\n    this.cache.delete(`skill:${id}`);\n\n    return this.transformSkill(data.data);\n  }\n\n  /**\n   * Delete a skill\n   */\n  async deleteSkill(id: string): Promise<void> {\n    await this.client.delete(`/skills/${id}`);\n    this.invalidateCache('skills');\n    this.cache.delete(`skill:${id}`);\n  }\n\n  // ============= MCP SERVERS =============\n\n  /**\n   * Get all MCP servers with optional filtering\n   */\n  async getAllMCPServers(options?: {\n    filters?: Record<string, any>;\n    populate?: boolean;\n  }): Promise<MCPServer[]> {\n    const cacheKey = `mcp-servers:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams({\n      ...options,\n      populate: options?.populate ? ['mcpTools'] : undefined\n    });\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/mcp-servers',\n      { params }\n    );\n\n    const mcpServers = data.data.map((item: StrapiAttributes<any>) => this.transformMCPServer(item));\n    this.cache.set(cacheKey, mcpServers);\n\n    return mcpServers;\n  }\n\n  /**\n   * Get a single MCP server by ID\n   */\n  async getMCPServer(id: string): Promise<MCPServer> {\n    const cacheKey = `mcp-server:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/mcp-servers/${id}`,\n      {\n        params: { populate: '*' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`MCP Server with ID ${id} not found`);\n    }\n\n    const mcpServer = this.transformMCPServer(data.data);\n    this.cache.set(cacheKey, mcpServer);\n\n    return mcpServer;\n  }\n\n  /**\n   * Get multiple MCP servers by their IDs\n   */\n  async getMCPServersByIds(ids: string[]): Promise<MCPServer[]> {\n    if (ids.length === 0) return [];\n\n    const filters = {\n      documentId: { $in: ids },\n    };\n\n    return this.getAllMCPServers({ filters });\n  }\n\n  /**\n   * Create a new MCP server\n   */\n  async createMCPServer(mcpData: CreateMCPServerDTO): Promise<MCPServer> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/mcp-servers',\n      {\n        data: this.prepareMCPServerData(mcpData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create MCP server');\n    }\n\n    this.invalidateCache('mcp-servers');\n    return this.transformMCPServer(data.data);\n  }\n\n  /**\n   * Update an existing MCP server\n   */\n  async updateMCPServer(id: string, mcpData: UpdateMCPServerDTO): Promise<MCPServer> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/mcp-servers/${id}`,\n      {\n        data: this.prepareMCPServerData(mcpData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update MCP server with ID ${id}`);\n    }\n\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${id}`);\n\n    return this.transformMCPServer(data.data);\n  }\n\n  /**\n   * Delete an MCP server\n   */\n  async deleteMCPServer(id: string): Promise<void> {\n    await this.client.delete(`/mcp-servers/${id}`);\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${id}`);\n  }\n\n  /**\n   * Update MCP server tools (DEPRECATED - use bulkSyncMCPTools instead)\n   */\n  async updateMCPServerTools(id: string, tools: any[]): Promise<MCPServer> {\n    console.warn('updateMCPServerTools is deprecated, use bulkSyncMCPTools instead');\n    return this.bulkSyncMCPTools(id, tools);\n  }\n\n  // ============= MCP TOOLS =============\n\n  /**\n   * Get all tools for an MCP server\n   */\n  async getMCPToolsByServerId(serverId: string): Promise<MCPTool[]> {\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/mcp-tools',\n      {\n        params: {\n          filters: { mcpServer: { documentId: serverId } },\n        },\n      }\n    );\n\n    return data.data.map((item: StrapiAttributes<any>) => this.transformMCPTool(item));\n  }\n\n  /**\n   * Create a new MCP tool\n   */\n  async createMCPTool(serverId: string, toolData: {\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }): Promise<MCPTool> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/mcp-tools',\n      {\n        data: {\n          ...toolData,\n          mcpServer: serverId,\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create MCP tool');\n    }\n\n    return this.transformMCPTool(data.data);\n  }\n\n  /**\n   * Update an existing MCP tool\n   */\n  async updateMCPTool(toolId: string, toolData: {\n    name?: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }): Promise<MCPTool> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/mcp-tools/${toolId}`,\n      {\n        data: toolData,\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update MCP tool with ID ${toolId}`);\n    }\n\n    return this.transformMCPTool(data.data);\n  }\n\n  /**\n   * Delete an MCP tool\n   */\n  async deleteMCPTool(toolId: string): Promise<void> {\n    await this.client.delete(`/mcp-tools/${toolId}`);\n  }\n\n  /**\n   * Bulk sync MCP tools for a server\n   * Compares fetched tools with existing tools and performs create/update/delete operations\n   */\n  async bulkSyncMCPTools(serverId: string, fetchedTools: Array<{\n    name: string;\n    description?: string;\n    inputSchema?: Record<string, unknown>;\n  }>): Promise<MCPServer> {\n    // Get existing tools for this server\n    const existingTools = await this.getMCPToolsByServerId(serverId);\n\n    // Create a map of existing tools by name\n    const existingToolsMap = new Map(existingTools.map(t => [t.name, t]));\n\n    // Create a set of fetched tool names\n    const fetchedToolNames = new Set(fetchedTools.map(t => t.name));\n\n    // Delete tools that no longer exist\n    const toolsToDelete = existingTools.filter(t => !fetchedToolNames.has(t.name));\n    await Promise.all(toolsToDelete.map(t => this.deleteMCPTool(t.id)));\n\n    // Create or update tools\n    for (const fetchedTool of fetchedTools) {\n      const existingTool = existingToolsMap.get(fetchedTool.name);\n\n      if (existingTool) {\n        // Update if changed\n        const hasChanged =\n          existingTool.description !== fetchedTool.description ||\n          JSON.stringify(existingTool.inputSchema) !== JSON.stringify(fetchedTool.inputSchema);\n\n        if (hasChanged) {\n          await this.updateMCPTool(existingTool.id, fetchedTool);\n        }\n      } else {\n        // Create new tool\n        await this.createMCPTool(serverId, fetchedTool);\n      }\n    }\n\n    // Update toolsFetchedAt timestamp on the server\n    await this.client.put(`/mcp-servers/${serverId}`, {\n      data: {\n        toolsFetchedAt: new Date().toISOString(),\n      },\n    });\n\n    // Invalidate cache\n    this.invalidateCache('mcp-servers');\n    this.cache.delete(`mcp-server:${serverId}`);\n\n    // Return updated server with tools\n    return this.getMCPServer(serverId);\n  }\n\n  // ============= FILE UPLOAD =============\n\n  /**\n   * Upload a file to Strapi Media Library\n   * @param file - File to upload (Buffer or Blob)\n   * @param filename - Original filename\n   * @returns Strapi media object with file ID and URL\n   */\n  async uploadFile(file: Buffer | Blob, filename: string): Promise<{\n    id: number;\n    documentId: string;\n    name: string;\n    url: string;\n    mime: string;\n    size: number;\n  }> {\n    const FormData = (await import('form-data')).default;\n    const formData = new FormData();\n\n    formData.append('files', file, filename);\n\n    const { data } = await this.client.post('/upload', formData, {\n      headers: {\n        ...formData.getHeaders(),\n      },\n    });\n\n    if (!data || !data[0]) {\n      throw new Error('Failed to upload file');\n    }\n\n    const uploadedFile = data[0];\n\n    return {\n      id: uploadedFile.id,\n      documentId: uploadedFile.documentId,\n      name: uploadedFile.name,\n      url: uploadedFile.url,\n      mime: uploadedFile.mime,\n      size: uploadedFile.size,\n    };\n  }\n\n  /**\n   * Delete a file from Strapi Media Library\n   * @param fileId - File ID to delete\n   */\n  async deleteFile(fileId: string): Promise<void> {\n    await this.client.delete(`/upload/files/${fileId}`);\n  }\n\n  // ============= TASKS =============\n\n  /**\n   * Get all tasks with optional filtering\n   */\n  async getAllTasks(options?: {\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Task[]> {\n    const cacheKey = `tasks:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams(options);\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/tasks',\n      { params }\n    );\n\n    const tasks = data.data.map((item: StrapiAttributes<any>) => this.transformTask(item));\n    this.cache.set(cacheKey, tasks);\n\n    return tasks;\n  }\n\n  /**\n   * Get a single task by ID\n   */\n  async getTask(id: string): Promise<Task> {\n    const cacheKey = `task:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/tasks/${id}`,\n      {\n        params: { populate: 'agent' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Task with ID ${id} not found`);\n    }\n\n    const task = this.transformTask(data.data);\n    this.cache.set(cacheKey, task);\n\n    return task;\n  }\n\n  /**\n   * Create a new task\n   */\n  async createTask(taskData: CreateTaskDTO): Promise<Task> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/tasks',\n      {\n        data: this.prepareTaskData(taskData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create task');\n    }\n\n    this.invalidateCache('tasks');\n    return this.transformTask(data.data);\n  }\n\n  /**\n   * Update an existing task\n   */\n  async updateTask(id: string, taskData: UpdateTaskDTO): Promise<Task> {\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/tasks/${id}`,\n      {\n        data: this.prepareTaskData(taskData),\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update task with ID ${id}`);\n    }\n\n    this.invalidateCache('tasks');\n    this.cache.delete(`task:${id}`);\n\n    return this.transformTask(data.data);\n  }\n\n  /**\n   * Delete a task\n   */\n  async deleteTask(id: string): Promise<void> {\n    await this.client.delete(`/tasks/${id}`);\n    this.invalidateCache('tasks');\n    this.cache.delete(`task:${id}`);\n  }\n\n  // ============= TRANSFORMERS =============\n  // Transform Strapi response format to domain models\n\n  /**\n   * Helper to extract attributes from Strapi response\n   * Handles both nested (attributes) and flat formats\n   */\n  private extractAttributes(strapiData: any): any {\n    // If data has attributes property, use it (Strapi 5 default format)\n    if (strapiData.attributes) {\n      return strapiData.attributes;\n    }\n\n    // Otherwise, data is already flat (some Strapi configurations)\n    return strapiData;\n  }\n\n  /**\n   * Transform Strapi agent response to Agent domain model\n   * Updated for component-based structure (Strapi 5)\n   */\n  private transformAgent(strapiData: StrapiAttributes<any>): Agent {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      slug: attrs.slug,\n      description: attrs.description || '',\n      systemPrompt: attrs.systemPrompt,\n      enabled: attrs.enabled ?? true,\n\n      // Component fields - pass through as-is\n      toolConfig: attrs.toolConfig || undefined,\n      modelConfig: attrs.modelConfig || {\n        model: 'sonnet',\n        temperature: 1.0,\n        timeout: 300000,\n      },\n      analytics: attrs.analytics || undefined,\n      metadata: attrs.metadata || [],\n\n      // Component-based relations - pass through as-is\n      mcpConfig: attrs.mcpConfig || [],\n      skillSelection: attrs.skillSelection || [],\n      tasks: attrs.tasks || [],\n\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi skill response to Skill domain model\n   * Updated for component-based structure (Strapi 5)\n   */\n  private transformSkill(strapiData: StrapiAttributes<any>): Skill {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      displayName: attrs.displayName,\n      description: attrs.description,\n      skillmd: attrs.skillmd, // Correct field name\n      skillConfig: attrs.skillConfig || undefined, // Add skillConfig (replaces systemPromptPrefix)\n      experienceScore: attrs.experienceScore || 0,\n      category: attrs.category || 'custom',\n      isPublic: attrs.isPublic ?? true,\n      version: attrs.version || '1.0.0',\n      license: attrs.license || undefined,\n\n      // Component fields - pass through as-is\n      trainingHistory: attrs.trainingHistory || [],\n      additionalFiles: attrs.additionalFiles || [],\n      agentSelection: attrs.agentSelection || [],\n      toolConfig: attrs.toolConfig || undefined,\n      modelConfig: attrs.modelConfig || undefined,\n      analytics: attrs.analytics || undefined,\n      mcpConfig: attrs.mcpConfig || [],\n      tasks: attrs.tasks || [],\n      inputFields: attrs.inputFields || [],\n\n      // Direct relation\n      trainingAgent: attrs.trainingAgent?.data?.documentId || attrs.trainingAgent,\n\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi MCP server response to MCPServer domain model\n   */\n  private transformMCPServer(strapiData: StrapiAttributes<any>): MCPServer {\n    const attrs = this.extractAttributes(strapiData);\n\n    // Create config object based on transport type to match frontend expectations\n    const config: any = {\n      type: attrs.transport || 'stdio',\n      command: attrs.command,\n      args: attrs.args || [],\n      env: attrs.env || {},\n      disabled: attrs.disabled ?? false,\n    };\n\n    // Transform mcpTools if populated\n    let mcpTools: MCPTool[] | undefined;\n    if (attrs.mcpTools) {\n      if (Array.isArray(attrs.mcpTools)) {\n        mcpTools = attrs.mcpTools.map((tool: any) => this.transformMCPTool(tool));\n      } else if (attrs.mcpTools.data && Array.isArray(attrs.mcpTools.data)) {\n        mcpTools = attrs.mcpTools.data.map((tool: any) => this.transformMCPTool(tool));\n      }\n    }\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      config: config,\n      command: attrs.command,\n      description: attrs.description || '',\n      args: attrs.args || [],\n      env: attrs.env || {},\n      disabled: attrs.disabled ?? false,\n      transport: attrs.transport || 'stdio',\n      healthCheckUrl: attrs.healthCheckUrl,\n      isHealthy: attrs.isHealthy ?? true,\n      lastHealthCheck: attrs.lastHealthCheck ? new Date(attrs.lastHealthCheck) : undefined,\n      startupTimeout: attrs.startupTimeout || 30000,\n      restartPolicy: attrs.restartPolicy || 'on-failure',\n      toolsFetchedAt: attrs.toolsFetchedAt ? new Date(attrs.toolsFetchedAt) : undefined,\n      mcpTools: mcpTools,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    } as MCPServer;\n  }\n\n  /**\n   * Transform Strapi MCP tool response to MCPTool domain model\n   */\n  private transformMCPTool(strapiData: StrapiAttributes<any>): MCPTool {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      description: attrs.description || undefined,\n      inputSchema: attrs.inputSchema || undefined,\n      mcpServer: attrs.mcpServer?.documentId || attrs.mcpServer?.data?.documentId || undefined,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Transform Strapi task response to Task domain model\n   */\n  private transformTask(strapiData: StrapiAttributes<any>): Task {\n    const attrs = this.extractAttributes(strapiData);\n    const metadata = attrs.metadata || {};\n\n    return {\n      id: strapiData.documentId,\n      agentId: attrs.agent?.documentId || attrs.agent?.data?.documentId || attrs.agentId,\n      agentName: attrs.agent?.name || attrs.agent?.data?.name || undefined,\n      name: metadata.name || attrs.message || 'Unnamed Task',\n      description: metadata.description || undefined,\n      message: attrs.message,\n      status: attrs.status || 'pending',\n      result: attrs.result,\n      error: attrs.error,\n      startedAt: attrs.startedAt ? new Date(attrs.startedAt) : undefined,\n      completedAt: attrs.completedAt ? new Date(attrs.completedAt) : undefined,\n      executionTime: attrs.executionTime,\n      tokensUsed: attrs.tokensUsed,\n      cost: attrs.cost,\n      metadata: metadata,\n      executionLog: attrs.executionLog || [], // Include execution log for viewing\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  // ============= DATA PREPARERS =============\n  // Prepare domain models for Strapi API\n\n  /**\n   * Prepare agent data for Strapi API\n   * Updated for component-based structure (Strapi 5)\n   */\n  private prepareAgentData(agent: Partial<Agent>) {\n    const data: any = {\n      name: agent.name,\n      description: agent.description,\n      systemPrompt: agent.systemPrompt,\n      enabled: agent.enabled,\n    };\n\n    // Generate slug from name if name is provided\n    // Strapi's auto-generation doesn't always work with programmatic API calls\n    if (agent.name) {\n      data.slug = generateSlug(agent.name);\n    }\n\n    // Component fields - pass through as-is\n    if (agent.toolConfig) {\n      data.toolConfig = agent.toolConfig;\n    }\n\n    if (agent.modelConfig) {\n      data.modelConfig = agent.modelConfig;\n    }\n\n    if (agent.analytics) {\n      data.analytics = agent.analytics;\n    }\n\n    if (agent.metadata) {\n      data.metadata = agent.metadata;\n    }\n\n    // Component-based relations\n    if (agent.mcpConfig) {\n      data.mcpConfig = agent.mcpConfig;\n    }\n\n    if (agent.skillSelection) {\n      data.skillSelection = agent.skillSelection;\n    }\n\n    if (agent.tasks) {\n      data.tasks = agent.tasks;\n    }\n\n    return data;\n  }\n\n  /**\n   * Prepare skill data for Strapi API\n   * Updated for component-based structure (Strapi 5)\n   */\n  private prepareSkillData(skill: Partial<Skill>) {\n    const data: any = {\n      name: skill.name,\n      displayName: skill.displayName,\n      description: skill.description,\n      skillmd: skill.skillmd, // Correct field name\n      experienceScore: skill.experienceScore,\n      category: skill.category,\n      isPublic: skill.isPublic,\n      version: skill.version,\n      license: skill.license,\n    };\n\n    // Component fields\n    if (skill.trainingHistory) {\n      data.trainingHistory = skill.trainingHistory;\n    }\n\n    if (skill.additionalFiles) {\n      data.additionalFiles = skill.additionalFiles;\n    }\n\n    if (skill.agentSelection) {\n      data.agentSelection = skill.agentSelection;\n    }\n\n    if (skill.toolConfig) {\n      data.toolConfig = skill.toolConfig;\n    }\n\n    if (skill.modelConfig) {\n      data.modelConfig = skill.modelConfig;\n    }\n\n    if (skill.analytics) {\n      data.analytics = skill.analytics;\n    }\n\n    if (skill.mcpConfig) {\n      data.mcpConfig = skill.mcpConfig;\n    }\n\n    if (skill.tasks) {\n      data.tasks = skill.tasks;\n    }\n\n    if (skill.inputFields) {\n      data.inputFields = skill.inputFields;\n    }\n\n    // Direct relation\n    if (skill.trainingAgent) {\n      data.trainingAgent = skill.trainingAgent;\n    }\n\n    return data;\n  }\n\n  /**\n   * Prepare MCP server data for Strapi API\n   */\n  private prepareMCPServerData(mcp: Partial<MCPServer>) {\n    return {\n      name: mcp.name,\n      command: mcp.command,\n      description: mcp.description,\n      args: mcp.args,\n      env: mcp.env,\n      disabled: mcp.disabled,\n      transport: mcp.transport,\n      healthCheckUrl: mcp.healthCheckUrl,\n      startupTimeout: mcp.startupTimeout,\n      restartPolicy: mcp.restartPolicy,\n    };\n  }\n\n  /**\n   * Prepare task data for Strapi API\n   */\n  private prepareTaskData(task: Partial<Task>) {\n    return {\n      agent: task.agentId,  // Strapi expects 'agent' relation field\n      message: task.message,\n      status: task.status,\n      result: task.result,\n      error: task.error,\n      startedAt: task.startedAt instanceof Date ? task.startedAt.toISOString() : task.startedAt,\n      completedAt: task.completedAt instanceof Date ? task.completedAt.toISOString() : task.completedAt,\n      executionTime: task.executionTime,\n      tokensUsed: task.tokensUsed,\n      cost: task.cost,\n      metadata: task.metadata,\n      executionLog: task.executionLog, // Include execution log for viewing\n    };\n  }\n\n  // ============= QUERY BUILDERS =============\n\n  /**\n   * Build Strapi query parameters from options\n   */\n  private buildQueryParams(options?: {\n    populate?: string[] | Record<string, any>;\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Record<string, any> {\n    const params: Record<string, any> = {};\n\n    if (options?.populate) {\n      // Strapi v5 requires array bracket notation: populate[0]=field1&populate[1]=field2\n      // Pass array directly, axios will serialize it correctly\n      params.populate = options.populate;\n    }\n\n    if (options?.filters) {\n      params.filters = options.filters;\n    }\n\n    if (options?.sort) {\n      params.sort = options.sort;\n    }\n\n    if (options?.pagination) {\n      params.pagination = options.pagination;\n    }\n\n    return params;\n  }\n\n  // ============= CACHE MANAGEMENT =============\n\n  /**\n   * Invalidate all cache entries with a given prefix\n   */\n  private invalidateCache(prefix: string) {\n    const keys = Array.from(this.cache.keys());\n    let invalidatedCount = 0;\n\n    for (const key of keys) {\n      if (typeof key === 'string' && key.startsWith(prefix)) {\n        this.cache.delete(key);\n        invalidatedCount++;\n      }\n    }\n\n    if (invalidatedCount > 0) {\n      console.log(`[Strapi] Invalidated ${invalidatedCount} cache entries with prefix \"${prefix}\"`);\n    }\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clearCache() {\n    const size = this.cache.size;\n    this.cache.clear();\n    console.log(`[Strapi] Cleared ${size} cache entries`);\n  }\n\n  /**\n   * Get current cache statistics\n   */\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      max: this.cache.max,\n      ttl: this.cache.ttl,\n    };\n  }\n\n  // ============= FLOWS =============\n\n  /**\n   * Get all flows with optional filtering, sorting, and pagination\n   * @param options - Query options for filtering, sorting, and pagination\n   * @returns Array of Flow objects\n   */\n  async getAllFlows(options?: {\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<Flow[]> {\n    const cacheKey = `flows:all:${JSON.stringify(options)}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const params = this.buildQueryParams({\n      ...options,\n      populate: ['nodes'],\n    });\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/flows',\n      { params }\n    );\n\n    const flows = data.data.map((item: StrapiAttributes<any>) => this.transformFlow(item));\n    this.cache.set(cacheKey, flows);\n\n    return flows;\n  }\n\n  /**\n   * Get a single flow by ID with populated relations\n   * @param id - Flow document ID\n   * @returns Flow object\n   */\n  async getFlow(id: string): Promise<Flow> {\n    const cacheKey = `flow:${id}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/flows/${id}`,\n      {\n        params: { populate: '*' },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Flow with ID ${id} not found`);\n    }\n\n    const flow = this.transformFlow(data.data);\n    this.cache.set(cacheKey, flow);\n\n    return flow;\n  }\n\n  /**\n   * Get a flow by slug\n   * @param slug - URL-friendly slug identifier\n   * @returns Flow object or null if not found\n   */\n  async getFlowBySlug(slug: string): Promise<Flow | null> {\n    const cacheKey = `flow:slug:${slug}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/flows',\n      {\n        params: {\n          filters: { slug: { $eq: slug } },\n          populate: '*',\n        },\n      }\n    );\n\n    if (!data.data || data.data.length === 0) {\n      return null;\n    }\n\n    const flow = this.transformFlow(data.data[0]);\n    this.cache.set(cacheKey, flow);\n\n    return flow;\n  }\n\n  /**\n   * Get all active flows (isActive = true)\n   * @returns Array of active Flow objects\n   */\n  async getActiveFlows(): Promise<Flow[]> {\n    return this.getAllFlows({\n      filters: { isActive: true },\n      sort: ['name:asc'],\n    });\n  }\n\n  /**\n   * Get flows by category\n   * @param category - Flow category\n   * @returns Array of Flow objects in the specified category\n   */\n  async getFlowsByCategory(category: FlowCategory): Promise<Flow[]> {\n    return this.getAllFlows({\n      filters: { category },\n      sort: ['name:asc'],\n    });\n  }\n\n  /**\n   * Get flows by status\n   * @param status - Flow status\n   * @returns Array of Flow objects with the specified status\n   */\n  async getFlowsByStatus(status: FlowStatus): Promise<Flow[]> {\n    return this.getAllFlows({\n      filters: { status },\n      sort: ['updatedAt:desc'],\n    });\n  }\n\n  /**\n   * Create a new flow\n   * @param flowData - Flow creation data\n   * @returns Created Flow object\n   */\n  async createFlow(flowData: Partial<Flow>): Promise<Flow> {\n    const preparedData = this.prepareFlowData(flowData);\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/flows',\n      { data: preparedData }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create flow');\n    }\n\n    this.invalidateCache('flows');\n    return this.transformFlow(data.data);\n  }\n\n  /**\n   * Update an existing flow\n   * @param id - Flow document ID\n   * @param flowData - Flow update data\n   * @returns Updated Flow object\n   */\n  async updateFlow(id: string, flowData: Partial<Flow>): Promise<Flow> {\n    const preparedData = this.prepareFlowData(flowData);\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/flows/${id}`,\n      { data: preparedData }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update flow with ID ${id}`);\n    }\n\n    this.invalidateCache('flows');\n    this.cache.delete(`flow:${id}`);\n\n    return this.transformFlow(data.data);\n  }\n\n  /**\n   * Delete a flow\n   * @param id - Flow document ID\n   */\n  async deleteFlow(id: string): Promise<void> {\n    await this.client.delete(`/flows/${id}`);\n    this.invalidateCache('flows');\n    this.cache.delete(`flow:${id}`);\n  }\n\n  /**\n   * Duplicate a flow with a new name\n   * @param id - Source flow document ID\n   * @param newName - Name for the duplicated flow\n   * @returns Duplicated Flow object\n   */\n  async duplicateFlow(id: string, newName?: string): Promise<Flow> {\n    const original = await this.getFlow(id);\n\n    const duplicateData: Partial<Flow> = {\n      name: newName || `${original.name} (Copy)`,\n      description: original.description,\n      nodes: original.nodes,\n      inputSchema: original.inputSchema,\n      outputSchema: original.outputSchema,\n      isActive: false,\n      status: 'draft' as FlowStatus,\n      version: '1.0.0',\n      category: original.category,\n      metadata: original.metadata,\n    };\n\n    return this.createFlow(duplicateData);\n  }\n\n  /**\n   * Transform Strapi flow response to Flow domain model\n   */\n  private transformFlow(strapiData: StrapiAttributes<any>): Flow {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      name: attrs.name,\n      slug: attrs.slug,\n      description: attrs.description,\n      nodes: (attrs.nodes || []) as FlowNode[],\n      status: (attrs.status || 'draft') as FlowStatus,\n      inputSchema: (attrs.inputSchema || { properties: {}, required: [] }) as FlowInputSchema,\n      outputSchema: (attrs.outputSchema || { properties: {} }) as FlowOutputSchema,\n      isActive: attrs.isActive ?? false,\n      version: attrs.version || '1.0.0',\n      category: (attrs.category || 'custom') as FlowCategory,\n      metadata: attrs.metadata,\n      schedule: attrs.schedule || undefined,\n      webhookEnabled: attrs.webhookEnabled ?? false,\n      webhookSecret: attrs.webhookSecret,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  /**\n   * Prepare flow data for Strapi API\n   */\n  private prepareFlowData(flow: Partial<Flow>): Record<string, any> {\n    const data: Record<string, any> = {};\n\n    if (flow.name !== undefined) {\n      data.name = flow.name;\n      // Generate slug from name\n      data.slug = generateSlug(flow.name);\n    }\n    if (flow.description !== undefined) data.description = flow.description;\n    if (flow.nodes !== undefined) data.nodes = flow.nodes;\n    if (flow.status !== undefined) data.status = flow.status;\n    if (flow.inputSchema !== undefined) data.inputSchema = flow.inputSchema;\n    if (flow.outputSchema !== undefined) data.outputSchema = flow.outputSchema;\n    if (flow.isActive !== undefined) data.isActive = flow.isActive;\n    if (flow.version !== undefined) data.version = flow.version;\n    if (flow.category !== undefined) data.category = flow.category;\n    if (flow.metadata !== undefined) data.metadata = flow.metadata;\n    if (flow.schedule !== undefined) data.schedule = flow.schedule;\n    if (flow.webhookEnabled !== undefined) data.webhookEnabled = flow.webhookEnabled;\n    if (flow.webhookSecret !== undefined) data.webhookSecret = flow.webhookSecret;\n\n    return data;\n  }\n\n  // ============= FLOW EXECUTIONS =============\n\n  /**\n   * Get all flow executions with optional filtering, sorting, and pagination\n   * @param options - Query options for filtering, sorting, and pagination\n   * @returns Array of FlowExecution objects\n   */\n  async getAllFlowExecutions(options?: {\n    filters?: Record<string, any>;\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<FlowExecution[]> {\n    const params = this.buildQueryParams({\n      ...options,\n      populate: ['flow'],\n    });\n    const { data } = await this.client.get<StrapiResponse<StrapiAttributes<any>[]>>(\n      '/flow-executions',\n      { params }\n    );\n\n    return data.data.map((item: StrapiAttributes<any>) => this.transformFlowExecution(item));\n  }\n\n  /**\n   * Get a single flow execution by ID\n   * @param id - Flow execution document ID\n   * @returns FlowExecution object\n   */\n  async getFlowExecution(id: string): Promise<FlowExecution> {\n    const { data } = await this.client.get<StrapiData<any>>(\n      `/flow-executions/${id}`,\n      {\n        params: {\n          populate: {\n            flow: true,\n          },\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error(`Flow execution with ID ${id} not found`);\n    }\n\n    return this.transformFlowExecution(data.data);\n  }\n\n  /**\n   * Create a new flow execution record\n   * @param executionData - Flow execution creation data\n   * @returns Created FlowExecution object\n   */\n  async createFlowExecution(executionData: {\n    flowId: string;\n    status: FlowExecutionStatus;\n    input?: Record<string, any>;\n    triggeredBy: FlowTriggerType;\n    triggerData?: Record<string, any>;\n    startedAt?: Date;\n    logs?: FlowExecutionLog[];\n    nodeExecutions?: NodeExecution[];\n    tokensUsed?: number;\n    cost?: number;\n    retryCount?: number;\n  }): Promise<FlowExecution> {\n    const { data } = await this.client.post<StrapiData<any>>(\n      '/flow-executions',\n      {\n        data: {\n          flow: executionData.flowId,\n          status: executionData.status,\n          input: executionData.input,\n          triggeredBy: executionData.triggeredBy,\n          triggerData: executionData.triggerData,\n          startedAt: executionData.startedAt?.toISOString(),\n          logs: executionData.logs || [],\n          nodeExecutions: executionData.nodeExecutions || [],\n          tokensUsed: executionData.tokensUsed || 0,\n          cost: executionData.cost || 0,\n          retryCount: executionData.retryCount || 0,\n        },\n      }\n    );\n\n    if (!data.data) {\n      throw new Error('Failed to create flow execution');\n    }\n\n    return this.transformFlowExecution(data.data);\n  }\n\n  /**\n   * Update a flow execution record\n   * @param id - Flow execution document ID\n   * @param executionData - Flow execution update data\n   * @returns Updated FlowExecution object\n   */\n  async updateFlowExecution(id: string, executionData: {\n    status?: FlowExecutionStatus;\n    output?: Record<string, any>;\n    logs?: FlowExecutionLog[];\n    error?: string;\n    errorDetails?: Record<string, any>;\n    completedAt?: Date;\n    executionTime?: number;\n    nodeExecutions?: NodeExecution[];\n    currentNodeId?: string;\n    tokensUsed?: number;\n    cost?: number;\n  }): Promise<FlowExecution> {\n    const updateData: Record<string, any> = {};\n\n    if (executionData.status !== undefined) updateData.status = executionData.status;\n    if (executionData.output !== undefined) updateData.output = executionData.output;\n    if (executionData.logs !== undefined) updateData.logs = executionData.logs;\n    if (executionData.error !== undefined) updateData.error = executionData.error;\n    if (executionData.errorDetails !== undefined) updateData.errorDetails = executionData.errorDetails;\n    if (executionData.completedAt !== undefined) updateData.completedAt = executionData.completedAt.toISOString();\n    if (executionData.executionTime !== undefined) updateData.executionTime = executionData.executionTime;\n    if (executionData.nodeExecutions !== undefined) updateData.nodeExecutions = executionData.nodeExecutions;\n    if (executionData.currentNodeId !== undefined) updateData.currentNodeId = executionData.currentNodeId;\n    if (executionData.tokensUsed !== undefined) updateData.tokensUsed = executionData.tokensUsed;\n    if (executionData.cost !== undefined) updateData.cost = executionData.cost;\n\n    const { data } = await this.client.put<StrapiData<any>>(\n      `/flow-executions/${id}`,\n      { data: updateData }\n    );\n\n    if (!data.data) {\n      throw new Error(`Failed to update flow execution with ID ${id}`);\n    }\n\n    return this.transformFlowExecution(data.data);\n  }\n\n  /**\n   * Delete a flow execution record\n   * @param id - Flow execution document ID\n   */\n  async deleteFlowExecution(id: string): Promise<void> {\n    await this.client.delete(`/flow-executions/${id}`);\n  }\n\n  /**\n   * Get flow executions by flow ID\n   * @param flowId - Flow document ID\n   * @param options - Optional sort and pagination\n   * @returns Array of FlowExecution objects for the specified flow\n   */\n  async getFlowExecutionsByFlowId(flowId: string, options?: {\n    sort?: string[];\n    pagination?: { page: number; pageSize: number };\n  }): Promise<FlowExecution[]> {\n    return this.getAllFlowExecutions({\n      ...options,\n      filters: { flow: { documentId: flowId } },\n    });\n  }\n\n  /**\n   * Get running flow executions\n   * @returns Array of FlowExecution objects with status 'running'\n   */\n  async getRunningFlowExecutions(): Promise<FlowExecution[]> {\n    return this.getAllFlowExecutions({\n      filters: { status: 'running' },\n      sort: ['startedAt:desc'],\n    });\n  }\n\n  /**\n   * Get recent flow executions\n   * @param limit - Maximum number of executions to return\n   * @returns Array of recent FlowExecution objects\n   */\n  async getRecentFlowExecutions(limit: number = 10): Promise<FlowExecution[]> {\n    return this.getAllFlowExecutions({\n      sort: ['createdAt:desc'],\n      pagination: { page: 1, pageSize: limit },\n    });\n  }\n\n  /**\n   * Get flow executions by status\n   * @param status - Execution status to filter by\n   * @returns Array of FlowExecution objects with the specified status\n   */\n  async getFlowExecutionsByStatus(status: FlowExecutionStatus): Promise<FlowExecution[]> {\n    return this.getAllFlowExecutions({\n      filters: { status },\n      sort: ['createdAt:desc'],\n    });\n  }\n\n  /**\n   * Get statistics for a specific flow\n   * @param flowId - Flow document ID\n   * @returns FlowStats object with execution statistics\n   */\n  async getFlowStats(flowId: string): Promise<FlowStats> {\n    const executions = await this.getFlowExecutionsByFlowId(flowId);\n\n    const stats: FlowStats = {\n      flowId,\n      totalExecutions: executions.length,\n      successCount: executions.filter(e => e.status === 'completed').length,\n      failedCount: executions.filter(e => e.status === 'failed').length,\n      cancelledCount: executions.filter(e => e.status === 'cancelled').length,\n      successRate: 0,\n      averageExecutionTime: 0,\n      totalTokensUsed: 0,\n      totalCost: 0,\n    };\n\n    // Calculate rates and totals\n    if (stats.totalExecutions > 0) {\n      stats.successRate = (stats.successCount / stats.totalExecutions) * 100;\n\n      const completedExecutions = executions.filter(e => e.executionTime !== undefined);\n      if (completedExecutions.length > 0) {\n        stats.averageExecutionTime = completedExecutions.reduce((sum, e) => sum + (e.executionTime || 0), 0) / completedExecutions.length;\n      }\n\n      stats.totalTokensUsed = executions.reduce((sum, e) => sum + (e.tokensUsed || 0), 0);\n      stats.totalCost = executions.reduce((sum, e) => sum + (e.cost || 0), 0);\n\n      // Find last execution time\n      const lastExecution = executions.find(e => e.startedAt);\n      if (lastExecution?.startedAt) {\n        stats.lastExecutedAt = lastExecution.startedAt;\n      }\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get global statistics across all flows\n   * @returns GlobalFlowStats object with aggregate statistics\n   */\n  async getGlobalFlowStats(): Promise<GlobalFlowStats> {\n    const [flows, executions] = await Promise.all([\n      this.getAllFlows(),\n      this.getAllFlowExecutions({ sort: ['createdAt:desc'] }),\n    ]);\n\n    const stats: GlobalFlowStats = {\n      totalFlows: flows.length,\n      activeFlows: flows.filter(f => f.isActive).length,\n      totalExecutions: executions.length,\n      runningExecutions: executions.filter(e => e.status === 'running').length,\n      successCount: executions.filter(e => e.status === 'completed').length,\n      failedCount: executions.filter(e => e.status === 'failed').length,\n      successRate: 0,\n      totalTokensUsed: 0,\n      totalCost: 0,\n    };\n\n    // Calculate success rate\n    const completedOrFailed = stats.successCount + stats.failedCount;\n    if (completedOrFailed > 0) {\n      stats.successRate = (stats.successCount / completedOrFailed) * 100;\n    }\n\n    // Calculate totals\n    stats.totalTokensUsed = executions.reduce((sum, e) => sum + (e.tokensUsed || 0), 0);\n    stats.totalCost = executions.reduce((sum, e) => sum + (e.cost || 0), 0);\n\n    return stats;\n  }\n\n  /**\n   * Clean up old flow executions\n   * @param olderThanDays - Delete executions older than this many days\n   * @returns Number of deleted executions\n   */\n  async cleanupOldFlowExecutions(olderThanDays: number = 30): Promise<number> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n\n    const oldExecutions = await this.getAllFlowExecutions({\n      filters: {\n        createdAt: { $lt: cutoffDate.toISOString() },\n        status: { $in: ['completed', 'failed', 'cancelled'] },\n      },\n    });\n\n    // Delete each old execution\n    await Promise.all(oldExecutions.map(e => this.deleteFlowExecution(e.id)));\n\n    return oldExecutions.length;\n  }\n\n  /**\n   * Transform Strapi flow execution response to FlowExecution domain model\n   */\n  private transformFlowExecution(strapiData: StrapiAttributes<any>): FlowExecution {\n    const attrs = this.extractAttributes(strapiData);\n\n    return {\n      id: strapiData.documentId,\n      flowId: attrs.flow?.documentId || attrs.flow,\n      flow: attrs.flow?.documentId ? this.transformFlow(attrs.flow) : undefined,\n      status: (attrs.status || 'pending') as FlowExecutionStatus,\n      input: attrs.input,\n      output: attrs.output,\n      logs: (attrs.logs || []) as FlowExecutionLog[],\n      error: attrs.error,\n      errorDetails: attrs.errorDetails,\n      startedAt: attrs.startedAt ? new Date(attrs.startedAt) : undefined,\n      completedAt: attrs.completedAt ? new Date(attrs.completedAt) : undefined,\n      executionTime: attrs.executionTime,\n      nodeExecutions: (attrs.nodeExecutions || []) as NodeExecution[],\n      currentNodeId: attrs.currentNodeId,\n      tokensUsed: attrs.tokensUsed || 0,\n      cost: attrs.cost || 0,\n      triggeredBy: (attrs.triggeredBy || 'manual') as FlowTriggerType,\n      triggerData: attrs.triggerData,\n      retryCount: attrs.retryCount || 0,\n      parentExecutionId: attrs.parentExecutionId,\n      metadata: attrs.metadata,\n      createdAt: new Date(attrs.createdAt),\n      updatedAt: new Date(attrs.updatedAt),\n    };\n  }\n\n  // ============= ERROR HANDLING =============\n\n  /**\n   * Handle axios errors with detailed logging\n   */\n  private handleError(error: AxiosError) {\n    if (error.response) {\n      // Server responded with error status\n      console.error('[Strapi] Response error:', {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data,\n        url: error.config?.url,\n      });\n    } else if (error.request) {\n      // Request made but no response\n      console.error('[Strapi] No response received:', {\n        message: error.message,\n        url: error.config?.url,\n      });\n    } else {\n      // Error in request setup\n      console.error('[Strapi] Request setup error:', {\n        message: error.message,\n        url: error.config?.url,\n      });\n    }\n  }\n}\n\n// ============= SINGLETON EXPORT =============\n\n/**\n * Singleton instance of StrapiClient\n * Use this throughout the application for all Strapi interactions\n */\nexport const strapiClient = new StrapiClient();\n",
        "last_modified": "2026-01-02T17:55:06.522219"
      },
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.675919",
  "last_updated": "2026-01-02T15:21:47.003099"
}