{
  "file_path": "src/services/chat-service.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "/**\n * Chat Service - Manages chat sessions and messages\n *\n * This service handles:\n * - Creating and managing chat sessions\n * - Sending messages with file attachments\n * - Streaming responses from Claude Agent SDK\n * - Storing messages in Strapi\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { query, type Query, type Options, type PermissionMode } from '@anthropic-ai/claude-agent-sdk';\nimport axios from 'axios';\nimport type {\n  ChatSession,\n  ChatMessage,\n  SendMessageRequest\n} from '../types/chat-types.js';\nimport { strapiClient } from './strapi-client.js';\nimport { createLogger, type Logger } from './logger.js';\nimport { chatLogService } from './chat-log-service.js';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nconst STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';\nconst STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;\n\nexport class ChatService extends EventEmitter {\n  private logger: Logger;\n  private activeStreams: Map<string, Query> = new Map();\n  private activeAbortControllers: Map<string, AbortController> = new Map();\n\n  constructor() {\n    super();\n    this.logger = createLogger('ChatService');\n  }\n\n  /**\n   * Helper method to make Strapi API calls\n   */\n  private async strapiRequest<T = any>(method: string, endpoint: string, data?: any, params?: any): Promise<T> {\n    const config: any = {\n      method,\n      url: `${STRAPI_URL}/api${endpoint}`,\n      headers: {\n        'Authorization': STRAPI_API_TOKEN ? `Bearer ${STRAPI_API_TOKEN}` : '',\n        'Content-Type': 'application/json',\n      },\n    };\n\n    if (data) config.data = data;\n    if (params) config.params = params;\n\n    const response = await axios(config);\n    return response.data;\n  }\n\n  /**\n   * Create a new chat session\n   * @param title - Session title\n   * @param skillIds - Array of skill documentIds to include\n   * @param agentId - Optional agent documentId for systemPrompt and configuration\n   * @param customSystemPrompt - Optional custom system prompt override\n   * @param workingDirectory - Working directory for SDK execution\n   * @param permissionMode - Permission mode for SDK (default, bypass, auto, plan)\n   * @returns Created chat session\n   */\n  async createChatSession(\n    title: string,\n    skillIds: string[],\n    agentId: string | undefined,\n    customSystemPrompt: string | undefined,\n    workingDirectory: string,\n    permissionMode?: 'default' | 'bypass' | 'auto' | 'plan'\n  ): Promise<ChatSession> {\n    try {\n      this.logger.info('Creating new chat session', {\n        title,\n        skillIds,\n        agentId,\n        customSystemPrompt: customSystemPrompt ? 'provided' : 'none',\n        workingDirectory,\n        permissionMode: permissionMode || 'default'\n      });\n\n      // Create session in Strapi with populate to return full data\n      // Note: \"plan\" is not in Strapi's permissionMode enum, so we use planMode boolean instead\n      const effectiveMode = permissionMode || 'default';\n      const isPlanMode = effectiveMode === 'plan';\n\n      const data = await this.strapiRequest('POST', '/chat-sessions?populate[skills]=true&populate[agent][populate][toolConfig]=true&populate[agent][populate][modelConfig]=true', {\n        data: {\n          title,\n          status: 'active',\n          sessionId: null, // Will be set when first message is sent\n          skills: { connect: skillIds.map(id => ({ documentId: id })) }, // Many-to-many relation (Strapi v5 format with documentId objects)\n          agent: agentId || undefined, // Many-to-one relation (Strapi v5 format - direct documentId string, no connect)\n          customSystemPrompt: customSystemPrompt, // Optional custom system prompt\n          permissionMode: isPlanMode ? 'default' : effectiveMode, // \"plan\" is not in enum, use \"default\" instead\n          planMode: isPlanMode, // Store plan mode as separate boolean field\n        },\n      });\n\n      if (!data.data) {\n        throw new Error('Failed to create chat session');\n      }\n\n      const session = this.transformChatSession(data.data);\n\n      this.logger.info('Chat session created successfully', { sessionId: session.documentId });\n\n      // Initialize chat log file\n      await chatLogService.initChatLog(session, workingDirectory);\n\n      return session;\n    } catch (error) {\n      this.logger.error('Failed to create chat session', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get chat session by documentId\n   */\n  async getChatSession(sessionDocId: string): Promise<ChatSession> {\n    try {\n      const data = await this.strapiRequest('GET', `/chat-sessions/${sessionDocId}`, undefined, {\n        populate: {\n          skills: {\n            populate: {\n              toolConfig: true,\n              mcpConfig: {\n                populate: {\n                  mcpServer: true,\n                  selectedTools: {\n                    populate: { mcpTool: true },\n                  },\n                },\n              },\n            },\n          },\n          agent: {\n            populate: {\n              toolConfig: true,\n              modelConfig: true,\n              mcpConfig: {\n                populate: {\n                  mcpServer: true,\n                  selectedTools: {\n                    populate: { mcpTool: true },\n                  },\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (!data.data) {\n        throw new Error(`Chat session ${sessionDocId} not found`);\n      }\n\n      return this.transformChatSession(data.data);\n    } catch (error) {\n      this.logger.error('Failed to get chat session', error, { sessionDocId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get all chat sessions\n   */\n  async getAllChatSessions(): Promise<ChatSession[]> {\n    try {\n      const data = await this.strapiRequest('GET', '/chat-sessions', undefined, {\n        sort: ['createdAt:desc'],\n        populate: {\n          skills: true,\n          agent: {\n            populate: {\n              toolConfig: true,\n              modelConfig: true,\n              mcpConfig: {\n                populate: {\n                  mcpServer: true,\n                  selectedTools: {\n                    populate: { mcpTool: true },\n                  },\n                },\n              },\n            },\n          },\n        },\n      });\n\n      return data.data.map((item: any) => this.transformChatSession(item));\n    } catch (error) {\n      this.logger.error('Failed to get chat sessions', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get messages for a chat session\n   */\n  async getChatMessages(sessionDocId: string): Promise<ChatMessage[]> {\n    try {\n      // Get session with populated messages (avoid direct filter on relations)\n      const sessionData = await this.strapiRequest('GET', `/chat-sessions/${sessionDocId}`, undefined, {\n        populate: {\n          messages: {\n            sort: ['timestamp:asc'],\n          },\n        },\n      });\n\n      if (!sessionData.data) {\n        this.logger.warn('Chat session not found', { sessionDocId });\n        return []; // Return empty array if session doesn't exist\n      }\n\n      const messages = sessionData.data.messages || [];\n      this.logger.info('Messages fetched successfully', { count: messages.length });\n\n      return messages.map((item: any) => this.transformChatMessage(item));\n    } catch (error) {\n      this.logger.error('Failed to get chat messages', error, { sessionDocId });\n      throw error;\n    }\n  }\n\n  /**\n   * Save a chat message to Strapi\n   */\n  private async saveChatMessage(\n    sessionDocId: string,\n    role: 'user' | 'assistant' | 'system',\n    content: string,\n    attachmentIds?: number[],\n    metadata?: any\n  ): Promise<ChatMessage> {\n    try {\n      const data = await this.strapiRequest('POST', '/chat-messages', {\n        data: {\n          session: sessionDocId,\n          role,\n          content,\n          attachments: attachmentIds,\n          metadata: metadata || {},\n          timestamp: new Date().toISOString(),\n        },\n      });\n\n      if (!data.data) {\n        throw new Error('Failed to save chat message');\n      }\n\n      return this.transformChatMessage(data.data);\n    } catch (error) {\n      this.logger.error('Failed to save chat message', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send a message and stream response\n   * This is an async generator that yields chat messages as they arrive\n   */\n  async* sendMessage(\n    sessionDocId: string,\n    message: string,\n    attachments: SendMessageRequest['attachments'],\n    workingDirectory: string,\n    permissionMode?: 'default' | 'bypass' | 'auto' | 'plan',\n    agentId?: string,\n    skillIds?: string[]\n  ): AsyncGenerator<any> {\n    try {\n      this.logger.info('Sending chat message', { sessionDocId, messageLength: message.length, attachmentCount: attachments?.length || 0 });\n\n      // Get chat session\n      const session = await this.getChatSession(sessionDocId);\n\n      // Determine effective skills: use provided skillIds or fallback to session skills\n      const effectiveSkillIds = skillIds || session.skills?.map(skill => skill.documentId) || [];\n\n      // Sync skills to filesystem\n      if (effectiveSkillIds.length > 0) {\n        try {\n          const { skillSyncService } = await import('./skill-sync-service.js');\n\n          // Fetch full skill details from Strapi\n          const fullSkills = await strapiClient.getSkillsByIds(effectiveSkillIds);\n\n          // Sync skills to filesystem\n          await skillSyncService.syncAllSkills(fullSkills);\n\n          this.logger.info('Synced skills to filesystem', {\n            sessionId: sessionDocId,\n            skillCount: fullSkills.length,\n            skillNames: fullSkills.map(s => s.name),\n            overridden: !!skillIds\n          });\n        } catch (syncError) {\n          this.logger.error('Failed to sync skills for chat', syncError);\n          // Continue execution - skills won't be available but chat still works\n        }\n      }\n\n      // Save user message to Strapi\n      let attachmentIds: number[] = [];\n      if (attachments && attachments.length > 0) {\n        // Upload attachments to Strapi\n        for (const attachment of attachments) {\n          const buffer = Buffer.from(attachment.data, 'base64');\n          const uploaded = await strapiClient.uploadFile(buffer, attachment.name);\n          attachmentIds.push(uploaded.id);\n        }\n      }\n\n      const userMessage = await this.saveChatMessage(\n        sessionDocId,\n        'user',\n        message,\n        attachmentIds\n      );\n\n      yield {\n        type: 'user_message_saved',\n        message: userMessage,\n      };\n\n      // Add user message to log\n      await chatLogService.addMessageToLog(sessionDocId, userMessage);\n\n      // Auto-update title if it's \"New Chat\" (first message)\n      if (session.title === 'New Chat') {\n        try {\n          // Generate title from first message (first 50 chars)\n          const autoTitle = message.length > 50\n            ? message.substring(0, 50) + '...'\n            : message;\n\n          await this.strapiRequest('PUT', `/chat-sessions/${sessionDocId}`, {\n            data: { title: autoTitle },\n          });\n\n          this.logger.info('Auto-updated chat title', {\n            sessionId: sessionDocId,\n            newTitle: autoTitle\n          });\n        } catch (error) {\n          this.logger.warn('Failed to auto-update chat title', error);\n          // Don't fail the chat if title update fails\n        }\n      }\n\n      // Build SDK options\n      // Use provided modes or fallback to session modes\n      const requestedMode = permissionMode ?? session.permissionMode ?? 'default';\n\n      // Check if plan mode is requested\n      const effectivePlanMode = requestedMode === 'plan' || session.planMode || false;\n\n      // Map our permission mode to SDK's PermissionMode\n      const mapPermissionMode = (mode: string): PermissionMode => {\n        switch (mode) {\n          case 'bypass': return 'bypassPermissions';\n          case 'auto': return 'acceptEdits';\n          case 'plan': return 'default'; // Plan mode uses default permission with planMode flag\n          case 'default':\n          default: return 'default';\n        }\n      };\n\n      const effectivePermissionMode = mapPermissionMode(requestedMode);\n\n      // Determine effective agent: use provided agentId or fallback to session agent\n      let effectiveAgent = session.agent;\n      if (agentId && agentId !== session.agent?.documentId) {\n        try {\n          // Fetch agent with full population\n          const agentData = await strapiClient.getAgent(agentId);\n          if (agentData) {\n            effectiveAgent = {\n              id: agentData.id ? Number(agentData.id) : 0,\n              documentId: agentData.id, // Agent uses id as documentId\n              name: agentData.name,\n              systemPrompt: agentData.systemPrompt,\n              toolConfig: agentData.toolConfig,\n              modelConfig: agentData.modelConfig,\n              mcpConfig: agentData.mcpConfig\n            };\n            this.logger.info('Using per-message agent override', {\n              sessionId: sessionDocId,\n              agentId: agentId,\n              agentName: effectiveAgent?.name\n            });\n          }\n        } catch (agentError) {\n          this.logger.error('Failed to fetch agent override', agentError);\n          // Fallback to session agent\n        }\n      }\n\n      // Build systemPrompt from effective agent or customSystemPrompt\n      let systemPrompt: string | undefined;\n      if (effectiveAgent) {\n        systemPrompt = effectiveAgent.systemPrompt;\n        this.logger.info('Using agent system prompt', {\n          sessionId: sessionDocId,\n          agentId: effectiveAgent.documentId,\n          agentName: effectiveAgent.name\n        });\n      } else if (session.customSystemPrompt) {\n        systemPrompt = session.customSystemPrompt;\n        this.logger.info('Using custom system prompt', { sessionId: sessionDocId });\n      }\n\n      // Get model from effective agent config or use default\n      const modelName = effectiveAgent?.modelConfig?.model || 'claude-sonnet-4-5';\n\n      // Get allowed tools from effective agent config or use defaults\n      const allowedTools = effectiveAgent?.toolConfig?.allowedTools || [\n        'Read', 'Write', 'Bash', 'Grep', 'Glob', 'Skill', 'Edit'\n      ];\n\n      // Get disallowed tools from effective agent config\n      const disallowedTools = effectiveAgent?.toolConfig?.disallowedTools || [];\n      // Build MCP servers from effective agent's mcpConfig\n      let mcpServers: Record<string, any> | undefined;\n      if (effectiveAgent?.mcpConfig && Array.isArray(effectiveAgent.mcpConfig) && effectiveAgent.mcpConfig.length > 0) {\n        try {\n          mcpServers = await this.buildMcpServersFromAgentConfig(effectiveAgent.mcpConfig, workingDirectory);\n          this.logger.info('Built MCP servers from agent config', {\n            sessionId: sessionDocId,\n            serverCount: mcpServers ? Object.keys(mcpServers).length : 0\n          });\n        } catch (mcpError) {\n          this.logger.warn('Failed to build MCP servers from agent config', { error: mcpError });\n        }\n      }\n\n      const options: Options = {\n        model: modelName,\n        systemPrompt: systemPrompt,\n        permissionMode: effectivePermissionMode,\n        includePartialMessages: true,\n        settingSources: ['project'], // Load skills from filesystem\n        cwd: workingDirectory,\n        allowedTools: allowedTools,\n        disallowedTools: disallowedTools,\n        mcpServers: mcpServers,\n\n        // Tool permission callback - handles runtime permission checks\n        canUseTool: async (toolName: string, input: any) => {\n          // Log tool permission request\n          await chatLogService.addSdkEvent(sessionDocId, sdkCallId, {\n            timestamp: new Date().toISOString(),\n            type: 'tool_permission_request',\n            data: { toolName, input }\n          });\n\n          this.logger.info('Tool permission requested', { toolName, mode: effectivePermissionMode, sessionId: sessionDocId });\n\n          // Auto-approve safe read-only tools\n          const autoApprovedTools = ['Read', 'Glob', 'Grep', 'Skill'];\n          if (autoApprovedTools.includes(toolName)) {\n            this.logger.debug('Tool auto-approved (safe read-only)', { toolName });\n            return { behavior: 'allow' as const, updatedInput: input };\n          }\n\n          // In bypassPermissions mode, allow all tools\n          if (effectivePermissionMode === 'bypassPermissions') {\n            this.logger.debug('Tool approved (bypass mode)', { toolName });\n            return { behavior: 'allow' as const, updatedInput: input };\n          }\n\n          // In acceptEdits mode, auto-approve Write/Edit tools\n          if (['Write', 'Edit'].includes(toolName) && effectivePermissionMode === 'acceptEdits') {\n            this.logger.debug('Tool auto-approved (acceptEdits mode)', { toolName });\n            return { behavior: 'allow' as const, updatedInput: input };\n          }\n\n          // For Bash commands in acceptEdits mode, check if safe filesystem operation\n          if (toolName === 'Bash' && effectivePermissionMode === 'acceptEdits') {\n            const command = typeof input === 'object' ? input.command : input;\n            const safeCommands = ['mkdir', 'touch', 'mv', 'cp'];\n            if (typeof command === 'string' && safeCommands.some(cmd => command.trim().startsWith(cmd))) {\n              this.logger.debug('Bash command auto-approved (acceptEdits mode)', { command });\n              return { behavior: 'allow' as const, updatedInput: input };\n            }\n          }\n\n          // Default: allow but log (TODO: implement user prompt for sensitive tools)\n          this.logger.info('Tool approved by default', { toolName, mode: effectivePermissionMode });\n          return { behavior: 'allow' as const, updatedInput: input };\n        },\n\n        // Hooks for fine-grained control over tool execution (SDK-compliant format)\n        hooks: {\n          PreToolUse: [{\n            hooks: [async (hookInput: any, toolUseID: string | undefined, hookOptions: { signal: AbortSignal }) => {\n              const toolName = hookInput.tool_name;\n              const input = hookInput.tool_input;\n              this.logger.info('Tool execution starting', { toolName, toolUseID, sessionId: sessionDocId });\n              await chatLogService.addSdkEvent(sessionDocId, sdkCallId, {\n                timestamp: new Date().toISOString(),\n                type: 'tool_use_start',\n                data: { toolName, input, toolUseID }\n              });\n              return { continue: true };\n            }]\n          }],\n          PostToolUse: [{\n            hooks: [async (hookInput: any, toolUseID: string | undefined, hookOptions: { signal: AbortSignal }) => {\n              const toolName = hookInput.tool_name;\n              const result = hookInput.tool_response;\n              const resultSize = result ? JSON.stringify(result).length : 0;\n              this.logger.info('Tool execution completed', { toolName, resultSize, toolUseID, sessionId: sessionDocId });\n              await chatLogService.addSdkEvent(sessionDocId, sdkCallId, {\n                timestamp: new Date().toISOString(),\n                type: 'tool_use_complete',\n                data: { toolName, result, toolUseID }\n              });\n              return { continue: true };\n            }]\n          }]\n        }\n      };\n\n      // Enable plan mode if requested (custom implementation since SDK doesn't support it yet)\n      if (effectivePlanMode) {\n        this.logger.info('Plan mode enabled - restricting to read-only tools and adding plan instructions');\n\n        // Restrict to read-only tools only\n        options.allowedTools = ['Read', 'Grep', 'Glob', 'Skill'];\n\n        // Add plan mode instructions to system prompt\n        const planModeInstructions = `\n\nIMPORTANT: You are in PLAN MODE. Your task is to:\n1. Analyze the codebase using read-only tools (Read, Grep, Glob, Skill)\n2. Present a detailed, step-by-step implementation plan\n3. DO NOT make any changes (no Write, Edit, or Bash commands)\n4. After presenting the plan, ask the user for approval before proceeding\n\nYour plan should include:\n- Files that need to be modified\n- New files that need to be created\n- Specific changes required in each file\n- Testing approach\n- Potential risks or considerations`;\n\n        options.systemPrompt = (options.systemPrompt || '') + planModeInstructions;\n      }\n\n      // Resume session if sessionId exists\n      if (session.sessionId) {\n        options.resume = session.sessionId;\n      }\n\n      // Build prompt generator for streaming input mode\n      const promptGenerator = this.buildPromptGenerator(message, attachments);\n\n      // Generate SDK call ID for logging\n      const sdkCallId = uuidv4();\n\n      // Log SDK call start (before creating query)\n      const promptForLog = {\n        type: 'user',\n        message: {\n          role: 'user',\n          content: attachments && attachments.length > 0\n            ? [{ type: 'text', text: message }, { type: 'attachments', count: attachments.length }]\n            : message,\n        },\n      };\n\n      await chatLogService.startSdkCall(sessionDocId, sdkCallId, userMessage.documentId, {\n        options: {\n          model: options.model || 'claude-sonnet-4-5',\n          permissionMode: options.permissionMode || 'default',\n          includePartialMessages: options.includePartialMessages || false,\n          settingSources: options.settingSources || [],\n          cwd: options.cwd || workingDirectory,\n          allowedTools: options.allowedTools || [],\n          resume: options.resume,\n        },\n        prompt: promptForLog,\n      });\n\n      // Save SDK payload to logs/chat folder (similar to task logging)\n      try {\n        const sdkPayload = {\n          prompt: promptForLog,\n          options: {\n            model: options.model || 'claude-sonnet-4-5',\n            systemPrompt: options.systemPrompt, // Agent's system prompt\n            permissionMode: options.permissionMode || 'default',\n            planMode: (options as any).planMode || false, // Plan mode flag\n            includePartialMessages: options.includePartialMessages || false,\n            settingSources: options.settingSources || [],\n            cwd: options.cwd || workingDirectory,\n            allowedTools: options.allowedTools || [],\n            disallowedTools: options.disallowedTools || [], // Disallowed tools from agent config\n            mcpServers: options.mcpServers, // MCP servers from agent config\n            resume: options.resume,\n          },\n        };\n\n        const logsDir = path.join(workingDirectory, 'logs', 'chat');\n        await fs.mkdir(logsDir, { recursive: true });\n        const payloadPath = path.join(logsDir, `${sessionDocId}-${sdkCallId}-sdk-payload.json`);\n        await fs.writeFile(payloadPath, JSON.stringify(sdkPayload, null, 2), 'utf-8');\n        this.logger.info('Chat SDK payload saved', { sessionDocId, sdkCallId, payloadPath });\n      } catch (payloadError) {\n        this.logger.warn('Failed to save chat SDK payload', { sessionDocId, sdkCallId, error: payloadError });\n      }\n\n      // Create AbortController for cancellation support\n      const abortController = new AbortController();\n      const streamId = uuidv4();\n\n      // Store abort controller for cancel capability\n      this.activeAbortControllers.set(streamId, abortController);\n\n      // Add abortController to options\n      const optionsWithAbort: Options = {\n        ...options,\n        abortController,\n      };\n\n      // Create query instance\n      const queryInstance = query({\n        prompt: promptGenerator,\n        options: optionsWithAbort,\n      });\n\n      this.activeStreams.set(streamId, queryInstance);\n\n      // Send stream ID to client immediately for cancel capability\n      yield {\n        type: 'stream_id',\n        streamId,\n        timestamp: new Date().toISOString(),\n      };\n\n      let assistantMessageContent = '';\n      let sdkSessionId: string | null = null;\n      let toolUses: any[] = [];\n      let finalCost: number | undefined;\n      let finalUsage: any | undefined;\n      let assistantMessageId: string | null = null;\n      let hasStreamingStarted = false;\n\n      try {\n        // Stream messages from SDK\n        for await (const msg of queryInstance) {\n          // Enhanced logging - similar to task execution logs\n          const timestamp = new Date().toISOString();\n\n          // Determine message category for better organization\n          let eventCategory = 'sdk_event';\n          let eventDetails: any = {\n            messageType: msg.type,\n            subtype: (msg as any).subtype,\n          };\n\n          // Categorize and extract details for different message types\n          if (msg.type === 'system') {\n            eventCategory = 'system';\n            if (msg.subtype === 'init') {\n              eventDetails.sessionId = msg.session_id;\n              eventDetails.model = msg.model;\n              eventDetails.tools = msg.tools;\n              eventDetails.permissionMode = msg.permissionMode;\n            }\n          } else if (msg.type === 'assistant') {\n            eventCategory = 'assistant_message';\n            if (Array.isArray(msg.message.content)) {\n              eventDetails.hasText = msg.message.content.some((b: any) => b.type === 'text');\n              eventDetails.hasToolUse = msg.message.content.some((b: any) => b.type === 'tool_use');\n              eventDetails.toolCount = msg.message.content.filter((b: any) => b.type === 'tool_use').length;\n\n              // Extract tool use details\n              const toolUseBlocks = msg.message.content.filter((b: any) => b.type === 'tool_use');\n              if (toolUseBlocks.length > 0) {\n                eventDetails.tools = toolUseBlocks.map((t: any) => ({\n                  name: t.name,\n                  id: t.id,\n                }));\n              }\n            }\n          } else if ('delta' in msg && (msg as any).delta?.type === 'text') {\n            eventCategory = 'text_delta';\n            eventDetails.textLength = (msg as any).delta.text?.length || 0;\n          } else if (msg.type === 'result') {\n            eventCategory = 'result';\n            eventDetails.isError = msg.is_error;\n            eventDetails.numTurns = msg.num_turns;\n            eventDetails.totalCost = msg.total_cost_usd;\n            eventDetails.duration = msg.duration_ms;\n          }\n\n          // Log SDK event with enhanced details\n          await chatLogService.addSdkEvent(sessionDocId, sdkCallId, {\n            timestamp,\n            type: msg.type,\n            subtype: (msg as any).subtype,\n            category: eventCategory,\n            details: eventDetails,\n            data: msg,\n          });\n\n          // Log detailed info for debugging\n          if (eventCategory === 'assistant_message' && eventDetails.hasToolUse) {\n            this.logger.info('Tool use detected in assistant message', {\n              sessionId: sessionDocId,\n              callId: sdkCallId,\n              tools: eventDetails.tools,\n            });\n          }\n\n          // Yield message to client immediately\n          yield {\n            type: 'sdk_message',\n            data: msg,\n          };\n\n          // Send assistant_message_start event on first text delta\n          // Text deltas come as stream_event with type content_block_delta\n          if (!hasStreamingStarted &&\n              msg.type === 'stream_event' &&\n              (msg as any).event?.type === 'content_block_delta' &&\n              (msg as any).event?.delta?.type === 'text_delta') {\n            hasStreamingStarted = true;\n            assistantMessageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n            yield {\n              type: 'assistant_message_start',\n              messageId: assistantMessageId,\n              timestamp: new Date().toISOString(),\n            };\n          }\n\n          // Process different message types\n          if (msg.type === 'system' && msg.subtype === 'init') {\n            sdkSessionId = msg.session_id || null;\n\n            // Update session with SDK session ID\n            if (sdkSessionId && !session.sessionId) {\n              await this.strapiRequest('PUT', `/chat-sessions/${sessionDocId}`, {\n                data: { sessionId: sdkSessionId },\n              });\n\n              // Update SDK session ID in log\n              await chatLogService.updateSdkSessionId(sessionDocId, sdkSessionId);\n            }\n          } else if (msg.type === 'assistant') {\n            // Accumulate assistant message content\n            if (Array.isArray(msg.message.content)) {\n              for (const block of msg.message.content) {\n                if (block.type === 'text') {\n                  assistantMessageContent += block.text;\n                } else if (block.type === 'tool_use') {\n                  toolUses.push(block);\n                }\n              }\n            }\n          } else if (msg.type === 'stream_event' &&\n                     (msg as any).event?.type === 'content_block_delta' &&\n                     (msg as any).event?.delta?.type === 'text_delta') {\n            // Real-time streaming text delta from stream_event\n            const textDelta = (msg as any).event.delta.text;\n            assistantMessageContent += textDelta;\n\n            // Yield assistant_message_delta event for frontend\n            if (assistantMessageId) {\n              yield {\n                type: 'assistant_message_delta',\n                delta: textDelta,\n                messageId: assistantMessageId,\n                timestamp: new Date().toISOString(),\n              };\n            }\n          } else if (msg.type === 'result') {\n            // Final result with cost and usage\n            finalCost = msg.total_cost_usd;\n            finalUsage = msg.usage;\n          }\n        }\n\n        // Save assistant message to Strapi\n        if (assistantMessageContent || toolUses.length > 0) {\n          const assistantMessage = await this.saveChatMessage(\n            sessionDocId,\n            'assistant',\n            assistantMessageContent,\n            undefined,\n            {\n              toolUses,\n              cost: finalCost,\n              usage: finalUsage,\n            }\n          );\n\n          yield {\n            type: 'assistant_message_saved',\n            message: assistantMessage,\n          };\n\n          // Add assistant message to log\n          await chatLogService.addMessageToLog(sessionDocId, assistantMessage);\n\n          // Complete SDK call log\n          await chatLogService.completeSdkCall(\n            sessionDocId,\n            sdkCallId,\n            assistantMessage.documentId,\n            {\n              cost: finalCost,\n              usage: finalUsage,\n            }\n          );\n        }\n\n        yield {\n          type: 'done',\n          cost: finalCost,\n          usage: finalUsage,\n        };\n\n      } catch (streamError) {\n        // Check if this was a cancellation (AbortController.abort())\n        if (abortController.signal.aborted) {\n          this.logger.info('Message stream was cancelled', { sessionDocId, streamId });\n\n          // Don't save incomplete assistant message when cancelled\n\n          yield {\n            type: 'cancelled',\n            streamId,\n            timestamp: new Date().toISOString(),\n            reason: 'User cancelled the request',\n          };\n        } else {\n          // Real error - log and yield error event\n          this.logger.error('Error during message streaming', streamError, { sessionDocId, streamId });\n          yield {\n            type: 'error',\n            error: streamError instanceof Error ? streamError.message : String(streamError),\n          };\n        }\n      } finally {\n        // Cleanup: Remove from active streams and abort controllers\n        this.activeStreams.delete(streamId);\n        this.activeAbortControllers.delete(streamId);\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to send message', error, { sessionDocId });\n      yield {\n        type: 'error',\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Build async generator for streaming input mode\n   */\n  private async* buildPromptGenerator(\n    message: string,\n    attachments?: SendMessageRequest['attachments']\n  ): AsyncGenerator<any> {\n    // Build content array\n    const content: any[] = [{ type: 'text', text: message }];\n\n    // Add attachments if present\n    if (attachments && attachments.length > 0) {\n      for (const attachment of attachments) {\n        const mimeType = attachment.mimeType;\n\n        if (mimeType.startsWith('image/')) {\n          content.push({\n            type: 'image',\n            source: {\n              type: 'base64',\n              media_type: mimeType,\n              data: attachment.data,\n            },\n          });\n        } else if (mimeType === 'application/pdf') {\n          // PDF support - SDK will process page by page\n          content.push({\n            type: 'document',\n            source: {\n              type: 'base64',\n              media_type: 'application/pdf',\n              data: attachment.data,\n            },\n          });\n        }\n        // Text files can be included as text content\n        else if (mimeType.startsWith('text/')) {\n          const textContent = Buffer.from(attachment.data, 'base64').toString('utf-8');\n          content.push({\n            type: 'text',\n            text: `\\n\\n--- File: ${attachment.name} ---\\n${textContent}\\n--- End of file ---\\n`,\n          });\n        }\n      }\n    }\n\n    // Yield user message\n    yield {\n      type: 'user',\n      message: {\n        role: 'user',\n        content: content.length === 1 ? message : content,\n      },\n    };\n  }\n\n  /**\n   * Delete a chat session\n   */\n  async deleteChatSession(sessionDocId: string): Promise<void> {\n    try {\n      // Delete all messages first\n      const messages = await this.getChatMessages(sessionDocId);\n      for (const message of messages) {\n        await this.strapiRequest('DELETE', `/chat-messages/${message.documentId}`);\n      }\n\n      // Delete session\n      await this.strapiRequest('DELETE', `/chat-sessions/${sessionDocId}`);\n\n      // Delete chat log file\n      await chatLogService.deleteChatLog(sessionDocId);\n\n      this.logger.info('Chat session deleted', { sessionDocId });\n    } catch (error) {\n      this.logger.error('Failed to delete chat session', error, { sessionDocId });\n      throw error;\n    }\n  }\n\n  /**\n   * Archive a chat session\n   */\n  async archiveChatSession(sessionDocId: string): Promise<ChatSession> {\n    try {\n      const data = await this.strapiRequest('PUT', `/chat-sessions/${sessionDocId}`, {\n        data: { status: 'archived' },\n      });\n\n      if (!data.data) {\n        throw new Error('Failed to archive chat session');\n      }\n\n      // Update status in log\n      await chatLogService.updateSessionStatus(sessionDocId, 'archived');\n\n      return this.transformChatSession(data.data);\n    } catch (error) {\n      this.logger.error('Failed to archive chat session', error, { sessionDocId });\n      throw error;\n    }\n  }\n\n  /**\n   * Cancel an active message stream\n   * @param streamId - The unique stream ID returned in stream_id event\n   * @returns true if stream was cancelled, false if stream not found\n   */\n  cancelMessage(streamId: string): boolean {\n    this.logger.info('Cancelling message stream', { streamId });\n\n    const abortController = this.activeAbortControllers.get(streamId);\n\n    if (abortController) {\n      // Abort the stream\n      abortController.abort();\n\n      // Cleanup\n      this.activeAbortControllers.delete(streamId);\n      this.activeStreams.delete(streamId);\n\n      this.logger.info('Message stream cancelled successfully', { streamId });\n      return true;\n    }\n\n    this.logger.warn('Stream not found or already completed', { streamId });\n    return false;\n  }\n\n  /**\n   * Get list of active stream IDs\n   * Useful for debugging or monitoring active conversations\n   */\n  getActiveStreamIds(): string[] {\n    return Array.from(this.activeStreams.keys());\n  }\n\n  /**\n   * Transform Strapi chat session response\n   */\n  private transformChatSession(strapiData: any): ChatSession {\n    const attrs = strapiData.attributes || strapiData;\n\n    // Handle skills - Strapi v5 returns direct array, v4 returned nested data array\n    let skills: any[] | undefined;\n    if (attrs.skills?.data) {\n      // Strapi v4 format\n      skills = attrs.skills.data.map((s: any) => ({\n        id: s.id,\n        documentId: s.documentId,\n        name: s.attributes?.name || s.name,\n      }));\n    } else if (Array.isArray(attrs.skills) && attrs.skills.length > 0) {\n      // Strapi v5 format - direct array\n      skills = attrs.skills.map((s: any) => ({\n        id: s.id,\n        documentId: s.documentId,\n        name: s.name,\n      }));\n    }\n\n    // Handle agent - Strapi v5 returns direct object, v4 returned nested data object\n    let agent: any | undefined;\n    if (attrs.agent?.data) {\n      // Strapi v4 format\n      agent = {\n        id: attrs.agent.data.id,\n        documentId: attrs.agent.data.documentId,\n        name: attrs.agent.data.attributes?.name || attrs.agent.data.name,\n        systemPrompt: attrs.agent.data.attributes?.systemPrompt || '',\n        toolConfig: attrs.agent.data.attributes?.toolConfig,\n        modelConfig: attrs.agent.data.attributes?.modelConfig,\n        mcpConfig: attrs.agent.data.attributes?.mcpConfig,\n      };\n    } else if (attrs.agent?.id) {\n      // Strapi v5 format - direct object\n      agent = {\n        id: attrs.agent.id,\n        documentId: attrs.agent.documentId,\n        name: attrs.agent.name,\n        systemPrompt: attrs.agent.systemPrompt || '',\n        toolConfig: attrs.agent.toolConfig,\n        modelConfig: attrs.agent.modelConfig,\n        mcpConfig: attrs.agent.mcpConfig,\n      };\n    }\n\n    // Map planMode boolean back to permissionMode: \"plan\" for client\n    const isPlanMode = attrs.planMode || false;\n    const effectivePermissionMode = isPlanMode ? 'plan' : (attrs.permissionMode || 'default');\n\n    return {\n      id: strapiData.id,\n      documentId: strapiData.documentId,\n      title: attrs.title,\n      status: attrs.status || 'active',\n      sessionId: attrs.sessionId || null,\n      skills,\n      agent,\n      customSystemPrompt: attrs.customSystemPrompt,\n      permissionMode: effectivePermissionMode as 'default' | 'bypass' | 'auto' | 'plan',\n      planMode: isPlanMode, // Keep for backwards compatibility\n      createdAt: attrs.createdAt,\n      updatedAt: attrs.updatedAt,\n      publishedAt: attrs.publishedAt,\n    };\n  }\n\n  /**\n   * Transform Strapi chat message response\n   */\n  private transformChatMessage(strapiData: any): ChatMessage {\n    const attrs = strapiData.attributes || strapiData;\n\n    return {\n      id: strapiData.id,\n      documentId: strapiData.documentId,\n      role: attrs.role,\n      content: attrs.content,\n      attachments: attrs.attachments?.data ? attrs.attachments.data.map((a: any) => ({\n        id: a.id,\n        documentId: a.documentId,\n        name: a.attributes?.name || a.name,\n        url: a.attributes?.url || a.url,\n        mime: a.attributes?.mime || a.mime,\n        size: a.attributes?.size || a.size,\n      })) : undefined,\n      metadata: attrs.metadata || {},\n      timestamp: attrs.timestamp,\n      createdAt: attrs.createdAt,\n      updatedAt: attrs.updatedAt,\n    };\n  }\n\n  /**\n   * Build MCP servers configuration from agent's mcpConfig\n   * Combines Strapi mcpConfig (which servers/tools to use) with .mcp.json (command/args)\n   */\n  private async buildMcpServersFromAgentConfig(\n    mcpConfig: any[],\n    workingDirectory: string\n  ): Promise<Record<string, any> | undefined> {\n    if (!mcpConfig || !Array.isArray(mcpConfig) || mcpConfig.length === 0) {\n      this.logger.debug('No mcpConfig found in agent');\n      return undefined;\n    }\n\n    // Load base MCP configuration from .mcp.json\n    const baseMcpConfig = await this.loadMcpConfig(workingDirectory);\n\n    if (!baseMcpConfig) {\n      this.logger.warn('No .mcp.json found, cannot build MCP servers from agent config');\n      return undefined;\n    }\n\n    const mcpServers: Record<string, any> = {};\n\n    for (const config of mcpConfig) {\n      // Extract server name from relation\n      const serverName = typeof config.mcpServer === 'string'\n        ? config.mcpServer\n        : config.mcpServer?.name;\n\n      if (!serverName) {\n        this.logger.warn('MCP config entry missing server name', { config });\n        continue;\n      }\n\n      // Get command/args from .mcp.json\n      if (baseMcpConfig[serverName]) {\n        mcpServers[serverName] = baseMcpConfig[serverName];\n        this.logger.debug('Added MCP server from agent config', {\n          serverName,\n          selectedTools: config.selectedTools?.map((t: any) =>\n            typeof t.mcpTool === 'string' ? t.mcpTool : t.mcpTool?.name\n          ) || []\n        });\n      } else {\n        this.logger.warn('MCP server not found in .mcp.json', { serverName });\n      }\n    }\n\n    return Object.keys(mcpServers).length > 0 ? mcpServers : undefined;\n  }\n\n  /**\n   * Load MCP configuration from .mcp.json\n   */\n  private async loadMcpConfig(workingDirectory: string): Promise<Record<string, any> | undefined> {\n    try {\n      const mcpConfigPath = path.join(workingDirectory, '.mcp.json');\n      const content = await fs.readFile(mcpConfigPath, 'utf-8');\n      const config = JSON.parse(content);\n\n      if (config.mcpServers && typeof config.mcpServers === 'object') {\n        return config.mcpServers;\n      }\n\n      return undefined;\n    } catch (error) {\n      // .mcp.json not found or invalid - this is okay\n      this.logger.debug('No MCP config found', { workingDirectory, error: (error as Error).message });\n      return undefined;\n    }\n  }\n}\n\n// Export singleton instance\nexport const chatService = new ChatService();\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "/**\n * ChatService - Real-time chat service with Claude Agent SDK integration\n *\n * @description\n * The ChatService manages interactive chat sessions with Claude AI using the Agent SDK,\n * providing real-time streaming conversations with support for file attachments, MCP servers,\n * and agent configurations. It extends EventEmitter to broadcast conversation events and\n * implements advanced stream management with abort controller patterns for cancellable requests.\n *\n * **Key Responsibilities:**\n * - Create and manage chat sessions stored in Strapi CMS\n * - Stream real-time responses from Claude Agent SDK with AsyncGenerator pattern\n * - Handle file attachments (images, PDFs, text files) with base64 encoding\n * - Integrate with agents (system prompts, model config, tool config, MCP servers)\n * - Manage conversation lifecycle (create, resume, archive, delete)\n * - Track active streams with cancellation support via AbortController\n * - Persist messages and SDK events to chat log files\n * - Sync skills to filesystem before conversation starts\n * - Transform SDK messages to application's chat message format\n *\n * **Architecture:**\n * - **EventEmitter Pattern**: Extends EventEmitter to broadcast chat events to subscribers\n * - **Active Streams Management**: Maintains Map of active Query instances indexed by streamId\n * - **Abort Controller Pattern**: Each stream has an AbortController for graceful cancellation\n * - **AsyncGenerator Streaming**: sendMessage() yields events as they arrive (user_message_saved,\n *   stream_id, sdk_message, assistant_message_delta, assistant_message_saved, done, error, cancelled)\n * - **Message Persistence**: Saves user/assistant messages to Strapi and chat log files\n * - **Agent Integration**: Supports per-session or per-message agent overrides with full config\n * - **MCP Server Support**: Loads MCP servers from agent's mcpConfig and .mcp.json files\n * - **Permission Modes**: Supports default, bypass, auto (acceptEdits), and plan modes\n * - **File Handling**: Uploads attachments to Strapi, processes images/PDFs/text for SDK\n *\n * **EventEmitter Events:**\n * Currently, ChatService extends EventEmitter but does not emit custom events.\n * Instead, it uses AsyncGenerator pattern to stream events directly to the caller.\n * Future versions may add events like 'chat:session:created', 'chat:message:sent', etc.\n *\n * **Active Streams Management:**\n * The service maintains two synchronized Maps for stream lifecycle:\n * - `activeStreams`: Map<streamId, Query> - Active SDK query instances\n * - `activeAbortControllers`: Map<streamId, AbortController> - Controllers for cancellation\n *\n * When a message is sent:\n * 1. Generate unique streamId (UUID)\n * 2. Create AbortController and store in activeAbortControllers\n * 3. Create SDK Query instance with abortController option\n * 4. Store Query in activeStreams\n * 5. Yield stream_id event to client (enables cancellation)\n * 6. Stream SDK messages via AsyncGenerator\n * 7. Cleanup: Remove from both Maps when stream completes/errors/cancelled\n *\n * **Abort Controller Pattern:**\n * - Each stream gets a dedicated AbortController instance\n * - Client receives streamId immediately after message send starts\n * - Client can call cancelMessage(streamId) to abort the stream\n * - Cancellation triggers abortController.abort()\n * - SDK Query respects abort signal and stops processing\n * - Cleanup happens in finally block (removes from Maps)\n * - Yields 'cancelled' event with reason and timestamp\n *\n * **Message Flow:**\n * 1. Client calls sendMessage() with text and optional attachments\n * 2. Service fetches chat session from Strapi with agent/skills config\n * 3. Syncs skills to filesystem (creates .claude/skills/*.md files)\n * 4. Uploads attachments to Strapi and saves user message\n * 5. Yields 'user_message_saved' event\n * 6. Builds SDK options (model, systemPrompt, permissions, tools, mcpServers)\n * 7. Creates SDK Query with AsyncGenerator prompt and AbortController\n * 8. Yields 'stream_id' event (enables cancellation)\n * 9. Streams SDK messages and yields 'sdk_message' events\n * 10. Accumulates assistant text from content_block_delta events\n * 11. Yields 'assistant_message_delta' events for real-time UI updates\n * 12. Saves complete assistant message to Strapi and chat log\n * 13. Yields 'assistant_message_saved' event\n * 14. Yields 'done' event with cost/usage metadata\n *\n * @example\n * ```typescript\n * // Basic usage - create session and send message\n * import { chatService } from './chat-service';\n *\n * // Create a new chat session\n * const session = await chatService.createChatSession(\n *   'Code Review Chat',\n *   ['skill-doc-id-1', 'skill-doc-id-2'], // Skill documentIds\n *   'agent-doc-id', // Agent documentId\n *   undefined, // No custom system prompt\n *   '/path/to/project',\n *   'default' // Permission mode\n * );\n *\n * console.log(`Session created: ${session.documentId}`);\n * ```\n *\n * @example\n * ```typescript\n * // Send message and handle streaming responses\n * import { chatService } from './chat-service';\n *\n * const sessionDocId = 'chat-session-doc-id';\n * const message = 'Review the authentication code in src/auth.ts';\n * const attachments = []; // No attachments\n * const workingDir = '/path/to/project';\n *\n * // Stream responses using AsyncGenerator\n * for await (const event of chatService.sendMessage(\n *   sessionDocId,\n *   message,\n *   attachments,\n *   workingDir\n * )) {\n *   switch (event.type) {\n *     case 'user_message_saved':\n *       console.log('User message saved:', event.message);\n *       break;\n *     case 'stream_id':\n *       console.log('Stream ID:', event.streamId);\n *       // Store streamId for potential cancellation\n *       break;\n *     case 'assistant_message_delta':\n *       // Real-time text streaming\n *       process.stdout.write(event.delta);\n *       break;\n *     case 'assistant_message_saved':\n *       console.log('\\nAssistant message saved:', event.message);\n *       break;\n *     case 'done':\n *       console.log('Conversation complete. Cost:', event.cost);\n *       break;\n *     case 'error':\n *       console.error('Error:', event.error);\n *       break;\n *     case 'cancelled':\n *       console.log('Stream cancelled:', event.reason);\n *       break;\n *   }\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Send message with file attachments\n * import { chatService } from './chat-service';\n * import fs from 'fs';\n *\n * const sessionDocId = 'chat-session-doc-id';\n * const message = 'Analyze this diagram and suggest improvements';\n * const imageBuffer = fs.readFileSync('./diagram.png');\n * const attachments = [{\n *   name: 'diagram.png',\n *   mimeType: 'image/png',\n *   data: imageBuffer.toString('base64')\n * }];\n *\n * for await (const event of chatService.sendMessage(\n *   sessionDocId,\n *   message,\n *   attachments,\n *   '/path/to/project'\n * )) {\n *   if (event.type === 'assistant_message_delta') {\n *     console.log(event.delta);\n *   }\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Cancel an active message stream\n * import { chatService } from './chat-service';\n *\n * let currentStreamId: string | null = null;\n *\n * // Start streaming in background\n * (async () => {\n *   for await (const event of chatService.sendMessage(\n *     sessionDocId,\n *     'This is a long running task...',\n *     [],\n *     workingDir\n *   )) {\n *     if (event.type === 'stream_id') {\n *       currentStreamId = event.streamId;\n *     }\n *     if (event.type === 'cancelled') {\n *       console.log('Stream was cancelled');\n *     }\n *   }\n * })();\n *\n * // Cancel after 5 seconds\n * setTimeout(() => {\n *   if (currentStreamId) {\n *     const cancelled = chatService.cancelMessage(currentStreamId);\n *     console.log('Cancellation requested:', cancelled);\n *   }\n * }, 5000);\n * ```\n *\n * @example\n * ```typescript\n * // Use plan mode for read-only analysis\n * import { chatService } from './chat-service';\n *\n * const session = await chatService.createChatSession(\n *   'Plan Mode Chat',\n *   [], // No skills\n *   'agent-doc-id',\n *   undefined,\n *   '/path/to/project',\n *   'plan' // Plan mode: read-only tools, requires user approval before changes\n * );\n *\n * for await (const event of chatService.sendMessage(\n *   session.documentId,\n *   'Create a plan to add a user authentication system',\n *   [],\n *   '/path/to/project',\n *   'plan' // Override permission mode for this message\n * )) {\n *   // Claude will analyze the codebase and present a detailed plan\n *   // without making any changes (Read, Grep, Glob tools only)\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Agent override - use different agent per message\n * import { chatService } from './chat-service';\n *\n * const session = await chatService.createChatSession(\n *   'Multi-Agent Chat',\n *   ['skill-1'],\n *   'default-agent-id',\n *   undefined,\n *   '/path/to/project'\n * );\n *\n * // First message uses default agent\n * for await (const event of chatService.sendMessage(\n *   session.documentId,\n *   'Write a test file',\n *   [],\n *   '/path/to/project'\n * )) { /* ... */ }\n *\n * // Second message overrides with specialized agent\n * for await (const event of chatService.sendMessage(\n *   session.documentId,\n *   'Review the code for security issues',\n *   [],\n *   '/path/to/project',\n *   undefined, // Use session permission mode\n *   'security-agent-id' // Override with security specialist agent\n * )) { /* ... */ }\n * ```\n *\n * @example\n * ```typescript\n * // Session management\n * import { chatService } from './chat-service';\n *\n * // Get all sessions\n * const sessions = await chatService.getAllChatSessions();\n * console.log(`Total sessions: ${sessions.length}`);\n *\n * // Get specific session\n * const session = await chatService.getChatSession('session-doc-id');\n * console.log(`Session title: ${session.title}`);\n *\n * // Get messages for session\n * const messages = await chatService.getChatMessages('session-doc-id');\n * console.log(`Message count: ${messages.length}`);\n *\n * // Archive old session\n * await chatService.archiveChatSession('old-session-doc-id');\n *\n * // Delete session permanently\n * await chatService.deleteChatSession('session-doc-id');\n * ```\n *\n * @example\n * ```typescript\n * // Monitor active streams\n * import { chatService } from './chat-service';\n *\n * // Get list of active stream IDs\n * const activeStreamIds = chatService.getActiveStreamIds();\n * console.log(`Active streams: ${activeStreamIds.length}`);\n *\n * // Cancel all active streams (e.g., on shutdown)\n * for (const streamId of activeStreamIds) {\n *   chatService.cancelMessage(streamId);\n * }\n * ```\n *\n * @see {@link https://docs.anthropic.com/en/api/agent-sdk|Claude Agent SDK Documentation}\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { query, type Query, type Options, type PermissionMode } from '@anthropic-ai/claude-agent-sdk';\nimport axios from 'axios';\nimport type {\n  ChatSession,\n  ChatMessage,\n  SendMessageRequest\n} from '../types/chat-types.js';\nimport { strapiClient } from './strapi-client.js';\nimport { createLogger, type Logger } from './logger.js';\nimport { chatLogService } from './chat-log-service.js';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nconst STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';\nconst STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;\n\nexport class ChatService extends EventEmitter {\n  /**\n   * Logger instance for structured logging\n   */\n  private logger: Logger;\n\n  /**\n   * Active SDK query instances indexed by stream ID\n   * Each Query represents an active conversation stream with Claude Agent SDK\n   * Streams are added when sendMessage() creates a query, removed on completion/error/cancellation\n   */\n  private activeStreams: Map<string, Query> = new Map();\n\n  /**\n   * Active abort controllers indexed by stream ID\n   * Each AbortController enables graceful cancellation of SDK queries\n   * Client receives streamId and can call cancelMessage(streamId) to abort the stream\n   * Controllers are created in sendMessage() and removed in finally block\n   */\n  private activeAbortControllers: Map<string, AbortController> = new Map();\n\n  constructor() {\n    super();\n    this.logger = createLogger('ChatService');\n  }\n\n  /**\n   * Helper method to make authenticated Strapi API calls\n   *\n   * @description\n   * Sends HTTP requests to Strapi API with authentication headers and proper configuration.\n   * Handles request method, endpoint routing, request body data, and query parameters.\n   * Uses axios for HTTP communication and automatically includes Bearer token authentication.\n   *\n   * @template T - Expected response data type\n   * @param method - HTTP method (GET, POST, PUT, DELETE, etc.)\n   * @param endpoint - Strapi API endpoint path (e.g., '/chat-sessions', '/chat-messages')\n   * @param data - Optional request body data for POST/PUT requests\n   * @param params - Optional query parameters for the request\n   * @returns Promise resolving to Strapi API response data of type T\n   * @throws {AxiosError} When the HTTP request fails\n   *\n   * @private\n   */\n  private async strapiRequest<T = any>(method: string, endpoint: string, data?: any, params?: any): Promise<T> {\n    const config: any = {\n      method,\n      url: `${STRAPI_URL}/api${endpoint}`,\n      headers: {\n        'Authorization': STRAPI_API_TOKEN ? `Bearer ${STRAPI_API_TOKEN}` : '',\n        'Content-Type': 'application/json',\n      },\n    };\n\n    if (data) config.data = data;\n    if (params) config.params = params;\n\n    const response = await axios(config);\n    return response.data;\n  }\n\n  /**\n   * Create a new chat session\n   * @param title - Session title\n   * @param skillIds - Array of skill documentIds to include\n   * @param agentId - Optional agent documentId for systemPrompt and configuration\n   * @param customSystemPrompt - Optional custom system prompt override\n   * @param workingDirectory - Working directory for SDK execution\n   * @param permissionMode - Permission mode for SDK (default, bypass, auto, plan)\n   * @returns Created chat session\n   */\n  async createChatSession(\n    title: string,\n    skillIds: string[],\n    agentId: string | undefined,\n    customSystemPrompt: string | undefined,\n    workingDirectory: string,\n    permissionMode?: 'default' | 'bypass' | 'auto' | 'plan'\n  ): Promise<ChatSession> {\n    try {\n      this.logger.info('Creating new chat session', {\n        title,\n        skillIds,\n        agentId,\n        customSystemPrompt: customSystemPrompt ? 'provided' : 'none',\n        workingDirectory,\n        permissionMode: permissionMode || 'default'\n      });\n\n      // Create session in Strapi with populate to return full data\n      // Note: \"plan\" is not in Strapi's permissionMode enum, so we use planMode boolean instead\n      const effectiveMode = permissionMode || 'default';\n      const isPlanMode = effectiveMode === 'plan';\n\n      const data = await this.strapiRequest('POST', '/chat-sessions?populate[skills]=true&populate[agent][populate][toolConfig]=true&populate[agent][populate][modelConfig]=true', {\n        data: {\n          title,\n          status: 'active',\n          sessionId: null, // Will be set when first message is sent\n          skills: { connect: skillIds.map(id => ({ documentId: id })) }, // Many-to-many relation (Strapi v5 format with documentId objects)\n          agent: agentId || undefined, // Many-to-one relation (Strapi v5 format - direct documentId string, no connect)\n          customSystemPrompt: customSystemPrompt, // Optional custom system prompt\n          permissionMode: isPlanMode ? 'default' : effectiveMode, // \"plan\" is not in enum, use \"default\" instead\n          planMode: isPlanMode, // Store plan mode as separate boolean field\n        },\n      });\n\n      if (!data.data) {\n        throw new Error('Failed to create chat session');\n      }\n\n      const session = this.transformChatSession(data.data);\n\n      this.logger.info('Chat session created successfully', { sessionId: session.documentId });\n\n      // Initialize chat log file\n      await chatLogService.initChatLog(session, workingDirectory);\n\n      return session;\n    } catch (error) {\n      this.logger.error('Failed to create chat session', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get chat session by documentId with populated relations\n   *\n   * @description\n   * Retrieves a single chat session from Strapi CMS with full population of related\n   * entities including skills, agent configuration, model config, tool config, and\n   * MCP server configurations. This method is used internally by sendMessage() to\n   * load session configuration before starting a conversation.\n   *\n   * **Deep Population Strategy:**\n   * The method uses Strapi v5's deep population syntax to eagerly load nested\n   * relations in a single query, avoiding N+1 query problems. It populates:\n   * - Skills with their toolConfig and mcpConfig\n   * - Agent with toolConfig, modelConfig, and mcpConfig\n   * - MCP server details and selected tools within mcpConfig\n   * - Nested mcpTool details within selectedTools\n   *\n   * **Use Cases:**\n   * - Load session configuration before sending messages\n   * - Display session details in UI (title, agent, skills)\n   * - Resume conversations with existing session context\n   * - Inspect session configuration for debugging\n   * - Validate session state before operations\n   *\n   * **Populated Relations:**\n   * - `skills`: Array of Skill objects with toolConfig and mcpConfig\n   * - `agent`: Agent object with systemPrompt, toolConfig, modelConfig, mcpConfig\n   * - `agent.mcpConfig[]`: MCP server configurations with selected tools\n   * - `agent.mcpConfig[].selectedTools[]`: Selected MCP tools for each server\n   *\n   * **Permission Mode Handling:**\n   * The method transforms Strapi's permissionMode and planMode fields into a\n   * unified permissionMode ('default' | 'bypass' | 'auto' | 'plan'). If planMode\n   * is true, permissionMode is set to 'plan' for client compatibility.\n   *\n   * @param {string} sessionDocId - The documentId of the chat session to retrieve\n   *\n   * @returns {Promise<ChatSession>} The chat session with populated relations\n   *\n   * @throws {Error} If the session is not found or Strapi request fails\n   *\n   * @example\n   * ```typescript\n   * // Basic session retrieval\n   * import { chatService } from './chat-service';\n   *\n   * const session = await chatService.getChatSession('session-doc-id-123');\n   *\n   * console.log(`Session: ${session.title}`);\n   * console.log(`Agent: ${session.agent?.name}`);\n   * console.log(`Skills: ${session.skills?.map(s => s.name).join(', ')}`);\n   * // Output:\n   * // Session: Code Review Chat\n   * // Agent: Code Review Agent\n   * // Skills: JavaScript Expert, Testing Helper\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Inspect session configuration\n   * import { chatService } from './chat-service';\n   *\n   * const session = await chatService.getChatSession('session-doc-id-123');\n   *\n   * console.log('Model:', session.agent?.modelConfig?.model);\n   * console.log('Allowed tools:', session.agent?.toolConfig?.allowedTools);\n   * console.log('Permission mode:', session.permissionMode);\n   * console.log('MCP servers:', session.agent?.mcpConfig?.map(c => c.mcpServer?.name));\n   * // Output:\n   * // Model: claude-sonnet-4-5\n   * // Allowed tools: ['Read', 'Write', 'Bash', 'Grep', 'Glob', 'Edit']\n   * // Permission mode: default\n   * // MCP servers: ['filesystem', 'database']\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Check session status before sending message\n   * import { chatService } from './chat-service';\n   *\n   * const session = await chatService.getChatSession('session-doc-id-123');\n   *\n   * if (session.status === 'archived') {\n   *   console.log('Cannot send message to archived session');\n   * } else {\n   *   console.log('Session is active, ready to send message');\n   *   // Proceed with sendMessage()\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle session not found error\n   * import { chatService } from './chat-service';\n   *\n   * try {\n   *   const session = await chatService.getChatSession('invalid-session-id');\n   * } catch (error) {\n   *   console.error('Session not found:', error);\n   *   // Error: Chat session invalid-session-id not found\n   *   // Handle error - redirect to session list or show error message\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Use in sendMessage workflow\n   * import { chatService } from './chat-service';\n   *\n   * async function sendChatMessage(sessionDocId: string, text: string) {\n   *   // Load session first to validate it exists\n   *   const session = await chatService.getChatSession(sessionDocId);\n   *\n   *   console.log(`Sending to: ${session.title}`);\n   *   console.log(`Using agent: ${session.agent?.name || 'none'}`);\n   *\n   *   // Stream message\n   *   for await (const event of chatService.sendMessage(\n   *     sessionDocId,\n   *     text,\n   *     [],\n   *     '/path/to/project'\n   *   )) {\n   *     // Handle events...\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link getAllChatSessions} - Get all sessions\n   * @see {@link createChatSession} - Create a new session\n   * @see {@link sendMessage} - Uses this method to load session config\n   */\n  async getChatSession(sessionDocId: string): Promise<ChatSession> {\n    try {\n      const data = await this.strapiRequest('GET', `/chat-sessions/${sessionDocId}`, undefined, {\n        populate: {\n          skills: {\n            populate: {\n              toolConfig: true,\n              mcpConfig: {\n                populate: {\n                  mcpServer: true,\n                  selectedTools: {\n                    populate: { mcpTool: true },\n                  },\n                },\n              },\n            },\n          },\n          agent: {\n            populate: {\n              toolConfig: true,\n              modelConfig: true,\n              mcpConfig: {\n                populate: {\n                  mcpServer: true,\n                  selectedTools: {\n                    populate: { mcpTool: true },\n                  },\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (!data.data) {\n        throw new Error(`Chat session ${sessionDocId} not found`);\n      }\n\n      return this.transformChatSession(data.data);\n    } catch (error) {\n      this.logger.error('Failed to get chat session', error, { sessionDocId });\n      throw error;\n    }\n  }\n\n  /**\n   * Get all chat sessions sorted by creation date (newest first)\n   *\n   * @description\n   * Retrieves all chat sessions from Strapi CMS with populated agent and skill\n   * relations, sorted by creation date in descending order (newest first).\n   * This method is used to display the session list in the UI and supports\n   * session management operations.\n   *\n   * **Population Strategy:**\n   * Unlike getChatSession(), this method uses lighter population to improve\n   * query performance when fetching multiple sessions. It populates:\n   * - Skills (basic info only - name, documentId)\n   * - Agent with full config (toolConfig, modelConfig, mcpConfig)\n   * - MCP server details within agent's mcpConfig\n   *\n   * **Sorting:**\n   * Sessions are sorted by createdAt in descending order, ensuring the most\n   * recent conversations appear first in the list. This matches typical chat\n   * application UX patterns.\n   *\n   * **Use Cases:**\n   * - Display session list in chat UI sidebar\n   * - Browse conversation history\n   * - Session management dashboard\n   * - Search and filter sessions\n   * - Export conversation data\n   * - Analytics and reporting\n   *\n   * **Performance Considerations:**\n   * For applications with many sessions (>100), consider implementing:\n   * - Pagination with Strapi's pagination params\n   * - Filtering by status (active vs archived)\n   * - Search by title or content\n   * - Virtual scrolling in UI\n   *\n   * **Session Status Values:**\n   * - `active`: Currently active conversation\n   * - `archived`: Archived for historical reference\n   *\n   * @returns {Promise<ChatSession[]>} Array of chat sessions sorted by newest first\n   *\n   * @throws {Error} If the Strapi request fails\n   *\n   * @example\n   * ```typescript\n   * // Basic usage - get all sessions\n   * import { chatService } from './chat-service';\n   *\n   * const sessions = await chatService.getAllChatSessions();\n   *\n   * console.log(`Total sessions: ${sessions.length}`);\n   * sessions.forEach(session => {\n   *   console.log(`- ${session.title} (${session.status})`);\n   * });\n   * // Output:\n   * // Total sessions: 5\n   * // - Code Review Chat (active)\n   * // - Bug Fix Session (active)\n   * // - Documentation Update (archived)\n   * // - API Integration (active)\n   * // - Refactoring Project (archived)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Filter active sessions only\n   * import { chatService } from './chat-service';\n   *\n   * const allSessions = await chatService.getAllChatSessions();\n   * const activeSessions = allSessions.filter(s => s.status === 'active');\n   *\n   * console.log(`Active sessions: ${activeSessions.length}/${allSessions.length}`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Display session list with agent info\n   * import { chatService } from './chat-service';\n   *\n   * const sessions = await chatService.getAllChatSessions();\n   *\n   * sessions.forEach(session => {\n   *   const agentName = session.agent?.name || 'No agent';\n   *   const skillCount = session.skills?.length || 0;\n   *   const date = new Date(session.createdAt).toLocaleDateString();\n   *\n   *   console.log(`${session.title}`);\n   *   console.log(`  Agent: ${agentName}`);\n   *   console.log(`  Skills: ${skillCount}`);\n   *   console.log(`  Created: ${date}`);\n   *   console.log('---');\n   * });\n   * // Output:\n   * // Code Review Chat\n   * //   Agent: Code Reviewer\n   * //   Skills: 2\n   * //   Created: 1/2/2026\n   * // ---\n   * // Bug Fix Session\n   * //   Agent: Debugging Expert\n   * //   Skills: 3\n   * //   Created: 1/1/2026\n   * // ---\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Search sessions by title\n   * import { chatService } from './chat-service';\n   *\n   * async function searchSessions(query: string) {\n   *   const allSessions = await chatService.getAllChatSessions();\n   *   const matches = allSessions.filter(session =>\n   *     session.title.toLowerCase().includes(query.toLowerCase())\n   *   );\n   *\n   *   console.log(`Found ${matches.length} sessions matching \"${query}\"`);\n   *   return matches;\n   * }\n   *\n   * const results = await searchSessions('code review');\n   * // => Found 3 sessions matching \"code review\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Group sessions by date\n   * import { chatService } from './chat-service';\n   *\n   * const sessions = await chatService.getAllChatSessions();\n   *\n   * const today = new Date().toDateString();\n   * const todaySessions = sessions.filter(s =>\n   *   new Date(s.createdAt).toDateString() === today\n   * );\n   *\n   * console.log(`Today's sessions: ${todaySessions.length}`);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Export session list for reporting\n   * import { chatService } from './chat-service';\n   * import fs from 'fs';\n   *\n   * const sessions = await chatService.getAllChatSessions();\n   *\n   * const report = sessions.map(s => ({\n   *   title: s.title,\n   *   status: s.status,\n   *   agent: s.agent?.name || 'None',\n   *   skills: s.skills?.map(sk => sk.name).join(', ') || 'None',\n   *   created: s.createdAt,\n   * }));\n   *\n   * fs.writeFileSync('sessions-report.json', JSON.stringify(report, null, 2));\n   * console.log('Report exported');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle empty session list\n   * import { chatService } from './chat-service';\n   *\n   * const sessions = await chatService.getAllChatSessions();\n   *\n   * if (sessions.length === 0) {\n   *   console.log('No sessions found. Create your first chat!');\n   * } else {\n   *   console.log(`You have ${sessions.length} conversation(s)`);\n   * }\n   * ```\n   *\n   * @see {@link getChatSession} - Get a specific session\n   * @see {@link createChatSession} - Create a new session\n   * @see {@link archiveChatSession} - Archive a session\n   * @see {@link deleteChatSession} - Delete a session permanently\n   */\n  async getAllChatSessions(): Promise<ChatSession[]> {\n    try {\n      const data = await this.strapiRequest('GET', '/chat-sessions', undefined, {\n        sort: ['createdAt:desc'],\n        populate: {\n          skills: true,\n          agent: {\n            populate: {\n              toolConfig: true,\n              modelConfig: true,\n              mcpConfig: {\n                populate: {\n                  mcpServer: true,\n                  selectedTools: {\n                    populate: { mcpTool: true },\n                  },\n                },\n              },\n            },\n          },\n        },\n      });\n\n      return data.data.map((item: any) => this.transformChatSession(item));\n    } catch (error) {\n      this.logger.error('Failed to get chat sessions', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all messages for a chat session sorted by timestamp\n   *\n   * @description\n   * Retrieves all chat messages (user, assistant, system) for a specific chat\n   * session from Strapi CMS, sorted by timestamp in ascending order (chronological).\n   * This method is used to display the conversation history in the chat UI and\n   * supports message replay and export functionality.\n   *\n   * **Message Loading Strategy:**\n   * The method retrieves messages through the session's populated messages relation\n   * rather than querying the chat-messages collection directly. This approach:\n   * - Avoids Strapi v5 issues with filtering on relations\n   * - Ensures consistent message ordering by timestamp\n   * - Returns empty array if session doesn't exist (graceful degradation)\n   * - Automatically filters messages for the specific session\n   *\n   * **Message Types:**\n   * - `user`: Messages sent by the user (with optional attachments)\n   * - `assistant`: Responses from Claude AI (with tool uses, cost, usage metadata)\n   * - `system`: System notifications or status messages\n   *\n   * **Message Metadata:**\n   * Each message may include metadata:\n   * - User messages: Typically minimal or empty metadata\n   * - Assistant messages: toolUses[], cost (USD), usage (token counts)\n   * - System messages: Initialization or status information\n   *\n   * **Attachment Handling:**\n   * Messages may have file attachments (images, PDFs, text files) referenced\n   * by Strapi upload IDs. The attachment objects include name, URL, MIME type,\n   * and file size for display and download.\n   *\n   * **Use Cases:**\n   * - Display conversation history in chat UI\n   * - Export chat transcript\n   * - Search message content\n   * - Calculate conversation cost (sum assistant message costs)\n   * - Analyze tool usage patterns\n   * - Replay conversations for debugging\n   *\n   * @param {string} sessionDocId - The documentId of the chat session\n   *\n   * @returns {Promise<ChatMessage[]>} Array of messages sorted by timestamp (oldest first)\n   *\n   * @throws {Error} If the Strapi request fails (but returns empty array if session not found)\n   *\n   * @example\n   * ```typescript\n   * // Basic usage - get all messages\n   * import { chatService } from './chat-service';\n   *\n   * const messages = await chatService.getChatMessages('session-doc-id-123');\n   *\n   * console.log(`Total messages: ${messages.length}`);\n   * messages.forEach(msg => {\n   *   console.log(`[${msg.role}] ${msg.content.substring(0, 50)}...`);\n   * });\n   * // Output:\n   * // Total messages: 6\n   * // [user] Review the authentication code in src/auth.ts...\n   * // [assistant] I'll analyze the authentication code. Let me...\n   * // [user] Can you also check for security vulnerabilities?...\n   * // [assistant] I found 3 security issues: ...\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Display conversation with timestamps\n   * import { chatService } from './chat-service';\n   *\n   * const messages = await chatService.getChatMessages('session-doc-id-123');\n   *\n   * messages.forEach(msg => {\n   *   const time = new Date(msg.timestamp).toLocaleTimeString();\n   *   const role = msg.role.toUpperCase();\n   *   console.log(`[${time}] ${role}:`);\n   *   console.log(msg.content);\n   *   console.log('---');\n   * });\n   * // Output:\n   * // [2:30:15 PM] USER:\n   * // Review the code\n   * // ---\n   * // [2:30:22 PM] ASSISTANT:\n   * // I'll review the code for you...\n   * // ---\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Calculate total conversation cost\n   * import { chatService } from './chat-service';\n   *\n   * const messages = await chatService.getChatMessages('session-doc-id-123');\n   *\n   * const totalCost = messages\n   *   .filter(msg => msg.role === 'assistant')\n   *   .reduce((sum, msg) => sum + (msg.metadata?.cost || 0), 0);\n   *\n   * console.log(`Total cost: $${totalCost.toFixed(4)}`);\n   * // => Total cost: $0.0125\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Export conversation transcript\n   * import { chatService } from './chat-service';\n   * import fs from 'fs';\n   *\n   * const session = await chatService.getChatSession('session-doc-id-123');\n   * const messages = await chatService.getChatMessages('session-doc-id-123');\n   *\n   * const transcript = {\n   *   session: {\n   *     title: session.title,\n   *     agent: session.agent?.name,\n   *     created: session.createdAt,\n   *   },\n   *   messages: messages.map(msg => ({\n   *     timestamp: msg.timestamp,\n   *     role: msg.role,\n   *     content: msg.content,\n   *     attachments: msg.attachments?.map(a => a.name),\n   *     cost: msg.metadata?.cost,\n   *   })),\n   * };\n   *\n   * fs.writeFileSync('transcript.json', JSON.stringify(transcript, null, 2));\n   * console.log('Transcript exported');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Analyze tool usage in conversation\n   * import { chatService } from './chat-service';\n   *\n   * const messages = await chatService.getChatMessages('session-doc-id-123');\n   *\n   * const toolUses = messages\n   *   .filter(msg => msg.role === 'assistant')\n   *   .flatMap(msg => msg.metadata?.toolUses || []);\n   *\n   * const toolCounts = toolUses.reduce((acc, tool) => {\n   *   acc[tool.name] = (acc[tool.name] || 0) + 1;\n   *   return acc;\n   * }, {} as Record<string, number>);\n   *\n   * console.log('Tool usage:');\n   * Object.entries(toolCounts).forEach(([tool, count]) => {\n   *   console.log(`  ${tool}: ${count}`);\n   * });\n   * // Output:\n   * // Tool usage:\n   * //   Read: 5\n   * //   Grep: 2\n   * //   Write: 3\n   * //   Bash: 1\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Get messages with attachments only\n   * import { chatService } from './chat-service';\n   *\n   * const messages = await chatService.getChatMessages('session-doc-id-123');\n   * const messagesWithAttachments = messages.filter(msg =>\n   *   msg.attachments && msg.attachments.length > 0\n   * );\n   *\n   * console.log(`Messages with attachments: ${messagesWithAttachments.length}`);\n   * messagesWithAttachments.forEach(msg => {\n   *   console.log(`- ${msg.role}: ${msg.attachments?.map(a => a.name).join(', ')}`);\n   * });\n   * // Output:\n   * // Messages with attachments: 2\n   * // - user: diagram.png\n   * // - user: report.pdf, config.json\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle empty message list\n   * import { chatService } from './chat-service';\n   *\n   * const messages = await chatService.getChatMessages('session-doc-id-123');\n   *\n   * if (messages.length === 0) {\n   *   console.log('No messages yet. Start the conversation!');\n   * } else {\n   *   console.log(`${messages.length} messages in conversation`);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle session not found gracefully\n   * import { chatService } from './chat-service';\n   *\n   * const messages = await chatService.getChatMessages('invalid-session-id');\n   * // Returns empty array instead of throwing error\n   * console.log(messages.length); // => 0\n   * ```\n   *\n   * @see {@link getChatSession} - Get the parent session\n   * @see {@link sendMessage} - Send a new message to the session\n   * @see {@link saveChatMessage} - Internal method used to save messages\n   */\n  async getChatMessages(sessionDocId: string): Promise<ChatMessage[]> {\n    try {\n      // Get session with populated messages (avoid direct filter on relations)\n      const sessionData = await this.strapiRequest('GET', `/chat-sessions/${sessionDocId}`, undefined, {\n        populate: {\n          messages: {\n            sort: ['timestamp:asc'],\n          },\n        },\n      });\n\n      if (!sessionData.data) {\n        this.logger.warn('Chat session not found', { sessionDocId });\n        return []; // Return empty array if session doesn't exist\n      }\n\n      const messages = sessionData.data.messages || [];\n      this.logger.info('Messages fetched successfully', { count: messages.length });\n\n      return messages.map((item: any) => this.transformChatMessage(item));\n    } catch (error) {\n      this.logger.error('Failed to get chat messages', error, { sessionDocId });\n      throw error;\n    }\n  }\n\n  /**\n   * Save a chat message to Strapi\n   *\n   * @description\n   * Persists a chat message (user, assistant, or system) to the Strapi CMS database\n   * with optional file attachments and metadata. This method is called internally by\n   * sendMessage() to save both user messages (before streaming) and assistant messages\n   * (after streaming completes).\n   *\n   * The saved message is associated with a chat session via the session documentId\n   * and includes a timestamp for message ordering. Attachments are referenced by their\n   * Strapi file upload IDs.\n   *\n   * **Key Features:**\n   * - Saves message to Strapi chat-messages collection\n   * - Associates message with chat session via session documentId\n   * - Supports file attachments (images, PDFs, text files) via attachment IDs\n   * - Stores arbitrary metadata (tool uses, cost, usage stats, etc.)\n   * - Auto-generates ISO timestamp for message ordering\n   * - Returns transformed ChatMessage with documentId for future reference\n   *\n   * **Message Metadata Usage:**\n   * - User messages: Typically empty or minimal metadata\n   * - Assistant messages: Includes toolUses[], cost (USD), usage (tokens)\n   * - System messages: May include initialization or status information\n   *\n   * **Database Schema:**\n   * The message is saved to Strapi with the following fields:\n   * - session: documentId of the parent ChatSession\n   * - role: 'user' | 'assistant' | 'system'\n   * - content: Full message text content\n   * - attachments: Array of Strapi file IDs (Many-to-many relation)\n   * - metadata: JSON object with custom data (toolUses, cost, usage, etc.)\n   * - timestamp: ISO 8601 timestamp for message ordering\n   *\n   * @param {string} sessionDocId - The documentId of the parent chat session\n   * @param {'user' | 'assistant' | 'system'} role - Message sender role\n   * @param {string} content - The message text content (may be empty for tool-only messages)\n   * @param {number[]} [attachmentIds] - Optional array of Strapi file upload IDs\n   * @param {any} [metadata] - Optional metadata object (toolUses, cost, usage, etc.)\n   *\n   * @returns {Promise<ChatMessage>} The saved message with documentId and timestamps\n   *\n   * @throws {Error} If the Strapi API request fails or returns invalid data\n   *\n   * @example\n   * ```typescript\n   * // Save user message with image attachment\n   * const buffer = await fs.readFile('./diagram.png');\n   * const uploaded = await strapiClient.uploadFile(buffer, 'diagram.png');\n   *\n   * const userMessage = await this.saveChatMessage(\n   *   'session-doc-id-123',\n   *   'user',\n   *   'Can you analyze this diagram?',\n   *   [uploaded.id], // Attachment IDs\n   *   {} // No metadata\n   * );\n   *\n   * console.log('Saved user message:', userMessage.documentId);\n   * // => Saved user message: msg_xyz789\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Save assistant message with tool uses and cost\n   * const assistantMessage = await this.saveChatMessage(\n   *   'session-doc-id-123',\n   *   'assistant',\n   *   'I analyzed the code and found 3 issues...',\n   *   undefined, // No attachments\n   *   {\n   *     toolUses: [\n   *       { type: 'tool_use', id: 'toolu_1', name: 'Read', input: { file_path: 'src/auth.ts' } },\n   *       { type: 'tool_use', id: 'toolu_2', name: 'Grep', input: { pattern: 'TODO' } }\n   *     ],\n   *     cost: 0.0025, // $0.0025 USD\n   *     usage: {\n   *       input_tokens: 1234,\n   *       output_tokens: 567,\n   *       cache_creation_input_tokens: 0,\n   *       cache_read_input_tokens: 890\n   *     }\n   *   }\n   * );\n   *\n   * console.log('Assistant message cost:', assistantMessage.metadata?.cost);\n   * // => Assistant message cost: 0.0025\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Save system message with initialization metadata\n   * const systemMessage = await this.saveChatMessage(\n   *   'session-doc-id-123',\n   *   'system',\n   *   'Session initialized with claude-sonnet-4-5',\n   *   undefined,\n   *   {\n   *     sessionId: 'sdk_session_abc123',\n   *     model: 'claude-sonnet-4-5',\n   *     tools: ['Read', 'Write', 'Bash', 'Grep'],\n   *     permissionMode: 'default'\n   *   }\n   * );\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle save errors gracefully\n   * try {\n   *   const message = await this.saveChatMessage(\n   *     'invalid-session-id',\n   *     'user',\n   *     'Hello',\n   *     undefined,\n   *     {}\n   *   );\n   * } catch (error) {\n   *   console.error('Failed to save message:', error);\n   *   // Error: Chat session invalid-session-id not found\n   * }\n   * ```\n   *\n   * @private\n   * @see {@link sendMessage} - Uses this method to save user and assistant messages\n   * @see {@link ChatMessage} - The returned message type\n   */\n  private async saveChatMessage(\n    sessionDocId: string,\n    role: 'user' | 'assistant' | 'system',\n    content: string,\n    attachmentIds?: number[],\n    metadata?: any\n  ): Promise<ChatMessage> {\n    try {\n      const data = await this.strapiRequest('POST', '/chat-messages', {\n        data: {\n          session: sessionDocId,\n          role,\n          content,\n          attachments: attachmentIds,\n          metadata: metadata || {},\n          timestamp: new Date().toISOString(),\n        },\n      });\n\n      if (!data.data) {\n        throw new Error('Failed to save chat message');\n      }\n\n      return this.transformChatMessage(data.data);\n    } catch (error) {\n      this.logger.error('Failed to save chat message', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send a message and stream response from Claude Agent SDK\n   *\n   * @description\n   * Core async generator method that sends a user message to Claude AI and streams\n   * the assistant's response in real-time. This method orchestrates the complete\n   * conversation lifecycle including message persistence, skill synchronization,\n   * agent configuration, MCP server setup, SDK query execution, and streaming events.\n   *\n   * **AsyncGenerator Streaming Pattern:**\n   * This method uses AsyncGenerator to yield events as they occur, enabling real-time\n   * UI updates and responsive user experience. The frontend can consume events using\n   * `for await (const event of chatService.sendMessage(...))` pattern.\n   *\n   * **Yielded Event Types:**\n   * 1. **user_message_saved** - User message saved to Strapi (before streaming)\n   * 2. **stream_id** - Unique stream ID for cancellation support\n   * 3. **sdk_message** - Raw SDK message (system, assistant, result, stream_event)\n   * 4. **assistant_message_start** - Assistant message streaming started\n   * 5. **assistant_message_delta** - Real-time text delta from Claude\n   * 6. **assistant_message_saved** - Complete assistant message saved to Strapi\n   * 7. **done** - Conversation complete with cost and usage metadata\n   * 8. **error** - Error occurred during streaming\n   * 9. **cancelled** - Stream was cancelled by user\n   *\n   * **Message Flow:**\n   * 1. Fetch chat session with agent and skill configurations\n   * 2. Sync skills to filesystem (.claude/skills/*.md files)\n   * 3. Upload attachments to Strapi and save user message\n   * 4. Yield 'user_message_saved' event\n   * 5. Build SDK options (model, systemPrompt, permissions, tools, mcpServers)\n   * 6. Create SDK Query with AsyncGenerator prompt and AbortController\n   * 7. Yield 'stream_id' event (enables cancellation via cancelMessage)\n   * 8. Stream SDK messages and yield 'sdk_message' events\n   * 9. Accumulate assistant text from content_block_delta stream events\n   * 10. Yield 'assistant_message_delta' events for real-time UI updates\n   * 11. Save complete assistant message to Strapi and chat log\n   * 12. Yield 'assistant_message_saved' event\n   * 13. Yield 'done' event with cost/usage metadata\n   *\n   * **Agent Override:**\n   * Supports per-message agent override via the agentId parameter. This allows\n   * using different agents within the same chat session (e.g., switching between\n   * a coding agent and a security review agent).\n   *\n   * **Skill Override:**\n   * Supports per-message skill override via the skillIds parameter. This allows\n   * using different skill sets for different messages in the same session.\n   *\n   * **Permission Modes:**\n   * - **default**: User approves tool usage (except safe read-only tools)\n   * - **bypass**: Auto-approve all tools (bypassPermissions)\n   * - **auto**: Auto-approve Write/Edit tools (acceptEdits mode)\n   * - **plan**: Read-only mode with Glob/Read/Grep/Skill tools only\n   *\n   * **Plan Mode:**\n   * When permissionMode is 'plan', the service restricts to read-only tools and\n   * adds plan mode instructions to the system prompt. Claude analyzes the codebase\n   * and presents a detailed implementation plan without making any changes.\n   *\n   * **File Attachment Support:**\n   * - Images: Sent as base64-encoded image blocks (image/png, image/jpeg, etc.)\n   * - PDFs: Sent as document blocks (application/pdf) - SDK processes page by page\n   * - Text: Sent as inline text content with file name header\n   *\n   * **MCP Server Integration:**\n   * Loads MCP servers from agent's mcpConfig (Strapi) and .mcp.json file (project root).\n   * Only includes servers enabled in the agent's mcpConfig. Merges command/args from\n   * .mcp.json with server selection from mcpConfig.\n   *\n   * **Stream Cancellation:**\n   * Each stream has a unique streamId (UUID) yielded in the 'stream_id' event.\n   * The client can call cancelMessage(streamId) to abort the stream gracefully.\n   * The SDK Query respects the abort signal and stops processing immediately.\n   *\n   * @param {string} sessionDocId - The documentId of the chat session\n   * @param {string} message - The user's message text\n   * @param {SendMessageRequest['attachments']} attachments - Optional file attachments (images, PDFs, text files)\n   * @param {string} workingDirectory - Working directory for SDK execution (project root)\n   * @param {'default' | 'bypass' | 'auto' | 'plan'} [permissionMode] - Permission mode override (defaults to session mode)\n   * @param {string} [agentId] - Optional agent override (defaults to session agent)\n   * @param {string[]} [skillIds] - Optional skill override (defaults to session skills)\n   *\n   * @yields {Object} Stream events with different types:\n   *   - `{ type: 'user_message_saved', message: ChatMessage }` - User message persisted\n   *   - `{ type: 'stream_id', streamId: string, timestamp: string }` - Stream ID for cancellation\n   *   - `{ type: 'sdk_message', data: SdkMessage }` - Raw SDK message (system, assistant, result, etc.)\n   *   - `{ type: 'assistant_message_start', messageId: string, timestamp: string }` - Streaming started\n   *   - `{ type: 'assistant_message_delta', delta: string, messageId: string, timestamp: string }` - Text delta\n   *   - `{ type: 'assistant_message_saved', message: ChatMessage }` - Assistant message persisted\n   *   - `{ type: 'done', cost: number, usage: object }` - Conversation complete\n   *   - `{ type: 'error', error: string }` - Error occurred\n   *   - `{ type: 'cancelled', streamId: string, timestamp: string, reason: string }` - Stream cancelled\n   *\n   * @returns {AsyncGenerator<any>} Async generator yielding stream events\n   *\n   * @throws {Error} If chat session is not found or SDK query fails\n   *\n   * @example\n   * ```typescript\n   * // Basic message streaming with event handling\n   * import { chatService } from './chat-service';\n   *\n   * const sessionDocId = 'chat-session-doc-id';\n   * const message = 'Review the authentication code in src/auth.ts';\n   *\n   * for await (const event of chatService.sendMessage(\n   *   sessionDocId,\n   *   message,\n   *   [], // No attachments\n   *   '/path/to/project'\n   * )) {\n   *   switch (event.type) {\n   *     case 'user_message_saved':\n   *       console.log('User message saved:', event.message.documentId);\n   *       break;\n   *     case 'stream_id':\n   *       console.log('Stream ID:', event.streamId);\n   *       // Store for potential cancellation\n   *       currentStreamId = event.streamId;\n   *       break;\n   *     case 'assistant_message_delta':\n   *       // Real-time streaming text\n   *       process.stdout.write(event.delta);\n   *       break;\n   *     case 'assistant_message_saved':\n   *       console.log('\\nAssistant response saved');\n   *       break;\n   *     case 'done':\n   *       console.log('Cost: $' + event.cost);\n   *       break;\n   *     case 'error':\n   *       console.error('Error:', event.error);\n   *       break;\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Send message with image attachment\n   * import { chatService } from './chat-service';\n   * import fs from 'fs';\n   *\n   * const imageBuffer = fs.readFileSync('./architecture-diagram.png');\n   * const attachments = [{\n   *   name: 'architecture-diagram.png',\n   *   mimeType: 'image/png',\n   *   data: imageBuffer.toString('base64')\n   * }];\n   *\n   * for await (const event of chatService.sendMessage(\n   *   'session-doc-id',\n   *   'Analyze this architecture diagram and suggest improvements',\n   *   attachments,\n   *   '/path/to/project'\n   * )) {\n   *   if (event.type === 'assistant_message_delta') {\n   *     updateUI(event.delta); // Real-time UI update\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Use plan mode for read-only analysis\n   * import { chatService } from './chat-service';\n   *\n   * for await (const event of chatService.sendMessage(\n   *   'session-doc-id',\n   *   'Create a detailed plan to add user authentication',\n   *   [],\n   *   '/path/to/project',\n   *   'plan' // Read-only mode - no file modifications\n   * )) {\n   *   if (event.type === 'assistant_message_delta') {\n   *     console.log(event.delta); // Claude presents implementation plan\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Override agent per message\n   * import { chatService } from './chat-service';\n   *\n   * // First message uses default agent\n   * for await (const event of chatService.sendMessage(\n   *   'session-doc-id',\n   *   'Write a test file',\n   *   [],\n   *   '/path/to/project'\n   * )) { /* ... */ }\n   *\n   * // Second message overrides with security specialist agent\n   * for await (const event of chatService.sendMessage(\n   *   'session-doc-id',\n   *   'Review this code for security vulnerabilities',\n   *   [],\n   *   '/path/to/project',\n   *   undefined, // Use session permission mode\n   *   'security-agent-id' // Override with security agent\n   * )) { /* ... */ }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Stream cancellation with AbortController\n   * import { chatService } from './chat-service';\n   *\n   * let currentStreamId: string | null = null;\n   *\n   * // Start streaming\n   * const streamPromise = (async () => {\n   *   for await (const event of chatService.sendMessage(\n   *     'session-doc-id',\n   *     'This is a long running task...',\n   *     [],\n   *     '/path/to/project'\n   *   )) {\n   *     if (event.type === 'stream_id') {\n   *       currentStreamId = event.streamId;\n   *     }\n   *     if (event.type === 'cancelled') {\n   *       console.log('Stream cancelled:', event.reason);\n   *     }\n   *   }\n   * })();\n   *\n   * // Cancel after 5 seconds\n   * setTimeout(() => {\n   *   if (currentStreamId) {\n   *     chatService.cancelMessage(currentStreamId);\n   *   }\n   * }, 5000);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Collect SDK messages for debugging\n   * import { chatService } from './chat-service';\n   *\n   * const sdkMessages: any[] = [];\n   *\n   * for await (const event of chatService.sendMessage(\n   *   'session-doc-id',\n   *   'Debug this error',\n   *   [],\n   *   '/path/to/project'\n   * )) {\n   *   if (event.type === 'sdk_message') {\n   *     sdkMessages.push(event.data);\n   *     console.log('SDK event:', event.data.type, event.data.subtype);\n   *   }\n   *   if (event.type === 'done') {\n   *     console.log('Total SDK messages:', sdkMessages.length);\n   *     fs.writeFileSync('sdk-debug.json', JSON.stringify(sdkMessages, null, 2));\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Override skills per message\n   * import { chatService } from './chat-service';\n   *\n   * // Use different skill set for this specific message\n   * for await (const event of chatService.sendMessage(\n   *   'session-doc-id',\n   *   'Generate API documentation',\n   *   [],\n   *   '/path/to/project',\n   *   undefined, // Use session permission mode\n   *   undefined, // Use session agent\n   *   ['documentation-skill-id', 'api-skill-id'] // Override skills\n   * )) {\n   *   if (event.type === 'assistant_message_delta') {\n   *     console.log(event.delta);\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link cancelMessage} - Cancel an active stream\n   * @see {@link buildPromptGenerator} - Builds the AsyncGenerator prompt for SDK\n   * @see {@link saveChatMessage} - Saves messages to Strapi\n   * @see {@link https://docs.anthropic.com/en/api/agent-sdk|Claude Agent SDK Documentation}\n   */\n  async* sendMessage(\n    sessionDocId: string,\n    message: string,\n    attachments: SendMessageRequest['attachments'],\n    workingDirectory: string,\n    permissionMode?: 'default' | 'bypass' | 'auto' | 'plan',\n    agentId?: string,\n    skillIds?: string[]\n  ): AsyncGenerator<any> {\n    try {\n      this.logger.info('Sending chat message', { sessionDocId, messageLength: message.length, attachmentCount: attachments?.length || 0 });\n\n      // Get chat session\n      const session = await this.getChatSession(sessionDocId);\n\n      // Determine effective skills: use provided skillIds or fallback to session skills\n      const effectiveSkillIds = skillIds || session.skills?.map(skill => skill.documentId) || [];\n\n      // Sync skills to filesystem\n      if (effectiveSkillIds.length > 0) {\n        try {\n          const { skillSyncService } = await import('./skill-sync-service.js');\n\n          // Fetch full skill details from Strapi\n          const fullSkills = await strapiClient.getSkillsByIds(effectiveSkillIds);\n\n          // Sync skills to filesystem\n          await skillSyncService.syncAllSkills(fullSkills);\n\n          this.logger.info('Synced skills to filesystem', {\n            sessionId: sessionDocId,\n            skillCount: fullSkills.length,\n            skillNames: fullSkills.map(s => s.name),\n            overridden: !!skillIds\n          });\n        } catch (syncError) {\n          this.logger.error('Failed to sync skills for chat', syncError);\n          // Continue execution - skills won't be available but chat still works\n        }\n      }\n\n      // Save user message to Strapi\n      let attachmentIds: number[] = [];\n      if (attachments && attachments.length > 0) {\n        // Upload attachments to Strapi\n        for (const attachment of attachments) {\n          const buffer = Buffer.from(attachment.data, 'base64');\n          const uploaded = await strapiClient.uploadFile(buffer, attachment.name);\n          attachmentIds.push(uploaded.id);\n        }\n      }\n\n      const userMessage = await this.saveChatMessage(\n        sessionDocId,\n        'user',\n        message,\n        attachmentIds\n      );\n\n      yield {\n        type: 'user_message_saved',\n        message: userMessage,\n      };\n\n      // Add user message to log\n      await chatLogService.addMessageToLog(sessionDocId, userMessage);\n\n      // Auto-update title if it's \"New Chat\" (first message)\n      if (session.title === 'New Chat') {\n        try {\n          // Generate title from first message (first 50 chars)\n          const autoTitle = message.length > 50\n            ? message.substring(0, 50) + '...'\n            : message;\n\n          await this.strapiRequest('PUT', `/chat-sessions/${sessionDocId}`, {\n            data: { title: autoTitle },\n          });\n\n          this.logger.info('Auto-updated chat title', {\n            sessionId: sessionDocId,\n            newTitle: autoTitle\n          });\n        } catch (error) {\n          this.logger.warn('Failed to auto-update chat title', error);\n          // Don't fail the chat if title update fails\n        }\n      }\n\n      // Build SDK options\n      // Use provided modes or fallback to session modes\n      const requestedMode = permissionMode ?? session.permissionMode ?? 'default';\n\n      // Check if plan mode is requested\n      const effectivePlanMode = requestedMode === 'plan' || session.planMode || false;\n\n      // Map our permission mode to SDK's PermissionMode\n      const mapPermissionMode = (mode: string): PermissionMode => {\n        switch (mode) {\n          case 'bypass': return 'bypassPermissions';\n          case 'auto': return 'acceptEdits';\n          case 'plan': return 'default'; // Plan mode uses default permission with planMode flag\n          case 'default':\n          default: return 'default';\n        }\n      };\n\n      const effectivePermissionMode = mapPermissionMode(requestedMode);\n\n      // Determine effective agent: use provided agentId or fallback to session agent\n      let effectiveAgent = session.agent;\n      if (agentId && agentId !== session.agent?.documentId) {\n        try {\n          // Fetch agent with full population\n          const agentData = await strapiClient.getAgent(agentId);\n          if (agentData) {\n            effectiveAgent = {\n              id: agentData.id ? Number(agentData.id) : 0,\n              documentId: agentData.id, // Agent uses id as documentId\n              name: agentData.name,\n              systemPrompt: agentData.systemPrompt,\n              toolConfig: agentData.toolConfig,\n              modelConfig: agentData.modelConfig,\n              mcpConfig: agentData.mcpConfig\n            };\n            this.logger.info('Using per-message agent override', {\n              sessionId: sessionDocId,\n              agentId: agentId,\n              agentName: effectiveAgent?.name\n            });\n          }\n        } catch (agentError) {\n          this.logger.error('Failed to fetch agent override', agentError);\n          // Fallback to session agent\n        }\n      }\n\n      // Build systemPrompt from effective agent or customSystemPrompt\n      let systemPrompt: string | undefined;\n      if (effectiveAgent) {\n        systemPrompt = effectiveAgent.systemPrompt;\n        this.logger.info('Using agent system prompt', {\n          sessionId: sessionDocId,\n          agentId: effectiveAgent.documentId,\n          agentName: effectiveAgent.name\n        });\n      } else if (session.customSystemPrompt) {\n        systemPrompt = session.customSystemPrompt;\n        this.logger.info('Using custom system prompt', { sessionId: sessionDocId });\n      }\n\n      // Get model from effective agent config or use default\n      const modelName = effectiveAgent?.modelConfig?.model || 'claude-sonnet-4-5';\n\n      // Get allowed tools from effective agent config or use defaults\n      const allowedTools = effectiveAgent?.toolConfig?.allowedTools || [\n        'Read', 'Write', 'Bash', 'Grep', 'Glob', 'Skill', 'Edit'\n      ];\n\n      // Get disallowed tools from effective agent config\n      const disallowedTools = effectiveAgent?.toolConfig?.disallowedTools || [];\n      // Build MCP servers from effective agent's mcpConfig\n      let mcpServers: Record<string, any> | undefined;\n      if (effectiveAgent?.mcpConfig && Array.isArray(effectiveAgent.mcpConfig) && effectiveAgent.mcpConfig.length > 0) {\n        try {\n          mcpServers = await this.buildMcpServersFromAgentConfig(effectiveAgent.mcpConfig, workingDirectory);\n          this.logger.info('Built MCP servers from agent config', {\n            sessionId: sessionDocId,\n            serverCount: mcpServers ? Object.keys(mcpServers).length : 0\n          });\n        } catch (mcpError) {\n          this.logger.warn('Failed to build MCP servers from agent config', { error: mcpError });\n        }\n      }\n\n      const options: Options = {\n        model: modelName,\n        systemPrompt: systemPrompt,\n        permissionMode: effectivePermissionMode,\n        includePartialMessages: true,\n        settingSources: ['project'], // Load skills from filesystem\n        cwd: workingDirectory,\n        allowedTools: allowedTools,\n        disallowedTools: disallowedTools,\n        mcpServers: mcpServers,\n\n        // Tool permission callback - handles runtime permission checks\n        canUseTool: async (toolName: string, input: any) => {\n          // Log tool permission request\n          await chatLogService.addSdkEvent(sessionDocId, sdkCallId, {\n            timestamp: new Date().toISOString(),\n            type: 'tool_permission_request',\n            data: { toolName, input }\n          });\n\n          this.logger.info('Tool permission requested', { toolName, mode: effectivePermissionMode, sessionId: sessionDocId });\n\n          // Auto-approve safe read-only tools\n          const autoApprovedTools = ['Read', 'Glob', 'Grep', 'Skill'];\n          if (autoApprovedTools.includes(toolName)) {\n            this.logger.debug('Tool auto-approved (safe read-only)', { toolName });\n            return { behavior: 'allow' as const, updatedInput: input };\n          }\n\n          // In bypassPermissions mode, allow all tools\n          if (effectivePermissionMode === 'bypassPermissions') {\n            this.logger.debug('Tool approved (bypass mode)', { toolName });\n            return { behavior: 'allow' as const, updatedInput: input };\n          }\n\n          // In acceptEdits mode, auto-approve Write/Edit tools\n          if (['Write', 'Edit'].includes(toolName) && effectivePermissionMode === 'acceptEdits') {\n            this.logger.debug('Tool auto-approved (acceptEdits mode)', { toolName });\n            return { behavior: 'allow' as const, updatedInput: input };\n          }\n\n          // For Bash commands in acceptEdits mode, check if safe filesystem operation\n          if (toolName === 'Bash' && effectivePermissionMode === 'acceptEdits') {\n            const command = typeof input === 'object' ? input.command : input;\n            const safeCommands = ['mkdir', 'touch', 'mv', 'cp'];\n            if (typeof command === 'string' && safeCommands.some(cmd => command.trim().startsWith(cmd))) {\n              this.logger.debug('Bash command auto-approved (acceptEdits mode)', { command });\n              return { behavior: 'allow' as const, updatedInput: input };\n            }\n          }\n\n          // Default: allow but log (TODO: implement user prompt for sensitive tools)\n          this.logger.info('Tool approved by default', { toolName, mode: effectivePermissionMode });\n          return { behavior: 'allow' as const, updatedInput: input };\n        },\n\n        // Hooks for fine-grained control over tool execution (SDK-compliant format)\n        hooks: {\n          PreToolUse: [{\n            hooks: [async (hookInput: any, toolUseID: string | undefined, hookOptions: { signal: AbortSignal }) => {\n              const toolName = hookInput.tool_name;\n              const input = hookInput.tool_input;\n              this.logger.info('Tool execution starting', { toolName, toolUseID, sessionId: sessionDocId });\n              await chatLogService.addSdkEvent(sessionDocId, sdkCallId, {\n                timestamp: new Date().toISOString(),\n                type: 'tool_use_start',\n                data: { toolName, input, toolUseID }\n              });\n              return { continue: true };\n            }]\n          }],\n          PostToolUse: [{\n            hooks: [async (hookInput: any, toolUseID: string | undefined, hookOptions: { signal: AbortSignal }) => {\n              const toolName = hookInput.tool_name;\n              const result = hookInput.tool_response;\n              const resultSize = result ? JSON.stringify(result).length : 0;\n              this.logger.info('Tool execution completed', { toolName, resultSize, toolUseID, sessionId: sessionDocId });\n              await chatLogService.addSdkEvent(sessionDocId, sdkCallId, {\n                timestamp: new Date().toISOString(),\n                type: 'tool_use_complete',\n                data: { toolName, result, toolUseID }\n              });\n              return { continue: true };\n            }]\n          }]\n        }\n      };\n\n      // Enable plan mode if requested (custom implementation since SDK doesn't support it yet)\n      if (effectivePlanMode) {\n        this.logger.info('Plan mode enabled - restricting to read-only tools and adding plan instructions');\n\n        // Restrict to read-only tools only\n        options.allowedTools = ['Read', 'Grep', 'Glob', 'Skill'];\n\n        // Add plan mode instructions to system prompt\n        const planModeInstructions = `\n\nIMPORTANT: You are in PLAN MODE. Your task is to:\n1. Analyze the codebase using read-only tools (Read, Grep, Glob, Skill)\n2. Present a detailed, step-by-step implementation plan\n3. DO NOT make any changes (no Write, Edit, or Bash commands)\n4. After presenting the plan, ask the user for approval before proceeding\n\nYour plan should include:\n- Files that need to be modified\n- New files that need to be created\n- Specific changes required in each file\n- Testing approach\n- Potential risks or considerations`;\n\n        options.systemPrompt = (options.systemPrompt || '') + planModeInstructions;\n      }\n\n      // Resume session if sessionId exists\n      if (session.sessionId) {\n        options.resume = session.sessionId;\n      }\n\n      // Build prompt generator for streaming input mode\n      const promptGenerator = this.buildPromptGenerator(message, attachments);\n\n      // Generate SDK call ID for logging\n      const sdkCallId = uuidv4();\n\n      // Log SDK call start (before creating query)\n      const promptForLog = {\n        type: 'user',\n        message: {\n          role: 'user',\n          content: attachments && attachments.length > 0\n            ? [{ type: 'text', text: message }, { type: 'attachments', count: attachments.length }]\n            : message,\n        },\n      };\n\n      await chatLogService.startSdkCall(sessionDocId, sdkCallId, userMessage.documentId, {\n        options: {\n          model: options.model || 'claude-sonnet-4-5',\n          permissionMode: options.permissionMode || 'default',\n          includePartialMessages: options.includePartialMessages || false,\n          settingSources: options.settingSources || [],\n          cwd: options.cwd || workingDirectory,\n          allowedTools: options.allowedTools || [],\n          resume: options.resume,\n        },\n        prompt: promptForLog,\n      });\n\n      // Save SDK payload to logs/chat folder (similar to task logging)\n      try {\n        const sdkPayload = {\n          prompt: promptForLog,\n          options: {\n            model: options.model || 'claude-sonnet-4-5',\n            systemPrompt: options.systemPrompt, // Agent's system prompt\n            permissionMode: options.permissionMode || 'default',\n            planMode: (options as any).planMode || false, // Plan mode flag\n            includePartialMessages: options.includePartialMessages || false,\n            settingSources: options.settingSources || [],\n            cwd: options.cwd || workingDirectory,\n            allowedTools: options.allowedTools || [],\n            disallowedTools: options.disallowedTools || [], // Disallowed tools from agent config\n            mcpServers: options.mcpServers, // MCP servers from agent config\n            resume: options.resume,\n          },\n        };\n\n        const logsDir = path.join(workingDirectory, 'logs', 'chat');\n        await fs.mkdir(logsDir, { recursive: true });\n        const payloadPath = path.join(logsDir, `${sessionDocId}-${sdkCallId}-sdk-payload.json`);\n        await fs.writeFile(payloadPath, JSON.stringify(sdkPayload, null, 2), 'utf-8');\n        this.logger.info('Chat SDK payload saved', { sessionDocId, sdkCallId, payloadPath });\n      } catch (payloadError) {\n        this.logger.warn('Failed to save chat SDK payload', { sessionDocId, sdkCallId, error: payloadError });\n      }\n\n      // Create AbortController for cancellation support\n      const abortController = new AbortController();\n      const streamId = uuidv4();\n\n      // Store abort controller for cancel capability\n      this.activeAbortControllers.set(streamId, abortController);\n\n      // Add abortController to options\n      const optionsWithAbort: Options = {\n        ...options,\n        abortController,\n      };\n\n      // Create query instance\n      const queryInstance = query({\n        prompt: promptGenerator,\n        options: optionsWithAbort,\n      });\n\n      this.activeStreams.set(streamId, queryInstance);\n\n      // Send stream ID to client immediately for cancel capability\n      yield {\n        type: 'stream_id',\n        streamId,\n        timestamp: new Date().toISOString(),\n      };\n\n      let assistantMessageContent = '';\n      let sdkSessionId: string | null = null;\n      let toolUses: any[] = [];\n      let finalCost: number | undefined;\n      let finalUsage: any | undefined;\n      let assistantMessageId: string | null = null;\n      let hasStreamingStarted = false;\n\n      try {\n        // Stream messages from SDK\n        for await (const msg of queryInstance) {\n          // Enhanced logging - similar to task execution logs\n          const timestamp = new Date().toISOString();\n\n          // Determine message category for better organization\n          let eventCategory = 'sdk_event';\n          let eventDetails: any = {\n            messageType: msg.type,\n            subtype: (msg as any).subtype,\n          };\n\n          // Categorize and extract details for different message types\n          if (msg.type === 'system') {\n            eventCategory = 'system';\n            if (msg.subtype === 'init') {\n              eventDetails.sessionId = msg.session_id;\n              eventDetails.model = msg.model;\n              eventDetails.tools = msg.tools;\n              eventDetails.permissionMode = msg.permissionMode;\n            }\n          } else if (msg.type === 'assistant') {\n            eventCategory = 'assistant_message';\n            if (Array.isArray(msg.message.content)) {\n              eventDetails.hasText = msg.message.content.some((b: any) => b.type === 'text');\n              eventDetails.hasToolUse = msg.message.content.some((b: any) => b.type === 'tool_use');\n              eventDetails.toolCount = msg.message.content.filter((b: any) => b.type === 'tool_use').length;\n\n              // Extract tool use details\n              const toolUseBlocks = msg.message.content.filter((b: any) => b.type === 'tool_use');\n              if (toolUseBlocks.length > 0) {\n                eventDetails.tools = toolUseBlocks.map((t: any) => ({\n                  name: t.name,\n                  id: t.id,\n                }));\n              }\n            }\n          } else if ('delta' in msg && (msg as any).delta?.type === 'text') {\n            eventCategory = 'text_delta';\n            eventDetails.textLength = (msg as any).delta.text?.length || 0;\n          } else if (msg.type === 'result') {\n            eventCategory = 'result';\n            eventDetails.isError = msg.is_error;\n            eventDetails.numTurns = msg.num_turns;\n            eventDetails.totalCost = msg.total_cost_usd;\n            eventDetails.duration = msg.duration_ms;\n          }\n\n          // Log SDK event with enhanced details\n          await chatLogService.addSdkEvent(sessionDocId, sdkCallId, {\n            timestamp,\n            type: msg.type,\n            subtype: (msg as any).subtype,\n            category: eventCategory,\n            details: eventDetails,\n            data: msg,\n          });\n\n          // Log detailed info for debugging\n          if (eventCategory === 'assistant_message' && eventDetails.hasToolUse) {\n            this.logger.info('Tool use detected in assistant message', {\n              sessionId: sessionDocId,\n              callId: sdkCallId,\n              tools: eventDetails.tools,\n            });\n          }\n\n          // Yield message to client immediately\n          yield {\n            type: 'sdk_message',\n            data: msg,\n          };\n\n          // Send assistant_message_start event on first text delta\n          // Text deltas come as stream_event with type content_block_delta\n          if (!hasStreamingStarted &&\n              msg.type === 'stream_event' &&\n              (msg as any).event?.type === 'content_block_delta' &&\n              (msg as any).event?.delta?.type === 'text_delta') {\n            hasStreamingStarted = true;\n            assistantMessageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n            yield {\n              type: 'assistant_message_start',\n              messageId: assistantMessageId,\n              timestamp: new Date().toISOString(),\n            };\n          }\n\n          // Process different message types\n          if (msg.type === 'system' && msg.subtype === 'init') {\n            sdkSessionId = msg.session_id || null;\n\n            // Update session with SDK session ID\n            if (sdkSessionId && !session.sessionId) {\n              await this.strapiRequest('PUT', `/chat-sessions/${sessionDocId}`, {\n                data: { sessionId: sdkSessionId },\n              });\n\n              // Update SDK session ID in log\n              await chatLogService.updateSdkSessionId(sessionDocId, sdkSessionId);\n            }\n          } else if (msg.type === 'assistant') {\n            // Accumulate assistant message content\n            if (Array.isArray(msg.message.content)) {\n              for (const block of msg.message.content) {\n                if (block.type === 'text') {\n                  assistantMessageContent += block.text;\n                } else if (block.type === 'tool_use') {\n                  toolUses.push(block);\n                }\n              }\n            }\n          } else if (msg.type === 'stream_event' &&\n                     (msg as any).event?.type === 'content_block_delta' &&\n                     (msg as any).event?.delta?.type === 'text_delta') {\n            // Real-time streaming text delta from stream_event\n            const textDelta = (msg as any).event.delta.text;\n            assistantMessageContent += textDelta;\n\n            // Yield assistant_message_delta event for frontend\n            if (assistantMessageId) {\n              yield {\n                type: 'assistant_message_delta',\n                delta: textDelta,\n                messageId: assistantMessageId,\n                timestamp: new Date().toISOString(),\n              };\n            }\n          } else if (msg.type === 'result') {\n            // Final result with cost and usage\n            finalCost = msg.total_cost_usd;\n            finalUsage = msg.usage;\n          }\n        }\n\n        // Save assistant message to Strapi\n        if (assistantMessageContent || toolUses.length > 0) {\n          const assistantMessage = await this.saveChatMessage(\n            sessionDocId,\n            'assistant',\n            assistantMessageContent,\n            undefined,\n            {\n              toolUses,\n              cost: finalCost,\n              usage: finalUsage,\n            }\n          );\n\n          yield {\n            type: 'assistant_message_saved',\n            message: assistantMessage,\n          };\n\n          // Add assistant message to log\n          await chatLogService.addMessageToLog(sessionDocId, assistantMessage);\n\n          // Complete SDK call log\n          await chatLogService.completeSdkCall(\n            sessionDocId,\n            sdkCallId,\n            assistantMessage.documentId,\n            {\n              cost: finalCost,\n              usage: finalUsage,\n            }\n          );\n        }\n\n        yield {\n          type: 'done',\n          cost: finalCost,\n          usage: finalUsage,\n        };\n\n      } catch (streamError) {\n        // Check if this was a cancellation (AbortController.abort())\n        if (abortController.signal.aborted) {\n          this.logger.info('Message stream was cancelled', { sessionDocId, streamId });\n\n          // Don't save incomplete assistant message when cancelled\n\n          yield {\n            type: 'cancelled',\n            streamId,\n            timestamp: new Date().toISOString(),\n            reason: 'User cancelled the request',\n          };\n        } else {\n          // Real error - log and yield error event\n          this.logger.error('Error during message streaming', streamError, { sessionDocId, streamId });\n          yield {\n            type: 'error',\n            error: streamError instanceof Error ? streamError.message : String(streamError),\n          };\n        }\n      } finally {\n        // Cleanup: Remove from active streams and abort controllers\n        this.activeStreams.delete(streamId);\n        this.activeAbortControllers.delete(streamId);\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to send message', error, { sessionDocId });\n      yield {\n        type: 'error',\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Build async generator for streaming input mode to Claude Agent SDK\n   *\n   * @description\n   * Creates an AsyncGenerator that yields a single user message with optional file\n   * attachments to the Claude Agent SDK. This generator serves as the prompt input\n   * for the SDK's query() function, which expects an AsyncGenerator to enable\n   * streaming conversation patterns.\n   *\n   * The generator constructs a user message with content blocks based on the message\n   * text and attachment types. It handles three types of attachments:\n   * - **Images**: Sent as base64-encoded image blocks (PNG, JPEG, WebP, GIF)\n   * - **PDFs**: Sent as document blocks - SDK extracts text and images page by page\n   * - **Text files**: Included as inline text content with file name headers\n   *\n   * **AsyncGenerator Pattern:**\n   * The SDK's query() function expects an AsyncGenerator<PromptMessage> as input\n   * to enable streaming conversations where messages can be added dynamically.\n   * This method creates a simple generator that yields a single user message\n   * with all content blocks (text + attachments).\n   *\n   * **Content Block Structure:**\n   * 1. **Text block**: `{ type: 'text', text: message }`\n   * 2. **Image block**: `{ type: 'image', source: { type: 'base64', media_type, data } }`\n   * 3. **Document block**: `{ type: 'document', source: { type: 'base64', media_type, data } }`\n   * 4. **Text file block**: `{ type: 'text', text: '--- File: name ---\\n...' }`\n   *\n   * **Supported Image Formats:**\n   * - image/png, image/jpeg, image/jpg, image/webp, image/gif\n   *\n   * **Supported Document Formats:**\n   * - application/pdf (SDK processes page by page, extracts text and images)\n   *\n   * **Text File Handling:**\n   * Text files are decoded from base64 and included as inline text content\n   * with file name headers for context. This allows Claude to reference the\n   * file name when discussing the content.\n   *\n   * @param {string} message - The user's message text\n   * @param {SendMessageRequest['attachments']} [attachments] - Optional file attachments\n   *   Each attachment has: `{ name: string, mimeType: string, data: string (base64) }`\n   *\n   * @yields {Object} A single user message with content blocks:\n   *   `{ type: 'user', message: { role: 'user', content: string | Array<ContentBlock> } }`\n   *\n   * @returns {AsyncGenerator<any>} Async generator yielding user message for SDK\n   *\n   * @example\n   * ```typescript\n   * // Simple text message\n   * const generator = this.buildPromptGenerator('Hello Claude');\n   *\n   * for await (const msg of generator) {\n   *   console.log(msg);\n   * }\n   * // Output:\n   * // {\n   * //   type: 'user',\n   * //   message: {\n   * //     role: 'user',\n   * //     content: 'Hello Claude'\n   * //   }\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Message with image attachment\n   * import fs from 'fs';\n   *\n   * const imageBuffer = fs.readFileSync('./diagram.png');\n   * const attachments = [{\n   *   name: 'diagram.png',\n   *   mimeType: 'image/png',\n   *   data: imageBuffer.toString('base64')\n   * }];\n   *\n   * const generator = this.buildPromptGenerator(\n   *   'Analyze this diagram',\n   *   attachments\n   * );\n   *\n   * for await (const msg of generator) {\n   *   console.log(msg);\n   * }\n   * // Output:\n   * // {\n   * //   type: 'user',\n   * //   message: {\n   * //     role: 'user',\n   * //     content: [\n   * //       { type: 'text', text: 'Analyze this diagram' },\n   * //       {\n   * //         type: 'image',\n   * //         source: {\n   * //           type: 'base64',\n   * //           media_type: 'image/png',\n   * //           data: 'iVBORw0KGgoAAAANS...'\n   * //         }\n   * //       }\n   * //     ]\n   * //   }\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Message with PDF document\n   * import fs from 'fs';\n   *\n   * const pdfBuffer = fs.readFileSync('./report.pdf');\n   * const attachments = [{\n   *   name: 'report.pdf',\n   *   mimeType: 'application/pdf',\n   *   data: pdfBuffer.toString('base64')\n   * }];\n   *\n   * const generator = this.buildPromptGenerator(\n   *   'Summarize this report',\n   *   attachments\n   * );\n   *\n   * for await (const msg of generator) {\n   *   console.log(msg.message.content[1].type);\n   *   // => 'document'\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Message with text file\n   * import fs from 'fs';\n   *\n   * const textBuffer = fs.readFileSync('./config.json');\n   * const attachments = [{\n   *   name: 'config.json',\n   *   mimeType: 'text/plain',\n   *   data: textBuffer.toString('base64')\n   * }];\n   *\n   * const generator = this.buildPromptGenerator(\n   *   'Review this configuration',\n   *   attachments\n   * );\n   *\n   * for await (const msg of generator) {\n   *   console.log(msg.message.content[1].text);\n   * }\n   * // Output:\n   * // --- File: config.json ---\n   * // {\n   * //   \"port\": 3000,\n   * //   \"host\": \"localhost\"\n   * // }\n   * // --- End of file ---\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Message with multiple attachments\n   * const attachments = [\n   *   { name: 'screenshot.png', mimeType: 'image/png', data: base64Image },\n   *   { name: 'logs.txt', mimeType: 'text/plain', data: base64Text },\n   *   { name: 'report.pdf', mimeType: 'application/pdf', data: base64Pdf }\n   * ];\n   *\n   * const generator = this.buildPromptGenerator(\n   *   'Debug this issue using these files',\n   *   attachments\n   * );\n   *\n   * for await (const msg of generator) {\n   *   console.log('Content blocks:', msg.message.content.length);\n   *   // => Content blocks: 4 (1 text + 1 image + 1 text file + 1 pdf)\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Use with SDK query() function\n   * import { query } from '@anthropic-ai/claude-agent-sdk';\n   *\n   * const promptGenerator = this.buildPromptGenerator('Review the code');\n   *\n   * const queryInstance = query({\n   *   prompt: promptGenerator,\n   *   options: {\n   *     model: 'claude-sonnet-4-5',\n   *     systemPrompt: 'You are a code reviewer',\n   *     cwd: '/path/to/project'\n   *   }\n   * });\n   *\n   * for await (const msg of queryInstance) {\n   *   console.log('SDK message:', msg.type);\n   * }\n   * ```\n   *\n   * @private\n   * @see {@link sendMessage} - Uses this generator to build SDK prompt\n   * @see {@link https://docs.anthropic.com/en/api/agent-sdk|Claude Agent SDK Documentation}\n   */\n  private async* buildPromptGenerator(\n    message: string,\n    attachments?: SendMessageRequest['attachments']\n  ): AsyncGenerator<any> {\n    // Build content array\n    const content: any[] = [{ type: 'text', text: message }];\n\n    // Add attachments if present\n    if (attachments && attachments.length > 0) {\n      for (const attachment of attachments) {\n        const mimeType = attachment.mimeType;\n\n        if (mimeType.startsWith('image/')) {\n          content.push({\n            type: 'image',\n            source: {\n              type: 'base64',\n              media_type: mimeType,\n              data: attachment.data,\n            },\n          });\n        } else if (mimeType === 'application/pdf') {\n          // PDF support - SDK will process page by page\n          content.push({\n            type: 'document',\n            source: {\n              type: 'base64',\n              media_type: 'application/pdf',\n              data: attachment.data,\n            },\n          });\n        }\n        // Text files can be included as text content\n        else if (mimeType.startsWith('text/')) {\n          const textContent = Buffer.from(attachment.data, 'base64').toString('utf-8');\n          content.push({\n            type: 'text',\n            text: `\\n\\n--- File: ${attachment.name} ---\\n${textContent}\\n--- End of file ---\\n`,\n          });\n        }\n      }\n    }\n\n    // Yield user message\n    yield {\n      type: 'user',\n      message: {\n        role: 'user',\n        content: content.length === 1 ? message : content,\n      },\n    };\n  }\n\n  /**\n   * Permanently delete a chat session and all its messages\n   *\n   * @description\n   * Permanently deletes a chat session from Strapi CMS along with all associated\n   * messages and chat log files. This operation is irreversible and should be used\n   * with caution. For non-destructive session management, consider using\n   * archiveChatSession() instead.\n   *\n   * **Deletion Workflow:**\n   * 1. Fetch all messages for the session via getChatMessages()\n   * 2. Delete each message individually from Strapi chat-messages collection\n   * 3. Delete the session from Strapi chat-sessions collection\n   * 4. Delete the associated chat log file from filesystem\n   * 5. Log successful deletion\n   *\n   * **Cascade Delete:**\n   * The method manually implements cascade deletion for messages because Strapi\n   * v5 doesn't automatically cascade delete related entities. This ensures no\n   * orphaned message records remain in the database.\n   *\n   * **File Cleanup:**\n   * The method calls chatLogService.deleteChatLog() to remove the filesystem\n   * log file created during the session. This prevents accumulation of unused\n   * log files and maintains filesystem hygiene.\n   *\n   * **Use Cases:**\n   * - User requests permanent deletion of conversation\n   * - Cleanup of test or temporary sessions\n   * - GDPR/privacy compliance (data deletion requests)\n   * - Freeing up database storage\n   * - Removing sensitive conversation data\n   *\n   * **Alternatives:**\n   * - **Archive**: Use archiveChatSession() for soft delete (preserves data)\n   * - **Export first**: Export conversation before deletion for backup\n   * - **Status filter**: Filter archived sessions in UI instead of deleting\n   *\n   * **Important Notes:**\n   * - This operation is IRREVERSIBLE - all conversation data is permanently lost\n   * - Attachments uploaded to Strapi are NOT automatically deleted (orphaned files)\n   * - Consider implementing user confirmation dialog in UI before calling\n   * - For production, consider implementing soft delete pattern instead\n   *\n   * @param {string} sessionDocId - The documentId of the chat session to delete\n   *\n   * @returns {Promise<void>} Resolves when deletion is complete\n   *\n   * @throws {Error} If the Strapi request fails or session/messages cannot be deleted\n   *\n   * @example\n   * ```typescript\n   * // Basic session deletion\n   * import { chatService } from './chat-service';\n   *\n   * await chatService.deleteChatSession('session-doc-id-123');\n   * console.log('Session deleted permanently');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Delete with user confirmation\n   * import { chatService } from './chat-service';\n   *\n   * async function deleteWithConfirmation(sessionDocId: string) {\n   *   const session = await chatService.getChatSession(sessionDocId);\n   *\n   *   const confirmed = confirm(\n   *     `Permanently delete \"${session.title}\"? This cannot be undone.`\n   *   );\n   *\n   *   if (confirmed) {\n   *     await chatService.deleteChatSession(sessionDocId);\n   *     console.log('Session deleted');\n   *   } else {\n   *     console.log('Deletion cancelled');\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Export before deletion (backup)\n   * import { chatService } from './chat-service';\n   * import fs from 'fs';\n   *\n   * async function exportAndDelete(sessionDocId: string) {\n   *   // Export conversation first\n   *   const session = await chatService.getChatSession(sessionDocId);\n   *   const messages = await chatService.getChatMessages(sessionDocId);\n   *\n   *   const backup = {\n   *     session,\n   *     messages,\n   *     exportedAt: new Date().toISOString(),\n   *   };\n   *\n   *   fs.writeFileSync(\n   *     `backup-${sessionDocId}.json`,\n   *     JSON.stringify(backup, null, 2)\n   *   );\n   *\n   *   // Now safe to delete\n   *   await chatService.deleteChatSession(sessionDocId);\n   *   console.log('Session backed up and deleted');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Bulk delete old sessions\n   * import { chatService } from './chat-service';\n   *\n   * async function deleteOldSessions(daysOld: number) {\n   *   const allSessions = await chatService.getAllChatSessions();\n   *   const cutoffDate = new Date();\n   *   cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n   *\n   *   const oldSessions = allSessions.filter(session =>\n   *     new Date(session.createdAt) < cutoffDate\n   *   );\n   *\n   *   console.log(`Deleting ${oldSessions.length} sessions older than ${daysOld} days`);\n   *\n   *   for (const session of oldSessions) {\n   *     await chatService.deleteChatSession(session.documentId);\n   *     console.log(`Deleted: ${session.title}`);\n   *   }\n   * }\n   *\n   * await deleteOldSessions(90); // Delete sessions older than 90 days\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle deletion errors gracefully\n   * import { chatService } from './chat-service';\n   *\n   * async function safeDelete(sessionDocId: string) {\n   *   try {\n   *     await chatService.deleteChatSession(sessionDocId);\n   *     return { success: true, message: 'Session deleted' };\n   *   } catch (error) {\n   *     console.error('Failed to delete session:', error);\n   *     return {\n   *       success: false,\n   *       message: 'Deletion failed. Session may not exist.',\n   *     };\n   *   }\n   * }\n   *\n   * const result = await safeDelete('session-doc-id-123');\n   * console.log(result.message);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Delete test sessions (cleanup after tests)\n   * import { chatService } from './chat-service';\n   *\n   * async function cleanupTestSessions() {\n   *   const sessions = await chatService.getAllChatSessions();\n   *   const testSessions = sessions.filter(s =>\n   *     s.title.startsWith('[TEST]')\n   *   );\n   *\n   *   console.log(`Cleaning up ${testSessions.length} test sessions`);\n   *\n   *   await Promise.all(\n   *     testSessions.map(s => chatService.deleteChatSession(s.documentId))\n   *   );\n   *\n   *   console.log('Test cleanup complete');\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Archive instead of delete (safer alternative)\n   * import { chatService } from './chat-service';\n   *\n   * async function archiveInsteadOfDelete(sessionDocId: string) {\n   *   // Archive preserves data but hides from active list\n   *   await chatService.archiveChatSession(sessionDocId);\n   *   console.log('Session archived (data preserved)');\n   *\n   *   // Later, can still retrieve if needed\n   *   const session = await chatService.getChatSession(sessionDocId);\n   *   console.log('Status:', session.status); // => 'archived'\n   * }\n   * ```\n   *\n   * @see {@link archiveChatSession} - Soft delete alternative (preserves data)\n   * @see {@link getAllChatSessions} - Get sessions for bulk operations\n   * @see {@link getChatMessages} - Get messages before deletion\n   */\n  async deleteChatSession(sessionDocId: string): Promise<void> {\n    try {\n      // Delete all messages first\n      const messages = await this.getChatMessages(sessionDocId);\n      for (const message of messages) {\n        await this.strapiRequest('DELETE', `/chat-messages/${message.documentId}`);\n      }\n\n      // Delete session\n      await this.strapiRequest('DELETE', `/chat-sessions/${sessionDocId}`);\n\n      // Delete chat log file\n      await chatLogService.deleteChatLog(sessionDocId);\n\n      this.logger.info('Chat session deleted', { sessionDocId });\n    } catch (error) {\n      this.logger.error('Failed to delete chat session', error, { sessionDocId });\n      throw error;\n    }\n  }\n\n  /**\n   * Archive a chat session (soft delete)\n   *\n   * @description\n   * Archives a chat session by updating its status to 'archived' in Strapi CMS\n   * and the associated chat log file. This is a non-destructive operation that\n   * preserves all conversation data while hiding the session from active lists.\n   * Archived sessions can still be accessed, retrieved, and restored if needed.\n   *\n   * **Soft Delete Pattern:**\n   * Archiving implements a soft delete pattern where data is marked as inactive\n   * rather than permanently deleted. Benefits include:\n   * - Data preservation for historical reference\n   * - Ability to restore sessions if needed\n   * - Safer alternative to permanent deletion\n   * - Compliance with data retention policies\n   * - Audit trail of past conversations\n   *\n   * **Update Workflow:**\n   * 1. Update session status to 'archived' in Strapi via PUT request\n   * 2. Update status in filesystem chat log via chatLogService\n   * 3. Return updated session object with new status\n   *\n   * **Status Values:**\n   * - `active`: Session is currently active and appears in default lists\n   * - `archived`: Session is archived and hidden from default views\n   *\n   * **Use Cases:**\n   * - Hide completed or old conversations from active list\n   * - Clean up UI without losing conversation history\n   * - Implement \"delete\" functionality with data preservation\n   * - Organize conversations by status (active vs historical)\n   * - Comply with data retention policies\n   * - Support conversation search across all time\n   *\n   * **Restoration:**\n   * To restore an archived session, update its status back to 'active' via\n   * Strapi API or implement an unarchive method. The session and all messages\n   * remain intact and can be resumed immediately.\n   *\n   * **UI Integration:**\n   * - Show archived sessions in separate \"Archived\" view\n   * - Filter archived sessions from main session list\n   * - Display archive status badge in session UI\n   * - Provide \"Unarchive\" action for archived sessions\n   *\n   * @param {string} sessionDocId - The documentId of the chat session to archive\n   *\n   * @returns {Promise<ChatSession>} The updated session with status='archived'\n   *\n   * @throws {Error} If the Strapi request fails or session is not found\n   *\n   * @example\n   * ```typescript\n   * // Basic session archiving\n   * import { chatService } from './chat-service';\n   *\n   * const archivedSession = await chatService.archiveChatSession('session-doc-id-123');\n   *\n   * console.log(`Archived: ${archivedSession.title}`);\n   * console.log(`Status: ${archivedSession.status}`);\n   * // Output:\n   * // Archived: Code Review Chat\n   * // Status: archived\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Archive with user confirmation\n   * import { chatService } from './chat-service';\n   *\n   * async function archiveWithConfirmation(sessionDocId: string) {\n   *   const session = await chatService.getChatSession(sessionDocId);\n   *\n   *   const confirmed = confirm(\n   *     `Archive \"${session.title}\"? You can restore it later.`\n   *   );\n   *\n   *   if (confirmed) {\n   *     const archived = await chatService.archiveChatSession(sessionDocId);\n   *     console.log('Session archived');\n   *     return archived;\n   *   } else {\n   *     console.log('Archive cancelled');\n   *     return session;\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Filter archived sessions from active list\n   * import { chatService } from './chat-service';\n   *\n   * const allSessions = await chatService.getAllChatSessions();\n   *\n   * const activeSessions = allSessions.filter(s => s.status === 'active');\n   * const archivedSessions = allSessions.filter(s => s.status === 'archived');\n   *\n   * console.log(`Active: ${activeSessions.length}`);\n   * console.log(`Archived: ${archivedSessions.length}`);\n   * // Output:\n   * // Active: 5\n   * // Archived: 12\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Archive old sessions automatically\n   * import { chatService } from './chat-service';\n   *\n   * async function archiveOldSessions(daysOld: number) {\n   *   const allSessions = await chatService.getAllChatSessions();\n   *   const cutoffDate = new Date();\n   *   cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n   *\n   *   const oldSessions = allSessions.filter(session =>\n   *     session.status === 'active' &&\n   *     new Date(session.createdAt) < cutoffDate\n   *   );\n   *\n   *   console.log(`Archiving ${oldSessions.length} sessions older than ${daysOld} days`);\n   *\n   *   for (const session of oldSessions) {\n   *     await chatService.archiveChatSession(session.documentId);\n   *     console.log(`Archived: ${session.title}`);\n   *   }\n   * }\n   *\n   * await archiveOldSessions(30); // Archive sessions older than 30 days\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Restore archived session (manual implementation)\n   * import { chatService } from './chat-service';\n   * import axios from 'axios';\n   *\n   * async function restoreSession(sessionDocId: string) {\n   *   const STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';\n   *   const STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;\n   *\n   *   await axios.put(\n   *     `${STRAPI_URL}/api/chat-sessions/${sessionDocId}`,\n   *     { data: { status: 'active' } },\n   *     { headers: { Authorization: `Bearer ${STRAPI_API_TOKEN}` } }\n   *   );\n   *\n   *   console.log('Session restored to active status');\n   *   return await chatService.getChatSession(sessionDocId);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Bulk archive by filter criteria\n   * import { chatService } from './chat-service';\n   *\n   * async function archiveByTitle(titlePattern: string) {\n   *   const allSessions = await chatService.getAllChatSessions();\n   *   const matchingSessions = allSessions.filter(s =>\n   *     s.status === 'active' &&\n   *     s.title.toLowerCase().includes(titlePattern.toLowerCase())\n   *   );\n   *\n   *   console.log(`Archiving ${matchingSessions.length} sessions matching \"${titlePattern}\"`);\n   *\n   *   const results = await Promise.all(\n   *     matchingSessions.map(s => chatService.archiveChatSession(s.documentId))\n   *   );\n   *\n   *   console.log('Bulk archive complete');\n   *   return results;\n   * }\n   *\n   * await archiveByTitle('test'); // Archive all sessions with 'test' in title\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Archive session after completion\n   * import { chatService } from './chat-service';\n   *\n   * async function completeAndArchiveSession(sessionDocId: string) {\n   *   // Send final message\n   *   for await (const event of chatService.sendMessage(\n   *     sessionDocId,\n   *     'Thank you! This conversation is complete.',\n   *     [],\n   *     '/path/to/project'\n   *   )) {\n   *     if (event.type === 'done') {\n   *       console.log('Final message sent, archiving session...');\n   *     }\n   *   }\n   *\n   *   // Archive the completed session\n   *   const archived = await chatService.archiveChatSession(sessionDocId);\n   *   console.log(`Session \"${archived.title}\" archived`);\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Show archived sessions in UI\n   * import { chatService } from './chat-service';\n   *\n   * async function displayArchivedSessions() {\n   *   const allSessions = await chatService.getAllChatSessions();\n   *   const archived = allSessions.filter(s => s.status === 'archived');\n   *\n   *   console.log('=== Archived Sessions ===');\n   *   archived.forEach(session => {\n   *     const date = new Date(session.createdAt).toLocaleDateString();\n   *     console.log(`- ${session.title} (${date})`);\n   *   });\n   *\n   *   if (archived.length === 0) {\n   *     console.log('No archived sessions');\n   *   }\n   * }\n   * ```\n   *\n   * @see {@link deleteChatSession} - Permanent deletion alternative\n   * @see {@link getAllChatSessions} - Get all sessions including archived\n   * @see {@link getChatSession} - Retrieve archived session details\n   */\n  async archiveChatSession(sessionDocId: string): Promise<ChatSession> {\n    try {\n      const data = await this.strapiRequest('PUT', `/chat-sessions/${sessionDocId}`, {\n        data: { status: 'archived' },\n      });\n\n      if (!data.data) {\n        throw new Error('Failed to archive chat session');\n      }\n\n      // Update status in log\n      await chatLogService.updateSessionStatus(sessionDocId, 'archived');\n\n      return this.transformChatSession(data.data);\n    } catch (error) {\n      this.logger.error('Failed to archive chat session', error, { sessionDocId });\n      throw error;\n    }\n  }\n\n  /**\n   * Cancel an active message stream\n   *\n   * @description\n   * Gracefully cancels an active message stream using the AbortController pattern.\n   * This method aborts the SDK query execution and triggers cleanup of active stream\n   * resources. The cancelled stream yields a 'cancelled' event to notify the client.\n   *\n   * **Cancellation Flow:**\n   * 1. Client receives 'stream_id' event from sendMessage()\n   * 2. Client calls cancelMessage(streamId) to abort the stream\n   * 3. Service calls abortController.abort() to signal cancellation\n   * 4. SDK Query respects the abort signal and stops processing\n   * 5. Service removes stream from activeStreams and activeAbortControllers Maps\n   * 6. sendMessage() generator yields 'cancelled' event with reason and timestamp\n   * 7. No incomplete assistant message is saved to Strapi (prevents partial data)\n   *\n   * **Use Cases:**\n   * - User manually cancels a long-running request\n   * - Timeout logic for requests exceeding a threshold\n   * - User navigates away from chat UI\n   * - Application shutdown cleanup\n   * - Rate limiting or quota management\n   * - User starts a new message (cancel previous)\n   *\n   * **AbortController Pattern:**\n   * Each stream has a dedicated AbortController instance stored in the\n   * activeAbortControllers Map. The abort signal is passed to the SDK Query\n   * via the options.abortController parameter. When abort() is called,\n   * the SDK immediately stops processing and throws an error that's caught\n   * by sendMessage()'s try/catch block.\n   *\n   * **Cleanup Safety:**\n   * The method performs cleanup even if the stream is already completed or\n   * doesn't exist. This ensures no memory leaks or dangling references in\n   * the activeStreams and activeAbortControllers Maps.\n   *\n   * **Partial Message Handling:**\n   * When a stream is cancelled, any accumulated assistant text is NOT saved\n   * to Strapi. This prevents partial, incomplete, or misleading responses\n   * from being persisted in the chat history.\n   *\n   * @param {string} streamId - The unique stream ID returned in the 'stream_id' event\n   *\n   * @returns {boolean} `true` if stream was found and cancelled successfully,\n   *   `false` if stream was not found (already completed or invalid ID)\n   *\n   * @example\n   * ```typescript\n   * // Basic cancellation flow\n   * import { chatService } from './chat-service';\n   *\n   * let currentStreamId: string | null = null;\n   *\n   * // Start streaming in background\n   * (async () => {\n   *   for await (const event of chatService.sendMessage(\n   *     'session-doc-id',\n   *     'This is a long running task...',\n   *     [],\n   *     '/path/to/project'\n   *   )) {\n   *     if (event.type === 'stream_id') {\n   *       currentStreamId = event.streamId;\n   *       console.log('Stream started:', currentStreamId);\n   *     }\n   *     if (event.type === 'cancelled') {\n   *       console.log('Stream cancelled:', event.reason);\n   *     }\n   *   }\n   * })();\n   *\n   * // Cancel after 5 seconds\n   * setTimeout(() => {\n   *   if (currentStreamId) {\n   *     const cancelled = chatService.cancelMessage(currentStreamId);\n   *     console.log('Cancellation requested:', cancelled);\n   *     // => Cancellation requested: true\n   *   }\n   * }, 5000);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Cancel on user action (button click)\n   * import { chatService } from './chat-service';\n   *\n   * let activeStreamId: string | null = null;\n   *\n   * // UI button handler\n   * function handleCancelClick() {\n   *   if (activeStreamId) {\n   *     const success = chatService.cancelMessage(activeStreamId);\n   *     if (success) {\n   *       showNotification('Request cancelled');\n   *       activeStreamId = null;\n   *     } else {\n   *       showNotification('Request already completed');\n   *     }\n   *   }\n   * }\n   *\n   * // Start streaming and enable cancel button\n   * async function sendMessage(text: string) {\n   *   for await (const event of chatService.sendMessage(\n   *     sessionDocId,\n   *     text,\n   *     [],\n   *     workingDir\n   *   )) {\n   *     if (event.type === 'stream_id') {\n   *       activeStreamId = event.streamId;\n   *       enableCancelButton(); // Enable UI cancel button\n   *     }\n   *     if (event.type === 'done' || event.type === 'cancelled') {\n   *       activeStreamId = null;\n   *       disableCancelButton(); // Disable UI cancel button\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Timeout-based cancellation\n   * import { chatService } from './chat-service';\n   *\n   * async function sendMessageWithTimeout(\n   *   sessionDocId: string,\n   *   message: string,\n   *   timeoutMs: number = 60000\n   * ) {\n   *   let streamId: string | null = null;\n   *   let timeoutHandle: NodeJS.Timeout | null = null;\n   *\n   *   try {\n   *     for await (const event of chatService.sendMessage(\n   *       sessionDocId,\n   *       message,\n   *       [],\n   *       '/path/to/project'\n   *     )) {\n   *       if (event.type === 'stream_id') {\n   *         streamId = event.streamId;\n   *\n   *         // Set timeout to cancel after timeoutMs\n   *         timeoutHandle = setTimeout(() => {\n   *           if (streamId) {\n   *             console.log('Request timeout - cancelling stream');\n   *             chatService.cancelMessage(streamId);\n   *           }\n   *         }, timeoutMs);\n   *       }\n   *\n   *       if (event.type === 'done' || event.type === 'cancelled' || event.type === 'error') {\n   *         // Clear timeout on completion\n   *         if (timeoutHandle) {\n   *           clearTimeout(timeoutHandle);\n   *         }\n   *       }\n   *\n   *       // Handle other events...\n   *     }\n   *   } catch (error) {\n   *     if (timeoutHandle) {\n   *       clearTimeout(timeoutHandle);\n   *     }\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Cancel all active streams (e.g., on shutdown)\n   * import { chatService } from './chat-service';\n   *\n   * function cancelAllActiveStreams() {\n   *   const activeStreamIds = chatService.getActiveStreamIds();\n   *   console.log(`Cancelling ${activeStreamIds.length} active streams`);\n   *\n   *   let cancelledCount = 0;\n   *   for (const streamId of activeStreamIds) {\n   *     const success = chatService.cancelMessage(streamId);\n   *     if (success) {\n   *       cancelledCount++;\n   *     }\n   *   }\n   *\n   *   console.log(`Successfully cancelled ${cancelledCount} streams`);\n   * }\n   *\n   * // Call during application shutdown\n   * process.on('SIGTERM', () => {\n   *   cancelAllActiveStreams();\n   *   process.exit(0);\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Cancel and start new message (replace current)\n   * import { chatService } from './chat-service';\n   *\n   * let currentStreamId: string | null = null;\n   *\n   * async function sendNewMessage(sessionDocId: string, message: string) {\n   *   // Cancel current stream if active\n   *   if (currentStreamId) {\n   *     const cancelled = chatService.cancelMessage(currentStreamId);\n   *     if (cancelled) {\n   *       console.log('Cancelled previous request');\n   *     }\n   *     currentStreamId = null;\n   *   }\n   *\n   *   // Start new stream\n   *   for await (const event of chatService.sendMessage(\n   *     sessionDocId,\n   *     message,\n   *     [],\n   *     '/path/to/project'\n   *   )) {\n   *     if (event.type === 'stream_id') {\n   *       currentStreamId = event.streamId;\n   *     }\n   *     if (event.type === 'done' || event.type === 'cancelled' || event.type === 'error') {\n   *       currentStreamId = null;\n   *     }\n   *     // Handle events...\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Check if stream was actually cancelled\n   * import { chatService } from './chat-service';\n   *\n   * const streamId = 'stream-uuid-123';\n   * const wasCancelled = chatService.cancelMessage(streamId);\n   *\n   * if (wasCancelled) {\n   *   console.log('Stream cancelled successfully');\n   * } else {\n   *   console.log('Stream not found - may have already completed');\n   * }\n   * ```\n   *\n   * @see {@link sendMessage} - Yields 'stream_id' event for cancellation\n   * @see {@link getActiveStreamIds} - Get list of active stream IDs\n   */\n  cancelMessage(streamId: string): boolean {\n    this.logger.info('Cancelling message stream', { streamId });\n\n    const abortController = this.activeAbortControllers.get(streamId);\n\n    if (abortController) {\n      // Abort the stream\n      abortController.abort();\n\n      // Cleanup\n      this.activeAbortControllers.delete(streamId);\n      this.activeStreams.delete(streamId);\n\n      this.logger.info('Message stream cancelled successfully', { streamId });\n      return true;\n    }\n\n    this.logger.warn('Stream not found or already completed', { streamId });\n    return false;\n  }\n\n  /**\n   * Get list of active stream IDs for monitoring and debugging\n   *\n   * @description\n   * Returns an array of all currently active stream IDs from the activeStreams Map.\n   * Each stream ID represents an ongoing message stream (sendMessage call) that is\n   * actively processing SDK responses. This method is useful for monitoring active\n   * conversations, debugging stream lifecycle issues, and implementing shutdown cleanup.\n   *\n   * **Active Stream Lifecycle:**\n   * A stream is considered active from the moment it's added to activeStreams Map\n   * (after creating SDK Query) until it's removed (completion, error, or cancellation).\n   * The lifecycle stages are:\n   * 1. Stream created - added to activeStreams Map with unique UUID\n   * 2. Stream ID yielded - 'stream_id' event sent to client\n   * 3. Stream processing - SDK messages streaming\n   * 4. Stream cleanup - removed from activeStreams Map (done/error/cancelled)\n   *\n   * **Use Cases:**\n   * - Monitor how many conversations are actively streaming\n   * - Debug stream lifecycle issues and memory leaks\n   * - Implement graceful shutdown (cancel all active streams)\n   * - Display \"active conversations\" count in UI\n   * - Rate limiting based on concurrent streams\n   * - Health check endpoint for monitoring\n   * - Prevent duplicate streams for same session\n   *\n   * **Monitoring Patterns:**\n   * - Poll periodically to track active stream count\n   * - Log stream count before/after operations\n   * - Alert if stream count exceeds threshold\n   * - Track average stream duration\n   * - Detect stuck or orphaned streams\n   *\n   * **Cleanup Patterns:**\n   * - Cancel all active streams on application shutdown\n   * - Cancel streams for specific session when replacing with new message\n   * - Timeout logic for streams exceeding duration threshold\n   * - Emergency abort for runaway streams\n   *\n   * **Map Synchronization:**\n   * This method reads from the activeStreams Map, which is synchronized with\n   * activeAbortControllers Map. Both Maps are updated atomically in sendMessage()\n   * to ensure consistency between stream IDs and abort controllers.\n   *\n   * @returns {string[]} Array of active stream IDs (UUIDs)\n   *\n   * @example\n   * ```typescript\n   * // Basic usage - get active stream count\n   * import { chatService } from './chat-service';\n   *\n   * const activeStreamIds = chatService.getActiveStreamIds();\n   * console.log(`Active streams: ${activeStreamIds.length}`);\n   * // Output:\n   * // Active streams: 3\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Monitor active streams periodically\n   * import { chatService } from './chat-service';\n   *\n   * setInterval(() => {\n   *   const activeStreams = chatService.getActiveStreamIds();\n   *   console.log(`[${new Date().toISOString()}] Active streams: ${activeStreams.length}`);\n   *\n   *   if (activeStreams.length > 10) {\n   *     console.warn('High number of concurrent streams detected!');\n   *   }\n   * }, 5000); // Check every 5 seconds\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Cancel all active streams (shutdown cleanup)\n   * import { chatService } from './chat-service';\n   *\n   * async function shutdown() {\n   *   const activeStreamIds = chatService.getActiveStreamIds();\n   *\n   *   if (activeStreamIds.length > 0) {\n   *     console.log(`Cancelling ${activeStreamIds.length} active streams...`);\n   *\n   *     for (const streamId of activeStreamIds) {\n   *       chatService.cancelMessage(streamId);\n   *     }\n   *\n   *     console.log('All streams cancelled');\n   *   }\n   *\n   *   process.exit(0);\n   * }\n   *\n   * process.on('SIGTERM', shutdown);\n   * process.on('SIGINT', shutdown);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Display active streams in admin UI\n   * import { chatService } from './chat-service';\n   *\n   * async function getActiveStreamInfo() {\n   *   const streamIds = chatService.getActiveStreamIds();\n   *\n   *   return {\n   *     count: streamIds.length,\n   *     streamIds: streamIds,\n   *     timestamp: new Date().toISOString(),\n   *   };\n   * }\n   *\n   * const info = await getActiveStreamInfo();\n   * console.log(JSON.stringify(info, null, 2));\n   * // Output:\n   * // {\n   * //   \"count\": 2,\n   * //   \"streamIds\": [\n   * //     \"550e8400-e29b-41d4-a716-446655440000\",\n   * //     \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"\n   * //   ],\n   * //   \"timestamp\": \"2026-01-02T12:00:00.000Z\"\n   * // }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Rate limiting based on active streams\n   * import { chatService } from './chat-service';\n   *\n   * async function sendMessageWithRateLimit(\n   *   sessionDocId: string,\n   *   message: string,\n   *   maxConcurrent: number = 5\n   * ) {\n   *   const activeStreams = chatService.getActiveStreamIds();\n   *\n   *   if (activeStreams.length >= maxConcurrent) {\n   *     throw new Error(\n   *       `Rate limit exceeded: ${activeStreams.length}/${maxConcurrent} streams active`\n   *     );\n   *   }\n   *\n   *   // Proceed with sending message\n   *   for await (const event of chatService.sendMessage(\n   *     sessionDocId,\n   *     message,\n   *     [],\n   *     '/path/to/project'\n   *   )) {\n   *     // Handle events...\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Health check endpoint\n   * import { chatService } from './chat-service';\n   * import express from 'express';\n   *\n   * const app = express();\n   *\n   * app.get('/health', (req, res) => {\n   *   const activeStreams = chatService.getActiveStreamIds();\n   *\n   *   res.json({\n   *     status: 'healthy',\n   *     activeStreams: activeStreams.length,\n   *     timestamp: new Date().toISOString(),\n   *   });\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Prevent duplicate streams for same session\n   * import { chatService } from './chat-service';\n   *\n   * const sessionStreamMap = new Map<string, string>(); // sessionDocId -> streamId\n   *\n   * async function sendMessageNoDuplicate(\n   *   sessionDocId: string,\n   *   message: string\n   * ) {\n   *   // Cancel existing stream for this session if active\n   *   const existingStreamId = sessionStreamMap.get(sessionDocId);\n   *   if (existingStreamId) {\n   *     const activeStreamIds = chatService.getActiveStreamIds();\n   *     if (activeStreamIds.includes(existingStreamId)) {\n   *       console.log('Cancelling existing stream for session');\n   *       chatService.cancelMessage(existingStreamId);\n   *     }\n   *   }\n   *\n   *   // Start new stream\n   *   for await (const event of chatService.sendMessage(\n   *     sessionDocId,\n   *     message,\n   *     [],\n   *     '/path/to/project'\n   *   )) {\n   *     if (event.type === 'stream_id') {\n   *       sessionStreamMap.set(sessionDocId, event.streamId);\n   *     }\n   *     if (event.type === 'done' || event.type === 'error' || event.type === 'cancelled') {\n   *       sessionStreamMap.delete(sessionDocId);\n   *     }\n   *     // Handle other events...\n   *   }\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Detect stuck streams (timeout monitoring)\n   * import { chatService } from './chat-service';\n   *\n   * const streamStartTimes = new Map<string, number>();\n   * const TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes\n   *\n   * // Track stream start times\n   * async function monitorStreams() {\n   *   const activeStreamIds = chatService.getActiveStreamIds();\n   *   const now = Date.now();\n   *\n   *   for (const streamId of activeStreamIds) {\n   *     if (!streamStartTimes.has(streamId)) {\n   *       streamStartTimes.set(streamId, now);\n   *     } else {\n   *       const elapsed = now - streamStartTimes.get(streamId)!;\n   *       if (elapsed > TIMEOUT_MS) {\n   *         console.warn(`Stream ${streamId} exceeded timeout (${elapsed}ms), cancelling`);\n   *         chatService.cancelMessage(streamId);\n   *         streamStartTimes.delete(streamId);\n   *       }\n   *     }\n   *   }\n   *\n   *   // Cleanup finished streams\n   *   for (const [streamId] of streamStartTimes) {\n   *     if (!activeStreamIds.includes(streamId)) {\n   *       streamStartTimes.delete(streamId);\n   *     }\n   *   }\n   * }\n   *\n   * setInterval(monitorStreams, 10000); // Check every 10 seconds\n   * ```\n   *\n   * @see {@link cancelMessage} - Cancel a specific stream by ID\n   * @see {@link sendMessage} - Creates streams tracked by this method\n   */\n  getActiveStreamIds(): string[] {\n    return Array.from(this.activeStreams.keys());\n  }\n\n  /**\n   * Transform Strapi chat session response into ChatSession format\n   *\n   * @description\n   * Converts Strapi API response data to the application's ChatSession interface.\n   * Handles both Strapi v4 and v5 response formats for backward compatibility.\n   * Processes nested relations including skills array and agent object with their configurations.\n   * Maps planMode boolean to permissionMode 'plan' value for client consumption.\n   *\n   * @param strapiData - Raw Strapi API response containing session data\n   * @returns Normalized ChatSession object with populated skills and agent relations\n   *\n   * @private\n   */\n  private transformChatSession(strapiData: any): ChatSession {\n    const attrs = strapiData.attributes || strapiData;\n\n    // Handle skills - Strapi v5 returns direct array, v4 returned nested data array\n    let skills: any[] | undefined;\n    if (attrs.skills?.data) {\n      // Strapi v4 format\n      skills = attrs.skills.data.map((s: any) => ({\n        id: s.id,\n        documentId: s.documentId,\n        name: s.attributes?.name || s.name,\n      }));\n    } else if (Array.isArray(attrs.skills) && attrs.skills.length > 0) {\n      // Strapi v5 format - direct array\n      skills = attrs.skills.map((s: any) => ({\n        id: s.id,\n        documentId: s.documentId,\n        name: s.name,\n      }));\n    }\n\n    // Handle agent - Strapi v5 returns direct object, v4 returned nested data object\n    let agent: any | undefined;\n    if (attrs.agent?.data) {\n      // Strapi v4 format\n      agent = {\n        id: attrs.agent.data.id,\n        documentId: attrs.agent.data.documentId,\n        name: attrs.agent.data.attributes?.name || attrs.agent.data.name,\n        systemPrompt: attrs.agent.data.attributes?.systemPrompt || '',\n        toolConfig: attrs.agent.data.attributes?.toolConfig,\n        modelConfig: attrs.agent.data.attributes?.modelConfig,\n        mcpConfig: attrs.agent.data.attributes?.mcpConfig,\n      };\n    } else if (attrs.agent?.id) {\n      // Strapi v5 format - direct object\n      agent = {\n        id: attrs.agent.id,\n        documentId: attrs.agent.documentId,\n        name: attrs.agent.name,\n        systemPrompt: attrs.agent.systemPrompt || '',\n        toolConfig: attrs.agent.toolConfig,\n        modelConfig: attrs.agent.modelConfig,\n        mcpConfig: attrs.agent.mcpConfig,\n      };\n    }\n\n    // Map planMode boolean back to permissionMode: \"plan\" for client\n    const isPlanMode = attrs.planMode || false;\n    const effectivePermissionMode = isPlanMode ? 'plan' : (attrs.permissionMode || 'default');\n\n    return {\n      id: strapiData.id,\n      documentId: strapiData.documentId,\n      title: attrs.title,\n      status: attrs.status || 'active',\n      sessionId: attrs.sessionId || null,\n      skills,\n      agent,\n      customSystemPrompt: attrs.customSystemPrompt,\n      permissionMode: effectivePermissionMode as 'default' | 'bypass' | 'auto' | 'plan',\n      planMode: isPlanMode, // Keep for backwards compatibility\n      createdAt: attrs.createdAt,\n      updatedAt: attrs.updatedAt,\n      publishedAt: attrs.publishedAt,\n    };\n  }\n\n  /**\n   * Transform Strapi chat message response into ChatMessage format\n   *\n   * @description\n   * Converts Strapi API response data to the application's ChatMessage interface.\n   * Handles both Strapi v4 and v5 response formats for backward compatibility.\n   * Processes nested attachments relation and extracts file metadata (name, url, mime, size).\n   * Preserves message metadata and timestamp information.\n   *\n   * @param strapiData - Raw Strapi API response containing message data\n   * @returns Normalized ChatMessage object with populated attachments if present\n   *\n   * @private\n   */\n  private transformChatMessage(strapiData: any): ChatMessage {\n    const attrs = strapiData.attributes || strapiData;\n\n    return {\n      id: strapiData.id,\n      documentId: strapiData.documentId,\n      role: attrs.role,\n      content: attrs.content,\n      attachments: attrs.attachments?.data ? attrs.attachments.data.map((a: any) => ({\n        id: a.id,\n        documentId: a.documentId,\n        name: a.attributes?.name || a.name,\n        url: a.attributes?.url || a.url,\n        mime: a.attributes?.mime || a.mime,\n        size: a.attributes?.size || a.size,\n      })) : undefined,\n      metadata: attrs.metadata || {},\n      timestamp: attrs.timestamp,\n      createdAt: attrs.createdAt,\n      updatedAt: attrs.updatedAt,\n    };\n  }\n\n  /**\n   * Build MCP servers configuration from agent's mcpConfig\n   *\n   * @description\n   * Constructs MCP (Model Context Protocol) servers configuration by combining agent's server\n   * selection from Strapi with command/args details from .mcp.json file.\n   * The agent's mcpConfig defines which servers/tools to enable, while .mcp.json provides\n   * the actual server command and arguments needed to launch each MCP server process.\n   *\n   * @param mcpConfig - Array of MCP server configurations from agent's Strapi record\n   * @param workingDirectory - Directory path where .mcp.json is located\n   * @returns Promise resolving to MCP servers configuration object, or undefined if no valid servers\n   *\n   * @private\n   */\n  private async buildMcpServersFromAgentConfig(\n    mcpConfig: any[],\n    workingDirectory: string\n  ): Promise<Record<string, any> | undefined> {\n    if (!mcpConfig || !Array.isArray(mcpConfig) || mcpConfig.length === 0) {\n      this.logger.debug('No mcpConfig found in agent');\n      return undefined;\n    }\n\n    // Load base MCP configuration from .mcp.json\n    const baseMcpConfig = await this.loadMcpConfig(workingDirectory);\n\n    if (!baseMcpConfig) {\n      this.logger.warn('No .mcp.json found, cannot build MCP servers from agent config');\n      return undefined;\n    }\n\n    const mcpServers: Record<string, any> = {};\n\n    for (const config of mcpConfig) {\n      // Extract server name from relation\n      const serverName = typeof config.mcpServer === 'string'\n        ? config.mcpServer\n        : config.mcpServer?.name;\n\n      if (!serverName) {\n        this.logger.warn('MCP config entry missing server name', { config });\n        continue;\n      }\n\n      // Get command/args from .mcp.json\n      if (baseMcpConfig[serverName]) {\n        mcpServers[serverName] = baseMcpConfig[serverName];\n        this.logger.debug('Added MCP server from agent config', {\n          serverName,\n          selectedTools: config.selectedTools?.map((t: any) =>\n            typeof t.mcpTool === 'string' ? t.mcpTool : t.mcpTool?.name\n          ) || []\n        });\n      } else {\n        this.logger.warn('MCP server not found in .mcp.json', { serverName });\n      }\n    }\n\n    return Object.keys(mcpServers).length > 0 ? mcpServers : undefined;\n  }\n\n  /**\n   * Load MCP configuration from .mcp.json file\n   *\n   * @description\n   * Reads and parses the .mcp.json configuration file from the working directory.\n   * This file contains MCP server definitions with their command, arguments, and environment settings.\n   * Returns the mcpServers object which maps server names to their launch configurations.\n   * Gracefully handles missing or invalid .mcp.json files by returning undefined.\n   *\n   * @param workingDirectory - Directory path where .mcp.json should be located\n   * @returns Promise resolving to MCP servers configuration object from .mcp.json, or undefined if not found/invalid\n   *\n   * @private\n   */\n  private async loadMcpConfig(workingDirectory: string): Promise<Record<string, any> | undefined> {\n    try {\n      const mcpConfigPath = path.join(workingDirectory, '.mcp.json');\n      const content = await fs.readFile(mcpConfigPath, 'utf-8');\n      const config = JSON.parse(content);\n\n      if (config.mcpServers && typeof config.mcpServers === 'object') {\n        return config.mcpServers;\n      }\n\n      return undefined;\n    } catch (error) {\n      // .mcp.json not found or invalid - this is okay\n      this.logger.debug('No MCP config found', { workingDirectory, error: (error as Error).message });\n      return undefined;\n    }\n  }\n}\n\n// Export singleton instance\nexport const chatService = new ChatService();\n",
        "last_modified": "2026-01-02T14:06:15.755272"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.458081",
  "last_updated": "2026-01-02T14:06:15.469449"
}