{
  "file_path": "src/web/manager/services/chat-api.ts",
  "main_branch_history": [],
  "task_views": {
    "004-document-frontend-react-components-and-hooks": {
      "task_id": "004-document-frontend-react-components-and-hooks",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "/**\n * Chat API functions\n */\n\n// Express API base URL\n// @ts-ignore - Vite env variables are available at runtime\nconst EXPRESS_API = import.meta.env?.VITE_EXPRESS_URL || 'http://localhost:3001/api';\nconst CHAT_BASE = `${EXPRESS_API}/chat`;\n\n/**\n * Get auth token from cookie\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Create fetch options with auth header\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\nexport interface ChatSession {\n  id: number;\n  documentId: string;\n  title: string;\n  status: 'active' | 'archived';\n  sessionId: string | null;\n  skills?: {\n    id: number;\n    documentId: string;\n    name: string;\n  }[];\n  agent?: {\n    id: number;\n    documentId: string;\n    name: string;\n    systemPrompt: string;\n    toolConfig?: {\n      allowedTools?: string[];\n    };\n    modelConfig?: {\n      model?: string;\n    };\n  };\n  customSystemPrompt?: string;\n  permissionMode: 'default' | 'bypass' | 'auto' | 'plan';\n  planMode: boolean; // Legacy field for backwards compatibility\n  createdAt: string;\n  updatedAt: string;\n  publishedAt?: string;\n}\n\nexport interface ChatMessage {\n  id: number;\n  documentId: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  attachments?: {\n    id: number;\n    documentId: string;\n    name: string;\n    url: string;\n    mime: string;\n    size: number;\n  }[];\n  metadata?: {\n    toolUses?: any[];\n    cost?: number;\n    usage?: {\n      input_tokens: number;\n      output_tokens: number;\n      cache_creation_input_tokens?: number;\n      cache_read_input_tokens?: number;\n    };\n    duration?: number;\n  };\n  timestamp: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface ChatAttachment {\n  name: string;\n  mimeType: string;\n  data: string; // base64\n}\n\n/**\n * Create a new chat session\n */\nexport async function createChatSession(\n  title: string,\n  skillIds: string[],\n  directory?: string,\n  permissionMode?: 'default' | 'bypass' | 'auto' | 'plan',\n  agentId?: string,\n  customSystemPrompt?: string\n): Promise<ChatSession> {\n  const params = new URLSearchParams();\n  if (directory) {\n    params.append('workingDirectory', directory);\n  }\n\n  const response = await fetch(`${CHAT_BASE}/sessions?${params.toString()}`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      title,\n      skillIds,\n      agentId,\n      customSystemPrompt,\n      permissionMode: permissionMode || 'default'\n    }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create chat session');\n  }\n\n  const data = await response.json();\n  return data.session;\n}\n\n/**\n * Get all chat sessions\n */\nexport async function getChatSessions(): Promise<ChatSession[]> {\n  const response = await fetch(`${CHAT_BASE}/sessions`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get chat sessions');\n  }\n\n  const data = await response.json();\n  return data.sessions;\n}\n\n/**\n * Get single chat session\n */\nexport async function getChatSession(sessionId: string): Promise<ChatSession> {\n  const response = await fetch(`${CHAT_BASE}/sessions/${sessionId}`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get chat session');\n  }\n\n  const data = await response.json();\n  return data.session;\n}\n\n/**\n * Delete chat session\n */\nexport async function deleteChatSession(sessionId: string): Promise<void> {\n  const response = await fetch(`${CHAT_BASE}/sessions/${sessionId}`, createFetchOptions({\n    method: 'DELETE',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to delete chat session');\n  }\n}\n\n/**\n * Archive chat session\n */\nexport async function archiveChatSession(sessionId: string): Promise<ChatSession> {\n  const response = await fetch(`${CHAT_BASE}/sessions/${sessionId}/archive`, createFetchOptions({\n    method: 'POST',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to archive chat session');\n  }\n\n  const data = await response.json();\n  return data.session;\n}\n\n/**\n * Get messages for chat session\n */\nexport async function getChatMessages(sessionId: string): Promise<ChatMessage[]> {\n  const response = await fetch(`${CHAT_BASE}/sessions/${sessionId}/messages`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get chat messages');\n  }\n\n  const data = await response.json();\n  return data.messages;\n}\n\n/**\n * Send message to chat session (SSE streaming)\n */\nexport function sendChatMessage(\n  sessionId: string,\n  message: string,\n  attachments: ChatAttachment[],\n  directory?: string,\n  permissionMode?: 'default' | 'bypass' | 'auto' | 'plan',\n  agentId?: string,\n  skillIds?: string[]\n): EventSource {\n  const params = new URLSearchParams();\n  if (directory) {\n    params.append('workingDirectory', directory);\n  }\n\n  const url = `${CHAT_BASE}/sessions/${sessionId}/messages?${params.toString()}`;\n\n  // Create a custom EventSource-like object\n  const eventTarget = new EventTarget();\n  const eventSource = Object.assign(eventTarget, {\n    close: () => {},\n    readyState: 0,\n    url: url,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n  }) as EventSource;\n\n  fetch(url, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      message,\n      attachments,\n      agentId,\n      skillIds,\n      permissionMode\n    }),\n  }))\n    .then(async (response) => {\n      if (!response.ok) {\n        const error = await response.json();\n        const errorEvent = new MessageEvent('error', {\n          data: JSON.stringify({ type: 'error', error: error.error || 'Failed to send message' }),\n        });\n        eventSource.dispatchEvent(errorEvent);\n        return;\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('No response body');\n      }\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            if (data.trim()) {\n              const messageEvent = new MessageEvent('message', { data });\n              eventSource.dispatchEvent(messageEvent);\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      const errorEvent = new MessageEvent('error', {\n        data: JSON.stringify({ type: 'error', error: error.message }),\n      });\n      eventSource.dispatchEvent(errorEvent);\n    });\n\n  return eventSource as EventSource;\n}\n\n/**\n * Convert file to base64\n */\nexport function fileToBase64(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const base64 = (reader.result as string).split(',')[1];\n      resolve(base64);\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * Get all available agents\n */\nexport async function getAgents(): Promise<{\n  id: number;\n  documentId: string;\n  name: string;\n  description?: string;\n  modelConfig?: { model?: string };\n}[]> {\n  const response = await fetch(`${EXPRESS_API}/agents`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get agents');\n  }\n\n  const data = await response.json();\n  return data.agents;\n}\n\n/**\n * Get all available skills\n */\nexport async function getSkills(): Promise<{\n  id: number;\n  documentId: string;\n  name: string;\n  displayName?: string;\n  description?: string;\n}[]> {\n  const response = await fetch(`${EXPRESS_API}/skills`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get skills');\n  }\n\n  const data = await response.json();\n  return data.skills;\n}\n\n/**\n * Cancel an active message stream\n */\nexport async function cancelMessage(\n  sessionId: string,\n  streamId: string\n): Promise<{ success: boolean; message: string }> {\n  const response = await fetch(\n    `${CHAT_BASE}/sessions/${sessionId}/messages/${streamId}/cancel`,\n    createFetchOptions({\n      method: 'POST',\n    })\n  );\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to cancel message');\n  }\n\n  return response.json();\n}\n",
        "timestamp": "2026-01-02T14:22:14.293924"
      },
      "worktree_state": {
        "content": "/**\n * Chat API service for Manager frontend\n *\n * Provides functions for managing chat sessions, sending messages,\n * and handling real-time streaming responses via Server-Sent Events (SSE).\n *\n * Chat sessions can be configured with:\n * - Agent-based chats (uses agent's system prompt and tools)\n * - Skill-based chats (custom system prompt with selected skills)\n * - Custom system prompts with permission modes\n */\n\n// Express API base URL\n// @ts-ignore - Vite env variables are available at runtime\nconst EXPRESS_API = import.meta.env?.VITE_EXPRESS_URL || 'http://localhost:3001/api';\nconst CHAT_BASE = `${EXPRESS_API}/chat`;\n\n/**\n * Retrieves the authentication token from browser cookies.\n *\n * Looks for the 'cui-auth-token' cookie and returns its decoded value.\n * This token is used to authenticate API requests to the backend.\n *\n * @returns The decoded auth token string if found, null otherwise\n *\n * @example\n * const token = getAuthToken();\n * if (token) {\n *   // Use token for authenticated requests\n * }\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Creates fetch options with authentication header.\n *\n * Merges provided options with an Authorization header containing the Bearer token\n * from the authentication cookie. Used internally for all authenticated API requests.\n *\n * @param options - Optional fetch configuration to merge with auth headers\n * @returns RequestInit object with auth header added\n *\n * @example\n * const options = createFetchOptions({\n *   method: 'POST',\n *   body: JSON.stringify({ data: 'value' })\n * });\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\n/**\n * Chat session configuration and state\n *\n * Represents a persistent chat session that can be either agent-based or skill-based.\n * Sessions maintain conversation history, configuration, and status.\n */\nexport interface ChatSession {\n  id: number;\n  documentId: string;\n  title: string;\n  status: 'active' | 'archived';\n  sessionId: string | null;\n  skills?: {\n    id: number;\n    documentId: string;\n    name: string;\n  }[];\n  agent?: {\n    id: number;\n    documentId: string;\n    name: string;\n    systemPrompt: string;\n    toolConfig?: {\n      allowedTools?: string[];\n    };\n    modelConfig?: {\n      model?: string;\n    };\n  };\n  customSystemPrompt?: string;\n  permissionMode: 'default' | 'bypass' | 'auto' | 'plan';\n  planMode: boolean; // Legacy field for backwards compatibility\n  createdAt: string;\n  updatedAt: string;\n  publishedAt?: string;\n}\n\n/**\n * Chat message with content, metadata, and attachments\n *\n * Represents a single message in a chat session from either the user or assistant.\n * Includes token usage, cost tracking, tool uses, and attached files.\n */\nexport interface ChatMessage {\n  id: number;\n  documentId: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  attachments?: {\n    id: number;\n    documentId: string;\n    name: string;\n    url: string;\n    mime: string;\n    size: number;\n  }[];\n  metadata?: {\n    toolUses?: any[];\n    cost?: number;\n    usage?: {\n      input_tokens: number;\n      output_tokens: number;\n      cache_creation_input_tokens?: number;\n      cache_read_input_tokens?: number;\n    };\n    duration?: number;\n  };\n  timestamp: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * File attachment for chat messages\n *\n * Represents a file attached to a user message, with base64-encoded content.\n * Supports various file types including images, documents, and code files.\n */\nexport interface ChatAttachment {\n  name: string;\n  mimeType: string;\n  data: string; // base64\n}\n\n/**\n * Creates a new chat session with specified configuration.\n *\n * Creates a session that can be either agent-based (using a predefined agent) or\n * skill-based (using custom system prompt with selected skills). Sessions persist\n * conversation history and maintain state across multiple messages.\n *\n * @param title - Descriptive title for the chat session\n * @param skillIds - Array of skill document IDs to enable in this session\n * @param directory - Optional working directory for agent/skill execution\n * @param permissionMode - Permission handling mode ('default', 'bypass', 'auto', 'plan')\n * @param agentId - Optional agent document ID to use for this session\n * @param customSystemPrompt - Optional custom system prompt (overrides agent's prompt)\n * @returns Promise resolving to the created chat session\n * @throws Error if creation fails or validation errors occur\n *\n * @example\n * // Create skill-based chat session\n * const session = await createChatSession(\n *   'Debug Session',\n *   ['skill-1', 'skill-2'],\n *   '/path/to/project',\n *   'default'\n * );\n *\n * @example\n * // Create agent-based chat session\n * const session = await createChatSession(\n *   'Code Review',\n *   [],\n *   '/path/to/project',\n *   'default',\n *   'agent-123'\n * );\n */\nexport async function createChatSession(\n  title: string,\n  skillIds: string[],\n  directory?: string,\n  permissionMode?: 'default' | 'bypass' | 'auto' | 'plan',\n  agentId?: string,\n  customSystemPrompt?: string\n): Promise<ChatSession> {\n  const params = new URLSearchParams();\n  if (directory) {\n    params.append('workingDirectory', directory);\n  }\n\n  const response = await fetch(`${CHAT_BASE}/sessions?${params.toString()}`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      title,\n      skillIds,\n      agentId,\n      customSystemPrompt,\n      permissionMode: permissionMode || 'default'\n    }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create chat session');\n  }\n\n  const data = await response.json();\n  return data.session;\n}\n\n/**\n * Retrieves all chat sessions for the current user.\n *\n * Fetches all chat sessions including both active and archived sessions.\n * Sessions are ordered by creation date with newest first.\n *\n * @returns Promise resolving to array of chat session objects\n * @throws Error if the API request fails\n *\n * @example\n * const sessions = await getChatSessions();\n * const activeSessions = sessions.filter(s => s.status === 'active');\n * console.log(`You have ${activeSessions.length} active chats`);\n */\nexport async function getChatSessions(): Promise<ChatSession[]> {\n  const response = await fetch(`${CHAT_BASE}/sessions`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get chat sessions');\n  }\n\n  const data = await response.json();\n  return data.sessions;\n}\n\n/**\n * Retrieves a specific chat session by ID.\n *\n * Fetches complete session details including configuration, agent/skill\n * associations, and metadata.\n *\n * @param sessionId - Chat session document ID (Strapi documentId)\n * @returns Promise resolving to chat session object\n * @throws Error if session not found or request fails\n *\n * @example\n * const session = await getChatSession('session-123');\n * console.log(session.title);\n * console.log(`Permission mode: ${session.permissionMode}`);\n */\nexport async function getChatSession(sessionId: string): Promise<ChatSession> {\n  const response = await fetch(`${CHAT_BASE}/sessions/${sessionId}`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get chat session');\n  }\n\n  const data = await response.json();\n  return data.session;\n}\n\n/**\n * Deletes a chat session and all associated messages.\n *\n * Permanently removes the session and its entire conversation history from the database.\n * This action cannot be undone. Consider archiving instead if you want to preserve history.\n *\n * @param sessionId - Chat session document ID (Strapi documentId)\n * @returns Promise that resolves when deletion completes\n * @throws Error if deletion fails or session not found\n *\n * @example\n * await deleteChatSession('session-123');\n * console.log('Session deleted');\n */\nexport async function deleteChatSession(sessionId: string): Promise<void> {\n  const response = await fetch(`${CHAT_BASE}/sessions/${sessionId}`, createFetchOptions({\n    method: 'DELETE',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to delete chat session');\n  }\n}\n\n/**\n * Archives a chat session to hide it from the active list.\n *\n * Changes the session status to 'archived' while preserving all conversation history.\n * Archived sessions can still be accessed but won't appear in the default session list.\n *\n * @param sessionId - Chat session document ID (Strapi documentId)\n * @returns Promise resolving to the updated chat session\n * @throws Error if archiving fails or session not found\n *\n * @example\n * const archivedSession = await archiveChatSession('session-123');\n * console.log(archivedSession.status); // 'archived'\n */\nexport async function archiveChatSession(sessionId: string): Promise<ChatSession> {\n  const response = await fetch(`${CHAT_BASE}/sessions/${sessionId}/archive`, createFetchOptions({\n    method: 'POST',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to archive chat session');\n  }\n\n  const data = await response.json();\n  return data.session;\n}\n\n/**\n * Retrieves all messages for a specific chat session.\n *\n * Fetches the complete conversation history for the session, including user messages,\n * assistant responses, attachments, and metadata like token usage and costs.\n *\n * @param sessionId - Chat session document ID (Strapi documentId)\n * @returns Promise resolving to array of chat messages ordered by timestamp\n * @throws Error if request fails or session not found\n *\n * @example\n * const messages = await getChatMessages('session-123');\n * messages.forEach(msg => {\n *   console.log(`${msg.role}: ${msg.content.substring(0, 50)}...`);\n *   if (msg.metadata?.usage) {\n *     console.log(`Tokens: ${msg.metadata.usage.input_tokens + msg.metadata.usage.output_tokens}`);\n *   }\n * });\n */\nexport async function getChatMessages(sessionId: string): Promise<ChatMessage[]> {\n  const response = await fetch(`${CHAT_BASE}/sessions/${sessionId}/messages`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get chat messages');\n  }\n\n  const data = await response.json();\n  return data.messages;\n}\n\n/**\n * Sends a message to a chat session with streaming Server-Sent Events (SSE) response.\n *\n * Sends a user message and streams the assistant's response in real-time via SSE.\n * The response includes status updates, content chunks, tool usage, and completion events.\n * Returns an EventSource-like object for handling streaming events.\n *\n * @param sessionId - Chat session document ID (Strapi documentId)\n * @param message - User's message text content\n * @param attachments - Array of file attachments (images, documents, etc.)\n * @param directory - Optional working directory for agent/skill execution\n * @param permissionMode - Permission handling mode ('default', 'bypass', 'auto', 'plan')\n * @param agentId - Optional agent document ID (can be changed per message)\n * @param skillIds - Optional skill document IDs (can be changed per message)\n * @returns EventSource object for handling streaming events\n *\n * @example\n * const eventSource = sendChatMessage(\n *   'session-123',\n *   'Analyze this code',\n *   [],\n *   '/path/to/project'\n * );\n *\n * eventSource.addEventListener('message', (e) => {\n *   const data = JSON.parse(e.data);\n *   if (data.type === 'content') {\n *     console.log(data.content);\n *   } else if (data.type === 'complete') {\n *     console.log('Response complete');\n *     eventSource.close();\n *   }\n * });\n *\n * eventSource.addEventListener('error', (e) => {\n *   const data = JSON.parse(e.data);\n *   console.error('Error:', data.error);\n * });\n */\nexport function sendChatMessage(\n  sessionId: string,\n  message: string,\n  attachments: ChatAttachment[],\n  directory?: string,\n  permissionMode?: 'default' | 'bypass' | 'auto' | 'plan',\n  agentId?: string,\n  skillIds?: string[]\n): EventSource {\n  const params = new URLSearchParams();\n  if (directory) {\n    params.append('workingDirectory', directory);\n  }\n\n  const url = `${CHAT_BASE}/sessions/${sessionId}/messages?${params.toString()}`;\n\n  // Create a custom EventSource-like object\n  const eventTarget = new EventTarget();\n  const eventSource = Object.assign(eventTarget, {\n    close: () => {},\n    readyState: 0,\n    url: url,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n  }) as EventSource;\n\n  fetch(url, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      message,\n      attachments,\n      agentId,\n      skillIds,\n      permissionMode\n    }),\n  }))\n    .then(async (response) => {\n      if (!response.ok) {\n        const error = await response.json();\n        const errorEvent = new MessageEvent('error', {\n          data: JSON.stringify({ type: 'error', error: error.error || 'Failed to send message' }),\n        });\n        eventSource.dispatchEvent(errorEvent);\n        return;\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('No response body');\n      }\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            if (data.trim()) {\n              const messageEvent = new MessageEvent('message', { data });\n              eventSource.dispatchEvent(messageEvent);\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      const errorEvent = new MessageEvent('error', {\n        data: JSON.stringify({ type: 'error', error: error.message }),\n      });\n      eventSource.dispatchEvent(errorEvent);\n    });\n\n  return eventSource as EventSource;\n}\n\n/**\n * Converts a File object to base64-encoded string.\n *\n * Reads a file and returns its base64-encoded content without the data URI prefix.\n * Used to prepare files for attachment to chat messages.\n *\n * @param file - File object to convert\n * @returns Promise resolving to base64-encoded file content (without data URI prefix)\n * @throws Error if file reading fails\n *\n * @example\n * const fileInput = document.querySelector('input[type=\"file\"]');\n * const file = fileInput.files[0];\n * const base64 = await fileToBase64(file);\n * const attachment = {\n *   name: file.name,\n *   mimeType: file.type,\n *   data: base64\n * };\n */\nexport function fileToBase64(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const base64 = (reader.result as string).split(',')[1];\n      resolve(base64);\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * Retrieves all available agents for chat sessions.\n *\n * Fetches a simplified list of agents that can be used in chat sessions.\n * Returns basic agent information including ID, name, description, and model.\n *\n * @returns Promise resolving to array of agent objects with basic information\n * @throws Error if the API request fails\n *\n * @example\n * const agents = await getAgents();\n * agents.forEach(agent => {\n *   console.log(`${agent.name}: ${agent.description}`);\n *   console.log(`Model: ${agent.modelConfig?.model || 'default'}`);\n * });\n */\nexport async function getAgents(): Promise<{\n  id: number;\n  documentId: string;\n  name: string;\n  description?: string;\n  modelConfig?: { model?: string };\n}[]> {\n  const response = await fetch(`${EXPRESS_API}/agents`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get agents');\n  }\n\n  const data = await response.json();\n  return data.agents;\n}\n\n/**\n * Retrieves all available skills for chat sessions.\n *\n * Fetches a simplified list of skills that can be used in chat sessions.\n * Returns basic skill information including ID, name, display name, and description.\n *\n * @returns Promise resolving to array of skill objects with basic information\n * @throws Error if the API request fails\n *\n * @example\n * const skills = await getSkills();\n * skills.forEach(skill => {\n *   console.log(`${skill.displayName || skill.name}: ${skill.description}`);\n * });\n */\nexport async function getSkills(): Promise<{\n  id: number;\n  documentId: string;\n  name: string;\n  displayName?: string;\n  description?: string;\n}[]> {\n  const response = await fetch(`${EXPRESS_API}/skills`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get skills');\n  }\n\n  const data = await response.json();\n  return data.skills;\n}\n\n/**\n * Cancels an active streaming message response.\n *\n * Sends a cancellation request to stop an ongoing message stream. This is useful\n * when the user wants to interrupt a long-running response or when switching contexts.\n *\n * @param sessionId - Chat session document ID (Strapi documentId)\n * @param streamId - Unique identifier for the active stream to cancel\n * @returns Promise resolving to cancellation result with success status and message\n * @throws Error if cancellation fails or stream not found\n *\n * @example\n * const result = await cancelMessage('session-123', 'stream-456');\n * if (result.success) {\n *   console.log('Message cancelled:', result.message);\n * }\n */\nexport async function cancelMessage(\n  sessionId: string,\n  streamId: string\n): Promise<{ success: boolean; message: string }> {\n  const response = await fetch(\n    `${CHAT_BASE}/sessions/${sessionId}/messages/${streamId}/cancel`,\n    createFetchOptions({\n      method: 'POST',\n    })\n  );\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to cancel message');\n  }\n\n  return response.json();\n}\n",
        "last_modified": "2026-01-02T14:22:15.595925"
      },
      "task_intent": {
        "title": "Document Frontend React Components and Hooks",
        "description": "Add comprehensive JSDoc documentation to all React components and custom hooks in the frontend, including prop types, usage examples, component purposes, state management, and side effects.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:22:15.471111",
  "last_updated": "2026-01-02T14:22:15.487049"
}