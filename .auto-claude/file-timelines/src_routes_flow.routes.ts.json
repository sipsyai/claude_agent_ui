{
  "file_path": "src/routes/flow.routes.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": {
        "content": "/**\n * Flow Routes - REST API for Flow Management and Execution\n *\n * Provides endpoints for:\n * - Flow CRUD operations (proxied to Strapi)\n * - Flow execution (start, stop, monitor)\n * - Server-Sent Events (SSE) streaming for real-time execution updates\n *\n * @see src/services/flow-execution-service.ts for execution logic\n * @see src/types/flow-types.ts for type definitions\n */\n\nimport { Router, Request, Response } from 'express';\nimport { strapiClient } from '../services/strapi-client.js';\nimport { flowExecutionService } from '../services/flow-execution-service.js';\nimport { createLogger } from '../services/logger.js';\nimport { asyncHandler, AppError } from '../middleware/error-handler.js';\nimport type { FlowExecutionUpdate } from '../types/flow-types.js';\nimport {\n  getAllTemplates,\n  getTemplateById,\n  getTemplatesByCategory,\n  searchTemplates,\n  createFlowFromTemplate,\n} from '../services/flow-templates.js';\n\n// Import validation schemas\nimport {\n  flowIdSchema,\n  executionIdSchema,\n  flowQuerySchema,\n  createFlowSchema,\n  updateFlowSchema,\n  startFlowExecutionSchema,\n  executionQuerySchema,\n} from '../validators/flow.validators.js';\n\n// ============= SSE HELPER CLASS =============\n\n/**\n * SSE Stream helper for flow execution updates\n */\nclass FlowSSEStream {\n  private keepAliveInterval: NodeJS.Timeout | null = null;\n  private isClosed = false;\n\n  constructor(private res: Response) {\n    // Set SSE headers\n    this.res.setHeader('Content-Type', 'text/event-stream');\n    this.res.setHeader('Cache-Control', 'no-cache, no-transform');\n    this.res.setHeader('Connection', 'keep-alive');\n    this.res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering\n\n    // Send initial connection comment\n    this.res.write(': SSE stream initialized\\n\\n');\n    this.res.flushHeaders();\n  }\n\n  /**\n   * Send a named SSE event with data\n   */\n  send(event: string, data: any): void {\n    if (this.isClosed) return;\n    this.res.write(`event: ${event}\\n`);\n    this.res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n  }\n\n  /**\n   * Send SSE data without event name\n   */\n  sendData(data: any): void {\n    if (this.isClosed) return;\n    this.res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n  }\n\n  /**\n   * Send SSE comment (for keep-alive)\n   */\n  sendComment(comment: string): void {\n    if (this.isClosed) return;\n    this.res.write(`: ${comment}\\n\\n`);\n  }\n\n  /**\n   * Close the SSE stream\n   */\n  close(): void {\n    if (this.isClosed) return;\n    this.isClosed = true;\n    if (this.keepAliveInterval) {\n      clearInterval(this.keepAliveInterval);\n      this.keepAliveInterval = null;\n    }\n    this.res.end();\n  }\n\n  /**\n   * Check if stream is closed\n   */\n  isStreamClosed(): boolean {\n    return this.isClosed;\n  }\n\n  /**\n   * Start keep-alive ping every 30 seconds\n   */\n  startKeepAlive(): void {\n    this.keepAliveInterval = setInterval(() => {\n      this.sendComment('keep-alive');\n    }, 30000);\n  }\n\n  /**\n   * Stop keep-alive ping\n   */\n  stopKeepAlive(): void {\n    if (this.keepAliveInterval) {\n      clearInterval(this.keepAliveInterval);\n      this.keepAliveInterval = null;\n    }\n  }\n}\n\n// ============= ROUTE FACTORY =============\n\nexport function createFlowRoutes(): Router {\n  const router = Router();\n  const logger = createLogger('FlowRoutes');\n\n  // ============= FLOW CRUD OPERATIONS =============\n\n  /**\n   * GET /api/flows\n   * List all flows with optional filtering, sorting, and pagination\n   */\n  router.get('/', asyncHandler(async (req: Request, res: Response) => {\n    const query = flowQuerySchema.parse(req.query);\n\n    logger.debug('Fetching flows', { query });\n\n    const filters: any = {};\n\n    if (query.status) {\n      filters.status = query.status;\n    }\n\n    if (query.category) {\n      filters.category = query.category;\n    }\n\n    if (query.isActive !== undefined) {\n      filters.isActive = query.isActive;\n    }\n\n    if (query.search) {\n      filters.$or = [\n        { name: { $containsi: query.search } },\n        { description: { $containsi: query.search } }\n      ];\n    }\n\n    const flows = await strapiClient.getAllFlows({\n      filters,\n      sort: [query.sort],\n      pagination: {\n        page: query.page,\n        pageSize: query.pageSize\n      }\n    });\n\n    res.json({\n      data: flows,\n      meta: {\n        page: query.page,\n        pageSize: query.pageSize,\n        total: flows.length\n      }\n    });\n  }));\n\n  // ============= FLOW TEMPLATES (must come before :id routes) =============\n\n  /**\n   * GET /api/flows/templates\n   * Get all available flow templates\n   */\n  router.get('/templates', asyncHandler(async (_req: Request, res: Response) => {\n    logger.debug('Fetching flow templates');\n\n    const templates = getAllTemplates();\n\n    res.json({\n      data: templates.map(t => ({\n        templateId: t.templateId,\n        name: t.name,\n        description: t.description,\n        category: t.category,\n        icon: t.icon,\n        tags: t.tags,\n      })),\n      count: templates.length\n    });\n  }));\n\n  /**\n   * GET /api/flows/templates/search\n   * Search templates by query (must come before /templates/:templateId)\n   */\n  router.get('/templates/search', asyncHandler(async (req: Request, res: Response) => {\n    const query = (req.query.q as string) || '';\n\n    logger.debug('Searching flow templates', { query });\n\n    const templates = searchTemplates(query);\n\n    res.json({\n      data: templates.map(t => ({\n        templateId: t.templateId,\n        name: t.name,\n        description: t.description,\n        category: t.category,\n        icon: t.icon,\n        tags: t.tags,\n      })),\n      count: templates.length\n    });\n  }));\n\n  /**\n   * GET /api/flows/templates/category/:category\n   * Get templates by category\n   */\n  router.get('/templates/category/:category', asyncHandler(async (req: Request, res: Response) => {\n    const category = req.params.category as any;\n\n    logger.debug('Fetching flow templates by category', { category });\n\n    const templates = getTemplatesByCategory(category);\n\n    res.json({\n      data: templates.map(t => ({\n        templateId: t.templateId,\n        name: t.name,\n        description: t.description,\n        category: t.category,\n        icon: t.icon,\n        tags: t.tags,\n      })),\n      count: templates.length\n    });\n  }));\n\n  /**\n   * GET /api/flows/templates/:templateId\n   * Get a specific template by ID\n   */\n  router.get('/templates/:templateId', asyncHandler(async (req: Request, res: Response) => {\n    const { templateId } = req.params;\n\n    logger.debug('Fetching flow template', { templateId });\n\n    const template = getTemplateById(templateId);\n\n    if (!template) {\n      throw new AppError(404, 'Template not found');\n    }\n\n    res.json({\n      templateId: template.templateId,\n      name: template.name,\n      description: template.description,\n      category: template.category,\n      icon: template.icon,\n      tags: template.tags,\n      flowData: template.flowData,\n    });\n  }));\n\n  /**\n   * POST /api/flows/templates/:templateId/create\n   * Create a new flow from a template\n   */\n  router.post('/templates/:templateId/create', asyncHandler(async (req: Request, res: Response) => {\n    const { templateId } = req.params;\n    const { name: customName } = req.body;\n\n    logger.info('Creating flow from template', { templateId, customName });\n\n    const flowData = createFlowFromTemplate(templateId);\n\n    if (!flowData) {\n      throw new AppError(404, 'Template not found');\n    }\n\n    // Apply custom name if provided\n    if (customName) {\n      flowData.name = customName;\n      flowData.slug = customName\n        .toLowerCase()\n        .replace(/[^a-z0-9\\s-]/g, '')\n        .replace(/\\s+/g, '-')\n        .replace(/-+/g, '-')\n        .substring(0, 50) + '-' + Date.now();\n    }\n\n    // Create the flow in Strapi\n    const flow = await strapiClient.createFlow(flowData);\n\n    res.status(201).json({\n      success: true,\n      flow,\n      message: `Flow \"${flow.name}\" created from template \"${templateId}\"`\n    });\n  }));\n\n  // ============= FLOW CRUD BY ID =============\n\n  /**\n   * GET /api/flows/:id\n   * Get a single flow by ID\n   */\n  router.get('/:id', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = flowIdSchema.parse(req.params);\n\n    logger.debug('Fetching flow', { id });\n\n    const flow = await strapiClient.getFlow(id);\n\n    if (!flow) {\n      throw new AppError(404, 'Flow not found');\n    }\n\n    res.json(flow);\n  }));\n\n  /**\n   * POST /api/flows\n   * Create a new flow\n   */\n  router.post('/', asyncHandler(async (req: Request, res: Response) => {\n    const validated = createFlowSchema.parse(req.body);\n\n    logger.info('Creating flow', { name: validated.name });\n\n    const flow = await strapiClient.createFlow(validated);\n\n    res.status(201).json({\n      success: true,\n      flow,\n      message: `Flow \"${flow.name}\" created successfully`\n    });\n  }));\n\n  /**\n   * PUT /api/flows/:id\n   * Update an existing flow\n   */\n  router.put('/:id', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = flowIdSchema.parse(req.params);\n    const validated = updateFlowSchema.parse(req.body);\n\n    logger.info('Updating flow', { id, updates: Object.keys(validated) });\n\n    const flow = await strapiClient.updateFlow(id, validated);\n\n    res.json({\n      success: true,\n      flow,\n      message: `Flow \"${flow.name}\" updated successfully`\n    });\n  }));\n\n  /**\n   * DELETE /api/flows/:id\n   * Delete a flow\n   */\n  router.delete('/:id', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = flowIdSchema.parse(req.params);\n\n    logger.info('Deleting flow', { id });\n\n    await strapiClient.deleteFlow(id);\n\n    res.status(204).send();\n  }));\n\n  // ============= FLOW EXECUTION ENDPOINTS =============\n\n  /**\n   * POST /api/flows/:id/execute\n   * Start a flow execution with SSE streaming for real-time updates\n   */\n  router.post('/:id/execute', async (req: Request, res: Response) => {\n    let stream: FlowSSEStream | null = null;\n\n    try {\n      const { id: flowId } = flowIdSchema.parse(req.params);\n      const body = startFlowExecutionSchema.parse(req.body);\n\n      logger.info('Flow execution requested', { flowId, triggeredBy: body.triggeredBy });\n\n      // 1. Verify flow exists and is active\n      const flow = await strapiClient.getFlow(flowId);\n\n      if (!flow) {\n        throw new AppError(404, 'Flow not found');\n      }\n\n      if (!flow.isActive) {\n        throw new AppError(403, 'Flow is not active. Please activate it before execution.');\n      }\n\n      // 2. Initialize SSE stream\n      stream = new FlowSSEStream(res);\n      stream.startKeepAlive();\n\n      // 3. Send initial status\n      stream.sendData({\n        type: 'status',\n        status: 'starting',\n        message: `Starting flow: ${flow.name}`,\n        flowId,\n        flowName: flow.name,\n        timestamp: new Date().toISOString()\n      });\n\n      // 4. Handle client disconnect\n      req.on('close', async () => {\n        logger.info('Client disconnected from flow execution', { flowId });\n\n        // If we have an active execution, we could cancel it here\n        // For now, just cleanup the stream\n        if (stream) {\n          stream.stopKeepAlive();\n          stream.close();\n        }\n      });\n\n      // 5. Set up execution update listener\n      const updateHandler = (update: FlowExecutionUpdate) => {\n        if (stream && !stream.isStreamClosed()) {\n          logger.debug('Sending execution update', { type: update.type, executionId: update.executionId });\n\n          stream.send(update.type, {\n            executionId: update.executionId,\n            type: update.type,\n            nodeId: update.nodeId,\n            nodeType: update.nodeType,\n            timestamp: update.timestamp,\n            data: update.data\n          });\n\n          // Close stream on terminal states\n          if (['execution_completed', 'execution_failed', 'execution_cancelled'].includes(update.type)) {\n            setTimeout(() => {\n              if (stream) {\n                stream.stopKeepAlive();\n                stream.close();\n              }\n            }, 100); // Small delay to ensure message is sent\n          }\n        }\n      };\n\n      // Register the update handler\n      flowExecutionService.on('execution-update', updateHandler);\n\n      // 6. Start the flow execution\n      try {\n        const result = await flowExecutionService.startExecution({\n          flowId,\n          input: body.input,\n          triggeredBy: body.triggeredBy,\n          triggerData: body.triggerData,\n        });\n\n        logger.info('Flow execution completed', {\n          flowId,\n          executionId: result.executionId,\n          success: result.success,\n          executionTime: result.executionTime\n        });\n\n        // Send final result\n        if (stream && !stream.isStreamClosed()) {\n          stream.sendData({\n            type: 'result',\n            result: {\n              executionId: result.executionId,\n              success: result.success,\n              status: result.status,\n              output: result.output,\n              error: result.error,\n              executionTime: result.executionTime,\n              tokensUsed: result.tokensUsed,\n              cost: result.cost,\n              nodeExecutions: result.nodeExecutions\n            },\n            timestamp: new Date().toISOString()\n          });\n        }\n\n      } catch (execError) {\n        logger.error('Flow execution error', execError as Error, { flowId });\n\n        if (stream && !stream.isStreamClosed()) {\n          stream.sendData({\n            type: 'error',\n            error: execError instanceof Error ? execError.message : String(execError),\n            timestamp: new Date().toISOString()\n          });\n        }\n      } finally {\n        // Cleanup\n        flowExecutionService.off('execution-update', updateHandler);\n\n        if (stream) {\n          stream.stopKeepAlive();\n          if (!stream.isStreamClosed()) {\n            stream.close();\n          }\n        }\n      }\n\n    } catch (error: any) {\n      logger.error('Flow execution request error', error);\n\n      // If headers already sent, send error via SSE\n      if (res.headersSent && stream) {\n        stream.sendData({\n          type: 'error',\n          message: error?.message || 'Unknown error',\n          errorType: error?.constructor?.name || 'Error',\n          timestamp: new Date().toISOString()\n        });\n        stream.stopKeepAlive();\n        stream.close();\n      } else {\n        // Otherwise send JSON error\n        const statusCode = error instanceof AppError ? error.statusCode : 500;\n        res.status(statusCode).json({\n          error: error?.message || 'Unknown error',\n          type: error?.constructor?.name || 'Error'\n        });\n      }\n    }\n  });\n\n  /**\n   * GET /api/flows/executions/running\n   * Get all currently running executions\n   * NOTE: This route must come BEFORE /executions/:id to avoid path conflict\n   */\n  router.get('/executions/running', asyncHandler(async (req: Request, res: Response) => {\n    logger.debug('Fetching running executions');\n\n    // Get running execution IDs from the service (in-memory)\n    const activeIds = flowExecutionService.getActiveExecutionIds();\n\n    // Also fetch from Strapi for persistent record\n    const strapiRunning = await strapiClient.getRunningFlowExecutions();\n\n    res.json({\n      active: activeIds,\n      executions: strapiRunning,\n      count: strapiRunning.length\n    });\n  }));\n\n  /**\n   * GET /api/flows/executions/:id\n   * Get a single execution by ID\n   */\n  router.get('/executions/:id', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = executionIdSchema.parse(req.params);\n\n    logger.debug('Fetching execution', { id });\n\n    // First check if it's an active execution (in-memory)\n    const activeExecution = flowExecutionService.getExecutionStatus(id);\n\n    if (activeExecution) {\n      res.json({\n        ...activeExecution,\n        isActive: true\n      });\n      return;\n    }\n\n    // Otherwise fetch from Strapi\n    const execution = await strapiClient.getFlowExecution(id);\n\n    if (!execution) {\n      throw new AppError(404, 'Execution not found');\n    }\n\n    res.json({\n      ...execution,\n      isActive: false\n    });\n  }));\n\n  /**\n   * POST /api/flows/executions/:id/cancel\n   * Cancel a running execution\n   */\n  router.post('/executions/:id/cancel', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = executionIdSchema.parse(req.params);\n\n    logger.info('Cancelling execution', { id });\n\n    const cancelled = await flowExecutionService.cancelExecution(id);\n\n    if (!cancelled) {\n      throw new AppError(404, 'Execution not found or already completed');\n    }\n\n    res.json({\n      success: true,\n      message: 'Execution cancelled successfully',\n      executionId: id\n    });\n  }));\n\n  /**\n   * GET /api/flows/executions/:id/stream\n   * SSE stream for monitoring a specific execution\n   */\n  router.get('/executions/:id/stream', async (req: Request, res: Response) => {\n    const { id } = executionIdSchema.parse(req.params);\n\n    const stream = new FlowSSEStream(res);\n    stream.startKeepAlive();\n\n    logger.info('SSE stream started for execution', { executionId: id });\n\n    // Check if execution exists\n    const activeExecution = flowExecutionService.getExecutionStatus(id);\n    const strapiExecution = activeExecution ? null : await strapiClient.getFlowExecution(id);\n\n    if (!activeExecution && !strapiExecution) {\n      stream.sendData({\n        type: 'error',\n        error: 'Execution not found',\n        timestamp: new Date().toISOString()\n      });\n      stream.close();\n      return;\n    }\n\n    // If execution is already completed, send final status and close\n    if (strapiExecution && ['completed', 'failed', 'cancelled'].includes(strapiExecution.status)) {\n      stream.sendData({\n        type: 'status',\n        status: strapiExecution.status,\n        execution: strapiExecution,\n        timestamp: new Date().toISOString()\n      });\n      stream.close();\n      return;\n    }\n\n    // Set up listener for updates\n    const updateHandler = (update: FlowExecutionUpdate) => {\n      if (update.executionId === id) {\n        stream.send(update.type, {\n          executionId: update.executionId,\n          type: update.type,\n          nodeId: update.nodeId,\n          nodeType: update.nodeType,\n          timestamp: update.timestamp,\n          data: update.data\n        });\n\n        // Close stream on terminal states\n        if (['execution_completed', 'execution_failed', 'execution_cancelled'].includes(update.type)) {\n          setTimeout(() => {\n            stream.stopKeepAlive();\n            stream.close();\n          }, 100);\n        }\n      }\n    };\n\n    flowExecutionService.on('execution-update', updateHandler);\n\n    // Send current status\n    if (activeExecution) {\n      stream.sendData({\n        type: 'status',\n        status: activeExecution.status,\n        currentNodeId: activeExecution.currentNodeId,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n    // Handle client disconnect\n    req.on('close', () => {\n      logger.info('Client disconnected from execution stream', { executionId: id });\n      flowExecutionService.off('execution-update', updateHandler);\n      stream.stopKeepAlive();\n      stream.close();\n    });\n  });\n\n  /**\n   * GET /api/flows/:id/executions\n   * Get all executions for a specific flow\n   */\n  router.get('/:id/executions', asyncHandler(async (req: Request, res: Response) => {\n    const { id: flowId } = flowIdSchema.parse(req.params);\n    const query = executionQuerySchema.parse(req.query);\n\n    logger.debug('Fetching executions for flow', { flowId, query });\n\n    // Verify flow exists\n    const flow = await strapiClient.getFlow(flowId);\n\n    if (!flow) {\n      throw new AppError(404, 'Flow not found');\n    }\n\n    const filters: any = {\n      flow: { documentId: flowId }\n    };\n\n    if (query.status) {\n      filters.status = query.status;\n    }\n\n    if (query.triggeredBy) {\n      filters.triggeredBy = query.triggeredBy;\n    }\n\n    const executions = await strapiClient.getAllFlowExecutions({\n      filters,\n      sort: [query.sort],\n      pagination: {\n        page: query.page,\n        pageSize: query.pageSize\n      }\n    });\n\n    res.json({\n      data: executions,\n      meta: {\n        flowId,\n        flowName: flow.name,\n        page: query.page,\n        pageSize: query.pageSize,\n        total: executions.length\n      }\n    });\n  }));\n\n  // ============= FLOW STATISTICS =============\n\n  /**\n   * GET /api/flows/stats/global\n   * Get global flow execution statistics\n   */\n  router.get('/stats/global', asyncHandler(async (req: Request, res: Response) => {\n    logger.debug('Fetching global flow statistics');\n\n    const stats = await strapiClient.getGlobalFlowStats();\n\n    res.json(stats);\n  }));\n\n  /**\n   * GET /api/flows/stats/:id\n   * Get statistics for a specific flow\n   */\n  router.get('/stats/:id', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = flowIdSchema.parse(req.params);\n\n    logger.debug('Fetching flow statistics', { flowId: id });\n\n    // Verify flow exists\n    const flow = await strapiClient.getFlow(id);\n\n    if (!flow) {\n      throw new AppError(404, 'Flow not found');\n    }\n\n    const stats = await strapiClient.getFlowStats(id);\n\n    res.json({\n      ...stats,\n      flowName: flow.name\n    });\n  }));\n\n  /**\n   * GET /api/flows/executions/recent\n   * Get recent flow executions across all flows\n   */\n  router.get('/executions/recent', asyncHandler(async (req: Request, res: Response) => {\n    const limit = Math.min(parseInt(req.query.limit as string) || 10, 50);\n\n    logger.debug('Fetching recent executions', { limit });\n\n    const executions = await strapiClient.getRecentFlowExecutions(limit);\n\n    res.json({\n      data: executions,\n      count: executions.length\n    });\n  }));\n\n  // ============= FLOW STATUS MANAGEMENT =============\n\n  /**\n   * POST /api/flows/:id/activate\n   * Activate a flow (set isActive to true)\n   */\n  router.post('/:id/activate', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = flowIdSchema.parse(req.params);\n\n    logger.info('Activating flow', { id });\n\n    const flow = await strapiClient.updateFlow(id, {\n      isActive: true,\n      status: 'active'\n    });\n\n    res.json({\n      success: true,\n      flow,\n      message: `Flow \"${flow.name}\" activated successfully`\n    });\n  }));\n\n  /**\n   * POST /api/flows/:id/deactivate\n   * Deactivate a flow (set isActive to false)\n   */\n  router.post('/:id/deactivate', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = flowIdSchema.parse(req.params);\n\n    logger.info('Deactivating flow', { id });\n\n    const flow = await strapiClient.updateFlow(id, {\n      isActive: false,\n      status: 'paused'\n    });\n\n    res.json({\n      success: true,\n      flow,\n      message: `Flow \"${flow.name}\" deactivated successfully`\n    });\n  }));\n\n  /**\n   * POST /api/flows/:id/duplicate\n   * Duplicate a flow\n   */\n  router.post('/:id/duplicate', asyncHandler(async (req: Request, res: Response) => {\n    const { id } = flowIdSchema.parse(req.params);\n    const { name } = req.body;\n\n    logger.info('Duplicating flow', { id, newName: name });\n\n    // Fetch original flow\n    const original = await strapiClient.getFlow(id);\n\n    if (!original) {\n      throw new AppError(404, 'Flow not found');\n    }\n\n    // Create duplicate\n    const duplicate = await strapiClient.createFlow({\n      name: name || `${original.name} (Copy)`,\n      description: original.description,\n      nodes: original.nodes,\n      inputSchema: original.inputSchema,\n      outputSchema: original.outputSchema,\n      isActive: false,\n      status: 'draft',\n      version: '1.0.0',\n      category: original.category,\n      metadata: original.metadata\n    });\n\n    res.status(201).json({\n      success: true,\n      flow: duplicate,\n      message: `Flow duplicated successfully as \"${duplicate.name}\"`\n    });\n  }));\n\n  return router;\n}\n\n// ============= DEFAULT EXPORT =============\n\nexport default createFlowRoutes;\n",
        "last_modified": "2026-01-02T17:55:06.515405"
      },
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:46.979336",
  "last_updated": "2026-01-02T15:21:46.990207"
}