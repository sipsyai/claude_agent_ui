{
  "file_path": "src/web/manager/services/flow-api.ts",
  "main_branch_history": [],
  "task_views": {
    "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu": {
      "task_id": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
      "branch_point": {
        "commit_hash": "9355e1f79162ecd7611ae3213457e87085b7fe4d",
        "content": "",
        "timestamp": "2026-01-02T15:21:46.864601"
      },
      "worktree_state": {
        "content": "/**\n * Flow API Service for Manager Frontend\n *\n * Provides API client functions for flow operations:\n * - Flow CRUD operations (via Express/Strapi proxy)\n * - Flow execution management (via Express with SSE streaming)\n * - Flow execution history and monitoring\n *\n * @see src/routes/flow.routes.ts for backend endpoints\n * @see src/web/manager/types.ts for type definitions\n */\n\nimport type {\n  Flow,\n  FlowNode,\n  FlowStatus,\n  FlowCategory,\n  FlowExecution,\n  FlowExecutionStatus,\n  FlowExecutionUpdate,\n  FlowStats,\n  GlobalFlowStats,\n  FlowTriggerType,\n  FlowCreateInput,\n  FlowUpdateInput,\n} from '../types';\n\n// Express API base URL\n// @ts-ignore - Vite env variables are available at runtime\nconst EXPRESS_API = import.meta.env?.VITE_EXPRESS_URL || 'http://localhost:3001/api';\nconst FLOWS_BASE = `${EXPRESS_API}/flows`;\n\n// =============================================================================\n// AUTH HELPERS (consistent with other API services)\n// =============================================================================\n\n/**\n * Get auth token from cookie\n */\nfunction getAuthToken(): string | null {\n  const cookies = document.cookie.split(';');\n  for (const cookie of cookies) {\n    const [name, value] = cookie.trim().split('=');\n    if (name === 'cui-auth-token') {\n      return decodeURIComponent(value);\n    }\n  }\n  return null;\n}\n\n/**\n * Create fetch options with auth header\n */\nfunction createFetchOptions(options: RequestInit = {}): RequestInit {\n  const token = getAuthToken();\n  const headers = new Headers(options.headers);\n\n  if (token) {\n    headers.set('Authorization', `Bearer ${token}`);\n  }\n\n  return {\n    ...options,\n    headers,\n  };\n}\n\n// =============================================================================\n// FLOW CRUD OPERATIONS\n// =============================================================================\n\n/**\n * Flow query parameters for listing flows\n */\nexport interface FlowQueryParams {\n  status?: FlowStatus;\n  category?: FlowCategory;\n  isActive?: boolean;\n  search?: string;\n  sort?: string;\n  page?: number;\n  pageSize?: number;\n}\n\n/**\n * Flow list response with pagination metadata\n */\nexport interface FlowListResponse {\n  data: Flow[];\n  meta: {\n    page: number;\n    pageSize: number;\n    total: number;\n  };\n}\n\n/**\n * Get all flows with optional filtering and pagination\n */\nexport async function getFlows(params?: FlowQueryParams): Promise<FlowListResponse> {\n  const url = new URL(FLOWS_BASE, window.location.origin);\n\n  if (params) {\n    if (params.status) url.searchParams.set('status', params.status);\n    if (params.category) url.searchParams.set('category', params.category);\n    if (params.isActive !== undefined) url.searchParams.set('isActive', String(params.isActive));\n    if (params.search) url.searchParams.set('search', params.search);\n    if (params.sort) url.searchParams.set('sort', params.sort);\n    if (params.page) url.searchParams.set('page', String(params.page));\n    if (params.pageSize) url.searchParams.set('pageSize', String(params.pageSize));\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get flows');\n  }\n\n  return response.json();\n}\n\n/**\n * Get a single flow by ID\n */\nexport async function getFlow(id: string): Promise<Flow> {\n  const response = await fetch(`${FLOWS_BASE}/${id}`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get flow');\n  }\n\n  return response.json();\n}\n\n/**\n * Create flow response\n */\nexport interface CreateFlowResponse {\n  success: boolean;\n  flow: Flow;\n  message: string;\n}\n\n/**\n * Create a new flow\n */\nexport async function createFlow(flow: FlowCreateInput): Promise<CreateFlowResponse> {\n  const response = await fetch(FLOWS_BASE, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(flow),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create flow');\n  }\n\n  return response.json();\n}\n\n/**\n * Update flow response\n */\nexport interface UpdateFlowResponse {\n  success: boolean;\n  flow: Flow;\n  message: string;\n}\n\n/**\n * Update an existing flow\n */\nexport async function updateFlow(id: string, updates: FlowUpdateInput): Promise<UpdateFlowResponse> {\n  const response = await fetch(`${FLOWS_BASE}/${id}`, createFetchOptions({\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to update flow');\n  }\n\n  return response.json();\n}\n\n/**\n * Delete a flow\n */\nexport async function deleteFlow(id: string): Promise<void> {\n  const response = await fetch(`${FLOWS_BASE}/${id}`, createFetchOptions({\n    method: 'DELETE',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to delete flow');\n  }\n}\n\n// =============================================================================\n// FLOW STATUS MANAGEMENT\n// =============================================================================\n\n/**\n * Activate a flow (sets isActive to true and status to 'active')\n */\nexport async function activateFlow(id: string): Promise<UpdateFlowResponse> {\n  const response = await fetch(`${FLOWS_BASE}/${id}/activate`, createFetchOptions({\n    method: 'POST',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to activate flow');\n  }\n\n  return response.json();\n}\n\n/**\n * Deactivate a flow (sets isActive to false and status to 'paused')\n */\nexport async function deactivateFlow(id: string): Promise<UpdateFlowResponse> {\n  const response = await fetch(`${FLOWS_BASE}/${id}/deactivate`, createFetchOptions({\n    method: 'POST',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to deactivate flow');\n  }\n\n  return response.json();\n}\n\n/**\n * Duplicate a flow\n */\nexport async function duplicateFlow(id: string, newName?: string): Promise<CreateFlowResponse> {\n  const response = await fetch(`${FLOWS_BASE}/${id}/duplicate`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ name: newName }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to duplicate flow');\n  }\n\n  return response.json();\n}\n\n// =============================================================================\n// FLOW EXECUTION\n// =============================================================================\n\n/**\n * SSE event data from flow execution\n */\nexport interface FlowExecutionEvent {\n  type: 'status' | 'result' | 'error' | string;\n  status?: string;\n  message?: string;\n  flowId?: string;\n  flowName?: string;\n  executionId?: string;\n  nodeId?: string;\n  nodeType?: string;\n  timestamp?: string;\n  data?: Record<string, any>;\n  result?: {\n    executionId: string;\n    success: boolean;\n    status: FlowExecutionStatus;\n    output?: Record<string, any>;\n    error?: string;\n    executionTime?: number;\n    tokensUsed?: number;\n    cost?: number;\n    nodeExecutions?: Record<string, any>[];\n  };\n  error?: string;\n}\n\n/**\n * Start flow execution request\n */\nexport interface StartFlowExecutionRequest {\n  input: Record<string, any>;\n  triggeredBy?: FlowTriggerType;\n  triggerData?: Record<string, any>;\n}\n\n/**\n * Execute a flow with SSE streaming for real-time updates\n *\n * @param flowId - The flow ID to execute\n * @param request - Execution request with input data\n * @param onEvent - Callback for SSE events\n * @returns Promise that resolves when execution completes or rejects on error\n */\nexport async function executeFlow(\n  flowId: string,\n  request: StartFlowExecutionRequest,\n  onEvent?: (event: FlowExecutionEvent) => void\n): Promise<void> {\n  const response = await fetch(`${FLOWS_BASE}/${flowId}/execute`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(request),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to execute flow');\n  }\n\n  if (!response.body) {\n    throw new Error('No response body');\n  }\n\n  // Read SSE stream\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) break;\n\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || '';\n\n      for (const line of lines) {\n        // Skip comments (keep-alive)\n        if (line.startsWith(':')) continue;\n\n        // Parse event lines\n        if (line.startsWith('event: ')) {\n          // Event name line - we'll capture data on the next data: line\n          continue;\n        }\n\n        if (line.startsWith('data: ')) {\n          try {\n            const data = JSON.parse(line.substring(6));\n            if (onEvent) {\n              onEvent(data);\n            }\n\n            // Check for terminal states\n            if (data.type === 'error') {\n              throw new Error(data.error || data.message || 'Flow execution failed');\n            }\n          } catch (e) {\n            if (e instanceof SyntaxError) {\n              // Ignore JSON parse errors for malformed data\n            } else {\n              throw e;\n            }\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * Create an EventSource-like object for monitoring flow execution\n *\n * This is useful when you need to attach event listeners for specific event types\n */\nexport function createFlowExecutionStream(\n  flowId: string,\n  request: StartFlowExecutionRequest\n): EventSource & { close: () => void } {\n  const eventTarget = new EventTarget();\n\n  // Create abort controller for cancellation\n  const abortController = new AbortController();\n\n  const eventSource = Object.assign(eventTarget, {\n    close: () => {\n      abortController.abort();\n    },\n    readyState: 0,\n    url: `${FLOWS_BASE}/${flowId}/execute`,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n  }) as EventSource & { close: () => void };\n\n  fetch(`${FLOWS_BASE}/${flowId}/execute`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(request),\n    signal: abortController.signal,\n  }))\n    .then(async (response) => {\n      if (!response.ok) {\n        const error = await response.json();\n        const errorEvent = new MessageEvent('error', {\n          data: JSON.stringify({ type: 'error', error: error.error || 'Failed to execute flow' }),\n        });\n        eventSource.dispatchEvent(errorEvent);\n        return;\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('No response body');\n      }\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n            if (data.trim()) {\n              const messageEvent = new MessageEvent('message', { data });\n              eventSource.dispatchEvent(messageEvent);\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      if (error.name !== 'AbortError') {\n        const errorEvent = new MessageEvent('error', {\n          data: JSON.stringify({ type: 'error', error: error.message }),\n        });\n        eventSource.dispatchEvent(errorEvent);\n      }\n    });\n\n  return eventSource;\n}\n\n// =============================================================================\n// FLOW EXECUTION HISTORY & MONITORING\n// =============================================================================\n\n/**\n * Execution query parameters\n */\nexport interface ExecutionQueryParams {\n  status?: FlowExecutionStatus;\n  triggeredBy?: FlowTriggerType;\n  sort?: string;\n  page?: number;\n  pageSize?: number;\n}\n\n/**\n * Execution list response\n */\nexport interface ExecutionListResponse {\n  data: FlowExecution[];\n  meta: {\n    flowId?: string;\n    flowName?: string;\n    page: number;\n    pageSize: number;\n    total: number;\n  };\n}\n\n/**\n * Get all executions for a specific flow\n */\nexport async function getFlowExecutions(\n  flowId: string,\n  params?: ExecutionQueryParams\n): Promise<ExecutionListResponse> {\n  const url = new URL(`${FLOWS_BASE}/${flowId}/executions`, window.location.origin);\n\n  if (params) {\n    if (params.status) url.searchParams.set('status', params.status);\n    if (params.triggeredBy) url.searchParams.set('triggeredBy', params.triggeredBy);\n    if (params.sort) url.searchParams.set('sort', params.sort);\n    if (params.page) url.searchParams.set('page', String(params.page));\n    if (params.pageSize) url.searchParams.set('pageSize', String(params.pageSize));\n  }\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get flow executions');\n  }\n\n  return response.json();\n}\n\n/**\n * Get running executions response\n */\nexport interface RunningExecutionsResponse {\n  active: string[];\n  executions: FlowExecution[];\n  count: number;\n}\n\n/**\n * Get all currently running executions\n */\nexport async function getRunningExecutions(): Promise<RunningExecutionsResponse> {\n  const response = await fetch(`${FLOWS_BASE}/executions/running`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get running executions');\n  }\n\n  return response.json();\n}\n\n/**\n * Get a single execution by ID\n */\nexport async function getExecution(executionId: string): Promise<FlowExecution & { isActive?: boolean }> {\n  const response = await fetch(`${FLOWS_BASE}/executions/${executionId}`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get execution');\n  }\n\n  return response.json();\n}\n\n/**\n * Cancel a running execution\n */\nexport async function cancelExecution(executionId: string): Promise<{\n  success: boolean;\n  message: string;\n  executionId: string;\n}> {\n  const response = await fetch(`${FLOWS_BASE}/executions/${executionId}/cancel`, createFetchOptions({\n    method: 'POST',\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to cancel execution');\n  }\n\n  return response.json();\n}\n\n/**\n * Create an SSE stream for monitoring a specific execution\n *\n * @param executionId - The execution ID to monitor\n * @param onEvent - Callback for execution updates\n * @returns Cleanup function to close the stream\n */\nexport function monitorExecution(\n  executionId: string,\n  onEvent: (event: FlowExecutionUpdate | FlowExecutionEvent) => void\n): () => void {\n  const abortController = new AbortController();\n\n  fetch(`${FLOWS_BASE}/executions/${executionId}/stream`, createFetchOptions({\n    signal: abortController.signal,\n  }))\n    .then(async (response) => {\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.error || 'Failed to monitor execution');\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('No response body');\n      }\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith(':')) continue; // Skip comments\n\n          if (line.startsWith('data: ')) {\n            try {\n              const data = JSON.parse(line.substring(6));\n              onEvent(data);\n            } catch (e) {\n              // Ignore parse errors\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      if (error.name !== 'AbortError') {\n        onEvent({\n          type: 'error',\n          error: error.message,\n          timestamp: new Date().toISOString(),\n        } as FlowExecutionEvent);\n      }\n    });\n\n  // Return cleanup function\n  return () => {\n    abortController.abort();\n  };\n}\n\n// =============================================================================\n// FLOW STATISTICS\n// =============================================================================\n\n/**\n * Get global flow execution statistics\n */\nexport async function getGlobalFlowStats(): Promise<GlobalFlowStats> {\n  const response = await fetch(`${FLOWS_BASE}/stats/global`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get global flow stats');\n  }\n\n  return response.json();\n}\n\n/**\n * Get statistics for a specific flow\n */\nexport async function getFlowStats(flowId: string): Promise<FlowStats & { flowName: string }> {\n  const response = await fetch(`${FLOWS_BASE}/stats/${flowId}`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get flow stats');\n  }\n\n  return response.json();\n}\n\n/**\n * Recent executions response\n */\nexport interface RecentExecutionsResponse {\n  data: FlowExecution[];\n  count: number;\n}\n\n/**\n * Get recent flow executions across all flows\n */\nexport async function getRecentExecutions(limit: number = 10): Promise<RecentExecutionsResponse> {\n  const url = new URL(`${FLOWS_BASE}/executions/recent`, window.location.origin);\n  url.searchParams.set('limit', String(limit));\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get recent executions');\n  }\n\n  return response.json();\n}\n\n// =============================================================================\n// FLOW TEMPLATES\n// =============================================================================\n\n/**\n * Flow template definition\n */\nexport interface FlowTemplate {\n  templateId: string;\n  name: string;\n  description: string;\n  category: FlowCategory;\n  icon: string;\n  tags: string[];\n  flowData?: Omit<Flow, 'id' | 'createdAt' | 'updatedAt'>;\n}\n\n/**\n * Templates list response\n */\nexport interface TemplatesListResponse {\n  data: FlowTemplate[];\n  count: number;\n}\n\n/**\n * Get all available flow templates\n */\nexport async function getFlowTemplates(): Promise<TemplatesListResponse> {\n  const response = await fetch(`${FLOWS_BASE}/templates`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get flow templates');\n  }\n\n  return response.json();\n}\n\n/**\n * Get a specific template by ID (includes full flow data)\n */\nexport async function getFlowTemplate(templateId: string): Promise<FlowTemplate> {\n  const response = await fetch(`${FLOWS_BASE}/templates/${templateId}`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get flow template');\n  }\n\n  return response.json();\n}\n\n/**\n * Get templates by category\n */\nexport async function getFlowTemplatesByCategory(category: FlowCategory): Promise<TemplatesListResponse> {\n  const response = await fetch(`${FLOWS_BASE}/templates/category/${category}`, createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to get flow templates by category');\n  }\n\n  return response.json();\n}\n\n/**\n * Search templates by query\n */\nexport async function searchFlowTemplates(query: string): Promise<TemplatesListResponse> {\n  const url = new URL(`${FLOWS_BASE}/templates/search`, window.location.origin);\n  url.searchParams.set('q', query);\n\n  const response = await fetch(url.toString(), createFetchOptions());\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to search flow templates');\n  }\n\n  return response.json();\n}\n\n/**\n * Create a new flow from a template\n */\nexport async function createFlowFromTemplate(\n  templateId: string,\n  customName?: string\n): Promise<CreateFlowResponse> {\n  const response = await fetch(`${FLOWS_BASE}/templates/${templateId}/create`, createFetchOptions({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ name: customName }),\n  }));\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || 'Failed to create flow from template');\n  }\n\n  return response.json();\n}\n\n// =============================================================================\n// CONVENIENCE EXPORTS\n// =============================================================================\n\nexport type {\n  Flow,\n  FlowNode,\n  FlowStatus,\n  FlowCategory,\n  FlowExecution,\n  FlowExecutionStatus,\n  FlowExecutionUpdate,\n  FlowStats,\n  GlobalFlowStats,\n  FlowTriggerType,\n  FlowCreateInput,\n  FlowUpdateInput,\n};\n",
        "last_modified": "2026-01-02T17:55:06.536163"
      },
      "task_intent": {
        "title": "007-uygulaman-n-genel-yap-s-n-d-zenleyece-iz-yani-uygu",
        "description": "Implement a workflow/flow system for organizing agents and skills into reusable, schedulable processes with input/output handling. This transforms the application from a simple agent manager to a process automation tool where users can define workflows like 'Web Scraper' that take input, run agents with skills, and produce structured outputs.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T15:21:47.043448",
  "last_updated": "2026-01-02T15:21:47.054860"
}