{
  "file_path": "src/services/log-stream-buffer.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import { EventEmitter } from 'events';\n\nexport class LogStreamBuffer extends EventEmitter {\n  private buffer: string[] = [];\n  private maxBufferSize: number;\n  \n  constructor(maxBufferSize: number = 1000) {\n    super();\n    this.maxBufferSize = maxBufferSize;\n  }\n  \n  public addLog(logLine: string): void {\n    // Add to buffer\n    this.buffer.push(logLine);\n    \n    // Maintain buffer size\n    if (this.buffer.length > this.maxBufferSize) {\n      this.buffer.shift();\n    }\n    \n    // Emit for real-time streaming\n    this.emit('log', logLine);\n  }\n  \n  public getRecentLogs(limit?: number): string[] {\n    // Handle zero limit explicitly\n    if (limit === 0) {\n      return [];\n    }\n    \n    // Handle undefined/null limit or limit larger than buffer\n    if (limit === undefined || limit === null || limit >= this.buffer.length) {\n      return [...this.buffer];\n    }\n    \n    return this.buffer.slice(-limit);\n  }\n  \n  public clear(): void {\n    this.buffer = [];\n  }\n}\n\n// Singleton instance\nexport const logStreamBuffer = new LogStreamBuffer();",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import { EventEmitter } from 'events';\n\n/**\n * Circular buffer for real-time log streaming with EventEmitter integration.\n *\n * LogStreamBuffer extends Node.js EventEmitter to provide a memory-efficient circular buffer\n * for storing recent log entries while emitting log events for real-time streaming to connected\n * clients. It automatically maintains a fixed-size buffer using LRU (Least Recently Used)\n * eviction when the buffer reaches capacity.\n *\n * ## Architecture\n *\n * **EventEmitter Pattern**: Emits 'log' events when new log entries are added, enabling\n * real-time log streaming to WebSocket clients, UI components, or monitoring systems.\n *\n * **Circular Buffer Management**: Maintains a fixed-size buffer of recent log entries.\n * When buffer reaches maxBufferSize, oldest entries are automatically evicted (FIFO).\n * Default capacity is 1000 log entries.\n *\n * **Memory Safety**: Prevents unbounded memory growth by enforcing strict buffer size limits.\n * Suitable for long-running processes where logs accumulate indefinitely.\n *\n * ## Events\n *\n * - `'log'` - Emitted when a new log entry is added via addLog()\n *   - Event payload: `(logLine: string)` - The new log line text\n *\n * ## Use Cases\n *\n * - Real-time log streaming to browser UI (WebSocket integration)\n * - Recent log history retrieval for debugging (last N entries)\n * - Multi-stream Pino logger output (console + buffer)\n * - Log aggregation for monitoring dashboards\n * - Tail-like functionality for viewing recent application logs\n *\n * @example Basic usage with event listeners\n * ```typescript\n * import { logStreamBuffer } from './log-stream-buffer';\n *\n * // Subscribe to real-time log events\n * logStreamBuffer.on('log', (logLine: string) => {\n *   console.log('New log:', logLine);\n *   // Send to WebSocket clients, UI, etc.\n * });\n *\n * // Add logs (usually via Pino stream)\n * logStreamBuffer.addLog('[2024-01-02 12:00:00] INFO  [ChatService] Message sent');\n * logStreamBuffer.addLog('[2024-01-02 12:00:01] DEBUG [MCPService] Tool called');\n *\n * // Retrieve recent logs\n * const recentLogs = logStreamBuffer.getRecentLogs(10);\n * console.log('Last 10 logs:', recentLogs);\n * ```\n *\n * @example WebSocket streaming integration\n * ```typescript\n * import WebSocket from 'ws';\n * import { logStreamBuffer } from './log-stream-buffer';\n *\n * const wss = new WebSocket.Server({ port: 8080 });\n *\n * wss.on('connection', (ws) => {\n *   // Send recent logs on connection\n *   const recentLogs = logStreamBuffer.getRecentLogs(50);\n *   ws.send(JSON.stringify({ type: 'history', logs: recentLogs }));\n *\n *   // Stream new logs in real-time\n *   const logHandler = (logLine: string) => {\n *     ws.send(JSON.stringify({ type: 'log', data: logLine }));\n *   };\n *   logStreamBuffer.on('log', logHandler);\n *\n *   // Cleanup on disconnect\n *   ws.on('close', () => {\n *     logStreamBuffer.off('log', logHandler);\n *   });\n * });\n * ```\n *\n * @example Pino multi-stream integration\n * ```typescript\n * import pino from 'pino';\n * import { logStreamBuffer } from './log-stream-buffer';\n * import { LogFormatter } from './log-formatter';\n *\n * const logger = pino(\n *   { level: 'info' },\n *   pino.multistream([\n *     // Console output with formatting\n *     { stream: new LogFormatter() },\n *     // Buffer for real-time streaming (receives raw formatted logs)\n *     {\n *       stream: {\n *         write: (chunk: string) => {\n *           logStreamBuffer.addLog(chunk.trim());\n *         }\n *       }\n *     }\n *   ])\n * );\n * ```\n *\n * @example Custom buffer size configuration\n * ```typescript\n * import { LogStreamBuffer } from './log-stream-buffer';\n *\n * // Create buffer with custom capacity for high-volume logs\n * const highVolumeBuffer = new LogStreamBuffer(5000);\n *\n * // Create buffer with smaller capacity for memory-constrained environments\n * const lowMemoryBuffer = new LogStreamBuffer(100);\n * ```\n *\n * @example Retrieving recent logs with limit variations\n * ```typescript\n * import { logStreamBuffer } from './log-stream-buffer';\n *\n * // Get all logs in buffer\n * const allLogs = logStreamBuffer.getRecentLogs();\n *\n * // Get last 50 logs\n * const last50 = logStreamBuffer.getRecentLogs(50);\n *\n * // Get zero logs (empty array)\n * const empty = logStreamBuffer.getRecentLogs(0);\n *\n * // Clear buffer\n * logStreamBuffer.clear();\n * ```\n *\n * @see {@link addLog} for adding log entries\n * @see {@link getRecentLogs} for retrieving log history\n * @see {@link clear} for clearing the buffer\n * @see {@link https://nodejs.org/api/events.html#class-eventemitter} for EventEmitter documentation\n */\nexport class LogStreamBuffer extends EventEmitter {\n  /** In-memory circular buffer storing recent log entries (FIFO eviction when full) */\n  private buffer: string[] = [];\n  /** Maximum number of log entries to retain in buffer (default: 1000) */\n  private maxBufferSize: number;\n\n  /**\n   * Creates a new LogStreamBuffer instance with configurable buffer size.\n   *\n   * Initializes the EventEmitter and sets the maximum buffer capacity. When the buffer\n   * reaches maxBufferSize, oldest entries are automatically evicted using FIFO strategy.\n   *\n   * @param maxBufferSize - Maximum number of log entries to retain (default: 1000)\n   *\n   * @example Default buffer size (1000 entries)\n   * ```typescript\n   * import { LogStreamBuffer } from './log-stream-buffer';\n   *\n   * const buffer = new LogStreamBuffer();\n   * // Buffer will hold up to 1000 log entries\n   * ```\n   *\n   * @example Custom buffer size for high-volume logs\n   * ```typescript\n   * // Larger buffer for applications with heavy logging\n   * const highVolumeBuffer = new LogStreamBuffer(5000);\n   *\n   * for (let i = 0; i < 10000; i++) {\n   *   highVolumeBuffer.addLog(`Log entry ${i}`);\n   * }\n   *\n   * const recent = highVolumeBuffer.getRecentLogs();\n   * console.log(recent.length); // 5000 (oldest 5000 entries evicted)\n   * ```\n   *\n   * @example Small buffer for memory-constrained environments\n   * ```typescript\n   * // Smaller buffer for embedded systems or containers\n   * const lowMemoryBuffer = new LogStreamBuffer(100);\n   * ```\n   */\n  constructor(maxBufferSize: number = 1000) {\n    super();\n    this.maxBufferSize = maxBufferSize;\n  }\n\n  /**\n   * Add a log entry to the buffer and emit 'log' event for real-time streaming.\n   *\n   * Appends the log line to the internal circular buffer. If the buffer size exceeds\n   * maxBufferSize, the oldest entry is automatically evicted (FIFO). After adding to\n   * the buffer, emits a 'log' event with the new log line for real-time subscribers.\n   *\n   * ## Buffer Management Workflow\n   *\n   * 1. Append log line to buffer array (push)\n   * 2. Check if buffer.length > maxBufferSize\n   * 3. If overflow, remove oldest entry (shift)\n   * 4. Emit 'log' event with new log line to all listeners\n   *\n   * ## Event Emission\n   *\n   * Event name: `'log'`\n   * Event payload: `(logLine: string)` - The new log line text\n   *\n   * @param logLine - The log line text to add (typically formatted log output)\n   *\n   * @example Basic usage\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * logStreamBuffer.addLog('[2024-01-02 12:00:00] INFO  [ChatService] Message sent');\n   * logStreamBuffer.addLog('[2024-01-02 12:00:01] DEBUG [MCPService] Tool called');\n   * ```\n   *\n   * @example Real-time streaming with event listeners\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * // Subscribe to log events\n   * logStreamBuffer.on('log', (logLine: string) => {\n   *   console.log('New log received:', logLine);\n   * });\n   *\n   * // Add logs (emits 'log' event for each)\n   * logStreamBuffer.addLog('[2024-01-02 12:00:00] INFO  Server started');\n   * // Output: New log received: [2024-01-02 12:00:00] INFO  Server started\n   *\n   * logStreamBuffer.addLog('[2024-01-02 12:00:01] DEBUG Config loaded');\n   * // Output: New log received: [2024-01-02 12:00:01] DEBUG Config loaded\n   * ```\n   *\n   * @example WebSocket streaming to multiple clients\n   * ```typescript\n   * import WebSocket from 'ws';\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * const clients = new Set<WebSocket>();\n   *\n   * // Broadcast logs to all connected WebSocket clients\n   * logStreamBuffer.on('log', (logLine: string) => {\n   *   const payload = JSON.stringify({ type: 'log', data: logLine });\n   *   clients.forEach(client => {\n   *     if (client.readyState === WebSocket.OPEN) {\n   *       client.send(payload);\n   *     }\n   *   });\n   * });\n   *\n   * // Add logs (broadcasts to all clients)\n   * logStreamBuffer.addLog('[2024-01-02 12:00:00] INFO  [API] Request received');\n   * ```\n   *\n   * @example Pino stream integration\n   * ```typescript\n   * import pino from 'pino';\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * // Create Pino logger that writes to logStreamBuffer\n   * const logger = pino({\n   *   level: 'info',\n   *   stream: {\n   *     write: (chunk: string) => {\n   *       logStreamBuffer.addLog(chunk.trim());\n   *     }\n   *   }\n   * });\n   *\n   * logger.info('Server started');\n   * // Log is added to buffer and emitted to subscribers\n   * ```\n   *\n   * @example Buffer overflow behavior\n   * ```typescript\n   * import { LogStreamBuffer } from './log-stream-buffer';\n   *\n   * const buffer = new LogStreamBuffer(3); // Small buffer for demo\n   *\n   * buffer.addLog('Log 1');\n   * buffer.addLog('Log 2');\n   * buffer.addLog('Log 3');\n   * console.log(buffer.getRecentLogs()); // ['Log 1', 'Log 2', 'Log 3']\n   *\n   * buffer.addLog('Log 4'); // Evicts 'Log 1'\n   * console.log(buffer.getRecentLogs()); // ['Log 2', 'Log 3', 'Log 4']\n   *\n   * buffer.addLog('Log 5'); // Evicts 'Log 2'\n   * console.log(buffer.getRecentLogs()); // ['Log 3', 'Log 4', 'Log 5']\n   * ```\n   *\n   * @example Multiple event listeners\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * // Listener 1: Console output\n   * logStreamBuffer.on('log', (log) => {\n   *   console.log('Console:', log);\n   * });\n   *\n   * // Listener 2: File writing\n   * logStreamBuffer.on('log', (log) => {\n   *   fs.appendFileSync('/var/log/app.log', log + '\\n');\n   * });\n   *\n   * // Listener 3: Metrics collection\n   * logStreamBuffer.on('log', (log) => {\n   *   if (log.includes('ERROR')) {\n   *     errorCount++;\n   *   }\n   * });\n   *\n   * // All listeners receive the event\n   * logStreamBuffer.addLog('[2024-01-02 12:00:00] ERROR Database connection failed');\n   * ```\n   *\n   * @see {@link getRecentLogs} for retrieving buffered logs\n   * @see {@link clear} for clearing the buffer\n   */\n  public addLog(logLine: string): void {\n    // Add to buffer\n    this.buffer.push(logLine);\n\n    // Maintain buffer size\n    if (this.buffer.length > this.maxBufferSize) {\n      this.buffer.shift();\n    }\n\n    // Emit for real-time streaming\n    this.emit('log', logLine);\n  }\n\n  /**\n   * Retrieve recent log entries from the buffer with optional limit.\n   *\n   * Returns an array of recent log entries from the circular buffer. By default, returns\n   * all buffered logs. When a limit is specified, returns the most recent N entries.\n   * Returns a shallow copy of the internal buffer to prevent external modifications.\n   *\n   * ## Return Behavior\n   *\n   * - `limit` undefined/null: Returns all logs in buffer (shallow copy)\n   * - `limit` = 0: Returns empty array `[]`\n   * - `limit` < buffer.length: Returns last N entries (most recent)\n   * - `limit` >= buffer.length: Returns all logs in buffer (same as undefined)\n   *\n   * ## Performance\n   *\n   * - Always returns a shallow copy of the buffer (prevents external mutation)\n   * - Uses `Array.slice(-limit)` for efficient tail extraction\n   * - O(N) time complexity where N is the limit or buffer size\n   *\n   * @param limit - Optional maximum number of recent log entries to return (default: all logs)\n   * @returns Array of log line strings (most recent logs when limit specified)\n   *\n   * @example Get all logs in buffer\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * logStreamBuffer.addLog('Log 1');\n   * logStreamBuffer.addLog('Log 2');\n   * logStreamBuffer.addLog('Log 3');\n   *\n   * const allLogs = logStreamBuffer.getRecentLogs();\n   * console.log(allLogs); // ['Log 1', 'Log 2', 'Log 3']\n   * ```\n   *\n   * @example Get last N logs\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * for (let i = 1; i <= 100; i++) {\n   *   logStreamBuffer.addLog(`Log ${i}`);\n   * }\n   *\n   * const last10 = logStreamBuffer.getRecentLogs(10);\n   * console.log(last10); // ['Log 91', 'Log 92', ..., 'Log 100']\n   *\n   * const last5 = logStreamBuffer.getRecentLogs(5);\n   * console.log(last5); // ['Log 96', 'Log 97', 'Log 98', 'Log 99', 'Log 100']\n   * ```\n   *\n   * @example WebSocket - send recent logs on connection\n   * ```typescript\n   * import WebSocket from 'ws';\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * const wss = new WebSocket.Server({ port: 8080 });\n   *\n   * wss.on('connection', (ws) => {\n   *   // Send last 50 logs to new client for context\n   *   const recentLogs = logStreamBuffer.getRecentLogs(50);\n   *   ws.send(JSON.stringify({\n   *     type: 'history',\n   *     logs: recentLogs\n   *   }));\n   *\n   *   // Then stream new logs in real-time\n   *   const logHandler = (logLine: string) => {\n   *     ws.send(JSON.stringify({ type: 'log', data: logLine }));\n   *   };\n   *   logStreamBuffer.on('log', logHandler);\n   *\n   *   ws.on('close', () => {\n   *     logStreamBuffer.off('log', logHandler);\n   *   });\n   * });\n   * ```\n   *\n   * @example API endpoint - paginated log retrieval\n   * ```typescript\n   * import express from 'express';\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * const app = express();\n   *\n   * app.get('/api/logs', (req, res) => {\n   *   const limit = parseInt(req.query.limit as string) || 100;\n   *   const logs = logStreamBuffer.getRecentLogs(limit);\n   *\n   *   res.json({\n   *     logs,\n   *     count: logs.length,\n   *     timestamp: new Date().toISOString()\n   *   });\n   * });\n   * ```\n   *\n   * @example Edge case - limit zero\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * logStreamBuffer.addLog('Log 1');\n   * logStreamBuffer.addLog('Log 2');\n   *\n   * const noLogs = logStreamBuffer.getRecentLogs(0);\n   * console.log(noLogs); // []\n   * ```\n   *\n   * @example Edge case - limit larger than buffer\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * logStreamBuffer.addLog('Log 1');\n   * logStreamBuffer.addLog('Log 2');\n   * logStreamBuffer.addLog('Log 3');\n   *\n   * const allLogs = logStreamBuffer.getRecentLogs(1000);\n   * console.log(allLogs); // ['Log 1', 'Log 2', 'Log 3'] (all available logs)\n   * console.log(allLogs.length); // 3 (not 1000)\n   * ```\n   *\n   * @example Shallow copy behavior\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * logStreamBuffer.addLog('Log 1');\n   * logStreamBuffer.addLog('Log 2');\n   *\n   * const logs = logStreamBuffer.getRecentLogs();\n   * logs.push('Fake log'); // Does NOT affect internal buffer\n   *\n   * const actualLogs = logStreamBuffer.getRecentLogs();\n   * console.log(actualLogs); // ['Log 1', 'Log 2'] (no 'Fake log')\n   * ```\n   *\n   * @example Debugging - display recent errors\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * // Get last 100 logs and filter for errors\n   * const recentLogs = logStreamBuffer.getRecentLogs(100);\n   * const errorLogs = recentLogs.filter(log => log.includes('ERROR'));\n   *\n   * console.log(`Found ${errorLogs.length} errors in last 100 logs:`);\n   * errorLogs.forEach(log => console.log(log));\n   * ```\n   *\n   * @see {@link addLog} for adding log entries\n   * @see {@link clear} for clearing the buffer\n   */\n  public getRecentLogs(limit?: number): string[] {\n    // Handle zero limit explicitly\n    if (limit === 0) {\n      return [];\n    }\n\n    // Handle undefined/null limit or limit larger than buffer\n    if (limit === undefined || limit === null || limit >= this.buffer.length) {\n      return [...this.buffer];\n    }\n\n    return this.buffer.slice(-limit);\n  }\n\n  /**\n   * Clear all log entries from the buffer.\n   *\n   * Resets the internal buffer to an empty array, removing all stored log entries.\n   * Does NOT emit any events. Use this for cleanup, testing, or when log history\n   * is no longer needed.\n   *\n   * ## Important Notes\n   *\n   * - Does NOT emit 'clear' or any other event (silent operation)\n   * - Does NOT affect active event listeners (listeners remain subscribed)\n   * - Does NOT prevent new logs from being added immediately after clearing\n   * - Safe to call even when buffer is already empty (no-op)\n   *\n   * ## Use Cases\n   *\n   * - Testing: Reset buffer state between tests\n   * - Memory management: Free memory after exporting logs\n   * - User-triggered action: \"Clear log history\" button in UI\n   * - Rotation: Clear buffer after writing logs to persistent storage\n   *\n   * @example Basic clearing\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * logStreamBuffer.addLog('Log 1');\n   * logStreamBuffer.addLog('Log 2');\n   * logStreamBuffer.addLog('Log 3');\n   *\n   * console.log(logStreamBuffer.getRecentLogs().length); // 3\n   *\n   * logStreamBuffer.clear();\n   *\n   * console.log(logStreamBuffer.getRecentLogs().length); // 0\n   * ```\n   *\n   * @example Testing - reset state between tests\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * describe('LogStreamBuffer', () => {\n   *   beforeEach(() => {\n   *     // Clear buffer before each test\n   *     logStreamBuffer.clear();\n   *   });\n   *\n   *   it('should add logs', () => {\n   *     logStreamBuffer.addLog('Test log');\n   *     expect(logStreamBuffer.getRecentLogs()).toHaveLength(1);\n   *   });\n   *\n   *   it('should retrieve logs', () => {\n   *     logStreamBuffer.addLog('Test log 1');\n   *     logStreamBuffer.addLog('Test log 2');\n   *     expect(logStreamBuffer.getRecentLogs()).toHaveLength(2);\n   *   });\n   * });\n   * ```\n   *\n   * @example Export and clear workflow\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   * import fs from 'fs';\n   *\n   * // Export logs to file\n   * const logs = logStreamBuffer.getRecentLogs();\n   * fs.writeFileSync('/var/log/app-export.log', logs.join('\\n'));\n   *\n   * // Clear buffer to free memory\n   * logStreamBuffer.clear();\n   *\n   * console.log('Exported and cleared', logs.length, 'logs');\n   * ```\n   *\n   * @example User-triggered clear action\n   * ```typescript\n   * import express from 'express';\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * const app = express();\n   *\n   * app.post('/api/logs/clear', (req, res) => {\n   *   const beforeCount = logStreamBuffer.getRecentLogs().length;\n   *   logStreamBuffer.clear();\n   *\n   *   res.json({\n   *     message: 'Logs cleared successfully',\n   *     clearedCount: beforeCount,\n   *     timestamp: new Date().toISOString()\n   *   });\n   * });\n   * ```\n   *\n   * @example Log rotation strategy\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   * import fs from 'fs';\n   *\n   * // Rotate logs every hour\n   * setInterval(() => {\n   *   const logs = logStreamBuffer.getRecentLogs();\n   *\n   *   if (logs.length > 0) {\n   *     // Write to persistent storage\n   *     const timestamp = new Date().toISOString().replace(/:/g, '-');\n   *     fs.appendFileSync(`/var/log/app-${timestamp}.log`, logs.join('\\n') + '\\n');\n   *\n   *     // Clear buffer after writing\n   *     logStreamBuffer.clear();\n   *     console.log(`Rotated ${logs.length} logs to persistent storage`);\n   *   }\n   * }, 60 * 60 * 1000); // Every hour\n   * ```\n   *\n   * @example Event listeners remain active after clear\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * // Add event listener\n   * logStreamBuffer.on('log', (logLine) => {\n   *   console.log('New log:', logLine);\n   * });\n   *\n   * // Add and clear logs\n   * logStreamBuffer.addLog('Log 1'); // Output: New log: Log 1\n   * logStreamBuffer.clear();\n   *\n   * // Listener still active after clear\n   * logStreamBuffer.addLog('Log 2'); // Output: New log: Log 2\n   * ```\n   *\n   * @example Safe to call on empty buffer\n   * ```typescript\n   * import { logStreamBuffer } from './log-stream-buffer';\n   *\n   * logStreamBuffer.clear(); // No error\n   * logStreamBuffer.clear(); // No error (idempotent)\n   *\n   * console.log(logStreamBuffer.getRecentLogs().length); // 0\n   * ```\n   *\n   * @see {@link addLog} for adding log entries\n   * @see {@link getRecentLogs} for retrieving log history\n   */\n  public clear(): void {\n    this.buffer = [];\n  }\n}\n\n/**\n * Singleton instance of LogStreamBuffer for application-wide log streaming.\n *\n * This is the default exported instance used throughout the application for real-time\n * log buffering and streaming. It uses the default buffer size of 1000 entries.\n *\n * ## Usage\n *\n * Import and use this singleton instance instead of creating new instances to ensure\n * all parts of the application share the same log buffer and event emitter.\n *\n * @example Using the singleton instance\n * ```typescript\n * import { logStreamBuffer } from './log-stream-buffer';\n *\n * // Subscribe to real-time log events\n * logStreamBuffer.on('log', (logLine) => {\n *   console.log('Log:', logLine);\n * });\n *\n * // Add logs (from any part of the application)\n * logStreamBuffer.addLog('[2024-01-02 12:00:00] INFO  Server started');\n *\n * // Retrieve recent logs\n * const recentLogs = logStreamBuffer.getRecentLogs(50);\n * ```\n *\n * @see {@link LogStreamBuffer} for class documentation\n */\nexport const logStreamBuffer = new LogStreamBuffer();",
        "last_modified": "2026-01-02T15:10:07.670788"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.576785",
  "last_updated": "2026-01-02T14:06:15.587804"
}