{
  "file_path": "src/services/sdk-history-writer.ts",
  "main_branch_history": [],
  "task_views": {
    "002-add-jsdoc-documentation-for-backend-services": {
      "task_id": "002-add-jsdoc-documentation-for-backend-services",
      "branch_point": {
        "commit_hash": "34a3f60da53773d90bd6579cb1cfd8417a1dd0b9",
        "content": "import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { homedir } from 'os';\nimport type {\n  ConversationMessage,\n  SDKAssistantMessage,\n  SDKUserMessage,\n  SDKResultMessage,\n} from '@/types/index.js';\nimport { createLogger, type Logger } from './logger.js';\n\n/**\n * Service for writing SDK conversation messages to history files\n * Maintains compatibility with Claude CLI history format (JSONL)\n */\nexport class SdkHistoryWriter {\n  private logger: Logger;\n  private historyDir: string;\n  private writeBuffers: Map<string, ConversationMessage[]> = new Map();\n\n  constructor(historyDir?: string) {\n    this.logger = createLogger('SdkHistoryWriter');\n    this.historyDir = historyDir || path.join(homedir(), '.claude', 'history');\n  }\n\n  /**\n   * Initialize the history directory if it doesn't exist\n   */\n  async initialize(): Promise<void> {\n    try {\n      await fs.mkdir(this.historyDir, { recursive: true });\n      this.logger.info('History directory initialized', { path: this.historyDir });\n    } catch (error) {\n      this.logger.error('Failed to initialize history directory', error, {\n        path: this.historyDir,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Write an assistant message to history\n   */\n  async writeAssistantMessage(\n    sdkMessage: SDKAssistantMessage,\n    cwd?: string,\n    version?: string\n  ): Promise<void> {\n    const historyMessage: ConversationMessage = {\n      uuid: sdkMessage.uuid,\n      type: 'assistant',\n      message: sdkMessage.message,\n      timestamp: new Date().toISOString(),\n      sessionId: sdkMessage.session_id,\n      parentUuid: sdkMessage.parent_tool_use_id || undefined,\n      isSidechain: !!sdkMessage.parent_tool_use_id,\n      cwd,\n      version,\n    };\n\n    await this.appendToHistory(sdkMessage.session_id, historyMessage);\n  }\n\n  /**\n   * Write a user message to history\n   */\n  async writeUserMessage(\n    sdkMessage: SDKUserMessage,\n    cwd?: string,\n    version?: string\n  ): Promise<void> {\n    const historyMessage: ConversationMessage = {\n      uuid: sdkMessage.uuid || `user-${Date.now()}`,\n      type: 'user',\n      message: sdkMessage.message,\n      timestamp: new Date().toISOString(),\n      sessionId: sdkMessage.session_id,\n      parentUuid: sdkMessage.parent_tool_use_id || undefined,\n      isSidechain: !!sdkMessage.parent_tool_use_id,\n      userType: 'external',\n      cwd,\n      version,\n    };\n\n    await this.appendToHistory(sdkMessage.session_id, historyMessage);\n  }\n\n  /**\n   * Write a result message metadata to history\n   * Result messages are stored as system messages for tracking\n   */\n  async writeResultMessage(\n    sdkMessage: SDKResultMessage,\n    cwd?: string,\n    version?: string\n  ): Promise<void> {\n    // Create a system message to track the conversation result\n    const historyMessage: ConversationMessage = {\n      uuid: sdkMessage.uuid,\n      type: 'system',\n      message: {\n        role: 'assistant',\n        content: [\n          {\n            type: 'text',\n            text: `Conversation ${sdkMessage.subtype}: ${sdkMessage.result || 'completed'}`,\n          },\n        ],\n      },\n      timestamp: new Date().toISOString(),\n      sessionId: sdkMessage.session_id,\n      durationMs: sdkMessage.duration_ms,\n      cwd,\n      version,\n    };\n\n    await this.appendToHistory(sdkMessage.session_id, historyMessage);\n  }\n\n  /**\n   * Append a message to the session's history file\n   */\n  private async appendToHistory(\n    sessionId: string,\n    message: ConversationMessage\n  ): Promise<void> {\n    try {\n      const historyFile = this.getHistoryFilePath(sessionId);\n      this.logger.info('\ud83d\udcc1 Appending to history file', { sessionId, historyFile, messageType: message.type });\n\n      const jsonLine = JSON.stringify(message) + '\\n';\n      this.logger.info('\ud83d\udcc4 JSON line prepared', { sessionId, jsonLength: jsonLine.length });\n\n      await fs.appendFile(historyFile, jsonLine, 'utf-8');\n      this.logger.info('\u2705 File write completed', { sessionId, historyFile });\n\n      this.logger.debug('Message written to history', {\n        sessionId,\n        messageType: message.type,\n        uuid: message.uuid,\n      });\n    } catch (error) {\n      this.logger.error('\u274c Failed to write message to history', error, {\n        sessionId,\n        messageUuid: message.uuid,\n        errorMessage: error instanceof Error ? error.message : String(error),\n      });\n      // Don't throw - history writing should not break the conversation\n    }\n  }\n\n  /**\n   * Get the history file path for a session\n   */\n  private getHistoryFilePath(sessionId: string): string {\n    return path.join(this.historyDir, `${sessionId}.jsonl`);\n  }\n\n  /**\n   * Flush any buffered messages for a session\n   */\n  async flush(sessionId: string): Promise<void> {\n    const buffer = this.writeBuffers.get(sessionId);\n    if (!buffer || buffer.length === 0) {\n      return;\n    }\n\n    try {\n      const historyFile = this.getHistoryFilePath(sessionId);\n      const content = buffer.map((msg) => JSON.stringify(msg)).join('\\n') + '\\n';\n\n      await fs.appendFile(historyFile, content, 'utf-8');\n\n      this.writeBuffers.delete(sessionId);\n\n      this.logger.debug('Flushed message buffer to history', {\n        sessionId,\n        messageCount: buffer.length,\n      });\n    } catch (error) {\n      this.logger.error('Failed to flush message buffer', error, { sessionId });\n    }\n  }\n\n  /**\n   * Check if a history file exists for a session\n   */\n  async historyExists(sessionId: string): Promise<boolean> {\n    try {\n      const historyFile = this.getHistoryFilePath(sessionId);\n      await fs.access(historyFile);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get the message count for a session\n   */\n  async getMessageCount(sessionId: string): Promise<number> {\n    try {\n      const historyFile = this.getHistoryFilePath(sessionId);\n      const content = await fs.readFile(historyFile, 'utf-8');\n      const lines = content.trim().split('\\n').filter((line) => line.trim());\n      return lines.length;\n    } catch {\n      return 0;\n    }\n  }\n}\n",
        "timestamp": "2026-01-02T14:06:14.995695"
      },
      "worktree_state": {
        "content": "import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { homedir } from 'os';\nimport type {\n  ConversationMessage,\n  SDKAssistantMessage,\n  SDKUserMessage,\n  SDKResultMessage,\n} from '@/types/index.js';\nimport { createLogger, type Logger } from './logger.js';\n\n/**\n * SdkHistoryWriter - Write SDK conversation messages to JSONL history files\n *\n * @description\n * The SdkHistoryWriter service writes SDK conversation messages to persistent JSONL history files,\n * maintaining compatibility with the Claude CLI history format. It stores messages in\n * `~/.claude/history/{sessionId}.jsonl` files, enabling conversation persistence, resumption,\n * and audit trails across SDK sessions.\n *\n * **Key Responsibilities:**\n * - Write user, assistant, and system messages to JSONL history files\n * - Transform SDK message formats to ConversationMessage format\n * - Initialize history directory structure (~/.claude/history/)\n * - Append messages to session-specific JSONL files\n * - Flush buffered messages for graceful shutdown\n * - Track message metadata (timestamps, cost, usage, sidechains)\n * - Provide history existence and message count utilities\n *\n * **Architecture:**\n * - **File Format**: JSONL (JSON Lines) - one JSON object per line, newline-delimited\n * - **File Location**: `~/.claude/history/{sessionId}.jsonl` (one file per SDK session)\n * - **Message Types**: user, assistant, system (for conversation results/metadata)\n * - **Append-Only**: Messages are appended, never modified (audit trail)\n * - **Graceful Degradation**: Write failures don't break conversation flow (logged as errors)\n * - **No Buffering**: Messages written immediately (flush available for shutdown cleanup)\n * - **Sidechain Support**: Tracks parent tool use IDs for nested conversations (agent sidechains)\n *\n * **JSONL File Structure:**\n * Each line is a ConversationMessage JSON object:\n * ```jsonl\n * {\"uuid\":\"msg-123\",\"type\":\"user\",\"message\":{\"role\":\"user\",\"content\":[{\"type\":\"text\",\"text\":\"Hello\"}]},\"timestamp\":\"2024-01-01T00:00:00.000Z\",\"sessionId\":\"session-abc\",\"cwd\":\"/project\",\"version\":\"1.0.0\"}\n * {\"uuid\":\"msg-456\",\"type\":\"assistant\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Hi there!\"}]},\"timestamp\":\"2024-01-01T00:00:05.000Z\",\"sessionId\":\"session-abc\",\"cwd\":\"/project\",\"version\":\"1.0.0\"}\n * {\"uuid\":\"msg-789\",\"type\":\"system\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"Conversation completed: success\"}]},\"timestamp\":\"2024-01-01T00:00:10.000Z\",\"sessionId\":\"session-abc\",\"durationMs\":5000,\"cwd\":\"/project\",\"version\":\"1.0.0\"}\n * ```\n *\n * **Message Types:**\n * - **user**: User messages with text/image/document content blocks\n * - **assistant**: Assistant responses with text/tool use content blocks\n * - **system**: Conversation metadata (completion, errors, results)\n *\n * **Sidechain Messages:**\n * Messages with `parentUuid` and `isSidechain: true` represent nested conversations\n * triggered by tool uses (e.g., Task tool launching autonomous agents).\n *\n * **Use Cases:**\n * - Conversation persistence across SDK restarts\n * - Resume conversations with existing context\n * - Audit trails for compliance and debugging\n * - Cost tracking and usage analytics\n * - Conversation export and replay\n * - Integration with Claude CLI history reader\n *\n * @example\n * ```typescript\n * // Initialize writer and create history directory\n * import { SdkHistoryWriter } from './sdk-history-writer';\n *\n * const writer = new SdkHistoryWriter();\n * await writer.initialize();\n * // Creates ~/.claude/history/ directory if not exists\n * ```\n *\n * @example\n * ```typescript\n * // Write user message to history\n * import { SdkHistoryWriter } from './sdk-history-writer';\n * import type { SDKUserMessage } from '@/types';\n *\n * const writer = new SdkHistoryWriter();\n * await writer.initialize();\n *\n * const userMessage: SDKUserMessage = {\n *   uuid: 'msg-user-123',\n *   session_id: 'session-abc',\n *   message: {\n *     role: 'user',\n *     content: [{ type: 'text', text: 'Review this code' }]\n *   }\n * };\n *\n * await writer.writeUserMessage(userMessage, '/project', '1.0.0');\n * // Appends to ~/.claude/history/session-abc.jsonl\n * ```\n *\n * @example\n * ```typescript\n * // Write assistant message with tool uses to history\n * import { SdkHistoryWriter } from './sdk-history-writer';\n * import type { SDKAssistantMessage } from '@/types';\n *\n * const writer = new SdkHistoryWriter();\n * await writer.initialize();\n *\n * const assistantMessage: SDKAssistantMessage = {\n *   uuid: 'msg-assistant-456',\n *   session_id: 'session-abc',\n *   message: {\n *     role: 'assistant',\n *     content: [\n *       { type: 'text', text: 'Let me read that file.' },\n *       { type: 'tool_use', id: 'tool-1', name: 'Read', input: { file_path: 'code.ts' } }\n *     ]\n *   }\n * };\n *\n * await writer.writeAssistantMessage(assistantMessage, '/project', '1.0.0');\n * // Appends assistant message to ~/.claude/history/session-abc.jsonl\n * ```\n *\n * @example\n * ```typescript\n * // Write sidechain message (nested conversation from Task tool)\n * import { SdkHistoryWriter } from './sdk-history-writer';\n * import type { SDKAssistantMessage } from '@/types';\n *\n * const writer = new SdkHistoryWriter();\n * await writer.initialize();\n *\n * // Main conversation assistant message triggers Task tool\n * const mainMessage: SDKAssistantMessage = {\n *   uuid: 'msg-main-1',\n *   session_id: 'session-abc',\n *   message: {\n *     role: 'assistant',\n *     content: [\n *       { type: 'tool_use', id: 'task-tool-1', name: 'Task', input: { prompt: 'Debug auth bug' } }\n *     ]\n *   }\n * };\n * await writer.writeAssistantMessage(mainMessage);\n *\n * // Sidechain message from Task agent (nested conversation)\n * const sidechainMessage: SDKAssistantMessage = {\n *   uuid: 'msg-sidechain-1',\n *   session_id: 'session-abc',\n *   parent_tool_use_id: 'task-tool-1', // Links to parent tool use\n *   message: {\n *     role: 'assistant',\n *     content: [{ type: 'text', text: 'Found the auth bug in login.ts' }]\n *   }\n * };\n * await writer.writeAssistantMessage(sidechainMessage);\n * // Written with isSidechain: true, parentUuid: 'task-tool-1'\n * ```\n *\n * @example\n * ```typescript\n * // Write conversation result message\n * import { SdkHistoryWriter } from './sdk-history-writer';\n * import type { SDKResultMessage } from '@/types';\n *\n * const writer = new SdkHistoryWriter();\n * await writer.initialize();\n *\n * const resultMessage: SDKResultMessage = {\n *   uuid: 'result-123',\n *   session_id: 'session-abc',\n *   subtype: 'completed',\n *   result: 'success',\n *   duration_ms: 5000\n * };\n *\n * await writer.writeResultMessage(resultMessage, '/project', '1.0.0');\n * // Writes system message tracking conversation completion\n * ```\n *\n * @example\n * ```typescript\n * // Flush buffered messages on shutdown\n * import { SdkHistoryWriter } from './sdk-history-writer';\n *\n * const writer = new SdkHistoryWriter();\n * await writer.initialize();\n *\n * // ... write messages during conversation ...\n *\n * // Graceful shutdown: flush any buffered messages\n * await writer.flush('session-abc');\n * // Ensures all messages written to disk before process exit\n * ```\n *\n * @example\n * ```typescript\n * // Check history existence and message count\n * import { SdkHistoryWriter } from './sdk-history-writer';\n *\n * const writer = new SdkHistoryWriter();\n * await writer.initialize();\n *\n * // Check if session has history file\n * const exists = await writer.historyExists('session-abc');\n * console.log(`History exists: ${exists}`);\n *\n * // Get message count for session\n * const count = await writer.getMessageCount('session-abc');\n * console.log(`Message count: ${count}`);\n * // Returns 0 if file doesn't exist (graceful degradation)\n * ```\n */\nexport class SdkHistoryWriter {\n  /** Logger instance for debugging history write operations */\n  private logger: Logger;\n\n  /** Directory path where history JSONL files are stored (default: ~/.claude/history) */\n  private historyDir: string;\n\n  /** Write buffers for batching messages per session (currently unused, reserved for future optimization) */\n  private writeBuffers: Map<string, ConversationMessage[]> = new Map();\n\n  constructor(historyDir?: string) {\n    this.logger = createLogger('SdkHistoryWriter');\n    this.historyDir = historyDir || path.join(homedir(), '.claude', 'history');\n  }\n\n  /**\n   * Initialize the history directory if it doesn't exist\n   *\n   * @description\n   * Creates the history directory structure (~/.claude/history/) if it doesn't already exist.\n   * This method is idempotent and safe to call multiple times. It should be called before\n   * writing any messages to ensure the directory exists.\n   *\n   * **Workflow:**\n   * 1. Attempt to create history directory with { recursive: true }\n   * 2. Log success with directory path\n   * 3. If creation fails, log error and rethrow\n   *\n   * **Directory Creation:**\n   * - Uses fs.mkdir with { recursive: true } (creates parent directories if needed)\n   * - Idempotent: no error if directory already exists\n   * - Default location: ~/.claude/history/ (unless custom historyDir provided to constructor)\n   *\n   * @returns {Promise<void>} Resolves when directory is created or already exists\n   *\n   * @throws {Error} If directory creation fails due to permissions or filesystem errors\n   *\n   * @example\n   * ```typescript\n   * // Initialize on service startup\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   * // Creates ~/.claude/history/ directory\n   * console.log('History directory ready');\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Initialize with custom directory\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   *\n   * const writer = new SdkHistoryWriter('/custom/path/history');\n   * await writer.initialize();\n   * // Creates /custom/path/history/ directory\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Idempotent initialization (safe to call multiple times)\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize(); // Creates directory\n   * await writer.initialize(); // No-op, directory already exists\n   * await writer.initialize(); // Still safe\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Handle initialization errors\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   *\n   * const writer = new SdkHistoryWriter('/root/protected/history');\n   *\n   * try {\n   *   await writer.initialize();\n   * } catch (error) {\n   *   console.error('Failed to create history directory:', error);\n   *   // Handle permission error or use fallback directory\n   * }\n   * ```\n   */\n  async initialize(): Promise<void> {\n    try {\n      await fs.mkdir(this.historyDir, { recursive: true });\n      this.logger.info('History directory initialized', { path: this.historyDir });\n    } catch (error) {\n      this.logger.error('Failed to initialize history directory', error, {\n        path: this.historyDir,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Write an assistant message to history\n   *\n   * @description\n   * Transforms an SDK assistant message to ConversationMessage format and appends it to the\n   * session's JSONL history file. Assistant messages contain Claude's responses, including\n   * text content and tool use blocks.\n   *\n   * **Workflow:**\n   * 1. Transform SDKAssistantMessage to ConversationMessage format\n   * 2. Add timestamp, sessionId, cwd, version metadata\n   * 3. Detect sidechain messages (parent_tool_use_id present)\n   * 4. Append message to ~/.claude/history/{sessionId}.jsonl\n   *\n   * **Message Transformation:**\n   * - Preserves message.role and message.content from SDK format\n   * - Adds uuid, type: 'assistant', timestamp, sessionId\n   * - Sets parentUuid and isSidechain if parent_tool_use_id present\n   * - Includes cwd and version metadata for environment tracking\n   *\n   * **Sidechain Messages:**\n   * Messages with parent_tool_use_id represent nested conversations triggered by tools\n   * (e.g., Task tool launching autonomous agents). These are marked with isSidechain: true\n   * and parentUuid for conversation tree reconstruction.\n   *\n   * **Error Handling:**\n   * Write failures are logged but don't throw errors (graceful degradation).\n   * Conversation flow continues even if history write fails.\n   *\n   * @param {SDKAssistantMessage} sdkMessage - The SDK assistant message to write\n   * @param {string} [cwd] - Optional working directory for context tracking\n   * @param {string} [version] - Optional SDK version for compatibility tracking\n   *\n   * @returns {Promise<void>} Resolves when message is written to history file\n   *\n   * @example\n   * ```typescript\n   * // Write basic assistant text response\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKAssistantMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const assistantMessage: SDKAssistantMessage = {\n   *   uuid: 'msg-assistant-123',\n   *   session_id: 'session-abc',\n   *   message: {\n   *     role: 'assistant',\n   *     content: [\n   *       { type: 'text', text: 'The code looks good!' }\n   *     ]\n   *   }\n   * };\n   *\n   * await writer.writeAssistantMessage(assistantMessage, '/project', '1.0.0');\n   * // Appends to ~/.claude/history/session-abc.jsonl\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write assistant message with tool uses\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKAssistantMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const assistantMessage: SDKAssistantMessage = {\n   *   uuid: 'msg-assistant-456',\n   *   session_id: 'session-abc',\n   *   message: {\n   *     role: 'assistant',\n   *     content: [\n   *       { type: 'text', text: 'Let me read that file and analyze it.' },\n   *       { type: 'tool_use', id: 'tool-1', name: 'Read', input: { file_path: 'code.ts' } },\n   *       { type: 'tool_use', id: 'tool-2', name: 'Grep', input: { pattern: 'TODO', path: 'src/' } }\n   *     ]\n   *   }\n   * };\n   *\n   * await writer.writeAssistantMessage(assistantMessage, '/project', '1.0.0');\n   * // Writes assistant message with 2 tool use blocks\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write sidechain message (nested conversation from Task tool)\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKAssistantMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * // Main conversation assistant triggers Task tool\n   * const mainMessage: SDKAssistantMessage = {\n   *   uuid: 'msg-main-1',\n   *   session_id: 'session-abc',\n   *   message: {\n   *     role: 'assistant',\n   *     content: [\n   *       { type: 'tool_use', id: 'task-123', name: 'Task', input: { prompt: 'Debug auth' } }\n   *     ]\n   *   }\n   * };\n   * await writer.writeAssistantMessage(mainMessage);\n   *\n   * // Task agent response (sidechain)\n   * const sidechainMessage: SDKAssistantMessage = {\n   *   uuid: 'msg-sidechain-1',\n   *   session_id: 'session-abc',\n   *   parent_tool_use_id: 'task-123', // Links to parent tool\n   *   message: {\n   *     role: 'assistant',\n   *     content: [{ type: 'text', text: 'Found auth bug in login.ts line 42' }]\n   *   }\n   * };\n   * await writer.writeAssistantMessage(sidechainMessage);\n   * // Written with isSidechain: true, parentUuid: 'task-123'\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write without optional metadata\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKAssistantMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const assistantMessage: SDKAssistantMessage = {\n   *   uuid: 'msg-assistant-789',\n   *   session_id: 'session-xyz',\n   *   message: {\n   *     role: 'assistant',\n   *     content: [{ type: 'text', text: 'Hello!' }]\n   *   }\n   * };\n   *\n   * await writer.writeAssistantMessage(assistantMessage);\n   * // Writes without cwd/version metadata (optional fields omitted)\n   * ```\n   */\n  async writeAssistantMessage(\n    sdkMessage: SDKAssistantMessage,\n    cwd?: string,\n    version?: string\n  ): Promise<void> {\n    const historyMessage: ConversationMessage = {\n      uuid: sdkMessage.uuid,\n      type: 'assistant',\n      message: sdkMessage.message,\n      timestamp: new Date().toISOString(),\n      sessionId: sdkMessage.session_id,\n      parentUuid: sdkMessage.parent_tool_use_id || undefined,\n      isSidechain: !!sdkMessage.parent_tool_use_id,\n      cwd,\n      version,\n    };\n\n    await this.appendToHistory(sdkMessage.session_id, historyMessage);\n  }\n\n  /**\n   * Write a user message to history\n   *\n   * @description\n   * Transforms an SDK user message to ConversationMessage format and appends it to the\n   * session's JSONL history file. User messages contain user input, including text,\n   * images, documents, and other content blocks.\n   *\n   * **Workflow:**\n   * 1. Transform SDKUserMessage to ConversationMessage format\n   * 2. Generate uuid if not provided (fallback: `user-{timestamp}`)\n   * 3. Add timestamp, sessionId, cwd, version, userType metadata\n   * 4. Detect sidechain messages (parent_tool_use_id present)\n   * 5. Append message to ~/.claude/history/{sessionId}.jsonl\n   *\n   * **Message Transformation:**\n   * - Preserves message.role and message.content from SDK format\n   * - Adds uuid (or generates fallback), type: 'user', timestamp, sessionId\n   * - Sets userType: 'external' (distinguishes from internal/system messages)\n   * - Sets parentUuid and isSidechain if parent_tool_use_id present\n   * - Includes cwd and version metadata for environment tracking\n   *\n   * **UUID Handling:**\n   * SDK user messages may not have a uuid (optional field). This method generates a\n   * fallback uuid using `user-{Date.now()}` to ensure all messages have unique identifiers\n   * for conversation tracking.\n   *\n   * **Sidechain Messages:**\n   * User messages with parent_tool_use_id represent user input within nested conversations\n   * (e.g., user responding to Task agent prompt). These are marked with isSidechain: true.\n   *\n   * **Error Handling:**\n   * Write failures are logged but don't throw errors (graceful degradation).\n   * Conversation flow continues even if history write fails.\n   *\n   * @param {SDKUserMessage} sdkMessage - The SDK user message to write\n   * @param {string} [cwd] - Optional working directory for context tracking\n   * @param {string} [version] - Optional SDK version for compatibility tracking\n   *\n   * @returns {Promise<void>} Resolves when message is written to history file\n   *\n   * @example\n   * ```typescript\n   * // Write basic user text message\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKUserMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const userMessage: SDKUserMessage = {\n   *   uuid: 'msg-user-123',\n   *   session_id: 'session-abc',\n   *   message: {\n   *     role: 'user',\n   *     content: [\n   *       { type: 'text', text: 'Review this code for bugs' }\n   *     ]\n   *   }\n   * };\n   *\n   * await writer.writeUserMessage(userMessage, '/project', '1.0.0');\n   * // Appends to ~/.claude/history/session-abc.jsonl\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write user message with image attachment\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKUserMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const userMessage: SDKUserMessage = {\n   *   uuid: 'msg-user-456',\n   *   session_id: 'session-abc',\n   *   message: {\n   *     role: 'user',\n   *     content: [\n   *       { type: 'text', text: 'What is in this screenshot?' },\n   *       {\n   *         type: 'image',\n   *         source: {\n   *           type: 'base64',\n   *           media_type: 'image/png',\n   *           data: 'iVBORw0KGgoAAAANSUhEUgA...'\n   *         }\n   *       }\n   *     ]\n   *   }\n   * };\n   *\n   * await writer.writeUserMessage(userMessage, '/project', '1.0.0');\n   * // Writes user message with image attachment\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write user message without uuid (auto-generated)\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKUserMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const userMessage: SDKUserMessage = {\n   *   // uuid omitted (optional field)\n   *   session_id: 'session-abc',\n   *   message: {\n   *     role: 'user',\n   *     content: [{ type: 'text', text: 'Hello' }]\n   *   }\n   * };\n   *\n   * await writer.writeUserMessage(userMessage);\n   * // Generates uuid: 'user-1704067200000' (timestamp-based fallback)\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write user message with document (PDF)\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKUserMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const userMessage: SDKUserMessage = {\n   *   uuid: 'msg-user-789',\n   *   session_id: 'session-abc',\n   *   message: {\n   *     role: 'user',\n   *     content: [\n   *       { type: 'text', text: 'Summarize this document' },\n   *       {\n   *         type: 'document',\n   *         source: {\n   *           type: 'base64',\n   *           media_type: 'application/pdf',\n   *           data: 'JVBERi0xLjQKJeLjz9MK...'\n   *         }\n   *       }\n   *     ]\n   *   }\n   * };\n   *\n   * await writer.writeUserMessage(userMessage, '/project', '1.0.0');\n   * // Writes user message with PDF document\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write sidechain user message (nested conversation input)\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKUserMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const sidechainUserMessage: SDKUserMessage = {\n   *   uuid: 'msg-sidechain-user-1',\n   *   session_id: 'session-abc',\n   *   parent_tool_use_id: 'task-123', // Links to parent Task tool\n   *   message: {\n   *     role: 'user',\n   *     content: [{ type: 'text', text: 'Check auth.ts file' }]\n   *   }\n   * };\n   *\n   * await writer.writeUserMessage(sidechainUserMessage);\n   * // Written with isSidechain: true, parentUuid: 'task-123'\n   * ```\n   */\n  async writeUserMessage(\n    sdkMessage: SDKUserMessage,\n    cwd?: string,\n    version?: string\n  ): Promise<void> {\n    const historyMessage: ConversationMessage = {\n      uuid: sdkMessage.uuid || `user-${Date.now()}`,\n      type: 'user',\n      message: sdkMessage.message,\n      timestamp: new Date().toISOString(),\n      sessionId: sdkMessage.session_id,\n      parentUuid: sdkMessage.parent_tool_use_id || undefined,\n      isSidechain: !!sdkMessage.parent_tool_use_id,\n      userType: 'external',\n      cwd,\n      version,\n    };\n\n    await this.appendToHistory(sdkMessage.session_id, historyMessage);\n  }\n\n  /**\n   * Write a result message metadata to history\n   *\n   * @description\n   * Transforms an SDK result message to a ConversationMessage system message and appends it\n   * to the session's JSONL history file. Result messages track conversation lifecycle events\n   * (completion, errors, cancellation) with duration and outcome metadata.\n   *\n   * **Workflow:**\n   * 1. Transform SDKResultMessage to ConversationMessage with type: 'system'\n   * 2. Create text content summarizing result (subtype + result)\n   * 3. Add timestamp, sessionId, durationMs, cwd, version metadata\n   * 4. Append system message to ~/.claude/history/{sessionId}.jsonl\n   *\n   * **Message Transformation:**\n   * - Type: 'system' (not user/assistant, metadata message)\n   * - Message: assistant role with text describing result\n   * - Content: \"Conversation {subtype}: {result}\" (e.g., \"Conversation completed: success\")\n   * - Includes durationMs for performance tracking\n   * - Preserves uuid, sessionId, timestamp for correlation\n   *\n   * **Result Types (subtype field):**\n   * - `completed`: Conversation finished successfully\n   * - `error`: Conversation failed with error\n   * - `cancelled`: Conversation cancelled by user or system\n   *\n   * **Use Cases:**\n   * - Track conversation lifecycle events (start, completion, errors)\n   * - Measure conversation duration for performance analysis\n   * - Audit trail for conversation outcomes\n   * - Filter system metadata messages from user/assistant messages\n   * - Debug conversation failures and cancellations\n   *\n   * **Error Handling:**\n   * Write failures are logged but don't throw errors (graceful degradation).\n   * Conversation flow continues even if history write fails.\n   *\n   * @param {SDKResultMessage} sdkMessage - The SDK result message to write\n   * @param {string} [cwd] - Optional working directory for context tracking\n   * @param {string} [version] - Optional SDK version for compatibility tracking\n   *\n   * @returns {Promise<void>} Resolves when message is written to history file\n   *\n   * @example\n   * ```typescript\n   * // Write successful conversation completion result\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKResultMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const resultMessage: SDKResultMessage = {\n   *   uuid: 'result-123',\n   *   session_id: 'session-abc',\n   *   subtype: 'completed',\n   *   result: 'success',\n   *   duration_ms: 5000\n   * };\n   *\n   * await writer.writeResultMessage(resultMessage, '/project', '1.0.0');\n   * // Writes system message: \"Conversation completed: success\" with durationMs: 5000\n   * // Appends to ~/.claude/history/session-abc.jsonl\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write conversation error result\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKResultMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const errorResult: SDKResultMessage = {\n   *   uuid: 'result-456',\n   *   session_id: 'session-abc',\n   *   subtype: 'error',\n   *   result: 'API rate limit exceeded',\n   *   duration_ms: 1200\n   * };\n   *\n   * await writer.writeResultMessage(errorResult, '/project', '1.0.0');\n   * // Writes system message: \"Conversation error: API rate limit exceeded\"\n   * // Useful for debugging conversation failures\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write conversation cancellation result\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKResultMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const cancelledResult: SDKResultMessage = {\n   *   uuid: 'result-789',\n   *   session_id: 'session-abc',\n   *   subtype: 'cancelled',\n   *   result: 'User cancelled conversation',\n   *   duration_ms: 3500\n   * };\n   *\n   * await writer.writeResultMessage(cancelledResult, '/project', '1.0.0');\n   * // Writes system message: \"Conversation cancelled: User cancelled conversation\"\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Write result without optional result field\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import type { SDKResultMessage } from '@/types';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * const resultMessage: SDKResultMessage = {\n   *   uuid: 'result-101',\n   *   session_id: 'session-xyz',\n   *   subtype: 'completed',\n   *   // result omitted (optional field)\n   *   duration_ms: 2000\n   * };\n   *\n   * await writer.writeResultMessage(resultMessage);\n   * // Writes system message: \"Conversation completed: completed\"\n   * // Falls back to subtype when result not provided\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Filter system result messages from conversation history\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import * as fs from 'fs/promises';\n   *\n   * const writer = new SdkHistoryWriter();\n   *\n   * // Read history file\n   * const historyFile = '~/.claude/history/session-abc.jsonl';\n   * const content = await fs.readFile(historyFile, 'utf-8');\n   * const messages = content.trim().split('\\n').map(line => JSON.parse(line));\n   *\n   * // Filter out system messages to get user/assistant conversation\n   * const conversation = messages.filter(msg => msg.type !== 'system');\n   * console.log(`Conversation messages: ${conversation.length}`);\n   *\n   * // Get result messages for analytics\n   * const results = messages.filter(msg => msg.type === 'system');\n   * console.log(`Result messages: ${results.length}`);\n   * console.log(`Average duration: ${results.reduce((sum, r) => sum + (r.durationMs || 0), 0) / results.length}ms`);\n   * ```\n   */\n  async writeResultMessage(\n    sdkMessage: SDKResultMessage,\n    cwd?: string,\n    version?: string\n  ): Promise<void> {\n    // Create a system message to track the conversation result\n    const historyMessage: ConversationMessage = {\n      uuid: sdkMessage.uuid,\n      type: 'system',\n      message: {\n        role: 'assistant',\n        content: [\n          {\n            type: 'text',\n            text: `Conversation ${sdkMessage.subtype}: ${sdkMessage.result || 'completed'}`,\n          },\n        ],\n      },\n      timestamp: new Date().toISOString(),\n      sessionId: sdkMessage.session_id,\n      durationMs: sdkMessage.duration_ms,\n      cwd,\n      version,\n    };\n\n    await this.appendToHistory(sdkMessage.session_id, historyMessage);\n  }\n\n  /**\n   * Append a message to the session's history file\n   */\n  private async appendToHistory(\n    sessionId: string,\n    message: ConversationMessage\n  ): Promise<void> {\n    try {\n      const historyFile = this.getHistoryFilePath(sessionId);\n      this.logger.info('\ud83d\udcc1 Appending to history file', { sessionId, historyFile, messageType: message.type });\n\n      const jsonLine = JSON.stringify(message) + '\\n';\n      this.logger.info('\ud83d\udcc4 JSON line prepared', { sessionId, jsonLength: jsonLine.length });\n\n      await fs.appendFile(historyFile, jsonLine, 'utf-8');\n      this.logger.info('\u2705 File write completed', { sessionId, historyFile });\n\n      this.logger.debug('Message written to history', {\n        sessionId,\n        messageType: message.type,\n        uuid: message.uuid,\n      });\n    } catch (error) {\n      this.logger.error('\u274c Failed to write message to history', error, {\n        sessionId,\n        messageUuid: message.uuid,\n        errorMessage: error instanceof Error ? error.message : String(error),\n      });\n      // Don't throw - history writing should not break the conversation\n    }\n  }\n\n  /**\n   * Get the history file path for a session\n   */\n  private getHistoryFilePath(sessionId: string): string {\n    return path.join(this.historyDir, `${sessionId}.jsonl`);\n  }\n\n  /**\n   * Flush any buffered messages for a session\n   *\n   * @description\n   * Writes any buffered messages for the specified session to the history file and clears\n   * the buffer. This method is intended for graceful shutdown scenarios to ensure all\n   * pending messages are persisted before the process exits.\n   *\n   * **Current Implementation Note:**\n   * The current implementation uses immediate writes (messages appended directly in\n   * writeUserMessage, writeAssistantMessage, writeResultMessage), so flush typically\n   * has nothing to do. The writeBuffers map is reserved for future optimization if\n   * batching is needed for performance.\n   *\n   * **Workflow:**\n   * 1. Check if buffer exists for sessionId\n   * 2. Return early if buffer is empty (no-op)\n   * 3. Convert buffered messages to JSONL format (one JSON per line)\n   * 4. Append all buffered messages to history file in single write\n   * 5. Clear buffer for sessionId\n   * 6. Log flush completion\n   *\n   * **Use Cases:**\n   * - Graceful shutdown: flush pending messages before process exit\n   * - Manual flush after batch operations (future optimization)\n   * - Testing: ensure all messages written before assertions\n   * - Periodic flush for long-running sessions (future optimization)\n   *\n   * **Error Handling:**\n   * Flush failures are logged but don't throw errors (graceful degradation).\n   * This ensures shutdown can proceed even if flush fails.\n   *\n   * @param {string} sessionId - The SDK session ID to flush messages for\n   *\n   * @returns {Promise<void>} Resolves when buffered messages are flushed (or buffer is empty)\n   *\n   * @example\n   * ```typescript\n   * // Graceful shutdown: flush all sessions\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * // ... write messages during conversation ...\n   *\n   * // Shutdown handler\n   * process.on('SIGTERM', async () => {\n   *   console.log('Shutting down gracefully...');\n   *   await writer.flush('session-abc');\n   *   await writer.flush('session-xyz');\n   *   process.exit(0);\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Flush after batch message writes (future optimization scenario)\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * // Hypothetical batched writes (not currently implemented)\n   * // await writer.writeUserMessage(msg1, { buffered: true });\n   * // await writer.writeAssistantMessage(msg2, { buffered: true });\n   * // await writer.writeAssistantMessage(msg3, { buffered: true });\n   *\n   * // Flush batch to disk\n   * await writer.flush('session-abc');\n   * // All 3 messages written in single file append\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Testing: ensure messages written before assertions\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   * import * as fs from 'fs/promises';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * // Write messages\n   * await writer.writeUserMessage(userMsg, '/project', '1.0.0');\n   * await writer.writeAssistantMessage(assistantMsg, '/project', '1.0.0');\n   *\n   * // Flush to ensure writes complete\n   * await writer.flush('session-abc');\n   *\n   * // Now safe to assert file contents\n   * const content = await fs.readFile('~/.claude/history/session-abc.jsonl', 'utf-8');\n   * const messages = content.trim().split('\\n').map(line => JSON.parse(line));\n   * expect(messages.length).toBe(2);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Idempotent flush (safe to call multiple times)\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * await writer.flush('session-abc'); // No-op if buffer empty\n   * await writer.flush('session-abc'); // Still safe\n   * await writer.flush('session-abc'); // Idempotent\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Periodic flush for long-running sessions (future optimization)\n   * import { SdkHistoryWriter } from './sdk-history-writer';\n   *\n   * const writer = new SdkHistoryWriter();\n   * await writer.initialize();\n   *\n   * // Flush every 60 seconds\n   * setInterval(async () => {\n   *   const activeSessions = ['session-abc', 'session-xyz', 'session-123'];\n   *   for (const sessionId of activeSessions) {\n   *     await writer.flush(sessionId);\n   *   }\n   *   console.log('Periodic flush completed');\n   * }, 60000);\n   * ```\n   */\n  async flush(sessionId: string): Promise<void> {\n    const buffer = this.writeBuffers.get(sessionId);\n    if (!buffer || buffer.length === 0) {\n      return;\n    }\n\n    try {\n      const historyFile = this.getHistoryFilePath(sessionId);\n      const content = buffer.map((msg) => JSON.stringify(msg)).join('\\n') + '\\n';\n\n      await fs.appendFile(historyFile, content, 'utf-8');\n\n      this.writeBuffers.delete(sessionId);\n\n      this.logger.debug('Flushed message buffer to history', {\n        sessionId,\n        messageCount: buffer.length,\n      });\n    } catch (error) {\n      this.logger.error('Failed to flush message buffer', error, { sessionId });\n    }\n  }\n\n  /**\n   * Check if a history file exists for a session\n   */\n  async historyExists(sessionId: string): Promise<boolean> {\n    try {\n      const historyFile = this.getHistoryFilePath(sessionId);\n      await fs.access(historyFile);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get the message count for a session\n   */\n  async getMessageCount(sessionId: string): Promise<number> {\n    try {\n      const historyFile = this.getHistoryFilePath(sessionId);\n      const content = await fs.readFile(historyFile, 'utf-8');\n      const lines = content.trim().split('\\n').filter((line) => line.trim());\n      return lines.length;\n    } catch {\n      return 0;\n    }\n  }\n}\n",
        "last_modified": "2026-01-02T15:10:07.674229"
      },
      "task_intent": {
        "title": "002-add-jsdoc-documentation-for-backend-services",
        "description": "Add comprehensive JSDoc documentation to 27 service files in src/services with 65+ exported functions, classes, and interfaces. Focus on function parameters, return types, usage patterns, and examples.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-02T14:06:15.626041",
  "last_updated": "2026-01-02T14:06:15.637288"
}